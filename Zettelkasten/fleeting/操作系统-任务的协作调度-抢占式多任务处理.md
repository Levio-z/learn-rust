---
tags:
  - permanent
---
## 1. 核心观点  

- **线程比内核多导致程序运行每个线程一段时间**：大多数现代计算机都拥有多个核心，因此它们可以同时运行多个线程。线程比内核多得多是很常见的，因此操作系统将运行每个线程一小段时间，然后暂停它并运行不同的线程一段时间。

- 时间片轮转：当多个线程以这种方式在单个内核上运行时，这被称为交错执行或时间片轮转
	- 操作系统还可以通过配置硬件定时器，令其在指定时间后发送中断，从而精确控制每个任务允许运行的时间。

- 优点
	- **操作系统负责调度线程，这意味着它决定线程运行的时间**。
		- 操作系统能够完全控制任务允许执行的时间。这种方式可以确保每个任务公平地获得 CPU 时间份额，而无需依赖任务间的协作。这一特性在运行第三方任务或多个用户共享系统时尤为重要。
	- 使得运行不受信任的用户空间程序成为可能
- 缺点
	- **抢占式多任务处理的缺点在于每个任务都需要独立的栈空间**。
		- 相较于共享栈，使用独立栈会导致每个任务占用更多内存，并且通常会限制任务的数量。
		- 另一个缺点是操作系统总是需要在每次任务切换时保存完整的 CPU 寄存器状态，即使任务只使用了寄存器的一小部分。
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
![](asserts/Pasted%20image%2020251211152101.png)
第一行中，CPU 正在执行程序 `A` 的任务 `A1` ，所有其他任务均处于暂停状态。在第二行，一个硬件中断到达 CPU 。如[硬件中断](https://os.phil-opp.com/hardware-interrupts/)文章所述，CPU 立即停止执行任务 `A1` 并跳转到中断描述符表(IDT)中定义的中断处理程序。通过这个中断处理程序，操作系统重新获得了 CPU 的控制权，这使得它能够切换到任务 `B1` 而非继续原任务 `A1` 。

### 保存状态

任务可能在任意时间点被中断，即使它们可能正处于某些计算过程中。为了稍后能够恢复他们，操作系统必须备份任务的完整状态，包括其[调用栈](https://en.wikipedia.org/wiki/Call_stack)和所有 CPU 寄存器的值。这一过程被称为[上下文切换](https://en.wikipedia.org/wiki/Context_switch)。

由于调用栈可能非常大，操作系统通常会为每个线程设置独立的调用栈，而非在每次任务切换时备份调用栈内容。这样一个拥有自己的栈的任务被称为一个 执行线程 [_thread of execution_](https://en.wikipedia.org/wiki/Thread_\(computing\)) 或简称 线程_thread_。为每个任务使用独立的栈，在上下文切换时就只需保存寄存器内容（包括程序计数器和栈指针）。这种方法最大限度地减少了上下文切换的性能开销，这一点非常重要，因为上下文切换每秒可能发生多达100次。



## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [操作系统-阻塞IO-抢占式任务处理系统的视角](../permanent/操作系统-阻塞IO-抢占式任务处理系统的视角.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 深入阅读 xxx
- [x] 验证这个观点的边界条件