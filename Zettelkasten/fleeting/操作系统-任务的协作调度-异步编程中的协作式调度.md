---
tags:
  - permanent
---
## 1. 核心观点  

**任务必须主动放弃控制权，允许另一个任务被调度**。由于任务必须相互协作（通过放弃控制权），因此这被称为协作式多任务处理。
- [任务](#任务)
- [调度器](操作系统-任务的协作调度-异步编程中的协作式调度.md#调度器)
- [特点](#特点)
- [状态机](#状态机)
- [保存状态](#保存状态)
- [与异步io配合](#与异步io配合)
- [应用场景](#应用场景)
### 总结

协作式多任务处理的缺点在于，**一个不愿意主动暂停的任务可能会长时间占用处理器资源。比如，恶意或有缺陷的任务可能会阻止其他任务运行，并且会拖慢甚至阻塞整个系统**。因此，协作式多任务处理应仅在确保所有任务都会协作的情况下使用。让操作系统依赖于任意用户级程序的协作并不是一个好主意。

然而，协作式多任务处理**在性能和内存方面的显著优势**，使其成为**适合在程序内部使用的好方法，特别是与异步操作结合使用**。操作系统内核作为**与异步硬件交互的性能关键程序，采用协作式多任务处理似乎是一种实现并发的理想方式**。
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 任务
[操作系统-异步编程-任务](操作系统-异步编程-任务.md)
### 调度器

在异步系统中，仍然**存在一个调度器来决定接下来运行哪个任务**（它是程序的一部分，而不是操作系统的一部分）。但是，**调度器不能抢占任务**。

### 协作式任务执行的特点
- 产生控制权**可能被移交的点之间，代码将按顺序执行** - 您永远不会意外暂停
- 如果一个任务在**让出点**之间花费了很长时间（例如，通过进行阻塞 IO 或执行长时间运行的计算），其他任务将无法取得进展
- 实现调度程序要简单得多，调度（和上下文切换）的**开销更少**。

#### 状态机

 在 Rust async/await 中： 编译器将 async fn 转换为状态机 所有仍然需要的局部变量： 被提升（spill）到一个自动生成的结构体中 暂停点仅保存该结构体 不再依赖真实调用栈内容 

#### 保存状态

由于任务自行决定暂停点，它们不**需要操作系统来保存其所有的状态，而是然需要的局部变量提升到一个结构体中




### 应用场景

协作式多任务处理常用于语言层面，比如以 [协程coroutines](https://en.wikipedia.org/wiki/Coroutine) 或 [async/await](https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html) 的形式实现。其核心思想是由程序员或编译器在程序中插入 [yield](https://en.wikipedia.org/wiki/Yield_\(multithreading\)) 操作，这些操作会放弃 CPU 控制权并允许其他任务运行。例如，可以在一个复杂循环的每次迭代后插入yield。

### 与异步io配合
通常我们会将协作式多任务与 [异步操作asynchronous operations](https://en.wikipedia.org/wiki/Asynchronous_I/O) 结合使用。不同于等待操作完成并在此期间阻止其他任务运行，**异步操作会在操作未完成时返回 “未就绪”（“not ready”）状态。在这种情况下，等待中的任务可以执行 yield 操作，让其他任务运行。**





## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 深入阅读 xxx
- [x] 验证这个观点的边界条件
