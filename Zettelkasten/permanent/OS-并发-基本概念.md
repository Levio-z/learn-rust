---
tags:
  - permanent
---
## 1. 核心观点  

同时做多件事（或看起来这样做）称为并发。程序（与作系统一起）必须管理它们的并发性，有很多方法可以做到这一点。

## 2. 背景/出处  
- 来源：https://rust-lang.github.io/async-book/part-guide/concurrency.html
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 详细内容
用户希望电脑能够执行多项任务。有时用户希望同时执行这些任务（例如，一边听音乐一边在编辑器中输入文字）。有时同时执行多项任务效率更高（例如，在下载大文件的同时在编辑器中完成一些工作）。有时多个用户希望同时使用同一台电脑（例如，多个客户端连接到服务器）。

举个更底层的例子，音乐程序可能需要在用户与用户界面 (UI) 交互时持续播放音乐。为了“持续播放音乐”，它可能需要从服务器获取音乐数据流，将数据从一种格式转换为另一种格式，并通过操作系统 (OS) 将处理后的数据发送到计算机的音频系统。对于用户而言，它可能需要根据用户的指令向服务器发送和接收数据或命令，可能需要向播放音乐的子系统发送信号（例如，用户切换曲目或暂停播放时），可能需要更新图形显示（例如，高亮显示按钮或更改曲目名称），并且在执行上述所有操作的同时，还必须保持鼠标光标或文本输入的响应性。

>从更底层看，这个音乐程序本质上是在**同一时间窗口内推进多条逻辑控制流**。这些控制流并非“可选优化”，而是系统正确性与可用性的前提：一旦其中某条被阻塞，其它功能就会直接退化甚至失效。

上述三条路径在设计上具有明确的**约束冲突**：
- 音频播放 **不能等 UI**
- UI 响应 **不能等网络**
- 网络 I/O **本身不可预测**

因此，**顺序执行在语义上就不成立**：

并发指程序在同一时间段内处理多个任务（不一定在同一时刻真正并行执行），其核心目标是**提升响应性、吞吐量与资源利用率**。在单核或多核环境下，并发通过操作系统调度、时间片轮转或多核并行来实现“同时进行”的效果。用户层面的需求（交互流畅、多用户共享）与系统层面的需求（I/O 等待掩蔽、流水化处理）共同推动了并发模型的产生。



## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
