---
tags:
  - permanent
title: Rust-交叉借用（cross-borrowing）
---

## 核心观点  
> 当你对智能指针或封装类型本身取引用时（`&Box<T>` / `&Rc<T>` 等），编译器自动帮你“跳过一层”引用，直接得到内部值的引用（`&T`），而不是字面上的 `&Box<T>`

## 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 展开说明  
### 历史
#### 早期
- 类似自动借用，交叉借用最初也是 **编译器硬编码**：
    - 对 `Box<T>` 特判：`&Box<T>` 被视作 `&T`。
- 原因：
    - 最常用的场景是调用方法时：`Box<T>` 里的 `T` 方法应该直接可见。
    - 避免每次都写 `&*b` 这种啰嗦写法。
```rust
let b = Box::new(String::from("hi"));

// 方法签名：fn len(&self) -> usize
// 逻辑上: (&Box<String>).len()
// 编译器硬编码: &Box<String> → &String
println!("{}", b.len()); // OK
```
→ 交叉借用让 `Box<String>` 的方法调用等同于 `String` 本身。
**范围受限**：
- **只支持 `Box<T>`（在早期）。
	- 不支持 Rc、Arc、自定义智能指针。
- 用户必须手动写 `&*rc` 或 `&**arc`。

#### 现代 Rust
随着 **Deref + Autoderef + Autoref** 一起引入，交叉借用泛化：
- 任何实现了 `Deref` 的智能指针，都支持交叉借用。
- `Box<T>`, `Rc<T>`, `Arc<T>`, 自定义智能指针都能自动进入内部。

## 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  

