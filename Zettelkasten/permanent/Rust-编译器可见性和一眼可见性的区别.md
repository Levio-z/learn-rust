---
tags:
  - permanent
title: Rust-编译器可见性和一眼可见性的区别
---

## 核心观点  
> 程序员一眼可见性，从代码文本上看，变量是否被移动、借用或产生切片不一定一眼就能判断。编译器能完全追踪所有权流向、借用和生命周期，无论临时引用、移动还是自动借用，都能检查并保证内存安全。

## 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 展开说明  
例子：比如同样 `v.len()`，从代码上看，你没写 `&v` 或 `&[T]`，程序员需要理解 Rust 的自动借用和切片规则才能判断是否移动或借用。**无法直接看出 `&v` 是临时借用**。
```rust
let v = vec![1,2,3];
let len = v.len(); // 自动借用 &v
```
- **编译器**知道生成了 `&v`，所以 `v` 不可变借用。
- **程序员**看代码只是 `v.len()`，无法直接看出 `&v` 是临时借用。
如果方法参数是 `self`（移动）：
```
v.into_inner(); // 移动 v
```
但程序员需要查方法签名 `fn into_inner(self)` 才能确认，**从调用处代码本身不明显**。

## 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：[Rust-所有权可见性](Rust-所有权可见性.md)

## 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 待办/进一步探索  
 
  
