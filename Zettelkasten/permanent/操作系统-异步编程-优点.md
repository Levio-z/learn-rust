---
tags:
  - permanent
---
## 1. 核心观点  

- **内存开销要低得多**，上下文切换是一种便宜得多的操作——
	- 不需要进入操作系统：**不需要将控制权交给作系统**并返回程序
	- **切换的数据要少得多**：因为可以做到精确保存与恢复执行状态
		- 因为编译器与运行时可以提前知道：
			- 哪些局部变量在未来仍会被使用
			- 哪些中间状态已经不再需要
		-  [ 结构体](#%20结构体)
- **共享调用栈，降低任务内存占用**：你可以拥有远多于作系统线程的任务数量级，因为异步运行时用少量（昂贵的）线程来处理大量（便宜的）任务。
	- 任务不拥有独立调用栈 所有任务可以共享运行时线程的栈 ，所有仍然需要的局部变量被保存在一个结构体中
	- [ 结构体](#%20结构体)
	- 结果是： 单个任务只占用： 状态机结构体的大小（通常几十到几百字节） 而不是： 一个完整线程栈（通常 MB 级）
- **尤其适用于大量 IO 受限任务的工作负载**，如服务器和数据库
- 一些缓存影响，新调度任务所需的数据可能不在内存缓存中
	- 虽然作系统的缓存（例如 [TLB](https://en.wikipedia.org/wiki/Translation_lookaside_buffer)）不需要更改，但任务很可能在内存的不同部分运行，因此新调度任务所需的数据可能不在内存缓存中。


## 2. 背景/出处  
- 来源：
	- https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  




## 4. 与其他卡片的关联  
- 前置卡片：
	- [AsyncBook-log-02-并发编程](../../Areas/Rust/Project/Async%20Book/3%20开发日志/AsyncBook-log-02-并发编程.md)
- 后续卡片：
	- 
	- 
- 相似主题：[阻塞是什么](../permanent/阻塞是什么.md)

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  

