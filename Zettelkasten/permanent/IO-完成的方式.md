---
tags:
  - permanent
---
## 1. 核心观点  


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 一、忙等（Busy Waiting / 自旋等待）

线程在用户态通过循环不断检查某个条件（标志位、状态变量、设备寄存器）是否变化。
- **定义**：反复轮询，直到 I/O 被认为完成。
- **实现方式**：`while (!done) {}`、轮询共享变量、轮询设备状态。
- **特点**：
    - 不发生上下文切换
    - 占用 CPU，能耗和竞争极高
- **适用场景**：
    - 等待时间极短（如自旋锁）
    - 内核或嵌入式低层代码
- **扩展知识点**：
    - 与 cache coherence、内存屏障密切相关
    - 在多核系统中会导致缓存行抖动（cache line bouncing）

---

### 二、阻塞等待（Blocking I/O）

线程发起 I/O 后进入睡眠态，由操作系统在 I/O 完成时唤醒。
- **定义**：I/O 未完成前线程不可运行
- **实现方式**：`read()`、`write()`、`accept()` 等阻塞系统调用
- **特点**：
    - 不浪费 CPU
    - 需要上下文切换
- **适用场景**：
    - 传统同步程序模型
    - 线程数量可控的服务器
- **扩展知识点**：
    - 线程阻塞时保存的是 **内核栈 + TCB**
    - I/O 完成通常通过中断唤醒
---

### 三、非阻塞轮询（Non-blocking Polling）

线程发起非阻塞 I/O，若未完成立即返回，再由程序周期性检查。
- **定义**：系统调用永不睡眠
- **实现方式**：`O_NONBLOCK` + 重试
- **特点**：
    - 比忙等友好，但仍需轮询
    - 延迟与轮询频率相关
- **适用场景**
    - 简单事件循环
    - 低延迟但不想阻塞线程
- **扩展知识点**：
    - 常与 `select/poll` 结合
    - 容易写出“半忙等”代码

---

### 四、多路复用等待（I/O Multiplexing）

线程阻塞在“事件集合”上，等待任一 I/O 就绪。
- **定义**：等待多个 I/O 的就绪事件
- **实现方式**：
    - `select`
    - `poll`
    - `epoll` / `kqueue`
- **特点**：
    - 单线程管理多 I/O
    - 减少线程数量
- **适用场景**：
    - 高并发网络服务器
- **扩展知识点**：
    - 属于 **Reactor 模型**
    - 就绪 ≠ 完成，只表示“现在可以操作”
        

---

### 五、信号 / 回调通知（Signal / Callback）

I/O 完成时通过异步通知机制告知线程
- **定义**：线程不主动等待，由系统“打断”通知
- **实现方式**：
    - POSIX 信号（`SIGIO`）
    - 用户态回调函数
- **特点**：
    - 控制流被打断
    - 编程复杂、可读性差
- **适用场景**：
    - 特殊系统工具
    - 早期异步 I/O 模型
- **扩展知识点**：
    - 信号处理受限（reentrancy）
    - 现代系统较少直接使用

---

### 六、异步 I/O 完成队列（Asynchronous I/O）

线程提交 I/O 后继续执行，通过完成事件获取结果。
- **定义**：提交与完成解耦
- **实现方式**：
    - POSIX AIO
    - Linux `io_uring`
    - Windows IOCP
- **特点**：
    - 高并发、低切换
    - 编程模型复杂
- **适用场景**：
    - 高性能存储、网络
- **扩展知识点**：
    - 属于 **Proactor 模型**
    - 完成事件仍不等于“持久化完成”
---

### 七、协作式等待（用户态调度 / async）

线程不阻塞内核线程，而是挂起当前任务。
- **定义**：任务主动让出执行权
- **实现方式**：
    - `async/await`
    - 用户态协程 / 纤程
- **特点**：
    - 低成本切换
    - 依赖运行时
- **适用场景**：
    - Rust async、Go runtime
- **扩展知识点**：
    - 本质仍依赖底层 epoll / AIO
    - “等待”是状态机切换而非线程阻塞
---

## 总结

线程等待 I/O 完成的方式从 **粗暴到精细** 包括：  
忙等 → 阻塞 → 非阻塞轮询 → 多路复用 → 信号回调 → 异步完成 → 协作式等待。  
它们在 **CPU 利用率、延迟、编程复杂度、扩展性** 上各有权衡。

**学习方法论**：

- 用“三问法”分析每种方式：  
    1）是否阻塞线程？  
    2）是否占用 CPU？  
    3）完成语义到哪一层？
    
- 结合内核视角理解“等待”的真实含义。
    

**练习题**：  
1）用同一 TCP 服务器分别实现阻塞、epoll、async 三种版本并对比。  
2）解释为什么 epoll 是“就绪通知”而不是“完成通知”。  
3）分析 async/await 中任务挂起时栈在哪里。

**高价值底层知识（重点关注）**：

- 上下文切换成本与 TCB
    
- Reactor vs Proactor
    
- 内核中断、完成队列与用户态调度器

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：
	- [IO的确切时间很复杂](IO的确切时间很复杂.md)
	- [DMA机制](DMA机制.md)
	- [OS-阻塞IO](OS-阻塞IO.md)

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
