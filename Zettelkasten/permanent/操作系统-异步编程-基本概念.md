---
tags:
  - permanent
---
## 1. 核心观点  

异步编程也是为并发而生，它与线程并发有着相同的高级目标（同时执行多个任务），但是实现方式和线程并发不同。
### 主要区别
- 异步并发完全由程序内部管理，无需操作系统干预 [；](https://rust-lang.github.io/async-book/part-guide/concurrency.html#footnote-threads) 
- 异步并发采用的是协作式多任务处理，而非抢占式[多](https://rust-lang.github.io/async-book/part-guide/concurrency.html#footnote-other)任务处理（我们稍后会详细解释）。

## 2. 背景/出处  
- 来源：
	- https://rust-lang.github.io/async-book/part-guide/concurrency.html#fr-proc-program-1
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 协作调度

[操作系统-任务的协作调度-异步编程中的协作式调度](../fleeting/操作系统-任务的协作调度-异步编程中的协作式调度.md)

### 异步IO
异步 I/O 与异步并发并非直接相关，但两者经常一起使用

- [操作系统-异步IO（非阻塞IO）](操作系统-异步IO（非阻塞IO）.md)
- [操作系统-异步IO的优点和适用场景](操作系统-异步IO的优点和适用场景.md)

### 异步并发的优点

- [操作系统-异步编程-优点](操作系统-异步编程-优点.md)
### 异步与线程的关系

- [操作系统-异步和线程的关系和适用任务](操作系统-异步和线程的关系和适用任务.md)
- [异步并发和线程并发之间的两大区别](异步并发和线程并发之间的两大区别.md)
### 并发和并行

- [操作系统-并发性](../../Projects/on%20hold/开源操作系统训练营/2025春夏/第二阶段：rcore/rCore-Turial-note/概念合集/操作系统-并发性.md)
- [操作系统-并发性与并行性：理解资源调度与利用的本质](../../Areas/course/并发编程/视频内容/3%20并行与并发/操作系统-并发性与并行性：理解资源调度与利用的本质.md)
- [操作系统-并发调度算法-难点](操作系统-并发调度算法-难点.md)
### 异步系统的并发和并行性

**并发性都由代码控制（生成线程或任务），而并行性则由调度器控制。**

线程系统的调度器是操作系统的一部分（由操作系统的 API 配置），而**异步系统的调度器则是运行时库的一部分**（由运行时的选择、运行时的实现方式以及运行时提供给客户端代码的选项配置）。然而，由于约定和常用默认值，两者之间存在实际差异。

#### 并行性的区别

在线程系统中，每个并发线程都会尽可能地并行执行。

在异步系统中，没有严格的默认值：
- **系统可以将所有任务运行在单个线程中**，
- 也可以将**多个任务分配给单个线程并将该线程锁定到某个核心**（这样，**任务组就可以并行执行，但组内的每个任务都是并发执行**的，但不会与其他任务并行执行）
- **任务可以并行运行**，无论并行度如何。

异步编程还可以提供灵活或细粒度的并发结构，而这些结构并非大多数操作系统线程 API 的一部分。

### 异步编程提供灵活或细粒度的并发结构

- 并发的**基本调度单元不是 OS 线程**，而是**更轻量的任务（task / future）**
- 并发的**切换点、唤醒条件、生命周期**由语言与运行时精确控制
- 可以表达 **OS 线程 API 无法直接表达或成本过高的并发形态**
#### 1. 显式、可控的切换点（Cooperative Yield）
- 只在 `await` / `yield` 处让出执行权
- 不存在“在你没意识到的地方被抢占”

**线程 API 无法表达**：

> “这个函数中，只有在这 3 个点允许被切换”

#### 2. 单线程内的大规模并发
- 成千上万 task 共享 **同一个 OS 线程**
- 无锁、无原子、无缓存一致性成本
- 逻辑并发 ≠ 物理并行

**线程 API 的问题**：
- 每个并发单元至少一个线程
- 栈空间、调度、上下文切换成本极高

#### 3. 非对称并发结构（Asymmetric Concurrency）
异步允许表达：
- 一个主任务
- 多个短生命周期子任务
- 子任务仅在特定事件完成时恢复

例如：
- 请求 → 多阶段 IO → 回调式恢复
- 流水线 / 状态机式并发

线程 API 只能表达：

> “启动一个线程，等它结束”
#### 4. 事件驱动而非时间驱动
异步并发天然是 **event-based**：
- IO 就绪
- channel 可读
- future ready

而线程调度是 **time-based**：
- 时间片耗尽
- 抢占发生
➡ 异步结构更贴近 **IO 与协议本质**

### 线程不具备的并发能力

#### 1. Structured Concurrency（结构化并发）

- 任务必须隶属于作用域
    
- 父任务结束 → 子任务自动取消
    
- 生命周期可推理、可组合
    

线程 API：

- 无法强制线程的结构化生命周期
    
- 易泄漏、难取消

#### 2. Select / Join / Race 组合算子

异步原语天然支持：

- `select!`：等多个事件之一
    
- `join!`：并发等待多个任务
    
- `race`：先完成者胜出
    

线程 API 只能通过：

- 条件变量
    
- 锁
    
- 手写状态机

#### 3. 背压（Backpressure）与流式并发

- async stream
    
- await-based flow control
    
- 消费者驱动生产速率
    

线程 API 中背压通常退化为：

- 阻塞
    
- 忙等
    
- 复杂锁协议




## 4. 与其他卡片的关联  
- 前置卡片：
	- [AsyncBook-log-02-并发编程](../../Areas/Rust/Project/Async%20Book/3%20开发日志/AsyncBook-log-02-并发编程.md)
- 后续卡片：
	- 
	- 
- 相似主题：[阻塞是什么](../permanent/阻塞是什么.md)

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  

![](asserts/Pasted%20image%2020260105194619.png)