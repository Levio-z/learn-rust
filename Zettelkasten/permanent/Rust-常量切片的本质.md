---
tags:
  - permanent
---

## 1. 核心观点  
> “引用了一个静态数组常量”，因此隐式地带有 `'static` 生命周期。把数组 `[8, 16, 32]` 存进静态内存；生成一个 `'static` 引用指向它。

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 底层例证（MIR 层级）  
```rust
const BLOCK_SIZES: &[usize] = &[8, 16, 32];
```
展开成：
```rust
static __BLOCK_SIZES_ARRAY: [usize; 3] = [8, 16, 32];
const BLOCK_SIZES: &[usize] = &__BLOCK_SIZES_ARRAY;
```
也就是说编译器内部**自动帮你做了两步处理**：
- **匿名静态数据**：编译器检测到 `const` 引用指向一个**字面量数据**（如 `[8, 16, 32]`）时，它会在内部执行**静态提升（Static Promotion）**：将这个字面量数据提升为一个**编译器生成的匿名静态变量** (`static __BLOCK_SIZES_ARRAY`)，并将其放置在静态/只读数据区（如 `.rodata` 段）。
- 把数组 `[8, 16, 32]` 存进静态内存；
	- `[8,16,32]` 这个数组在编译期作为 **编译器生成的匿名静态数据段对象** 存在。
- 生成一个 `'static` 引用指向它。
	- `&[8,16,32]` 实际是一个指向 `.rodata` 段静态数组的引用。
- 也就是说，虽然 **`const` 本身不分配内存**，  
	- 但它**的值中包含的引用指向的是静态区的常量对象**。  
	- 因此这个引用自然拥有 `'static` 生命周期。
### 切片编译期间传播的是什么
一个编译期可确定的 `(data_ptr, len)` 对。

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
