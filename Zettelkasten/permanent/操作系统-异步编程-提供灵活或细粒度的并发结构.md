---
tags:
  - permanent
---
## 1. 核心观点  

- 并发的**基本调度单元不是 OS 线程**，而是**更轻量的任务（task / future）**
- 并发的**切换点、唤醒条件、生命周期**由语言与运行时精确控制
- 可以表达 **OS 线程 API 无法直接表达或成本过高的并发形态**

## 2. 背景/出处  
- 来源：
	- https://rust-lang.github.io/async-book/part-guide/concurrency.html#fr-proc-program-1
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

#### 1. 显式、可控的切换点（Cooperative Yield）
- 只在 `await` / `yield` 处让出执行权
- 不存在“在你没意识到的地方被抢占”
**线程 API 无法表达**：
> “这个函数中，只有在这 3 个点允许被切换”

#### 2. 单线程内的大规模并发
- 成千上万 task 共享 **同一个 OS 线程**
- 无锁、无原子、无缓存一致性成本
- 逻辑并发 ≠ 物理并行
**线程 API 的问题**：
- 每个并发单元至少一个线程
- 栈空间、调度、上下文切换成本极高
#### 3. 非对称并发结构（Asymmetric Concurrency）
异步允许表达：
- 一个主任务
- 多个短生命周期子任务
- 子任务仅在特定事件完成时恢复
例如：
- 请求 → 多阶段 IO → 回调式恢复
- 流水线 / 状态机式并发
线程 API 只能表达：
> “启动一个线程，等它结束”
#### 4. 事件驱动而非时间驱动
异步并发天然是 **event-based**：
- IO 就绪
- channel 可读
- future ready
而线程调度是 **time-based**：
- 时间片耗尽
- 抢占发生
➡ 异步结构更贴近 **IO 与协议本质**

### 线程不具备的并发能力

#### 1. Structured Concurrency（结构化并发）
- 任务必须隶属于作用域
- 父任务结束 → 子任务自动取消
- 生命周期可推理、可组合
线程 API：
- 无法强制线程的结构化生命周期
- 易泄漏、难取消
#### 2. Select / Join / Race 组合算子
异步原语天然支持：
- `select!`：等多个事件之一
- `join!`：并发等待多个任务
- `race`：先完成者胜出
线程 API 只能通过：
- 条件变量
- 锁
- 手写状态机
#### 3. 背压（Backpressure）与流式并发
- async stream
- await-based flow control
- 消费者驱动生产速率

线程 API 中背压通常退化为：
- 阻塞
- 忙等
- 复杂锁协议




## 4. 与其他卡片的关联  
- 前置卡片：
	- [操作系统-异步编程-基本概念](操作系统-异步编程-基本概念.md)
- 后续卡片：
	- 
	- 
- 相似主题：[阻塞是什么](../permanent/阻塞是什么.md)

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
