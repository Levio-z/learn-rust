选择最小包的计算按如下方式进行（C = 客户端，S = 服务器）：

  _init 步骤：_

C：使用引用发现获取通告的引用。

C：将任何看到的物体放入广告`的`集合中。

C：构建一个空集， `公共` ，以容纳后来确定在两端的对象。

C：根据客户端在引用发现期间看到的内容，从客户端想要获取的`广告`中构建一组对象。

C：启动一个队列，`c_pending`，按提交时间排序（在前弹出最新的）。添加所有客户端引用。当提交从队列中弹出时，它的父提交应该自动插入回来。提交必须只进入队列一次。

  _一个计算步骤：_

```
C：发送一个 `$GIT_URL/git-upload-pack` 请求：

C: 0032want <want #1>...............................
C: 0032want <want #2>...............................
....
C: 0032have <common #1>.............................
C: 0032have <common #2>.............................
....
C: 0032have <have #1>...............................
C: 0032have <have #2>...............................
....
C: 0000
```

流被组织成“命令”，每个命令单独出现在 pkt 行中。在命令行中，第一个空格之前的文本是命令名称，第一个 LF 的其余部分是值。命令行以 LF 作为 pkt-line 值的最后一个字节终止。

如果命令出现在请求流中，则必须按以下顺序显示：

-   “想要”
    
-   “有”
    

流由 pkt-line 刷新 （`0000`） 终止。

单个“want”或“have”命令必须有一个十六进制格式的对象名称作为其值。必须通过发送多个命令来发送多个对象名称。必须使用通过`对象格式`功能协商的对象格式（默认 SHA-1）给出对象名称。

`have` 列表是通过从 `c_pending` 中弹出前 32 个提交来创建的。如果 `c_pending` 空了，可以提供更少的东西。

如果客户端已发送 256 个“have”提交，但尚未收到来自 `s_common` 的其中一个，或者客户端已清空 `c_pending` 则它应该包含一个“done”命令，让服务器知道它不会继续：

C: 0009done

S：解析 git-upload-pack 请求：

验证 `want` 中的所有对象都可以从 refs 直接访问。

服务器可以倒向浏览历史记录或 reflog 以允许稍微过时的请求。

如果没有收到“want”对象，请发送错误：TODO：如果没有请求“want”行，则定义错误。

如果无法访问任何“want”对象，请发送错误：TODO：如果请求无效的“want”，则定义错误。

`s_common` 创建一个空列表。

如果发送了“have”：

按照客户端提供的顺序循环遍历对象。

对于每个对象，如果服务器具有可从引用访问的对象，请将其添加到 `s_common`。如果提交已添加到 `s_common`，请不要添加任何祖先，即使它们也出现在 `have` 中。

S：发送 git-upload-pack 响应：

如果服务器找到了一组要打包的封闭对象，或者请求以“完成”结尾，则它会回复打包。TODO：记录基于包的响应

S: PACK...

返回的流是 git-upload-pack 服务支持的 side-band-64k 协议，该包嵌入到流 1 中。来自服务器端的进度消息可能会出现在流 2 中。

这里，“封闭的对象集”被定义为至少有一个从每个“想要”到至少一个“公共”对象的路径。

如果服务器需要更多信息，它会回复状态继续响应：TODO：记录非包响应

C：解析上传包响应：TODO：文档解析响应

  _执行另一个计算步骤。_