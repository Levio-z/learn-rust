---
tags:
  - note
---
## 1. 核心观点  

每个对象的头部（object header）使用一种特殊的**可变长度整数编码（variable-length integer encoding）**来描述对象大小。这段头部同时包含对象类型和部分大小信息，是 packfile 格式中最“紧凑”的部分。

对于非去质化类型，元信息后面的数据是 zlib 压缩的对象数据，我们可以像处理普通 Git 对象一样处理这些数据。可变长度整数告诉我们对象膨胀（解压缩）后对象的预期大小。
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
##### **1. 基础字节结构**

对象头部的第一个字节结构如下（从高位到低位）：

```
bit7  bit6-0
 └─┬────┘
   └── 若 bit7=1 表示后面仍有字节

```

解释如下
- **bit 7 (MSB)**：延续位（continuation bit）
    - 若为 1，则表示后续还有字节属于该整数；
    - 若为 0，则这是最后一个字节。
- **bits 4–6**：对象类型（type）
    - 1 = commit
    - 2 = tree
    - 3 = blob
    - 4 = tag
    - 6 = OFS_DELTA（基于偏移的 delta）
    - 7 = REF_DELTA（基于对象哈希的 delta）
- **bits 0–3**：对象大小的低 4 位。
##### **2. 多字节扩展编码**

若对象大小超过 15（即需要更多位数），则高位（bit7）为 1 表示还需要读取下一字节。  
后续字节的结构：

```
bit7  bit6-0
 └─┬────┘
   └── 若 bit7=1 表示后面仍有字节
```

每个后续字节提供 **7 位有效位**，连续拼接在之前的高位上。  
换言之，大小字段是以 7 位为一组的可变长整数，直到某个字节的 MSB=0 为止。

##### **3. 例子**

假设 packfile 的头部前几个字节如下：
`0b10101100  0b00001001`
解析步骤：
- 第一个字节：`10101100`
    - bit7 = 1 → 有后续字节
    - type = 010 (tree)
    - size低4位 = 1100 (12)
- 第二个字节：`00001001`
    - bit7 = 0 → 最后一个字节
    - 有效位 = 0001001 (9)
    - 拼接后 size = 9 << 4 + 12 = 156  
        ⇒ 表示一个 **tree 对象**，大小为 156 字节。
###  Delta 对象的特殊头部

若对象类型为 `OFS_DELTA` 或 `REF_DELTA`，在大小信息之后还会有一段额外字段，表示其“基对象”：
- **REF_DELTA**：跟随一个 20 字节的 base object SHA1 哈希。
- **OFS_DELTA**：跟随一个可变长偏移量，表示距离当前位置的 base 对象的相对偏移。

这使得 delta 对象能被正确还原，同时避免重复存储完整数据。

### packfile 中元信息的作用

元信息承担三大职责：

1. 描述对象的类型与大小（高效存取与解压）。
2. 通过 delta 链接形成层级结构。
3. 在解析时提供高性能的顺序读取（offset 优化）。

Git 读取 packfile 时，只需依次解码这些头部，就能快速识别每个对象的类型与数据范围，从而在压缩效率和访问性能之间取得平衡。


## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
