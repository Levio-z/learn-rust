/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Syllogism
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/StandardFormConstruction.ts
var StandardFormConstruction = class {
  constructor() {
    this.elements = [];
  }
  // for now i think i like a more flexible and dynamic approach and dont force it into strict classes
};
var Element = class {
  constructor(label, text) {
    this.label = label;
    this.text = text;
  }
};
var Argument = class extends Element {
};
var ConclusionDivider = class extends Element {
  /**
   * Creates a ConclusionDivider.
   * @param dividerType The type of divider.
   * @param conclusionPrinciple Optional conclusion principle. Defaults to empty string.
   */
  constructor(dividerType, conclusionPrinciple = "") {
    super("", "");
    this.dividerType = dividerType;
    this.text = conclusionPrinciple;
  }
};

// src/StandardFormParser.ts
var StandardFormParser = class {
  constructor() {
    this.premissePattern = /(.*?(?<!\\)[.:])?\s*(.*)/;
    this.dividerPattern = /(--|==)\s*(.*?)\s*(?:--|==)/;
  }
  parse(codeblock_content) {
    var _a;
    const sfc = new StandardFormConstruction();
    const lines = codeblock_content.split("\n").map((line) => line.trim());
    for (const line of lines) {
      let match;
      if (line.trim() == "--") {
        sfc.elements.push(new ConclusionDivider(0 /* Line */));
      } else if (line.trim() == "==") {
        sfc.elements.push(new ConclusionDivider(1 /* DoubleLine */));
      } else if (match = line.match(this.dividerPattern)) {
        const dividerType = match[1];
        const conclusionPrinciple = match[2];
        if (dividerType == "--") {
          sfc.elements.push(new ConclusionDivider(2 /* TextLine */, conclusionPrinciple));
        } else if (dividerType == "==") {
          sfc.elements.push(new ConclusionDivider(3 /* DoubleTextLine */, conclusionPrinciple));
        }
      } else if (match = line.match(this.premissePattern)) {
        const type = (_a = match[1]) != null ? _a : "";
        const text = match[2];
        if (text == "" && type != "") {
          sfc.elements.push(new Argument("", type));
        } else {
          sfc.elements.push(new Argument(type, text));
        }
      } else {
        console.log(`Line not recognized: ${line}`);
      }
    }
    return Promise.resolve(sfc);
  }
};
var StandardFormParser_default = StandardFormParser;

// src/StandardFormElement.ts
var import_obsidian = require("obsidian");
var StandardFormElement = class extends import_obsidian.MarkdownRenderChild {
  constructor(el, construction) {
    super(el);
    this.el = el;
    this.construction = construction;
  }
  onload() {
    this.renderTable();
  }
  renderTable() {
    const table = this.el.createEl("table");
    const anyLabel = this.construction.elements.some((e) => e.label !== "");
    for (const el of this.construction.elements) {
      const tr = table.createEl("tr");
      if (el instanceof Argument) {
        if (anyLabel) {
          tr.createEl("td", { text: el.label });
        }
        el.text = el.text.split("\\.").join(".").split("\\:").join(":");
        tr.createEl("td", { text: el.text });
      } else if (el instanceof ConclusionDivider) {
        if (anyLabel) {
          tr.createEl("td");
        }
        const td = tr.createEl("td");
        switch (el.dividerType) {
          case 0:
            td.createDiv({ cls: "conclusionLong" });
            break;
          case 1:
            td.createDiv({ cls: "conclusionDouble" });
            break;
          case 2:
            td.createDiv({ text: el.text, cls: "conclusionText" });
            break;
          case 3:
            td.createDiv({ text: el.text, cls: "conclusionDoubleText" });
            break;
        }
      }
    }
  }
};
var StandardFormElement_default = StandardFormElement;

// src/main.ts
var Syllogism = class extends import_obsidian2.Plugin {
  async onload() {
    this.registerMarkdownCodeBlockProcessor("standardform", async (source, el, ctx) => {
      await this.codeProcessor(source, el, ctx);
    });
  }
  async codeProcessor(source, el, ctx) {
    const parser = new StandardFormParser_default();
    const elements = await parser.parse(source);
    ctx.addChild(new StandardFormElement_default(el, elements));
  }
};


/* nosourcemap */