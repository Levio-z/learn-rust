### 操作系统接口就是基于 C ABI 提供的
- Rust 不能绕过这些系统 API，除非自己用汇编或 FFI 重写 syscall。为了跨平台和开发效率，**直接使用 libc 是合情合理的策略**。
### Rust 的目标是构建“安全封装”，不是重造 libc
- 并不是直接构建在“系统调用指令”上，而是**以 libc 为基础构建高层安全抽象**。
### **libc 是跨平台和移植的最佳中介**
Rust 是一门强调“可移植性”的系统语言，libc 是它连接各个平台的统一后端：
- Rust 的 `libc` crate 为 POSIX、Linux、macOS、BSD、Windows、WASI 等平台都做了封装；
- 不同平台 libc 实现差异很大，Rust 不重造轮子，而是通过 FFI 使用系统已有库，**保持统一 API 封装逻辑**
### 如果不依赖 libc，会怎样？
在 **`no_std`（无标准库）** 模式下，Rust 是可以完全不依赖 libc 的。但代价是：
- **你需要自己实现所有系统调用**（如 `write`、`exit`）；
- 手动管理堆内存（实现 `malloc` 替代）；
- 自己写启动代码、异常处理、堆栈初始化等；
- 这类用法见于**内核开发、裸机开发、嵌入式或 bootloader** 场景。