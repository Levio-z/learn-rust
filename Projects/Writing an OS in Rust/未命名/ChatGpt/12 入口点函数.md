操作系统期望程序结束时调用退出系统调用（`exit` syscall），或者在嵌入式/内核中程序不会“正常返回”。

与前文的 `panic` 函数类似，这个函数的返回值类型为`!`——它定义了一个发散函数，或者说一个不允许返回的函数。
- 这一点很重要，因为这个入口点不会被任何函数调用，但将直接被操作系统或**引导程序**（bootloader）调用。所以作为函数返回的替代，这个入口点应该去调用，比如操作系统提供的 **exit 系统调用**（[“exit” system call](https://en.wikipedia.org/wiki/Exit_\(system_call\))）函数。



- **独立式可执行程序（freestanding binary）**指的是不依赖操作系统运行时环境的程序，比如裸机程序、操作系统内核等。
	- 这类程序的入口函数（如 `_start`）由引导程序或硬件直接调用，不存在上层调用者。
	- 因此，当入口函数“返回”时，没有任何调用方等待返回值，也没有后续代码需要执行或资源需要回收。
- 一般
	- 调用操作系统的退出调用（如 `exit` syscall），或
	- 在裸机环境下进入无限循环，停止执行。
## 1. `#[no_mangle]` 的作用

- Rust 编译器默认会对函数名进行**名称重整（name mangling）**，例如将 `_start` 编译为 `_ZN3blog_os4_start7hb173fedf945531caE` 这样混淆且带有哈希的名字。
    
- **名称重整**用于支持 Rust 的模块、泛型和重载等特性，保证符号唯一性。
    
- 使用 `#[no_mangle]` 属性后，**禁用名称重整**，让编译器直接输出符号名为 `_start`。
    
- 这对于程序入口函数极为关键，因为操作系统和链接器期望入口点符号为固定名称。
    

---

## 2. `extern "C"` 的作用

- Rust 默认使用自己的调用约定（ABI），在函数调用时会有不同的参数传递、栈清理规则等。
    
- 标记 `extern "C"`，告诉编译器**采用 C 语言的调用约定**，保证符号在链接时与其他用 C 语言编写的代码或运行时环境兼容。
    
- **入口点函数通常由操作系统或链接器调用，它们期望遵循 C ABI。**
    

---

## 3. `_start` 符号的意义

- 大多数操作系统和链接器**默认将 `_start` 作为程序的入口点符号**。
    
- 该函数负责程序启动时最早被调用，负责完成必要初始化（如栈准备、环境设置等）后再调用 Rust 语言层面的入口。
    
- 自定义入口时，必须确保此符号的名称和调用约定正确，才能成功被操作系统识别