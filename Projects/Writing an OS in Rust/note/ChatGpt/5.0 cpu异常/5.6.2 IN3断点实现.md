```rust
use x86_64::structures::idt::{InterruptDescriptorTable, InterruptStackFrame};

  

use crate::println;

pub fn init_idt() {

    let mut idt = InterruptDescriptorTable::new();

    idt.breakpoint.set_handler_fn(breakpoint_handler);

}

  

extern "x86-interrupt" fn breakpoint_handler(stack_frame: InterruptStackFrame) {

    println!("EXCEPTION: BREAKPOINT\n{:#?}", stack_frame);

}
```


```rust
extern "x86-interrupt" fn breakpoint_handler(stack_frame: InterruptStackFrame) {
    println!("EXCEPTION: BREAKPOINT\n{:#?}", stack_frame);
}
```
- 指定这是一个 **中断处理函数**，调用约定不同于普通函数（会用 `IRETQ` 返回）。   
    - Rust 编译器因此会生成正确的 prologue/epilogue。
- 参数 `stack_frame: InterruptStackFrame`
    - 这是 CPU 自动压栈的寄存器状态，被封装成结构体传递进来。
    - 包含触发断点时的指令指针、代码段寄存器、标志位、栈指针等信息。
- `println!("EXCEPTION: BREAKPOINT\n{:#?}", stack_frame);`
    - 打印提示信息：`EXCEPTION: BREAKPOINT`。
    - 使用 `{:#?}`（pretty debug 格式化）打印 `stack_frame` 的内容，按多行缩进展示寄存器和上下文，方便阅读。
