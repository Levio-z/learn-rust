### 中断描述符表

要捕捉CPU异常，我们需要设置一个 _中断描述符表_ (_Interrupt Descriptor Table_, IDT)，用来捕获每一个异常。由于硬件层面会不加验证的直接使用，所以我们需要根据预定义格式直接写入数据。符表的每一行都遵循如下的16字节结构。

| Type | Name                     | Description                                                                                                                                           |
| ---- | ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| u16  | Function Pointer [0:15]  | **处理函数地址的低 16 位**。由于中断/异常处理函数可能位于 64 位地址空间中，这里存放地址的最低 16 位。                                                                                           |
| u16  | GDT selector             | [全局描述符表](https://en.wikipedia.org/wiki/Global_Descriptor_Table)中的代码段标记。**段选择子**（Segment Selector），指定代码段（通常是 GDT 中的内核代码段）。CPU 在跳转到处理函数时，会把它加载到 CS 寄存器。 |
| u16  | Options                  | （如下所述）                                                                                                                                                |
| u16  | Function Pointer [16:31] | 处理函数地址的中位（中间16位）                                                                                                                                      |
| u32  | Function Pointer [32:63] | 处理函数地址的高位（剩下的所有位）                                                                                                                                     |
| u32  | Reserved                 | <br>**保留字段**，必须置 0。主要用于：  <br>- 保证结构体对齐到 16 字节  <br>- 为未来扩展预留位  <br>- CPU 规范要求非 0 时会触发` #GP（通用保护错误）。`                                                 |

Options字段的格式如下：

| Bits  | Name                             | Description                            |
| ----- | -------------------------------- | -------------------------------------- |
| 0-2   | Interrupt Stack Table Index      | 0: 不要切换栈, 1-7: 当处理函数被调用时，切换到中断栈表的第n层。  |
| 3-7   | Reserved                         |                                        |
| 8     | 0: Interrupt Gate, 1: Trap Gate  | 0=Interrupt Gate（关中断），1=Trap Gate（不中断） |
| 9-11  | must be one                      |                                        |
| 12    | must be zero                     |                                        |
| 13‑14 | Descriptor Privilege Level (DPL) | 执行处理函数所需的最小特权等级。                       |
| 15    | Present                          | Present：该条目是否有效                        |
每个异常都具有一个预定义的IDT序号，比如 invalid opcode 异常对应6号，而 page fault 异常对应14号，因此硬件可以直接寻找到对应的IDT条目。 OSDev wiki中的 [异常对照表](https://wiki.osdev.org/Exceptions) 可以查到所有异常的IDT序号（在Vector nr.列）。

通常而言，当异常发生时，CPU会执行如下步骤：

1. 将一些寄存器数据入栈，包括指令指针以及 [RFLAGS](https://en.wikipedia.org/wiki/FLAGS_register) 寄存器。（我们会在文章稍后些的地方用到这些数据。）
2. 读取中断描述符表（IDT）的对应条目，比如当发生 page fault 异常时，调用14号条目。
3. 判断该条目确实存在，如果不存在，则触发 double fault 异常。
4. 如果该条目属于中断门（interrupt gate，bit 40 被设置为0），则禁用硬件中断。
5. 将 [GDT](https://en.wikipedia.org/wiki/Global_Descriptor_Table) 选择器载入代码段寄存器（CS segment）。
6. 跳转执行处理函数。

不过现在我们不必为4和5多加纠结，未来我们会单独讲解全局描述符表和硬件中断的。


### IDT类型
与其创建我们自己的IDT类型映射，不如直接使用 `x86_64` crate 内置的 [`InterruptDescriptorTable` 结构](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html)，其实现是这样的：
```rust
#[repr(C)]
pub struct InterruptDescriptorTable {
    pub divide_by_zero: Entry<HandlerFunc>,
    pub debug: Entry<HandlerFunc>,
    pub non_maskable_interrupt: Entry<HandlerFunc>,
    pub breakpoint: Entry<HandlerFunc>,
    pub overflow: Entry<HandlerFunc>,
    pub bound_range_exceeded: Entry<HandlerFunc>,
    pub invalid_opcode: Entry<HandlerFunc>,
    pub device_not_available: Entry<HandlerFunc>,
    pub double_fault: Entry<HandlerFuncWithErrCode>,
    pub invalid_tss: Entry<HandlerFuncWithErrCode>,
    pub segment_not_present: Entry<HandlerFuncWithErrCode>,
    pub stack_segment_fault: Entry<HandlerFuncWithErrCode>,
    pub general_protection_fault: Entry<HandlerFuncWithErrCode>,
    pub page_fault: Entry<PageFaultHandlerFunc>,
    pub x87_floating_point: Entry<HandlerFunc>,
    pub alignment_check: Entry<HandlerFuncWithErrCode>,
    pub machine_check: Entry<HandlerFunc>,
    pub simd_floating_point: Entry<HandlerFunc>,
    pub virtualization: Entry<HandlerFunc>,
    pub security_exception: Entry<HandlerFuncWithErrCode>,
    // some fields omitted
}
```


每一个字段都是 [`idt::Entry<F>`](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.Entry.html) 类型，这个类型包含了一条完整的IDT条目（定义参见上文）。 其泛型参数 `F` 定义了中断处理函数的类型，在有些字段中该参数为 [`HandlerFunc`](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFunc.html)，而有些则是 [`HandlerFuncWithErrCode`](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFuncWithErrCode.html)，而对于 page fault 这种特殊异常，则为 [`PageFaultHandlerFunc`](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.PageFaultHandlerFunc.html)。

首先让我们看一看 `HandlerFunc` 类型的定义：

```rust
type HandlerFunc = extern "x86-interrupt" fn(_: InterruptStackFrame);
```

这是一个针对 `extern "x86-interrupt" fn` 类型的 [类型别名](https://doc.rust-lang.org/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases)。`extern` 关键字使用 [外部调用约定](https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions) 定义了一个函数，这种定义方式多用于和C语言代码通信（`extern "C" fn`），那么这里的外部调用约定又究竟调用了哪些东西？
