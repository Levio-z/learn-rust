你总结得很准确。调用约定里寄存器分为两类：

1. **callee-saved（被调用者保存，保留寄存器）**
    - 特点：调用结束后必须保持原值。
    - 责任：**被调用函数**（callee）要负责保存和恢复。
    - 实现方式：在函数入口时压栈（`push`），在返回前恢复（`pop`）。
    - 例子（x86-64 System V ABI）：`rbx, rbp, r12–r15`。
    > 这也是为什么很多函数汇编开头是：
    > `push rbp mov  rbp, rsp`
    > 因为 `rbp` 是 callee-saved。
---

2. **caller-saved（调用者保存，临时寄存器）**
    - 特点：调用结束后可能被覆盖，不保证值还在。
    - 责任：**调用者**（caller）在调用函数之前若还要用这些寄存器的值，就得先保存（通常压栈），调用完成后再恢复。
    - 实现方式：调用函数前自己保存（`push` 或写到栈帧里），返回后再恢复。
    - 例子（x86-64 System V ABI）：`rax, rcx, rdx, rsi, rdi, r8–r11`。
    > 比如 `rax` 既是 caller-saved，又是函数返回值寄存器，所以调用函数时通常会破坏它的内容。
---

### 总结一句
- **callee-saved = 被调用者保存（函数要保证返回后寄存器值不变）**
- **caller-saved = 调用者保存（调用函数前要自己备份值）**

所以这两类寄存器的区别就在于：**谁来负责保证寄存器值的延续性**。