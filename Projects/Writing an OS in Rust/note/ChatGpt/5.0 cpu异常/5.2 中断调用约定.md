### 中断调用约定

异常触发十分类似于函数调用：CPU会直接跳转到处理函数的第一个指令处开始执行，执行结束后，CPU会跳转到返回地址，并继续执行之前的函数调用。

然而两者最大的不同点是：函数调用是由编译器通过 `call` 指令主动发起的，而错误处理函数则可能会由任何指令触发。要了解这两者所造成影响的不同，我们需要更深入的追踪函数调用。

[调用约定](https://en.wikipedia.org/wiki/Calling_convention) 指定了函数调用的详细信息，比如可以指定函数的参数存放在哪里（寄存器，或者栈，或者别的什么地方）以及如何返回结果。在 x86_64 Linux 中，以下规则适用于C语言函数（指定于 [System V ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf) 标准）：

- 前六个整型参数从寄存器传入 `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`
- 其他参数从栈传入
- 函数返回值存放在 `rax` 和 `rdx`

注意，Rust并不遵循C ABI，而是遵循自己的一套规则，即 [尚未正式发布的 Rust ABI 草案](https://github.com/rust-lang/rfcs/issues/600)，所以这些规则仅在使用 `extern "C" fn` 对函数进行定义时才会使用。

### 保留寄存器和临时寄存器

调用约定将寄存器分为两部分：_保留寄存器_ 和 _临时寄存器_ 。

_保留寄存器_ **的值应当在函数调用时保持不变**，所以被调用的函数（ _“callee”_ ）只有在保证“返回之前将这些寄存器的值恢复到初始值“的前提下，才被允许覆写这些寄存器的值， 在函数开始时将这类寄存器的值存入栈中，并在返回之前将之恢复到寄存器中是一种十分常见的做法。

而 _临时寄存器_ 则相反，被调用函数可以无限制的反复写入寄存器，若调用者希望此类寄存器在函数调用后保持数值不变，则需要自己来处理备份和恢复过程（例如将其数值保存在栈中），因而这类寄存器又被称为 _caller-saved_。

在 x86_64 架构下，C调用约定指定了这些寄存器分类：


|保留寄存器|临时寄存器|
|---|---|
|`rbp`, `rbx`, `rsp`, `r12`, `r13`, `r14`, `r15`|`rax`, `rcx`, `rdx`, `rsi`, `rdi`, `r8`, `r9`, `r10`, `r11`|
|_callee-saved_|_caller-saved_|

编译器已经内置了这些规则，因而可以自动生成保证程序正常执行的指令。例如绝大多数函数的汇编指令都以 `push rbp` 开头，也就是将 `rbp` 的值备份到栈中（因为它是 `callee-saved` 型寄存器）。

### 保存所有寄存器数据

区别于函数调用，异常在执行 _任何_ 指令时都有可能发生。在大多数情况下，我们在编译期不可能知道程序跑起来会发生什么异常。比如编译器无法预知某条指令是否会触发 page fault 或者 stack overflow。

正因我们不知道异常会何时发生，所以我们无法预先保存寄存器。这意味着我们无法使用依赖调用方备份 (caller-saved) 的寄存器的调用传统作为异常处理程序。因此，我们需要一个保存所有寄存器的传统。x86-interrupt 恰巧就是其中之一，它可以保证在函数返回时，寄存器里的值均返回原样。

但请注意，这并不意味着所有寄存器都会在进入函数时备份入栈。编译器仅会备份被函数覆写的寄存器，继而为只使用几个寄存器的短小函数生成高效的代码。
