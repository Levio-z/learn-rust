内存以称为缓存行的单位存储在缓存系统中。**缓存行是连续字节 2 的幂，通常大小为 32-256**。最常见的缓存行大小是 64 字节。错误共享是一个术语，适用于线程在修改共享同一缓存行的自变量时无意中影响彼此的性能。缓存行上的写入争用是实现 SMP 系统中并行执行线程的可伸缩性的最限制因素。我听说过错误共享被描述为无声性能杀手，因为它在查看代码时远非明显。

为了实现线程数的线性可伸缩性，**我们必须确保没有两个线程写入同一变量或缓存行。可以在代码级别跟踪写入同一变量的两个线程**。为了能够知道自变量是否共享相同的缓存行，我们需要知道内存布局，或者我们可以获得一个工具来告诉我们。英特尔 VTune 就是这样一个分析工具。在本文中，我将解释如何为 Java 对象布局内存，以及如何填充缓存行以避免错误共享。

![](asserts/Pasted%20image%2020250910163321.png)


图 1.上面说明了错误共享的问题。在内核 1 上运行的线程想要更新变量 X，而内核 2 上的线程想要更新变量 Y。**不幸的是，这两个热变量驻留在同一个缓存行中。每个线程都会争夺缓存行的所有权，以便他们可以更新它**。如果内核 1 获得所有权，那么缓存子系统将需要使内核 2 的相应缓存行失效。当内核 2 获得所有权并执行其更新时，内核 1 将被告知使其缓存行的副本失效。这将通过 L3 缓存来回乒乓球，从而极大地影响性能。如果竞争内核位于不同的套接字上，并且还必须跨越套接字互连，则这个问题将进一步加剧。


### **Java 内存布局**

对于热点 JVM，所有对象都有一个 2 字的标头。第一个是“标记”字，它由 24 位的哈希码和 8 位的标志（如锁状态）组成，或者可以交换为锁对象。第二个是对对象类的引用。数组有一个额外的词来表示数组的大小。每个对象都与 8 字节的粒度边界对齐以提高性能。因此，为了在打包时提高效率，对象字段根据大小（以字节为单位）从声明顺序重新排序为以下顺序：

1. doubles (8) and longs (8)  
    双打 （8） 和多头 （8）
2. ints (4) and floats (4)  
    ints （4） 和浮点数 （4）
3. shorts (2) and chars (2)  
    短裤 （2） 和字符 （2）
4. booleans (1) and bytes (1)  
    布尔值 （1） 和字节数 （1）
5. references (4/8)  参考资料 （4/8）
6. `<repeat for sub-class fields>  `
    `<对子类字段重复>`

有了这些知识，我们可以在任何具有 7 个 long 的字段之间填充缓存行。 在 [Disruptor](http://code.google.com/p/disruptor/) 中，我们在 [RingBuffer](http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/RingBuffer.java) 光标和 [BatchEventProcessor](http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/BatchEventProcessor.java) 序列周围填充缓存行。
```java
/**
 * False Sharing 演示
 * 
 * 本示例展示了多线程写入独立计数器时的性能影响。
 * 通过填充（padding）缓存行，可以避免 False Sharing。
 */

public final class FalseSharing implements Runnable {

    // ===============================
    // 配置参数
    // ===============================
    public final static int NUM_THREADS = 4;                       // 线程数
    public final static long ITERATIONS = 500L * 1000L * 1000L;    // 每个线程写入次数

    private final int arrayIndex;   // 当前线程操作的计数器索引

    // ===============================
    // 线程共享数组
    // ===============================
    private static VolatileLong[] longs = new VolatileLong[NUM_THREADS];

    static {
        // 初始化每个计数器对象
        for (int i = 0; i < longs.length; i++) {
            longs[i] = new VolatileLong();
        }
    }

    // ===============================
    // 构造方法
    // ===============================
    public FalseSharing(final int arrayIndex) {
        this.arrayIndex = arrayIndex;
    }

    // ===============================
    // 主函数
    // ===============================
    public static void main(final String[] args) throws Exception {
        final long start = System.nanoTime();
        runTest();
        System.out.println("duration = " + (System.nanoTime() - start));
    }

    // ===============================
    // 启动线程执行测试
    // ===============================
    private static void runTest() throws InterruptedException {
        Thread[] threads = new Thread[NUM_THREADS];

        // 创建线程
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(new FalseSharing(i));
        }

        // 启动线程
        for (Thread t : threads) {
            t.start();
        }

        // 等待所有线程完成
        for (Thread t : threads) {
            t.join();
        }
    }

    // ===============================
    // 线程执行逻辑：写入自己的计数器
    // ===============================
    public void run() {
        long i = ITERATIONS + 1;
        while (0 != --i) {
            longs[arrayIndex].value = i;  // 写入独立变量
        }
    }

    // ===============================
    // 计数器类
    // ===============================
    public final static class VolatileLong {
        public volatile long value = 0L;  // 线程操作的核心变量

        // ===============================
        // 填充字段（避免 False Sharing）
        // ===============================
        // 每个 long 占 8 字节，7 个 long 约 56 字节，加上对象头 8 字节 ≈ 64 字节缓存行
        public long p1, p2, p3, p4, p5, p6; 

        /*
        如果想测试 False Sharing，可以注释掉上面的 padding 字段：
        // public long p1, p2, p3, p4, p5, p6;
        然后比较性能差异
        */
    }
}


```


### 注释说明

1. **VolatileLong.value**
    - `volatile` 保证线程间可见性。
    - 但 False Sharing 是缓存层面的问题，`volatile` 并不能解决。
2. **缓存行填充（p1~p6）**
    - 避免多个线程的计数器共享同一缓存行。
    - 填充后，每个计数器独占一个缓存行 → 性能大幅提升。
3. **False Sharing 测试方法**
    - 注释掉填充字段，再运行测试 → 耗时显著增加。
    - 保留填充字段 → 耗时减少。
### 结果
为了显示性能影响，让我们以几个线程为例，每个线程更新自己的独立计数器。 这些计数器将是不_稳定的，_ 因此世界可以看到它们的进步。 **结果**  
  

运行上述代码，同时增加线程数并添加/删除缓存行填充，我得到了图 2 中所示的结果。 下面。 这是在测量我的 4 核 Nehalem 上的测试运行持续时间。

![](asserts/Pasted%20image%2020250910163627.png)



从完成测试所需的执行时间增加可以清楚地看到错误共享的影响。如果没有缓存行争用，我们就实现了线程的近乎线性纵向扩展。

这不是一个完美的测试，因为我们无法确定 _VolatileLong 将_放置在内存中的哪个位置。 它们是独立的对象。 然而，经验表明，同时分配的对象往往位于同一位置。

所以你有它。虚假分享可能是无声的性能杀手。






