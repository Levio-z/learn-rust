**VGA 字符模式**（[VGA text mode](https://en.wikipedia.org/wiki/VGA-compatible_text_mode)）是打印字符到屏幕的一种简单方式。在这篇文章中，为了包装这个模式为一个安全而简单的接口，我们将包装 unsafe 代码到独立的模块。我们还将实现对 Rust 语言**格式化宏**（[formatting macros](https://doc.rust-lang.org/std/fmt/#related-macros)）的支持。

### VGA 字符缓冲区
为了在 VGA 字符模式中向屏幕打印字符，我们必须将它写入硬件提供的 **VGA 字符缓冲区**（VGA text buffer）。通常状况下，VGA 字符缓冲区是一个 25 行、80 列的二维数组，它的内容将被实时渲染到屏幕。这个数组的元素被称作**字符单元**（character cell），它使用下面的格式描述一个屏幕上的字符：

| Bit(s) | Value            |
| ------ | ---------------- |
| 0-7    | ASCII code point |
| 8-11   | Foreground color |
| 12-14  | Background color |
| 15     | Blink            |
第一个字节表示了应当输出的 [ASCII 编码](https://en.wikipedia.org/wiki/ASCII)，更加准确的说，类似于 [437 字符编码表](https://en.wikipedia.org/wiki/Code_page_437) 中字符对应的编码，但又有细微的不同。 这里为了简化表达，我们在文章里将其简称为ASCII字符。

第二个字节则定义了字符的显示方式，前四个比特定义了前景色，中间三个比特定义了背景色，最后一个比特则定义了该字符是否应该闪烁，以下是可用的颜色列表：

| Number | Color      | Number + Bright Bit | Bright Color |
| ------ | ---------- | ------------------- | ------------ |
| 0x0    | Black      | 0x8                 | Dark Gray    |
| 0x1    | Blue       | 0x9                 | Light Blue   |
| 0x2    | Green      | 0xa                 | Light Green  |
| 0x3    | Cyan       | 0xb                 | Light Cyan   |
| 0x4    | Red        | 0xc                 | Light Red    |
| 0x5    | Magenta    | 0xd                 | Pink         |
| 0x6    | Brown      | 0xe                 | Yellow       |
| 0x7    | Light Gray | 0xf                 | White        |
每个颜色的第四位称为**加亮位**（bright bit），比如blue加亮后就变成了light blue，但对于背景色，这个比特会被用于标记是否闪烁。

要修改 VGA 字符缓冲区，我们可以通过**存储器映射输入输出**（[memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)）的方式，读取或写入地址 `0xb8000`；这意味着，我们可以像操作普通的内存区域一样操作这个地址。

需要注意的是，一些硬件虽然映射到存储器，但可能**不会完全支持所有的内存操作**：可能会有一些设备支持按 `u8` 字节读取，但在读取 `u64` 时返回无效的数据。幸运的是，字符缓冲区都[支持标准的读写操作](https://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#manip)，所以我们不需要用特殊的标准对待它。
### VGA 显示内存地址转换

在 VGA 显示系统中，内存地址的转换是一个复杂的过程，尤其是主机地址和显示内存地址之间的映射。为了理解这一点，我们需要了解 VGA 内部的内存结构以及主机如何与显示内存交互。

#### VGA 内存结构

VGA 显示系统有 64K 的 32 位内存位置。这些内存位置被分为四个 64K 位平面，每个平面负责显示不同颜色的组成部分。由于 VGA 最初是为 8 位和 16 位总线系统设计的，它并不能直接通过主机 CPU 进行内存访问。取而代之的是，主机通过 I/O 寄存器与 VGA 显示内存进行交互，I/O 寄存器允许将一部分显示内存暴露给主机。

65536 个位置×4 字节/位置=262144 字节=256 KB

#### 寻址模式

VGA 显示系统有三种寻址模式，分别是：

1. **链 4（Chain 4）模式**
    
    - **用途**：这种模式主要用于 MCGA（多颜色图形适配器）仿真，尤其是在 320x200 256 色模式下。该模式会将地址映射到内存的 MOD 4，即将地址右移 2 位。
        
    - **原理**：在这种模式下，VGA 显示器将内存地址按照每 4 个内存位置为一组进行映射。每次对显示内存的访问都将地址右移两位，从而访问不同的位平面。这意味着，主机 CPU 和显示内存之间的地址转换实际上是通过 I/O 寄存器来间接完成的。
        
2. **奇数/偶数模式（Odd/Even Mode）**
    
    - **用途**：这种模式通常用于同时访问显示内存的两个位平面，其中一个位平面用于偶数行，另一个位平面用于奇数行的显示内容。
        
    - **原理**：在此模式下，VGA 的地址将被拆分为偶数位和奇数位，确保显示图像时行和列之间的映射更加高效。
        
3. **正常模式（Normal Mode）**
    
    - **用途**：这是 VGA 的标准显示模式，通常在 256 色模式下使用。
        
    - **原理**：在此模式下，VGA 显示内存的地址映射更加简单，直接将主机地址转换为显示内存地址。此模式下的地址映射没有额外的转换或位移，因此更容易理解。
        

#### 地址转换的复杂性

VGA 内存地址转换的复杂性来自于主机地址与显示内存地址之间的间接映射。这是因为 VGA 使用了 I/O 寄存器来映射内存，主机无法直接访问显示内存的各个位平面，必须通过寄存器来操作特定的内存位置。具体来说，主机 CPU 会根据显示模式和显示内存的布局，通过某些寄存器来决定哪个内存位置需要被访问，从而实现显示内容的更新。

### 用作显示内存

VGA 显示硬件具有对数据执行位操作的能力，允许在 **四个显示平面** 上进行操作。这意味着，可以同时对显示内存中的多个位平面进行读写，从而加速图形的渲染和更新。显示平面通常存储图像的不同颜色通道或层。
#### **常见位操作包括：**

- **位与 (AND)**：执行逐位的逻辑与操作，用于清除某些位。
- **位或 (OR)**：执行逐位的逻辑或操作，用于设置某些位。
- **异或 (XOR)**：执行逐位的逻辑异或操作，常用于翻转某些位。
- **位旋转和屏蔽**：对位进行旋转或屏蔽，可以改变位的顺序或屏蔽掉不需要的数据。
#### 硬件加速
- **快速比较**：硬件可以直接比较显示内存中的数据，而不需要通过 CPU 进行逐位操作。这使得在处理图形时可以更高效地进行图像检测和碰撞检测等任务。
    
- **同时写入多个平面**：VGA 硬件支持一次性向多个显示平面写入数据，而不需要逐一操作。这种并行写入大大提高了图形更新的效率。
    
- **数据移动**：VGA 硬件支持将显示内存中的数据块快速移动到另一个区域，这对于实现图像滚动或窗口移动等操作非常重要，避免了 CPU 的繁重计算。
    
- **快速逻辑运算（AND/OR/XOR）**：这些操作在硬件中直接执行，而不是通过软件实现，能够加速图形效果的生成，如图像合成、透明度效果等。

#### **16 种颜色模式编程**

VGA 支持 **16 种颜色模式**，每种模式可能涉及不同的位平面配置。利用这些硬件功能能够更高效地处理不同的显示模式，如：

- **文本模式**：通常是 80x25 的字符显示，每个字符由 2 字节表示，利用位操作可以进行高效的文本处理和修改。
- **256 色模式**：每个像素由 1 字节表示，直接与颜色索引映射。
- **16 色模式**：每个像素由 4 位表示，硬件位操作可以在多个位平面中同时写入数据，提高效率。


VGA 显示系统的硬件功能提供了大量的位操作和图形加速选项，可以极大提高图形操作的效率。通过使用这些硬件功能，程序员能够更高效地处理图像显示，尤其是在复杂的颜色模式和快速动态变化的图形中。这些功能虽然简单，但也足够复杂，很多程序员为了简化编程，可能会忽略它们，然而在高效编程时，它们的作用不容忽视。

### 1. **Reading from Display Memory（从显示器内存读取）**

VGA 显示系统有两种读取模式，分别由 **Read Mode** 字段选择。这两种模式具有不同的用途，分别是：

#### **Read Mode 0**

- **功能**：从显示内存的单个位平面读取一个或多个连续的字节。
- **操作**：读取的数据来自 **Read Map Select** 字段指定的显示内存页面。对于平面模式下的每个像素值，必须执行四次读取操作，**每个操作读取一个位平面的数据。如果读取多个字节数据，推荐一次读取一个平面，避免对每个字节执行多个 I/O 操作**，从而提高读取效率。
    
#### **Read Mode 1**

- **功能**：将显示内存与 **Color Compare** 字段指定的参考颜色进行比较，并且使用 **Color Don’t Care** 字段来屏蔽掉不关心的颜色通道。
- **操作**：该模式允许快速执行最多 32 个像素的比较，适用于快速的泛洪填充（flood-fill）算法。例如，在用颜色填充某个区域时，可以在此模式下执行快速像素比较，减少读取次数并加速填充过程。
- **用途**：适用于 **颜色替换** 或者 **泛洪填充** 操作，结合 **Write Mode 3** 使用时，还能进行高效的颜色替换。
    

---

### 2. **Writing to Display Memory（写入显示内存）**

VGA 显示系统有四种写入模式，通过 **Write Mode** 字段选择。这些模式定义了如何将主机数据写入显示内存。

#### **Write Mode 0**

- **功能**：标准的通用写入模式，执行五个阶段的处理，对数据进行旋转、复制、逻辑运算等操作。
    
- **操作**：
    
    1. **旋转操作**：根据 **Rotate Count** 字段旋转主机数据。例如，旋转可以用于调整图像的方向、进行颜色通道的调整等。
        
    2. **复制和设置/重置操作**：通过 **Enable Set/Reset** 字段，选择哪些位平面接收主机数据，哪些位平面接收设置/重置字段中的数据。**Set/Reset** 字段控制将每个平面的数据设置为全 0（重置）或全 1（设置）。
        
    3. **逻辑运算**：对主机数据和锁存寄存器数据进行逻辑运算（AND、OR、XOR 等）。该操作用来**选择性地更新显示内存中的不同位平面**，并为某些像素赋值为完全的“0”或“1”。这个操作对于**设置/清除特定区域**（例如清除屏幕或填充区域）是非常有用的。该操作用于对数据进行**条件处理和修改**，例如合成不同层次的数据、将图形数据进行合并或修改。对于**图像合成、遮罩处理**等图形操作非常有用。
        
    4. **位掩码操作**：根据 **Bit Mask** 字段选择结果数据或锁存寄存器数据。通过掩码操作，可以实现对显示内存中特定位平面**部分更新**。这允许精确控制哪些像素或颜色通道需要更新或修改。例如，**仅更新图像的某个特定颜色通道或区域，而不影响其他区域**。
        
    5. **写入操作**：将处理后的数据写入显示内存，受到 **Memory Plane Write Enable** 字段的控制。
        

#### **Write Mode 1**

- **功能**：将**锁存寄存器**中的数据直接传输到显示器屏幕，受 **Memory Plane Write Enable** 字段的影响。
- **操作**：这种模式适用于将数据在字节边界之间快速传输，或填充显示区域。例如，可以用来快速移动显示内存中的数据或填充 8 像素的图案。
	-  **快速数据传输**：比如将一个区域的数据从显示内存中的一个位置迅速移动到另一个位置。
	- **填充图案**：此模式也非常适用于填充屏幕上的 **8 像素**模式图案。由于此操作是直接的，它可以非常快速地完成数据复制和填充操作，减少了其他复杂操作的影响。
    

#### **Write Mode 2**

- **功能**：将主机数据字节的低 4 位解压到 4 个显示平面中。
- **操作**：每个位平面的数据位将通过复制的方式填充显示内存。逻辑运算和位掩码操作会按照指定字段进行处理，最后将数据写入显示内存。
	- 每个位平面的数据位将被 **复制** 来填充显示内存中的相应位置。
	- **数据解压**：从主机数据字节的低 4 位中提取每个像素的数据，并将其分配到不同的位平面上。这对于**多通道显示**或**像素级别的颜色解码**非常有效。
	- **逻辑运算和位掩码操作**：此模式支持执行进一步的 **逻辑运算**（如 AND、OR、XOR）和 **位掩码** 操作，以进一步处理解压后的数据。
	- 最终的结果数据会写入显示内存，确保显示数据正确分配到对应的颜色平面。
    

#### **Write Mode 3**

- **功能**：适用于**颜色恒定但需要频繁改变位掩码字段的操作**（例如绘制单色线条或文本）。我们会用到 **位掩码** 来精确地控制哪些像素点需要更新。这些操作常见于 VGA 或其他图形硬件的显示控制。这里的“位掩码字段”指的是控制哪些像素更新或保留的标志。通过位掩码操作，我们可以精确控制哪些像素需要被修改、哪些需要保留原样。
- **操作**：
    1. **旋转**：根据 **Rotate Count** 字段旋转主机数据。
	    1. 调整数据的排列顺序，以适应图形或文本的方向要求。根据 **Rotate Count** 字段，旋转主机数据的位。这通常在需要将图形旋转到不同角度时使用（例如文本的旋转、线条的方向调整等）。
    2. **与位掩码结合**：将主机数据与 **Bit Mask** 字段进行 AND 操作。位掩码操作确保只有特定区域的像素被更新，这对于频繁绘制图形或文本时非常高效。
    3. **逻辑运算**：对结果数据和锁存寄存器的数据进行逻辑运算。
	    1. 当绘制一条线时，使用 **OR** 运算将新数据与已有显示数据合并，确保线条在正确的区域显示，而不影响其他图形或背景。
	    2. **AND**：保留主机数据中的匹配位，清除不匹配位
	    3. **XOR**：对比数据，只有不同的位才会被设置为1。
    4. **写入**：最终将数据写入显示内存，受 **Memory Plane Write Enable** 字段的影响。
        
