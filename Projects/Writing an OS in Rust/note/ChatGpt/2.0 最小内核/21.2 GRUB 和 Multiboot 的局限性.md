#### 1. **仅支持 32 位保护模式**
Multiboot 标准最初是为 32 位 x86 架构设计的，因此它只支持将操作系统引导到 32 位保护模式。这意味着：
- 如果你开发的是一个 64 位操作系统，内核在被引导后仍然需要自行切换到 64 位的长模式（Long Mode）。
- 这增加了内核启动时的复杂性，因为内核需要在引导后立即进行模式切换，而这个过程需要处理许多低级细节，例如设置分页机制、配置 CPU 控制寄存器等。
#### 2. **精简引导程序，而非精简内核**

GRUB 和 Multiboot 标准的设计目标是简化引导程序的实现，但这也带来了一些限制：

- **内核链接要求**：内核需要以特定的方式链接，例如使用调整过的默认页长度（default page size）。如果内核没有按照这些要求链接，GRUB 可能无法正确找到内核的 Multiboot 头，从而导致引导失败。
	- Multiboot2 头文件的第一部分是一个在 8 字节边界上对齐的结构体，其中包含四个 “神奇” 的 32 位整数。这些字段分别包含幻数 0xE85250D6、描述架构的标志、包括后续标签在内的标头总长度以及幻字段的校验和。
    
- **引导信息的复杂性**：引导信息（boot information）包含大量与架构相关的数据，这些数据在引导启动时直接传递给操作系统，而没有经过一层清晰的抽象。这意味着内核需要直接处理这些低级数据，增加了内核启动代码的复杂性。
    

#### 3. **文档和易用性问题**

- **文档不详细**：GRUB 和 Multiboot 的文档并没有详细解释所有细节，阅读和理解这些文档需要一定的经验，尤其是对于初学者来说，可能会感到困惑。
    
- **开发环境限制**：为了创建一个能够被引导的磁盘映像，开发人员通常需要在开发环境中安装 GRUB。这对于基于 Windows 或 macOS 的开发环境来说增加了难度，因为这些系统通常不自带 GRUB，需要额外配置。
    

### 替代方案：bootimage 工具

bootimage 是一个现代的工具，旨在简化操作系统开发过程，特别是在 Rust 语言的生态系统中。它提供了一些优势：

- **支持多种目标架构**：包括 64 位系统，而不仅仅是 32 位。
    
- **简化开发流程**：不需要在开发环境中安装 GRUB，降低了开发难度。
    
- **更好的抽象和封装**：提供更清晰的接口和抽象，使得内核开发更加简单。