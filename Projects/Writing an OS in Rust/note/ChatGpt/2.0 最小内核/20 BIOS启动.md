几乎所有的 x86 硬件系统都支持 BIOS 启动，这也包含新型的、基于 UEFI、用**模拟 BIOS**（emulated BIOS）的方式向后兼容的硬件系统。这可以说是一件好事情，因为无论是上世纪还是现在的硬件系统，你都只需编写同样的引导启动逻辑；但这种兼容性有时也是 BIOS 引导启动最大的缺点，因为这意味着在系统启动前，你的 CPU 必须先进入一个 16 位系统兼容的**实模式**（[real mode](https://en.wikipedia.org/wiki/Real_mode)），这样 1980 年代古老的引导固件才能够继续使用。


BIOS 并**不理解文件系统**，它只知道如何读磁盘扇区。它找 bootloader 的方式非常“原始”但固定：

### BIOS 加载 bootloader 的完整流程：

1. **POST 检查硬件**后，BIOS 会读取 CMOS 设置中设定的启动顺序（比如 USB → 硬盘 → 网络）。
2. 以最高优先级设备为目标，从其读取第一个扇区：**主引导记录（MBR，Master Boot Record）**。
    - 位于磁盘 LBA 0（也就是扇区 0），大小为 **512 字节**。
3. 将这个扇区加载到 **内存地址 `0x7C00`**。
4. BIOS 检查最后两个字节是否为魔数 `0x55AA`（用于识别是否是可引导扇区）。
5. 如果是，就**跳转执行 `0x7C00` 处的代码**，即交出控制权。
[21 引导程序](21%20引导程序.md)


### MBR 的结构：

|偏移|长度|含义|
|---|---|---|
|0x000|446 字节|Bootloader stub（bootloader 代码片段）|
|0x1BE|64 字节|分区表（4 个 16 字节项）|
|0x1FE|2 字节|启动标志 `0x55AA`|
### BIOS 启动的兼容性
- **历史积淀**：自 1980 年代 IBM PC 起，BIOS 标准成为 x86 生态系统的启动基础。
- **广泛支持**：从老旧台式机、笔记本，到如今大部分基于 x86 的硬件系统，都能识别和执行 BIOS 固件代码。
- **向后兼容**：即使是现代硬件通常采用 UEFI 固件，也会实现“兼容支持模式”（CSM，Compatibility Support Module），模拟 BIOS 行为。
- **引导统一性**：操作系统厂商和开发者可以编写一套引导代码，兼容所有 x86 设备，降低开发复杂度。
#### 实模式（Real Mode）是什么
- 16 位寻址，最大可寻址内存为 1MB。
- 无分页机制，无内存保护。
- 只能执行简单指令集，且寄存器与内存访问受限。
**为何必须先进入实模式**：
- 传统 BIOS 固件和 MBR 引导程序都是基于实模式设计，依赖其简单的内存模型和中断机制。
- 这保证了即使是极其古老的启动代码也能执行。
#### 兼容性带来的限制与缺点
- **启动性能瓶颈**：
    - 进入实模式意味着 CPU 在启动初期只能以非常低效的方式运行。
    - 后续必须切换到保护模式（Protected Mode）或长模式（Long Mode）才能利用现代 CPU 的全部性能。
- **开发复杂性**：
    - 开发现代操作系统或引导加载器时，必须先写实模式下的启动汇编代码，再切换到更高级模式。
    - 这增加了启动代码的复杂度和调试难度。
- **功能受限**：
    - 实模式无法访问现代硬件的高级特性（如大容量内存、64 位寄存器、复杂中断控制等）。
    - 这限制了启动程序的设计空间。
#### UEFI 如何解决
- UEFI 规范定义了从固件启动就进入 **保护模式或长模式**。
- UEFI 支持现代 CPU 的 64 位特性，能直接加载更大、更复杂的引导程序。
- 但为了兼容 BIOS 启动的遗留操作系统，很多 UEFI 固件仍然提供 CSM 模块。
	- 很多操作系统（尤其是 Windows 7 之前的版本、某些老旧 Linux 发行版）和旧软件依赖 BIOS 启动流程。没有 CSM，这些系统无法在纯 UEFI 环境下启动。
	- 主板厂商和芯片组设计者需要在不破坏现有用户体验的前提下，逐步推广 UEFI。CSM 是桥梁，确保用户无需立刻升级操作系统。