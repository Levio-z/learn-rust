`test` 库依赖于标准库，所以它在我们的裸机目标上并不可用。虽然将 `test` 库移植到一个 `#[no_std]` 上下文环境中是[可能的](https://github.com/japaric/utest)，但是这样做是高度不稳定的，并且还会需要一些特殊的hacks，例如重定义 `panic` 宏。

### 自定义测试框架
Rust 提供了一个 **不稳定特性** `custom_test_frameworks`，允许用户 **替换默认的测试框架**。它的核心目的在于：
- 允许在 **`#[no_std]`** 环境下进行测试，而无需依赖 `std` 或 `libtest`。
- 提供对测试收集与执行过程的 **完全控制**。
- 允许自定义测试报告、执行顺序、日志收集等行为。

与默认的测试框架相比，它的缺点是有一些高级功能诸如 [`should_panic` tests](https://doc.rust-lang.org/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic) 都不可用了。相对的，如果需要这些功能，我们需要自己来实现。当然，这点对我们来说是好事，因为我们的环境非常特殊，在这个环境里，这些高级功能的默认实现无论如何都是无法工作的，举个例子， `#[should_panic]` 属性依赖于栈展开来捕获内核panic，而我们的内核早已将其禁用了。

要为我们的内核实现自定义测试框架，我们需要将如下代码添加到我们的 `main.rs` 中去:

```rust
// in src/main.rs

#![feature(custom_test_frameworks)]
#![test_runner(crate::test_runner)]

#[cfg(test)]
pub fn test_runner(tests: &[&dyn Fn()]) {
    println!("Running {} tests", tests.len());
    for test in tests {
        test();
    }
}
```
我们的runner会打印一个简短的debug信息然后调用列表中的每个测试函数。参数类型 `&[&dyn Fn()]` 是[_Fn()_](https://doc.rust-lang.org/std/ops/trait.Fn.html) trait的 [_trait object_](https://doc.rust-lang.org/1.30.0/book/first-edition/trait-objects.html) 引用的一个 [_slice_](https://doc.rust-lang.org/std/primitive.slice.html)。它基本上可以被看做一个可以像函数一样被调用的类型的引用列表。由于这个函数在不进行测试的时候没有什么用，这里我们使用 `#[cfg(test)]`属性保证它只会出现在测试中。

现在当我们运行 `cargo test` ，我们可以发现运行成功了。然而，我们看到的仍然是“Hello World“而不是我们的 `test_runner`传递来的信息。这是由于我们的入口点仍然是 `_start` 函数——**自定义测试框架会生成一个`main`函数来调用`test_runner`**，但是由于我们使用了 `#[no_main]`并提供了我们自己的入口点，所以这个`main`函数就被忽略了。
- 在裸机环境下，由于没有标准 `main` 调用点，这个函数 **没有被 `_start` 调用**。
- 需要显示调用

>**Note:** cargo目前有个bug，就是某些测试用例会在执行 `cargo test` 时抛出 `duplicate lang item` 错误。目前已知的复现条件是在你的 `Cargo.toml` 中配置 `panic = "abort"`，只要移除掉，`cargo test` 即可正常执行。如果你对这个bug感兴趣，可以关注一下这个 [cargo issue](https://github.com/rust-lang/cargo/issues/7359)。

为了修复这个问题，**我们需要通过 `reexport_test_harness_main`属性来将生成的函数的名称更改为与`main`不同的名称**。然后我们可以在我们的`_start`函数里调用这个重命名的函数:

```rust
// in src/main.rs

#![reexport_test_harness_main = "test_main"]

#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    println!("Hello World{}", "!");

    #[cfg(test)]
    test_main();

    loop {}
}
```

我们将测试框架的入口函数的名字设置为`test_main`，并在我们的 `_start`入口点里调用它。通过使用**条件编译**（[conditional compilation](https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html)），我们能够只在上下文环境为测试（test）时调用 `test_main` ，因为该函数将不在非测试上下文中生成。

现在当我们执行 `cargo test`时，我们可以看到我们的`test_runner`将“Running 0 tests“信息显示在屏幕上了。我们可以创建第一个测试函数了:

### 普通环境
### 1. 普通二进制 crate（有 `main`，没有 `#[no_main]`）

- Rust 编译器会把 `fn main()` 作为程序入口。
    
- 使用自定义测试框架（`custom_test_frameworks`）时，编译器会 **自动生成一个 `main` 函数**，其作用是：
    
    1. 收集所有标记了 `#[test_case]` 的函数。
        
    2. 调用用户指定的 `test_runner`。
        
- **自动调用**：这个生成的 `main` 会替换原有的 `main`，或者在测试模式下作为入口被执行。
    
- 结论：在标准 Rust 测试环境下，生成的 `main` 会自动调用。

### 2. 裸机 / `#[no_std]` / `#[no_main]` crate

- 你自己定义了 `_start` 作为入口点：
    `#[no_mangle] pub extern "C" fn _start() -> ! {     // 初始化     loop {} }`
- 因为 `#[no_main]`：
    - 编译器不会生成标准 `main`。
    - 自定义测试框架生成的 `main` 也**不会被 `_start` 自动调用**。
- 结果：
    - 你看到的输出还是 `_start` 内的逻辑（如 “Hello World”）。
    - 测试函数虽然被收集，但没有执行，除非显式调用生成的测试入口函数（通常用 `reexport_test_harness_main` 重命名）。
