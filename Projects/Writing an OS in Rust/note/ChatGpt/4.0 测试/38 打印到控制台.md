要在控制台上查看测试输出，我们需要以某种方式将数据从内核发送到宿主系统。 有多种方法可以实现这一点，例如通过TCP网络接口来发送数据。但是，设置网络堆栈是一项很复杂的任务，这里我们可以选择更简单的解决方案。
### 串口

发送数据的一个简单的方式是通过[串行端口](https://en.wikipedia.org/wiki/Serial_port)，这是一个现代电脑中已经不存在的旧标准接口（译者注：玩过单片机的同学应该知道，其实译者上大学的时候有些同学的笔记本电脑还有串口的，没有串口的同学在烧录单片机程序的时候也都会需要usb转串口线，一般是51，像stm32有st-link，这个另说，不过其实也可以用串口来下载）。串口非常易于编程，QEMU可以将通过串口发送的数据重定向到宿主机的标准输出或是文件中。

用来实现串行接口的芯片被称为 [UARTs](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter)。在x86上，有[很多UART模型](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#UART_models)，但是幸运的是，它们之间仅有的那些不同之处都是我们用不到的高级功能。目前通用的UARTs都会兼容[16550 UART](https://en.wikipedia.org/wiki/16550_UART)，所以我们在我们测试框架里采用该模型。

我们使用 [`uart_16550`](https://docs.rs/uart_16550) crate来初始化UART，并通过串口来发送数据。为了将该crate添加为依赖，我们需要将 `Cargo.toml` 和 `main.rs` 修改为如下:


```toml
# in Cargo.toml

[dependencies]
uart_16550 = "0.2.0"
```

`uart_16550` crate包含了一个代表UART寄存器的 `SerialPort` 结构体，但是我们仍然需要自己来创建一个相应的实例。我们使用以下代码来创建一个新的串口模块 `serial`:

```rust
// in src/main.rs

mod serial;
```



就像[VGA文本缓冲区](https://os.phil-opp.com/vga-text-mode/#lazy-statics)一样，我们使用 `lazy_static` 和一个自旋锁来创建一个 `static` writer实例。通过使用 `lazy_static` ，我们可以保证 `init` 方法只会在该示例第一次被使用使被调用。
```rust
// in src/serial.rs

use uart_16550::SerialPort;
use spin::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    pub static ref SERIAL1: Mutex<SerialPort> = {
        let mut serial_port = unsafe { SerialPort::new(0x3F8) };
        serial_port.init();
        Mutex::new(serial_port)
    };
}
```
和 `isa-debug-exit` 设备一样，UART也是通过I/O端口进行编程的。由于UART相对来讲更加复杂，它使用多个I/O端口来对不同的设备寄存器进行编程。`unsafe` 的 `SerialPort::new` 函数需要UART的第一个I/O端口的地址作为参数，从该地址中可以计算出所有所需端口的地址。我们传递的端口地址为 `0x3F8` ，该地址是第一个串行接口的标准端口号。

为了使串口更加易用，我们添加了 `serial_print!` 和 `serial_println!`宏:

该实现和我们此前的 `print` 和 `println` 宏的实现非常类似。 由于 `SerialPort` 类型已经实现了 [`fmt::Write`](https://doc.rust-lang.org/nightly/core/fmt/trait.Write.html) trait，所以我们不需要提供我们自己的实现了。

现在我们可以从测试代码里向串行接口打印而不是向VGA文本缓冲区打印了:

```rust
// in src/main.rs

#[cfg(test)]
fn test_runner(tests: &[&dyn Fn()]) {
    serial_println!("Running {} tests", tests.len());
    […]
}

#[test_case]
fn trivial_assertion() {
    serial_print!("trivial assertion... ");
    assert_eq!(1, 1);
    serial_println!("[ok]");
}
```
###  QEMU参数
为了查看QEMU的串行输出，我们需要使用 `-serial` 参数将输出重定向到stdout：
```toml
# in Cargo.toml

[package.metadata.bootimage]
test-args = [
    "-device", "isa-debug-exit,iobase=0xf4,iosize=0x04", "-serial", "stdio"
]
```
现在，当我们运行 `cargo test` 时，我们可以直接在控制台里看到测试输出了:
```
> cargo test
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a
Building bootloader
    Finished release [optimized + debuginfo] target(s) in 0.02s
Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device
    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
Running 1 tests
trivial assertion... [ok]
```
然而，当测试失败时，我们仍然会在QEMU内看到输出结果，因为我们的panic handler还是用了 `println`。为了模拟这个过程，我们将我们的 `trivial_assertion` test中的断言(assertion)修改为 `assert_eq!(0, 1)`:
```
可以看到，panic信息被打印到了VGA缓冲区里，而测试输出则被打印到串口上了。panic信息非常有用，所以我们希望能够在控制台中来查看它。
```

###  在panic时打印一个错误信息
为了在panic时使用错误信息来退出QEMU，我们可以使用**条件编译**（[conditional compilation](https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html)）在测试模式下使用（与非测试模式下）不同的panic处理方式:

```rust
// in src/main.rs

// our existing panic handler
#[cfg(not(test))] // new attribute
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    loop {}
}

// our panic handler in test mode
#[cfg(test)]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    serial_println!("[failed]\n");
    serial_println!("Error: {}\n", info);
    exit_qemu(QemuExitCode::Failed);
    loop {}
}
```
在我们的测试panic处理中，我们用 `serial_println` 来代替 `println` 并使用失败代码来退出QEMU。注意，在 `exit_qemu` 调用后，我们仍然需要一个无限循环的 `loop` 因为编译器并不知道 `isa-debug-exit` 设备会导致程序退出。

现在，即使在测试失败的情况下QEMU仍然会退出，并会将一些有用的错误信息打印到控制台：
```
> cargo test
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a
Building bootloader
    Finished release [optimized + debuginfo] target(s) in 0.02s
Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device
    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
Running 1 tests
trivial assertion... [failed]

Error: panicked at 'assertion failed: `(left == right)`
  left: `0`,
 right: `1`', src/main.rs:65:5
```


由于现在所有的测试都将输出到控制台上，我们不再需要让QEMU窗口弹出一小会儿了——我们完全可以把窗口藏起来。

###  隐藏 QEMU
由于我们使用 `isa-debug-exit` 设备和串行端口来报告完整的测试结果，所以我们不再需要QEMU的窗口了。我们可以通过向QEMU传递 `-display none` 参数来将其隐藏:
```toml
# in Cargo.toml

[package.metadata.bootimage]
test-args = [
    "-device", "isa-debug-exit,iobase=0xf4,iosize=0x04", "-serial", "stdio",
    "-display", "none"
]
```
现在QEMU完全在后台运行,且没有任何窗口会被打开。这不仅很清爽，还允许我们的测试框架在没有图形界面的环境里，诸如CI服务器或是[SSH](https://en.wikipedia.org/wiki/Secure_Shell)连接里运行。

### 超时

由于 `cargo test` 会等待test runner退出，如果一个测试永远不返回那么它就会一直阻塞test runner。幸运的是，在实际应用中这并不是一个大问题，因为无限循环通常是很容易避免的。在我们的这个例子里，无限循环会发生在以下几种不同的情况中：

- bootloader加载内核失败，导致系统不停重启；
- BIOS/UEFI固件加载bootloader失败，同样会导致无限重启；
- CPU在某些函数结束时进入一个 `loop {}` 语句，例如因为QEMU的exit设备无法正常工作而导致死循环；
- 硬件触发了系统重置，例如未捕获CPU异常时（后续的文章将会详细解释）。

由于无限循环可能会在各种情况中发生，因此， `bootimage` 工具默认为每个可执行测试设置了一个长度为5分钟的超时时间。如果测试未在此时间内完成，则将其标记为失败，并向控制台输出“Timed Out（超时）“错误。这个功能确保了那些卡在无限循环里的测试不会一直阻塞 `cargo test`。

你可以将`loop {}`语句添加到 `trivial_assertion` 测试中来进行尝试。当你运行 `cargo test` 时，你可以发现该测试会在五分钟后被标记为超时。超时持续的时间可以通过Cargo.toml中的 `test-timeout` 配置项来进行[配置](https://github.com/rust-osdev/bootimage#configuration)：

```toml
# in Cargo.toml

[package.metadata.bootimage]
test-timeout = 300          # (in seconds)
```

###  自动添加打印语句
`trivial_assertion` 测试仅能使用 `serial_print!`/`serial_println!` 输出自己的状态信息：
```rust
#[test_case]
fn trivial_assertion() {
    serial_print!("trivial assertion... ");
    assert_eq!(1, 1);
    serial_println!("[ok]");
}
```
为每一个测试手动添加固定的日志实在是太烦琐了，所以我们可以修改一下 `test_runner` 把这部分逻辑改进一下，使其可以自动添加日志输出。那么我们先建立一个 `Testable` trait：
```rust
// in src/main.rs

pub trait Testable {
    fn run(&self) -> ();
}
```
下面这个 trick 将会实现上面书写的 trait，并约束只有满足 [`Fn()` trait](https://doc.rust-lang.org/stable/core/ops/trait.Fn.html) 的泛型可使用这个实现：
```rust
// in src/main.rs

impl<T> Testable for T
where
    T: Fn(),
{
    fn run(&self) {
        serial_print!("{}...\t", core::any::type_name::<T>());
        self();
        serial_println!("[ok]");
    }
}
```
我们实现的 `run` 函数中，首先使用 [`any::type_name`](https://doc.rust-lang.org/stable/core/any/fn.type_name.html) 输出了函数名，这个函数事实上是被编译器实现的，可以返回任意类型的字符串形式。对于函数而言，其类型的字符串形式就是它的函数名，而函数名也正是我们想要的测试用例名称。至于 `\t` 则代表 [制表符](https://en.wikipedia.org/wiki/Tab_key#Tab_characters)，其作用是为后面的 `[ok]` 输出增加一点左边距。

输出函数名之后，我们通过 `self()` 调用了测试函数本身，该调用方式属于 `Fn()` trait 独有，如果测试函数顺利执行完毕，则 `[ok]` 也会被输出出来。

最后一步就是给 `test_runner` 的参数附加上 `Testable` trait：
```rust
// in src/main.rs

pub trait Testable {
    fn run(&self) -> ();
}
```
下面这个 trick 将会实现上面书写的 trait，并约束只有满足 [`Fn()` trait](https://doc.rust-lang.org/stable/core/ops/trait.Fn.html) 的泛型可使用这个实现：
```rust
// in src/main.rs

impl<T> Testable for T
where
    T: Fn(),
{
    fn run(&self) {
        serial_print!("{}...\t", core::any::type_name::<T>());
        self();
        serial_println!("[ok]");
    }
}
```

我们实现的 `run` 函数中，首先使用 [`any::type_name`](https://doc.rust-lang.org/stable/core/any/fn.type_name.html) 输出了函数名，这个函数事实上是被编译器实现的，可以返回任意类型的字符串形式。对于函数而言，其类型的字符串形式就是它的函数名，而函数名也正是我们想要的测试用例名称。至于 `\t` 则代表 [制表符](https://en.wikipedia.org/wiki/Tab_key#Tab_characters)，其作用是为后面的 `[ok]` 输出增加一点左边距。

输出函数名之后，我们通过 `self()` 调用了测试函数本身，该调用方式属于 `Fn()` trait 独有，如果测试函数顺利执行完毕，则 `[ok]` 也会被输出出来。

最后一步就是给 `test_runner` 的参数附加上 `Testable` trait：
```rust
// in src/main.rs

#[cfg(test)]
pub fn test_runner(tests: &[&dyn Testable]) {
    serial_println!("Running {} tests", tests.len());
    for test in tests {
        test.run(); // new
    }
    exit_qemu(QemuExitCode::Success);
}
```

仅有的两处修改，就是将 `tests` 参数的类型从 `&[&dyn Fn()]` 改为了 `&[&dyn Testable]`，以及将函数调用方式从 `test()` 改成了 `test.run()`。

由于我们已经完成了首尾输出的自动化，所以 `trivial_assertion` 里那两行输出语句也就可以删掉了：
```rust
// in src/main.rs

#[test_case]
fn trivial_assertion() {
    assert_eq!(1, 1);
}
```

现在 `cargo test` 的输出就变成了下面这样：
```
Running 1 tests
blog_os::trivial_assertion...	[ok]
```
