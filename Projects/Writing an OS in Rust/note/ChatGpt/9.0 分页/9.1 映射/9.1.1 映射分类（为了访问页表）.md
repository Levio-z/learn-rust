### 🔗 方案一：身份映射（Identity Mapping）

**原理**：将所有页表帧映射到与其物理地址相同的虚拟地址上。
**优点**：
-   访问页表非常直接。**CR3 中存的物理地址可以直接作为虚拟地址来访问**，内核不需要额外的转换。我们访问各级页表会更加容易。
**缺点**：
-   碎片化（找到连续的物理内存会更加困难）：虚拟地址空间被占用，难以找到大块连续虚拟空间（例如内存映射文件）。当我们要保留一段较大的连续虚拟内存区域（例如 1000 KiB 用于文件映射），就必须**确保对应的物理帧区间完全空闲**。
-   对新建页表的影响（物理页帧被使用了，我们也不能对他们进行映射）：创建新的页表时，需要寻找未被映射的物理页帧，会受限。**身份映射直接把物理地址布局限制死了，物理帧和虚拟页空间会互相影响，降低灵活性**。
---
### 🔗 方案二：固定偏移映射（Map at a Fixed Offset）

**原理**：为页表映射保留一块虚拟内存区域（例如 `10 TiB` 起始），将页表映射到该偏移区域。
**优点**：
-   避免身份映射导致的虚拟地址空间碎片问题和冲突问题。
**缺点**：
-   新建页表仍需要创建新的映射。
-   无法访问其他地址空间的页表（跨进程操作受限）。

---

### 🔗 方案三：映射完整物理内存（Map Complete Physical Memory）

**原理**：不仅映射页表帧，而是映射整个物理内存（例如 `10 TiB + X`）。
**优点**：
-   内核可访问任意物理内存，包括其他地址空间的页表帧。保留的虚拟内存范围的大小与以前一样，**不同的是它不再包含未映射的页面。**
-   保留的虚拟区域连续，无未映射页。
**缺点**
-   **需要额外页表存储映射，占用物理内存。**
-   在小内存设备上可能不合适。  
    **优化**：使用大页（Huge Pages, 2 MiB）可以减少页表开销，提高 TLB 缓存效率。
    

---

### 🔗 方案四：临时映射（Temporary Mapping）

**原理**：只在需要访问页表帧时临时创建映射。仅需一个身份映射的一级页表。
**步骤**：
1.  在一级页表中找到空闲条目。
2.  将条目映射到目标页表物理帧。
3.  通过虚拟地址访问目标页表。
4.  访问完毕后清空条目，移除临时映射。
**优点**：
-   物理内存占用极少（仅 4 KiB）。
-   可重复使用同一批虚拟页创建映射。
**缺点**：
-   操作繁琐，需要多次修改页表条目。
-   若跨多级页表操作，需重复整个过程。
---

### 🔗 方案五：递归页表映射（Recursive Page Tables）

**原理**：将高层页表条目映射到自身，实现虚拟地址空间对页表的递归访问。

**原理解析**：
-   在 L4 页表的某个条目（如 index 511）映射 L4 页表自身。
-   CPU 会将 L4 表当作 L3 表处理，从而可以通过虚拟地址访问所有层级页表。
-   多次递归条目可以“缩短” CPU 遍历的层数。
-   允许读取和写入 L1–L4 页表，无需额外页表。
**特点**：
-   高效、无需额外页表。
-   概念复杂，需要理解递归映射的地址计算。

⚠️ 注意：本文实现不会使用递归页表，只需了解原理即可。

递归分页是一种有趣的技术，它显示了页表中的单个映射可以有多么强大。它比较容易实现，而且只需要少量的设置（只是一个单一的递归条目），所以它是第一次实验分页的一个好选择。

然而，它也有一些弊端:

- 它占据了大量的虚拟内存（512 GiB）。在大的48位地址空间中，这不是一个大问题，但它可能会导致次优的缓存行为。
- 它只允许轻松访问当前活动的地址空间。通过改变递归条目，访问其他地址空间仍然是可能的，但切换回来时需要一个临时映射。我们在(已过期的)[_Remap The Kernel_](https://os.phil-opp.com/remap-the-kernel/#overview) 文章“地址空间 “中描述了如何做到这一点。
- 它在很大程度上依赖于x86的页表格式，在其他架构上可能无法工作。





---

### 总结

1.  **访问页表的关键问题**：内核运行在虚拟地址上，页表存储在物理内存中，需要映射才能访问。
    
2.  **常见方案**：
    -   身份映射（简单，但占用虚拟空间）
    -   固定偏移映射（避免虚拟碎片，但无法跨进程访问）
    -   完整物理映射（灵活，但占用页表和内存）
    -   临时映射（低内存占用，但操作繁琐）
    -   递归映射（无需额外页表，高效但概念复杂）
3.  **学习方法论**：
    -   画图理解每种映射方式的虚拟/物理地址关系。
    -   用实际内核/模拟器尝试访问页表，理解映射和页表条目关系。
    -   对比优缺点，掌握设计选择背后的权衡。
4.  **练习题**：
    -   在内核模拟器中实现固定偏移映射，并访问 L1–L4 页表。
    -   分析身份映射和完整物理映射对虚拟地址空间的占用情况。
    -   画递归页表的虚拟地址访问流程图，理解 CPU 遍历过程。
5.  **重点关注**：
    -   页表访问机制与虚拟/物理地址转换原理。
    -   各种映射方式的优势、适用场景及内存消耗。
    -   临时映射和递归映射的底层原理，理解后对实际内核优化有价值。

### 附录
#### CR3
CR3 是 x86/x86_64 架构中的一个 **控制寄存器（Control Register 3）**，用于存储 **当前活动页表的物理基地址**。它是 CPU 分页机制的核心寄存器之一。