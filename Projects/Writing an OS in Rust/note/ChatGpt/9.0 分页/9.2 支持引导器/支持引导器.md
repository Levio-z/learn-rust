所有这些方法的设置都需要对页表进行修改。例如，需要创建物理内存的映射，或者需要对4级表的一个条目进行递归映射。问题是，如果没有访问页表的现有方法，我们就无法创建这些所需的映射。

这意味着我们需要 bootloader 的帮助，bootloader 创建了内核运行的页表。Bootloader 可以访问页表，所以它可以创建内核需要的任何映射。在目前的实现中，“bootloader” 工具箱支持上述两种方法，通过 [cargo features](https://doc.rust-lang.org/cargo/reference/features.html#the-features-section) 进行控制。

- `map_physical_memory` 功能将某处完整的物理内存映射到虚拟地址空间。因此，内核可以访问所有的物理内存，并且可以遵循[_映射完整物理内存_](https://os.phil-opp.com/zh-CN/paging-implementation/#ying-she-wan-zheng-de-wu-li-nei-cun)的方法。
- 有了 “recursive_page_table” 功能，bootloader会递归地映射4级page table的一个条目。这允许内核访问页表，如[_递归页表_](https://os.phil-opp.com/zh-CN/paging-implementation/#di-gui-ye-biao)部分所述。

我们为我们的内核选择了第一种方法，因为它很简单，与平台无关，而且更强大（它还允许访问非页表框架）。为了启用所需的引导程序支持，我们在 “引导程序” 的依赖中加入了 “map_physical_memory“功能。

```toml
[dependencies]
bootloader = { version = "0.9", features = ["map_physical_memory"]}
```
启用这个功能后，bootloader 将整个物理内存映射到一些未使用的虚拟地址范围。为了将虚拟地址范围传达给我们的内核，bootloader 传递了一个 _启动信息_ 结构。

### 启动信息

`Bootloader` 板块定义了一个[`BootInfo`](https://docs.rs/bootloader/0.9/bootloader/bootinfo/struct.BootInfo.html)结构，包含了它传递给我们内核的所有信息。这个结构还处于早期阶段，所以在更新到未来的 [semver-incompatible](https://doc.rust-lang.org/stable/cargo/reference/specifying-dependencies.html#caret-requirements) bootloader 版本时，可能会出现一些故障。在启用 “map_physical_memory” 功能后，它目前有两个字段 “memory_map” 和 “physical_memory_offset”。

- `memory_map`字段包**含了可用物理内存的概览。它告诉我们的内核，系统中有多少物理内存可用，哪些内存区域被保留给设备，如VGA硬件。内存图可以从BIOS或UEFI固件中查询，但只能在启动过程的早期查询**。由于这个原因，它必须由引导程序提供，因为内核没有办法在以后检索到它。在这篇文章的后面我们将需要内存图。
- `physical_memory_offset`告诉我们物理内存映射的虚拟起始地址。通过把**这个偏移量加到物理地址上，我们得到相应的虚拟地址**。这使得我们可以从我们的内核中访问任意的物理内存。
- 这个物理内存偏移可以通过在Cargo.toml中添加一个`[package.metadata.bootloader]`表并设置`physical-memory-offset = "0x0000f00000000000"`（或任何其他值）来定制。然而，请注意，如果bootloader遇到物理地址值开始与偏移量以外的空间重叠，也就是说，它以前会映射到其他早期的物理地址的区域，就会出现恐慌。所以一般来说，这个值越高（>1 TiB）越好。

Bootloader将 `BootInfo` 结构以 `&'static BootInfo`参数的形式传递给我们的内核，并传递给我们的`_start`函数。我们的函数中还没有声明这个参数，所以让我们添加它。

在 **x86_64 System V 调用约定**中：
- 第一个整数或指针参数通过寄存器 `RDI` 传递（内核启动时 Bootloader 会放入这个寄存器）。
- 如果函数没有声明参数，Rust 会生成一个无参数函数。
- 调用者（Bootloader）仍会把参数放入 `RDI`，但无参数函数会忽略寄存器中的值。CPU 不会报错，只是参数被丢弃。

因此以前省略这个参数不会立即导致错误，但有两个潜在问题：
1. **类型不匹配风险**  
    如果函数声明了错误类型（如 `u64` 而不是 `&'static BootInfo`），编译器无法检查寄存器内容是否正确解释为引用。使用不正确类型会导致**未定义行为**。
2. **可维护性与文档性**  
    明确声明 `_start` 的参数可以让其他开发者理解 Bootloader 向内核传递了哪些信息，并方便使用 `boot_info` 结构体中的各类数据（内存映射、显存信息等）。
### `entry_point` 宏

由于我们的`_start`函数是在外部从引导程序中调用的，所以没有对我们的函数签名进行检查。这意味着我们可以让它接受任意参数而不出现任何编译错误，但在运行时它会失败或导致未定义行为。

为了确保入口点函数总是具有引导程序所期望的正确签名，`bootloader`板块提供了一个[`entry_point`](https://docs.rs/bootloader/0.6.4/bootloader/macro.entry_point.html)宏，它提供了一种类型检查的方法来定义一个Rust函数作为入口点。让我们重写我们的入口点函数来使用这个宏。

```rust
// in src/main.rs

use bootloader::{BootInfo, entry_point};

entry_point!(kernel_main);

fn kernel_main(boot_info: &'static BootInfo) -> ! {
    […]
}
```

我们不再需要使用`extern "C"`或`no_mangle`作为我们的入口点，因为宏为我们定义了真正的低级`_start`入口点。`kernel_main`函数现在是一个完全正常的Rust函数，所以我们可以为它选择一个任意的名字。**重要的是，它是经过类型检查的，所以当我们使用一个错误的函数签名时，例如增加一个参数或改变参数类型，就会发生编译错误。**

让我们在我们的`lib.rs`中进行同样的修改。
```rust
// in src/lib.rs

#[cfg(test)]
use bootloader::{entry_point, BootInfo};

#[cfg(test)]
entry_point!(test_kernel_main);

/// Entry point for `cargo test`
#[cfg(test)]
fn test_kernel_main(_boot_info: &'static BootInfo) -> ! {
    // like before
    init();
    test_main();
    hlt_loop();
}
```
由于这个入口点只在测试模式下使用，我们在所有项目中添加了`#[cfg(test)]`属性。我们给我们的测试入口点一个独特的名字`test_kernel_main`，以避免与我们的`main.rs`的`kernel_main`混淆。我们现在不使用`BootInfo`参数，所以我们在参数名前加上`_`，以消除未使用变量的警告。






