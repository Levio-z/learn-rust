那么我们来创建一个新的包含单独的 double fault 专属栈以及中断栈表的TSS。为此我们需要一个TSS结构体，幸运的是 `x86_64` crate 也已经自带了 [`TaskStateSegment` 结构](https://docs.rs/x86_64/0.14.2/x86_64/structures/tss/struct.TaskStateSegment.html) 用来映射它。

那么我们新建一个 `gdt` 模块（稍后会说明为何要使用这个名字）用来创建TSS：

```rust
// in src/lib.rs

pub mod gdt;

// in src/gdt.rs

use x86_64::VirtAddr;
use x86_64::structures::tss::TaskStateSegment;
use lazy_static::lazy_static;

pub const DOUBLE_FAULT_IST_INDEX: u16 = 0;

lazy_static! {
    static ref TSS: TaskStateSegment = {
        let mut tss = TaskStateSegment::new();
        tss.interrupt_stack_table[DOUBLE_FAULT_IST_INDEX as usize] = {
            const STACK_SIZE: usize = 4096 * 5;
            static mut STACK: [u8; STACK_SIZE] = [0; STACK_SIZE];

            let stack_start = VirtAddr::from_ptr(&raw const STACK);
            let stack_end = stack_start + STACK_SIZE;
            stack_end
        };
        tss
    };
}
```

- `TaskStateSegment`（TSS）：64 位模式下主要用于**异常时的栈切换**（`privilege_stack_table` 与 `interrupt_stack_table`）。
- `DOUBLE_FAULT_IST_INDEX: u16 = 0`：约定 IST 第 0 槽位用于 double fault。
- `lazy_static! { static ref TSS: TaskStateSegment = {...} }`：以运行期初始化的方式构造全局 TSS。
- `static mut STACK: [u8; STACK_SIZE]`：用一段静态可写的内存模拟“栈空间”。
- `let stack_start = VirtAddr::from_ptr(&raw const STACK); let stack_end = stack_start + STACK_SIZE;`：把静态数组的起始虚拟地址转为 `VirtAddr`，再加长度得到**高地址端**，将其写入 `IST[0]` 作为栈顶（空栈指针）。

作用与为什么要这么写
- **为 double fault 单独切栈**：double fault 常由**栈已损坏或不可用**引发，若仍用原栈处理，很可能再次故障 → 三重错误（triple fault）→ 机器复位。独立的 IST 栈能在最坏情况下也“踩着一块干净的地”完成处理。
- **使用高地址作为初始 RSP**：x86 的栈向**低地址增长**，以高地址作为“空栈顶”，第一次 push/中断压栈才会向下生长，避免越界立即发生。
- **`static mut` 而非 `static`**：只读 `static` 可能被引导器映射到只读页，作为“栈”必须可写，故需 `static mut`。
- **`lazy_static`**：TSS 初始化需要运行期计算（地址运算等）。目前（在这个项目语境下）编译期 `const` 求值器尚未覆盖到全部场景，用 `lazy_static` 保持简洁与安全的单次初始化。

但要注意，由于现在 double fault 获取的栈不再具有用于防止栈溢出的 guard page，所以我们不应该做任何栈密集型操作了，否则就有可能会污染到栈下方的内存区域。

在 double fault 处理函数中：
- 仅做必要操作，如打印日志、触发 CPU 重置或 halt。
- **避免任何深递归、大数组或临时结构**。



