### 使用 TSS 的步骤解析与原理

在 x86/x86_64 架构中，**TSS（Task State Segment）**并不是直接被 CPU 自动识别的，而是通过 **段描述符和 `ltr` 指令**间接加载和启用。你描述的流程可以拆解如下：

---

#### 1. TSS 的作用

- **TSS** 是一块特殊的内存结构，用于：
    
    - 保存特定特权级（Ring 0）的栈指针，尤其是 **中断或异常处理时的内核栈**。
        
    - 支持 hardware task switch（现代 OS 很少使用硬件任务切换）。
        
    - 保存 I/O 位图（允许/禁止特定端口访问）。
        
- 对于现代操作系统，主要用途是 **为 double fault 或其他关键异常提供独立栈**。
    

---

#### 2. 为什么 TSS 要用分段系统

- TSS 的历史源自 **x86 分段机制**。
    
- CPU 并不会直接知道 TSS 的物理地址：
    
    - 它只知道一个 **GDT 中的段选择器（selector）**。
        
    - 通过段选择器访问 TSS 内容时，CPU 会使用 **GDT 或 LDT 表中的描述符**。
        
- 因此加载 TSS 必须经过 GDT（全局描述符表）。
    

---

#### 3. 将 TSS 放入 GDT

1. **在 GDT 中创建 TSS 描述符**：
    
    - 描述符类型为 0x9（32-bit TSS 可用）或 0xB（64-bit TSS 可用）。
        
    - 填写 TSS 的基地址和大小。
        
    - 指定特权级（DPL）。
        
2. **选择器（selector）**：
    
    - GDT 中的索引 × 8 + 特权位 = 段选择器。
        
    - CPU 通过选择器知道 TSS 的位置。
        

---

#### 4. 使用 `ltr` 指令加载 TSS

- **语法**：`ltr ax`，其中 `ax` 是 TSS 段选择器。
    
- **作用**：
    
    - 将 TSS 段基地址加载到 **Task Register (TR)** 寄存器。
        
    - CPU 之后在发生异常/中断时，会查阅 TR 中的 TSS 来获取内核栈指针。
        
- **注意**：
    
    - 必须在启用保护模式或长模式（64-bit）之后执行。
        
    - TSS 描述符必须存在于 GDT，否则 CPU 会 GP（General Protection Fault）。
        

---

#### 5. 总结流程

1. 创建一个 TSS 数据结构。
    
2. 在 GDT 中为 TSS 分配段描述符。
    
3. 使用 `ltr` 指令加载段选择器到 TR。
    
4. CPU 在中断或异常时，会自动切换到 TSS 中指定的内核栈。