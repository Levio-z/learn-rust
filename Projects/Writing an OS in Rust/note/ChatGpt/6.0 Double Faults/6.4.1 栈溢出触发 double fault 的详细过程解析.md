### 栈溢出触发 double fault 的详细过程解析

你问的这一段描述的是 **CPU 在处理异常时的压栈失败流程**，我们可以拆开理解：

---

### 1. 栈溢出发生

- **栈底有 guard page**：一页未映射的内存，用于捕获栈溢出
- 栈增长超出分配空间，**栈指针 `RSP` 指向 guard page**
- 下一条函数调用或局部变量访问 → CPU 尝试写栈 → **触发 page fault**

---

### 2. CPU 响应 Page Fault

1. **CPU 查询 IDT**
    
    - 根据异常向量找到 page fault handler 的入口地址
        
2. **压入中断栈帧 (Interrupt Stack Frame)**
    
    - CPU 需要保存当前 CPU 状态：RIP、CS、RFLAGS、RSP、SS 等
        
    - 压入栈的操作本质上是对 `RSP` 指向的地址写入数据
        

---

### 3. 压栈失败

- 当前栈指针 `RSP` **仍指向 guard page**
- guard page **未映射到物理内存** → 栈写入失败 → **再次触发 page fault**
- 这是第二次异常发生，CPU **不能完成 page fault 的处理**

---

### 4. Double Fault 触发4. 双重故障触发
- CPU 检测到第一次异常处理失败（page fault handler 无法成功压栈）
- 根据 x86 架构规范，触发 **double fault**（异常处理失败的异常）
- 如果 double fault handler 也需要压栈，而栈仍不可用 → triple fault → 系统重启 
---
### 关键点总结
1. **CPU 压栈步骤**：
    - 写入中断栈帧到当前栈（RSP）
    - 如果栈不可写 → 再次异常
2. **问题核心**：
    - 不是 page fault handler 本身出错，而是 **栈不可用**
3. **解决方案**：
    - 为 double fault handler 使用 **独立中断栈 (IST)**
    - 这样即使原栈溢出，double fault 也能安全处理
        
