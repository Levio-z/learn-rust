>https://os.phil-opp.com/zh-CN/allocator-designs/#gu-ding-da-xiao-kuai-fen-pei-qi

接下来，我们展示一种**使用固定大小的内存块来满足分配请求的分配器设计**。使用这种方法，分配器往往会返回比实际需要更大的内存块，这将会由于 [内部碎片](https://en.wikipedia.org/wiki/Fragmentation_\(computing\)#Internal_fragmentation) 导致浪费内存，但它会显著减少寻找合适的内存块的时间（相比链表分配器而言），从而获得更好的分配性能。

### 介绍
- 定义一个固定的块大小列表，**不再精确分配请求所需的内存大小，将每个分配向上取整为列表中的下一个内存块大小**。例如，对于 16、64 和 512 的块大小，一个 4 字节的分配将返回一个 16 字节的块，一个 48 字节的分配将返回一个 64 字节的块，一个 128 字节的分配将返回一个 512 字节的块。
- 和链表分配器相同，我们通过在未使用的内存区域中创建链表来跟踪未使用的内存。然而，不再使用单一链表管理不同尺块大小的内存区域，而是为**每个尺寸类别创建一个单独的链表。每个列表只存储相同大小的块**。例如，对于块大小为 16、64 和 512 的情况，内存中会存在三个单独的链表。
#### 高效的分配操作
- 将请求的分配大小向上取整为下一个块的大小
- 获取该链表的头指针，例如，对于块大小 16，我们需要使用 `head_16`。
- 移除该链表中的第一个块并返回它。
- 值得注意的是，我们**只需要返回链表的第一个元素，不需要遍历整个链表**。因此，分配性能相比于链表分配器要更好。
#### 块大小和浪费的内存 
根据块大小的不同，**向上取整时会浪费大量内存**。举个例子，当一个512字节的块被分配给128字节的分配请求时，已分配内存的四分之三是未使用的。通过定义合理的块大小，限制浪费内存的大小是可能的。举例来说，我们使用2的幂（4，8，16，32，64，128，…）作为块大小时，**在最差的情况下我们限制浪费内存的大小为已分配大小的一半，平均情况下是四分之一的已分配内存大小**。

**基于程序中常见的分配内存大小来优化块大小也是普遍做法**。举例来说，如果程序中频繁分配24字节的内存时，我们可以额外添加24字节的块大小。这样做可以减少浪费的内存，但不会影响性能。
#### 内存释放
- 将需要释放的块的大小取整到下一个块大小，这是必需的，因为编译器只将请求的大小传入 `dealloc` ，而不是 `alloc` 返回的块大小。通过使用在 `alloc` 中 `dealloc` 中相同的尺寸调整函数，我们能确保释放了正确的内存大小。
- 获取链表的头指针
- 通过更新头指针将已释放的块放到链表头部
值得注意的是，释放内存时不需要遍历链表。这意味着释放内存的时间与链表的长度无关。

#### 后备分配器
考虑到大尺寸内存分配（ >2 KB ）较少出现，尤其是在操作系统内核中，因此将这些分配回退到不同的分配器是有意义的。例如，我们可以**将大于2048字节的分配回退到链表分配器，以减少内存浪费**。由于预期这种大小的分配很少，链表规模会保持较小，分配和释放操作的性能也较好。
### 创建新块
以上的叙述中，我们一直假定有足够的特定大小的未使用块可供分配。然而，在某个特定的块大小的链表为空时，我们有两种方法可以创建新的未使用的特定大小的块来满足分配请求：

- 从后备分配器分配一个新块（如果有的话）
- 从不同的链表中分配一个更大的块。如果块大小是2的幂，这种方法效果最好。例如，一个32字节的块可以被分成两个16字节的块。
	- 空间利用率更高
		- 如果你从后备分配器申请一个新的 16 字节块，可能导致 **碎片化**，因为大块可能已经存在但未被利用。
		- 32 字节块 → 两个 16 字节块
	- 简化分裂/合并逻辑（2 的幂次优势）
	- 减少对后备分配器的依赖
		- 从已有更大块拆分：不需要额外系统调用
	- 与 buddy allocator 思路一致
		- 可以快速找到最近大块
		- 支持**动态合并空闲块，减少碎片**

对于我们的实现，我们将从后备分配器分配新的块，因为实现起来要简单得多。

基于你提供的笔记内容，我来总结一下固定大小块分配器的核心要点：

## 固定大小块分配器总结

### 核心设计思想
这种分配器使用**固定大小的内存块**来满足分配请求，将每个分配请求向上取整到预定义的块大小列表中[^1]。

### 主要优势
- **分配性能高**：只需要返回链表的第一个元素，不需要遍历整个链表[^1]
- **释放性能高**：释放操作与链表长度无关[^1]
- **实现相对简单**

### 内存管理机制
- 为**每个尺寸类别创建单独的链表**，每个链表只存储相同大小的块[^1]
- 分配时：向上取整大小 → 获取对应链表头 → 移除第一个块并返回[^1]
- 释放时：向上取整大小 → 获取对应链表头 → 将块插入链表头部[^1]

### 内存浪费问题
- **内部碎片**是主要缺点，可能浪费大量内存[^1]
- 使用2的幂作为块大小时，最差情况浪费一半内存，平均浪费四分之一[^1]
- 可根据程序常见分配大小优化块大小列表来减少浪费[^1]

### 后备策略
- 大尺寸分配（如>2KB）可回退到链表分配器[^1]
- 当特定大小链表为空时，可从后备分配器分配新块或从更大块拆分[^1]

### 适用场景
特别适合操作系统内核等对性能要求高、大尺寸分配较少的场景[^1]。

#### Sources
[^1]: [[11.3.1 介绍]]