### slab分配器
**Slab 分配**是一种[内存管理](https://en.wikipedia.org/wiki/Memory_management "Memory management")机制，旨在对对象进行高效的内存分配。与早期机制相比，它减少了分配和释放造成的[碎片化](https://en.wikipedia.org/wiki/Fragmentation_\(computer\) "Fragmentation (computer)") 。**此技术用于保留包含某种类型的数据对象的已分配内存，以便在后续分配相同类型的对象时重用**。它类似于[对象池](https://en.wikipedia.org/wiki/Object_pool "Object pool") ，但仅适用于内存，不适用于其他资源。
### 伙伴分配器

[伙伴分配器](https://en.wikipedia.org/wiki/Buddy_memory_allocation) 使用一个 [二叉树](https://en.wikipedia.org/wiki/Binary_tree) 数据结构而不是链表来管理空闲块，并使用2的幂作为块大小。当需要一个特定大小的块时，它会将一个更大的块拆成两半，从而在树中创建两个子节点。当一个块再次被释放时，会检查它在树上的相邻块。如果相邻块也是空闲的，那么这两个块就会合并为一个双倍尺寸的块。

**合并过程的优势在于减少了 [内部碎片](https://en.wikipedia.org/wiki/Fragmentation_\(computing\)#Internal_fragmentation) ，因此小的空闲块也能被一个大的分配重用**。同时它也不需要一个后备分配器，因此性能更容易预测。然而，伙伴分配器只支持2的幂作为块大小，这会因为 [内部碎片](https://en.wikipedia.org/wiki/Fragmentation_\(computing\)#Internal_fragmentation) 问题导致浪费大量内存。因此，伙伴分配器通常与slab分配器结合使用，进一步将分配的块拆分成多个较小的块。


- **策略**：
    1. 伙伴分配器负责分配较大的内存块（比如 2KB、4KB、8KB 等）。
    2. Slab 分配器把这些大块切分成很多固定大小的小块，供频繁分配的小对象使用。
- **优势**：
    - 既保留了伙伴分配器快速合并大块内存的能力。
    - 又提高了小对象的内存利用率，减少内部碎片。
- 伙伴分配器负责分配较大的内存块（比如 2KB、4KB、8KB 等）。
- Slab 分配器把这些大块切分成很多固定大小的小块，供频繁分配的小对象使用。
#### 伙伴分配器（Buddy Allocator）
- **作用**：减少**释放时产生的内存碎片**（外部碎片）。
- **原理：**
	- 当释放某块内存时，如果相邻的块大小相同且空闲，就可以**合并成更大的块**。
	- 这样可以有效回收大块连续内存，减少外部碎片。
- **限制**：
    - 分配小对象时仍可能浪费部分空间（内部碎片），因为分配的最小块可能比对象实际大小大。
---
#### Slab 分配器（Slab Allocator）
- **作用**：减少**分配时产生的内存碎片**（内部碎片）。
- **原理**：
    - 预先分配一组固定大小的内存块（slab），每个 slab 中块大小与对象大小**精确匹配**。
    - **对象直接从 slab 中获取，不需要切分大块。**
    - 高效利用小块内存，内部碎片极少。
- **限制**：
    - 需要管理大量 slab，如果对象类型多，可能占用更多元数据空间。
    - 对大对象不适合，需要依赖上层分配器（如伙伴分配器）提供大块内存。