
```rust
// in src/allocator/linked_list.rs

impl LinkedListAllocator {
    /// 调整给定的内存布局，使最终分配的内存区域
    /// 足以存储一个 `ListNode` 。
    ///
    /// 将调整后的大小和对齐方式作为（size, align）元组返回。
    fn size_align(layout: Layout) -> (usize, usize) {
        let layout = layout
            .align_to(mem::align_of::<ListNode>())
            .expect("adjusting alignment failed")
            .pad_to_align();
        let size = layout.size().max(mem::size_of::<ListNode>());
        (size, layout.align())
    }
}
```
https://os.phil-opp.com/zh-CN/allocator-designs/#bu-ju-diao-zheng
### 核心知识点
调整给定内存布局 `layout`，使最终分配的内存区域：
1. align_to
	1. 当你想在一块**内存中放某个类型（比如 `ListNode`）**，  这块内存必须满足 **该类型的对齐要求**,即最大字段对齐要求[为什么结构体要按最大字段对齐](../../../../../../Zettelkasten/permanent/为什么结构体要按最大字段对齐.md)，CPU 访问 `u128` 时就可能 **未对齐** → 性能下降 / 崩溃。
	2. 如果原来的对齐要求已经 **≥ `align`**，那么直接返回原来的 `Layout`。
2. pad_to_align()
	1. **把内存块大小填充到满足对齐要求的倍数**。
	2. pad_to_align()是**保证尾部也对齐**，保证后面的块也能满足对齐要求
3. max
	1. 保证该内存区域能存下这个结构体
	2. **确保 `dealloc` 函数可以安全地在已释放的内存块写入 `ListNode`**
### 知识点
