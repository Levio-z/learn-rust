分支：03-bare_bones-vga
## 功能

1. **VGA 字符缓冲区结构**
    - VGA 字符缓冲区是一个映射在内存中的二维数组，通常为 25 行 80 列，每个单元包含字符和颜色信息。每个字符单元由 2 个字节组成，第一个字节为 ASCII 码，第二个字节定义前景色、背景色和闪烁位。
	    - [3.0 VGA 字符模式](3.0%20VGA%20字符模式.md)
	- 可以通过**存储器映射输入输出**（[memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)）的方式，读取或写入地址 `0xb8000`；这意味着，我们可以像操作普通的内存区域一样操作这个地址。
		- [35 内存映射 IO (MMIO) 和 端口映射 IO (PMIO)](../ChatGpt/3.0%20VGA字符模式/35%20内存映射%20IO%20(MMIO)%20和%20端口映射%20IO%20(PMIO).md)
	1. **颜色定义**
	    - 使用枚举 `Color` 来表示 16 种颜色，并定义一个 `ColorCode` 类型来存储前景色和背景色的组合。
	2. **屏幕字符定义**
		- 这将按 C 语言约定的顺序布局它的成员变量，让我们能正确地映射内存片段
	3. **内存映射**
	    - 通过裸指针直接访问 0xb8000 地址处的 VGA 字符缓冲区。
	    - 使用 `unsafe` 代码块来进行裸指针的解引用操作。
	4. **字符打印**
	    - 创建了一个 `Writer` 结构体，负责将字符写入缓冲区。
	    - 通过 `write_byte` 方法向字符缓冲区写入字节，并通过 `write_string` 方法支持字符串打印。
	    - 支持打印非 ASCII 字符，未识别的字符用 `■`（0xFE）表示。
	5. **换行处理**
	    - 实现了 `new_line` 方法，当当前行满时，将所有行向上移动一行，并清空最后一行。
	6. 易失操作
		- “**异步修改与读取**”意味着变量的值可以在程序运行时由外部因素（如其他线程、硬件中断、外部事件、信号处理程序等）改变，因此，程序的主线程在读取该变量时不能依赖它的值不会被改变
		- 在多线程环境下，寄存器并不是与某个线程绑定的资源，而是 CPU 内部硬件的一部分。因此，寄存器的值是与当前执行的线程或任务相关的，但并不“属于”某个线程。每个线程在执行时，会被分配到 CPU 的寄存器中进行操作，但每个线程的寄存器内容通常不会互相干扰，除非显式地发生上下文切换。
		- 编译器通常会对变量进行优化，比如将变量的值保存在寄存器中，减少内存访问次数。然而，易失性变量不能被编译器优化，因为它们的值可能在每次访问时都发生变化，或者可能会被外部环境改变。所以，**编译器必须保证每次访问易失性变量时都会从内存中读取最新的值，而不是从寄存器或缓存中获取**。
			- [33 易失操作](../ChatGpt/3.0%20VGA字符模式/33%20易失操作.md)
	7. **全局接口**
	    - 使用 `lazy_static` 宏和自旋锁 (`Mutex`) 来实现全局的 `WRITER` 变量，确保可以在全局范围内安全地访问字符缓冲区。
	8. **格式化宏**
	    - 支持 Rust 内置的格式化宏，如 `println!` 和 `write!`，实现了 `fmt::Write` trait。
2. **安全性**
	- 将所有不安全的操作封装在模块内部，并通过类型系统确保内存安全。通过使用 `unsafe` 语句块控制裸指针的访问。
3. **错误处理与 Panic**
### 面试题目

1. **VGA 字符缓冲区如何工作？**
    
    - 描述如何通过内存映射访问 VGA 字符缓冲区，以及它是如何存储字符和颜色的。
        
2. **Rust 中如何操作裸指针？**
    
    - 解释 `unsafe` 代码块的作用，为什么裸指针的解引用需要 `unsafe`，以及裸指针带来的安全风险。
        
3. **Rust 中如何实现格式化宏（如 `println!`）？**
    
    - 讨论实现 `fmt::Write` trait 的过程，特别是如何支持不同类型的格式化输出。
        
4. **Rust 中的 `lazy_static` 宏是如何解决延迟初始化的问题的？**
    
    - 解释 `lazy_static` 宏的工作原理及其在 Rust 中的应用场景，特别是在裸机环境中的使用。
        
5. **在裸机编程中如何处理换行符？**
    
    - 解释如何在 VGA 字符缓冲区中处理行满时的换行操作。
        
6. **如何在 Rust 中实现安全的全局变量？**
    
    - 讨论如何使用 `lazy_static` 和自旋锁来实现全局变量的安全访问，特别是在没有线程和阻塞机制的情况下。
        
7. **如何避免 Rust 编译器对重要操作进行优化？**
    
    - 解释 `volatile` 操作的使用，如何避免编译器优化对 I/O 操作的影响。
        
8. **Rust 的类型系统如何帮助确保内存安全？**
    
    - 讨论 Rust 类型系统如何帮助开发者避免内存访问错误（如越界、空指针解引用等）。
        

### 与面试官的讨论点

1. **Rust 在嵌入式和裸机编程中的优势**
    
	- 探讨 Rust 如何通过内存安全的特性避免许多传统 C 语言中的问题，如缓冲区溢出和数据竞争。

	- **内存安全**：Rust 通过所有权（ownership）、借用（borrowing）和生命周期（lifetime）等特性，保证了编译时对内存的严格检查。这避免了许多 C/C++ 中常见的内存错误，如缓冲区溢出、悬垂指针和数据竞争等。这使得 Rust 在没有垃圾回收的环境下，也能有效防止内存错误。
    
	- **并发性**：Rust 的并发模型通过对共享内存访问的严格控制，使得并发编程变得更加安全。`Send` 和 `Sync` trait 分别用于控制线程间数据的传递和共享，确保了线程安全性，避免了多线程环境中的数据竞争问题。
    
	- **零成本抽象**：Rust 提供高效的抽象能力，几乎没有运行时开销。它通过静态分析和编译器优化，在不牺牲性能的前提下提供强大的功能。这对于嵌入式系统，尤其是资源受限的裸机环境来说尤为重要。

2. **裸机编程中的内存映射 I/O**
    
    - 讨论在裸机环境中如何通过内存映射访问硬件资源，并与 Rust 的 `unsafe` 代码结合使用。

	- **直接访问硬件**：通过将硬件设备的寄存器映射到内存地址空间，程序可以像访问内存一样操作硬件设备。例如，读取或写入特定内存位置时，实际上是与硬件交互。
    
	- **Rust 中的 `unsafe` 代码**：裸机编程中常常需要直接操作内存，因此必须使用 `unsafe` 代码块来绕过 Rust 的安全检查。**例如，在与外设交互时，通过裸指针或 `Volatile` 类型来确保不会进行不安全的内存操作。**
    
	- **安全与性能**：尽管 Rust 提供了内存安全的保障，但裸机环境通常需要绕过 Rust 的安全模型，这就需要开发者对裸机环境的硬件进行深入了解。Rust 的 `unsafe` 能够直接操作内存**并提供性能优化，但开发者需要小心使用**。
        
3. **Rust 的 `unsafe` 和内存安全**
    
    - **Rust 中的 `unsafe`**：`unsafe` 代码块允许开发者直接访问裸指针和执行不受 Rust 类型系统保护的操作。**尽管如此，Rust 提供了明确的界限，要求开发者明确表示某些操作是不安全的，并且这种不安全是局部的**。Rust 编译器可以对 `unsafe` 代码进行严格的检查，以保证其在逻辑上的正确性。开发者必须明确标记出不安全的部分，这增强了可控性。
        
4. **延迟初始化和全局变量**
    
    - 探讨在没有标准库支持的情况下，如何在裸机环境中实现全局变量的安全初始化和访问。
        
5. **面向操作系统开发的 Rust 特性**
    
	- **所有权与内存管理**：Rust 的所有权系统能够自动管理内存，避免了 C 中的手动内存管理错误。它还提供了借用和生命周期机制，确保在操作系统开发中避免悬空指针和内存泄漏。
    
	- **错误处理**：Rust 使用 `Result` 和 `Option` 类型来处理错误，使得程序员可以在编译时就避免许多运行时错误。因为`Result`和`Option`是枚举类型，Rust要求程序员在编译时处理这些类型的每一种可能性。

    
	- **并发与同步**：Rust的所有权系统和借用检查机制确保了在**多线程环境下的数据访问是安全**的。Rust编译器通过在编译时检查数据是否能安全地在多个线程间共享，消除了数据竞争和其他并发问题
    
	- **模式匹配**：Rust 提供了强大的模式匹配能力，极大简化了操作系统开发中的**状态机和控制流的编写**。C 语言则依赖更复杂的 `if-else` 和 `switch` 语句，代码可读性差。