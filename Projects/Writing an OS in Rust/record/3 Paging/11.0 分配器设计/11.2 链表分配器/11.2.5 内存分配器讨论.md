>https://os.phil-opp.com/zh-CN/allocator-designs/#tao-lun-1

和bump分配器相比，链表分配器更适合作为一个通用分配器，主要是因为它可以**直接重用已释放的内存**。然而，它也有一些缺点，一部分是由于我们的基础实现所致，另一部分则是由于分配器设计本身的缺陷。
### 合并已释放的内存块
我们的实现主要的问题就是它**只将堆分成更小的内存块，但从不将它们合并到一起**。
### 我们需要实现合并策略
当释放内存块时，不能只是简单地把它插入空闲链表，还要尝试**和相邻的空闲块合并**，否则会产生严重的**内存碎片化**。
### 如何实现
在 `deallocate` 调用中，它不会将已释放的内存块插入链表的头部，而是始终保持按起始地址排序维护链表。这样，在 `deallocate` 调用中就可以直接通过检查链表中相邻块的地址和大小来执行合并操作。当然，这样做会使释放操作变慢，但避免了我们上面看到的堆碎片化问题。

### 性能讨论
因为**链表长度取决于未使用内存块的数量**，不同程序的性能表现可能差异极大。对于仅创建少量分配的程序，分配性能相对较好。而对于因大量分配导致堆碎片化的程序，分配性能会非常差，因为链表会非常长，大部分内存块尺寸极小。

值得强调的是，相比于我们基础的实现而言，链表方法本身的缺陷才是造成性能问题的主要原因。因为在**内核级代码中分配性能相当重要**，所以我们将在下文中探索第三种通过**降低内存使用率换取性能提升**的分配器设计。

