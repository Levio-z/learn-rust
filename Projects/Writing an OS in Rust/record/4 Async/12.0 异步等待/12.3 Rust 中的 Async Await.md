[Rust-future-基本概念-TOC](../../../../../Areas/Rust/Area/1%20基本概念/1%20基础知识/RustBook/17.Async和Await/Future/Rust-future-基本概念-TOC.md)
[Rust-future-组合设计的思想](../../../../../Areas/Rust/Area/1%20基本概念/1%20基础知识/RustBook/17.Async和Await/Future/Rust-future-组合设计的思想.md)
[Rust-Async和Await-基本概念](../../../../../Areas/Rust/Area/1%20基本概念/1%20基础知识/RustBook/17.Async和Await/Async和Await/Rust-Async和Await-基本概念.md)

[Rust-异步-Executors 执行器](../../../note/note/inbox/Rust-异步-Executors%20执行器.md)
[Rust-异步-Wakers 唤醒器](../../../note/note/inbox/Rust-异步-Wakers%20唤醒器.md)
[Rust-一个假的RawWaker](../../../../../Areas/Rust/Area/1%20基本概念/3%20库/库/标准库/std/task/Rust-一个假的RawWaker.md)

- 首先，创建一个新的 `SimpleExecutor` 类型实例，其 `task_queue` 为空。
- 接着，我们调用异步函数 `example_task`，该函数返回一个 future。我们将这个 future 包装在 `Task` 类型中，这会将其移动到堆上并固定，然后通过 `spawn` 方法将任务添加到执行器的 `task_queue` 中。
- 接着我们调用 `run` 方法来启动队列中单个任务的执行。这包括：
    - 从 `task_queue` 前端弹出任务。
    - 为任务创建一个 `RawWaker` ，将其转换为`Waker` 实例，之后从它创建一个 `Context` 实例。
    - 使用 `Context` ，在任务的 future 上调用 `poll` 方法。
    - 由于 `example_task` 并不需要等待什么，它可以在第一次轮询就直接跑完。于是就会打印出 _“async number: 42”_ 消息。
    - 由于 `example_task` 直接返回 `Poll::Ready` ，它不会被重新添加到 `task_queue` 尾部。
- `run` 方法会在 `task_queue` 变空之后返回。`kernel_main` 函数会继续执行，并打印 _“It did not crash!”_ 。

### 一个run方法
```rust
use core::task::{Context, Poll};

impl SimpleExecutor {
    pub fn run(&mut self) {
        while let Some(mut task) = self.task_queue.pop_front() {
            let waker = dummy_waker();
            let mut context = Context::from_waker(&waker);
            match task.poll(&mut context) {
                Poll::Ready(()) => {} // 任务完成
                Poll::Pending => self.task_queue.push_back(task),
            }
        }
    }
}

```
该函数使用 `while let` 循环来处理 `task_queue` 中的所有任务。对于每个任务，它首先通过包装由我们的 `dummy_waker` 函数返回的 `Waker` 实例来创建一个 `Context` 类型。然后它使用这个 `context` 调用 `Task::poll` 方法。如果 `poll` 方法返回 `Poll::Ready`，就表示任务已完成，我们可以接着处理下一个任务。如果任务仍处于 `Poll::Pending` 状态，我们会再次将其添加到队列末尾，以便后续的循环迭代再次轮询它。

### main.rs
现在有了 `SimpleExecutor` 类型，我们可以在 `main.rs` 中尝试运行 `example_task` 函数返回的任务：
```rust
// in src/main.rs

use blog_os::task::{Task, simple_executor::SimpleExecutor};

fn kernel_main(boot_info: &'static BootInfo) -> ! {
    // […] 初始化过程，包括 `init_heap`

    let mut executor = SimpleExecutor::new();
    executor.spawn(Task::new(example_task()));
    executor.run();

    // […] test_main, "it did not crash" 信息, hlt_loop
}


// 下面再次展示 example_task 函数，方便阅读

async fn async_number() -> u32 {
    42
}

async fn example_task() {
    let number = async_number().await;
    println!("async number: {}", number);
}
```

[os-rust-异步-异步键盘输入](../../../note/project/inbox/os-rust-异步-异步键盘输入.md)