由于调用栈可能非常大，操作系统通常会为**每个线程设置独立的调用栈**，而非在每次任务切换时备份调用栈内容。
- 切换时只更新栈指针

抢占式多任务处理的缺点在于每个任务都需要独立的栈空间。相较于共享栈，使用独立栈会导致每个任务占用更多内存，并且通常会限制任务的数量。另一个缺点是操作系统总是需要在每次任务切换时保存完整的 CPU 寄存器状态，即使任务只使用了寄存器的一小部分。

**单栈执行**：协作式任务在任何时刻只有一个任务在运行，和函数调用一样使用当前栈执行。可以共享栈。

**明确切换点**：协作式任务的暂停点类似函数内的 `yield` 或返回点，只是可以再次恢复继续执行。

### 什么是安全点（Safe Point）

安全点是指**程序执行到一个“上下文完整、状态一致、可安全暂停或切换”的位置**。  
在这个位置，运行时、调度器或 GC 可以确定：

- 栈帧结构完整
    
- 局部变量状态稳定
    
- 调用链没有被破坏
    
- 寄存器内容符合 ABI 要求
    
- 不会在半条指令或未完成的内存写入中断
    

因此，在安全点暂停任务、切换任务或执行 GC 是**绝对安全**的。

---

### 为什么需要安全点

现代语言的运行时必须避免以下危险情况：

- 指令只执行了一半（处于中间状态）
    
- 栈指针处于半构造/半销毁状态
    
- 局部变量尚未写入内存
    
- ABI prologue/epilogue 未完成
    
- 内存复制、算术指令、中断敏感区刚开始未结束
    

如果在这些地方暂停，将导致：

- 栈损坏
    
- 寄存器非法
    
- 内存内容不一致
    
- 恢复执行时崩溃
    

**因此，暂停必须发生在“安全点”。**

---

### 协作式任务为什么天然处于安全点

因为协作式任务**只能**在你显式写 `yield()` 或 `await` 的地方暂停，而编译器/ABI 会保证：

- 到达 `yield/await` 之前所有指令都执行完毕
    
- 局部变量已经写入对应的内存槽位
    
- 调用栈的结构稳定且合法
    
- 所有可能破坏上下文的操作已结束
    
- 调用指令即将返回，此时寄存器布局符合 ABI
    

因此协作式切换点 **天然是 Safe Point**。