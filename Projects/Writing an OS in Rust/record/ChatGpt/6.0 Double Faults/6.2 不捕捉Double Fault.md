我们先来试试看不捕捉 double fault 的情况下触发它会有什么后果：
```rust
#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    println!("Hello World{}", "!");

    blog_os::init();

    // trigger a page fault
    unsafe {
        *(0xdeadbeef as *mut u8) = 42;
    };

    // as before
    #[cfg(test)]
    test_main();

    println!("It did not crash!");
    loop {}
}
```
这里我们使用 `unsafe` 块直接操作了一个无效的内存地址 `0xdeadbeef`，由于该虚拟地址并未在页表中映射到物理内存，所以必然会抛出 page fault 异常。我们又并未在 [IDT](https://os.phil-opp.com/cpu-exceptions/#the-interrupt-descriptor-table) 中注册对应的处理器，所以 double fault 会紧接着被抛出。

现在启动内核，我们可以看到它直接陷入了崩溃和重启的无限循环，其原因如下：

1. CPU试图向 `0xdeadbeef` 写入数据，这就造成了 page fault 异常。
2. CPU没有在IDT中找到相应的处理函数，所以又抛出了 double fault 异常。
3. CPU再一次没有在IDT中找到相应的处理函数，所以又抛出了 _triple fault_ 异常。
4. 在抛出 triple fault 之后就没有然后了，这个错误是致命级别，如同大多数硬件一样，QEMU对此的处理方式就是重置系统，也就是重启。

通过这个小实验，我们知道在这种情况下，需要提前注册 page faults 或者 double fault 的处理函数才行，但如果想要在任何场景下避免触发 triple faults 异常，则必须注册能够捕捉一切未注册异常类型的 double fault 处理函数。

![](asserts/Pasted%20image%2020250902193601.png)
让我们来分析一下又发生了什么：

1. CPU尝试往 `0xdeadbeef` 写入数据，引发了 page fault 异常。
2. 如同上次运行一样，CPU并没有在IDT里找到对应的处理函数，所以又引发了 double fault 异常。
3. CPU又跳转到了我们刚刚定义的 double fault 处理函数。

现在 triple fault 及其衍生的重启循环不会再出现了，因为CPU已经妥善处理了 double fault 异常。

这还真是直截了当对吧，但为什么要为这点内容单独写一篇文章呢？没错，我们的确已经可以捕获 _大部分_ double faults 异常，但在部分情况下，这样的做法依然不够。