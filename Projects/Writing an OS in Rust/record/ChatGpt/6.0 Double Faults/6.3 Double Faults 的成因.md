在解释这些部分情况之前，我们需要先明确一下 double faults 的成因，上文中我们使用了一个模糊的定义：
>double fault 就是当CPU执行错误处理函数失败时抛出的特殊异常。

但究竟什么叫 _“调用失败”_ ？没有提供处理函数？处理函数被[换出](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf)内存了？或者处理函数本身也出现了异常？

比如以下情况出现时：

1. 如果 breakpoint 异常被触发，但其对应的处理函数已经被换出内存了？
2. 如果 page fault 异常被触发，但其对应的处理函数已经被换出内存了？
3. 如果 divide-by-zero 异常处理函数又触发了 breakpoint 异常，但 breakpoint 异常处理函数已经被换出内存了？
4. 如果我们的内核发生了栈溢出，意外访问到了 _guard page_ ？

幸运的是，AMD64手册（[PDF](https://www.amd.com/system/files/TechDocs/24593.pdf)）给出了一个准确的定义（在8.2.9这个章节中）。 根据里面的说法，“double fault” 异常 _会_ 在执行主要（一层）异常处理函数时触发二层异常时触发。 这个“会”字十分重要：只有特定的两个异常组合会触发 double fault。 这些异常组合如下：


| 一层异常                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | 二层异常                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Divide-by-zero](https://wiki.osdev.org/Exceptions#Division_Error),  除[以零](https://wiki.osdev.org/Exceptions#Division_Error) ，  <br>[Invalid TSS](https://wiki.osdev.org/Exceptions#Invalid_TSS),  [无效的 TSS](https://wiki.osdev.org/Exceptions#Invalid_TSS)，  <br>[Segment Not Present](https://wiki.osdev.org/Exceptions#Segment_Not_Present),  <br>[不存在段](https://wiki.osdev.org/Exceptions#Segment_Not_Present) ，  <br>[Stack-Segment Fault](https://wiki.osdev.org/Exceptions#Stack-Segment_Fault),  <br>[堆栈段故障](https://wiki.osdev.org/Exceptions#Stack-Segment_Fault) /  <br>[General Protection Fault  <br>一般保护故障](https://wiki.osdev.org/Exceptions#General_Protection_Fault) | [Invalid TSS](https://wiki.osdev.org/Exceptions#Invalid_TSS),  [无效的 TSS](https://wiki.osdev.org/Exceptions#Invalid_TSS)，  <br>[Segment Not Present](https://wiki.osdev.org/Exceptions#Segment_Not_Present),  <br>[不存在段](https://wiki.osdev.org/Exceptions#Segment_Not_Present) ，  <br>[Stack-Segment Fault](https://wiki.osdev.org/Exceptions#Stack-Segment_Fault),  <br>[堆栈段故障](https://wiki.osdev.org/Exceptions#Stack-Segment_Fault) /  <br>[General Protection Fault  <br>一般保护故障](https://wiki.osdev.org/Exceptions#General_Protection_Fault)                                                                                                                          |
| [Page Fault  页面错误](https://wiki.osdev.org/Exceptions#Page_Fault)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | [Page Fault](https://wiki.osdev.org/Exceptions#Page_Fault),  [页面错误](https://wiki.osdev.org/Exceptions#Page_Fault) ，  <br>[Invalid TSS](https://wiki.osdev.org/Exceptions#Invalid_TSS),  [无效的 TSS](https://wiki.osdev.org/Exceptions#Invalid_TSS)，  <br>[Segment Not Present](https://wiki.osdev.org/Exceptions#Segment_Not_Present),  <br>[不存在段](https://wiki.osdev.org/Exceptions#Segment_Not_Present) ，  <br>[Stack-Segment Fault](https://wiki.osdev.org/Exceptions#Stack-Segment_Fault),  <br>[堆栈段故障](https://wiki.osdev.org/Exceptions#Stack-Segment_Fault) /  <br>[General Protection Fault  <br>一般保护故障](https://wiki.osdev.org/Exceptions#General_Protection_Fault) |

所以那些假设里的 divide-by-zero 异常处理函数触发了 page fault 并不会出问题，只会紧接着触发下一个异常处理函数。但如果 divide-by-zero 异常处理函数触发的是 general-protection fault，则一定会触发 double fault。

那么根据上表，我们可以回答刚刚的假设中的前三个：

1. 如果 breakpoint 异常被触发，但对应的处理函数被换出了内存，_page fault_ 异常就会被触发，并调用其对应的异常处理函数。
2. 如果 page fault 异常被触发，但对应的处理函数被换出了内存，那么 _double fault_ 异常就会被触发，并调用其对应的处理函数。
3. 如果 divide-by-zero 异常处理函数又触发了 breakpoint 异常，但 breakpoint 异常处理函数已经被换出内存了，那么被触发的就是 _page fault_ 异常。

实际上，因在IDT里找不到对应处理函数而抛出异常的内部机制是：当异常发生时，CPU会去试图读取对应的IDT条目，如果该条目不是一个有效的条目，即其值为0，就会触发 _general protection fault_ 异常。但我们同样没有为该异常注册处理函数，所以又一个 general protection fault 被触发了，随后 double fault 也被触发了。
### 内核栈溢出

现在让我们看一下第四个假设：

> 如果我们的内核发生了栈溢出，意外访问到了 _guard page_ ？

guard page 是一类位于栈底部的特殊内存页，所以如果发生了栈溢出，最典型的现象就是访问这里。这类内存页不会映射到物理内存中，所以访问这里只会造成 page fault 异常，而不会污染其他内存。bootloader 已经为我们的内核栈设置好了一个 guard page，所以栈溢出会导致 _page fault_ 异常。

当 page fault 发生时，CPU会在IDT寻找对应的处理函数，并尝试将 [中断栈帧](https://os.phil-opp.com/cpu-exceptions/#the-interrupt-stack-frame) 入栈，但此时栈指针指向了一个实际上并不存在的 guard page，然后第二个 page fault 异常就被触发了，根据上面的表格，double fault 也随之被触发了。

这时，CPU会尝试调用 _double fault_ 对应的处理函数，然而CPU依然会试图将错误栈帧入栈，由于栈指针依然指向 guard page，于是 _第三次_ page fault 发生了，最终导致 _triple fault_ 异常的抛出，系统因此重启。所以仅仅是注册错误处理函数并不能在此种情况下阻止 triple fault 的发生。

让我们来尝试一下，写一个能造成栈溢出的递归函数非常简单：

