现在我们可以访问物理内存了，我们终于可以开始实现我们的页表代码了。首先，我们将看一下我们的内核目前运行的活动页表。第二步，我们将创建一个转换函数，返回一个给定的虚拟地址所映射到的物理地址。作为最后一步，我们将尝试修改页表，以便创建一个新的映射。

在我们开始之前，我们为我们的代码创建一个新的`memory`模块。

```rust
// in src/lib.rs

pub mod memory;
```
对于该模块，我们创建一个空的`src/memory.rs`文件。

### 访问页表
	在[上一篇文章的结尾](https://os.phil-opp.com/paging-introduction/#accessing-the-page-tables)，我们试图查看我们的内核运行的页表，但是由于我们无法访问`CR3`寄存器所指向的物理帧而失败了。我们现在可以通过创建一个`active_level_4_table`函数来继续，该函数返回对活动的4级页面表的引用。
```rust
// in src/memory.rs

use x86_64::{
    structures::paging::PageTable,
    VirtAddr,
};

/// 返回一个对活动的4级表的可变引用。
///
/// 这个函数是不安全的，因为调用者必须保证完整的物理内存在传递的 
/// `physical_memory_offset`处被映射到虚拟内存。另外，这个函数
/// 必须只被调用一次，以避免别名"&mut "引用（这是未定义的行为）。
pub unsafe fn active_level_4_table(physical_memory_offset: VirtAddr)
    -> &'static mut PageTable
{
    use x86_64::registers::control::Cr3;

    let (level_4_table_frame, _) = Cr3::read();

    let phys = level_4_table_frame.start_address();
    let virt = physical_memory_offset + phys.as_u64();
    let page_table_ptr: *mut PageTable = virt.as_mut_ptr();

    unsafe { &mut *page_table_ptr }
}
```

### 翻译页表的代码
```rust
/// # Safety

/// 此函数是 unsafe 的，因为它涉及直接的内存操作和指针转换，

/// 这些操作可能导致未定义行为，需要调用者确保物理内存偏移量正确且有效。

pub unsafe fn transplate_addr(

    addr: VirtAddr,

    physical_memory_offset: VirtAddr,

) -> Option<PhysAddr> {

    transplate_addr_inner(addr, physical_memory_offset)

}

  

fn transplate_addr_inner(addr: VirtAddr, physical_memory_offset: VirtAddr) -> Option<PhysAddr> {

    use x86_64::{registers::control::Cr3, structures::paging::page_table::FrameError};

    // 从CR3寄存器获取当前页表的物理地址

    let (level_4_table_frame, _) = Cr3::read();

  

    let table_indexes = [

        addr.p4_index(),

        addr.p3_index(),

        addr.p2_index(),

        addr.p1_index(),

    ];

  

    let mut frame = level_4_table_frame;

  

    for &index in &table_indexes {

        // 将该框架转换为页表参考

        let virt = physical_memory_offset + frame.start_address().as_u64();

        let table_ptr: *const PageTable = virt.as_ptr();

        let table = unsafe { &*table_ptr };

  

        // 读取页表条目并更新框架

        let entry = &table[index];

        frame = match entry.frame() {

            Ok(frame) => frame,

            Err(FrameError::FrameNotPresent) => return None,

            Err(FrameError::HugeFrame) => panic!("huge pages not supported"),

        };

    }

    // 通过添加页面偏移量来计算物理地址

    Some(frame.start_address() + u64::from(addr.page_offset()))

}
```

### 映射内存
```rust
fn kernel_main(boot_info: &'static BootInfo) -> ! {

    // 导入必要的函数和类型

    // active_level_4_table: 获取当前活动的 Level 4 页表的函数

    // VirtAddr: 表示虚拟内存地址的类型

    use os_rust::memory;

    use x86_64::{VirtAddr, structures::paging::Page};

  

    // 在屏幕上打印 "Hello World!" 消息，作为内核启动的标志

    println!("Hello World{}", "!");

  

    // 初始化操作系统的关键组件，如 GDT（全局描述符表）、IDT（中断描述符表）等

    os_rust::init(); // new

  

    // 从引导信息中获取物理内存偏移量

    // 这个偏移量用于在虚拟地址空间中访问物理内存

    let phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);

  

    // // 不安全操作：使用物理内存偏移量获取当前活动的 Level 4 页表

    // // Level 4 页表是 x86_64 架构中页表层次结构的最高层

    // let l4_table = unsafe { active_level_4_table(phy_mem_offset) };

  

    // // 遍历 Level 4 页表中的所有条目

    // for (i, entry) in l4_table.iter().enumerate() {

    //     // 如果页表条目不是未使用的（即已映射），则打印其信息

    //     if !entry.is_unused() {

    //         println!("L4 Entry{}:{:?}", i, entry);

    //     }

    // }

    // let mapper = unsafe { memory::init(phys_mem_offset) };

  

    // let addresses = [

    //     // the identity-mapped vga buffer page

    //     0xb8000,

    //     // some code page

    //     0x201008,

    //     // some stack page

    //     0x0100_0020_1a10,

    //     // virtual address mapped to physical address 0

    //     boot_info.physical_memory_offset,

    // ];

  

    // for &address in &addresses {

    //     let virt = VirtAddr::new(address);

    //     let phys = mapper.translate_addr(virt);

    //     println!("{:?} -> {:?}", virt, phys);

    // }

  

    let mut mapper = unsafe { memory::init(phys_mem_offset) };

    let mut frame_allocator =

        unsafe { memory::BootInfoFrameAllocator::init(&boot_info.memory_map) };

  

    let page = Page::containing_address(VirtAddr::new(0));

    memory::create_example_mapping(page, &mut mapper, &mut frame_allocator);

  

    let page_ptr: *mut u64 = page.start_address().as_mut_ptr();

    unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e) };

  

    // 条件编译：仅在测试配置下执行

    // 调用测试主函数，运行内核中的测试用例

    #[cfg(test)]

    test_main();

  

    // 打印消息，表示内核成功执行到此处而没有崩溃

    println!("It did not crash!");

  

    // 进入 HLT 循环，使 CPU 进入低功耗状态，等待中断唤醒

    // 这是一个无限循环，内核会一直停留在这个状态直到收到中断

    os_rust::hlt_loop();

}
```