```rust
struct ListNode {
    size: usize,
    // 节点可能分配在 静态缓冲区 或堆管理的内存池中
    // 因此用 'static 表示引用 在整个程序运行期间都是有效的。
    next: Option<&'static mut ListNode>,

}
```

- **`size`**：当前节点所表示内存块的大小。
- **`next`**：指向下一个链表节点。
    - 使用 `Option` 表示可能为空（链表尾）。
    - 类型是 `&'static mut ListNode`，意味着这是一个 **可变引用**，且生命周期 `'static`。

- `&'static mut T` = 独占可变访问 + 不会自动释放 + 程序全生命周期有效。

此类型包含一个名为 `new` 的构造函数，以及用于计算代表区域起始地址和结束地址的方法。我们将 `new` 函数定义为[常量函数](https://doc.rust-lang.org/reference/items/functions.html#const-functions)，这一特性在后续构建静态链表分配器时是必需的。为啥？
#### 1. `const fn` 的作用
- `const fn` 是 **常量函数**，可以在 **编译期计算** 并生成常量值。
- 特点：
    1. 可以在 `const` 或 `static` 上下文中调用。
    2. 编译期就能完成初始化。
    3. 结果可以嵌入程序的只读数据段或静态内存段。
---
#### 2. 静态链表分配器的特点
- 分配器本身可能是一个 **全局静态对象**：
`static mut FREE_LIST_ALLOCATOR: Allocator = Allocator::new(...);`
- 它必须在编译期生成初始值：
    - 分配器包含空闲链表节点的起始和结束地址。
    - 链表节点也可能是 **静态存放在内存池中**。
- Rust 的规则：
    - **静态变量必须使用编译期可确定的初始值**。
    - 普通函数（非 `const fn`）不能在 `static` 初始化中调用。
    - 只有 `const fn` 可以在编译期执行并返回值。
### 结构体设计
此结构体包含一个指向第一个堆区域的 `head` 节点。我们只关注 `next` 指针的值，所以我们在 `ListNode::new` 函数中将 `size` 设置为0。将 `head` 定义为 `ListNode` 类型而不是 `&'static mut ListNode` 类型的优势在于，`alloc` 方法的实现会更简单。

- **生命周期问题**：你需要保证 `head` 永远指向一块静态有效内存（`'static` 生命周期），否则 Rust 编译器会报生命周期错误。
    
- **初始化困难**：在 `const fn new()` 中无法直接生成 `'static` 引用，因为 `'static` 引用必须指向静态分配的内存（通常是全局变量或 `.bss`/`.data` 段）。

- **可变借用冲突**：链表操作（插入/删除节点）需要多次可变借用链表节点。如果 `head` 是引用，借用规则会更严格，容易出现编译错误。

优点：
- **链表操作更灵活**：`head` 作为值存在，指针只需管理 `head.next` 的指向即可：
	- **无需担心生命周期**：链表中的真实节点可以通过 `&'static mut` 或裸指针管理，而 `head` 本身作为虚拟节点存在于分配器结构体内，其生命周期自动跟随分配器。
- **链表的前置哨兵节点**。
	- 这种设计让插入、删除节点操作无需处理特殊情况（例如空链表），逻辑上更干净。
#### 堆分配
和bump分配器一样，`new` 函数并未用堆边界初始化分配器。除了保持API兼容性外，这是因为**初始化操作需要将链表节点写入堆内存，而这只能在运行时发生**。但是，`new` 函数必须被定义为可以在编译期求值的[常量函数](https://doc.rust-lang.org/reference/items/functions.html#const-functions)，因为该函数将用于初始化 `ALLOCATOR` 静态变量。出于这个原因，我们再次提供一个独立的非常量 `init` 方法。

- Rust 要求 **静态变量初始化必须在编译期可确定**，因此构造器不能访问运行时堆内存。
	- **限制**
		- 不能写入堆内存或执行复杂的运行时逻辑。
		- 只能做简单的值初始化（如构造虚拟头节点）。
- 用实际的堆内存初始化分配器，将整个堆视作 free region 加入链表。
	- 需要写入堆内存（创建链表节点），而堆地址在编译期不可知。
	- 可能涉及裸指针或 `unsafe` 内存操作，无法在编译期执行。

总结
- `new` 提供编译期构造，保证静态变量初始化合法。
- `init` 提供运行时初始化，完成真实堆管理逻辑。
