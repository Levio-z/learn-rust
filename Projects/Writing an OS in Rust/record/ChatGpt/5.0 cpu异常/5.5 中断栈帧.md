当一个常规函数调用发生时（使用 `call` 指令），CPU会在跳转目标函数之前，将返回地址入栈。当函数返回时（使用 `ret` 指令），CPU会在跳回目标函数之前弹出返回地址。所以常规函数调用的栈帧看起来是这样的：
![](asserts/Pasted%20image%2020250902105215.png)
对于错误和中断处理函数，仅仅压入一个返回地址并不足够，因为中断处理函数通常会运行在一个不那么一样的上下文中（栈指针、CPU flags等等）。所以CPU在遇到中断发生时是这么处理的：

1. **对齐栈指针**: 任何指令都有可能触发中断，所以栈指针可能是任何值，而部分CPU指令（比如部分SSE指令）需要栈指针16字节边界对齐，因此CPU会在中断触发后立刻为其进行对齐。
	- CPU 在进入中断时，可能会调整栈指针 `RSP`，保证其是 **16 字节对齐**。这是为了避免中断服务例程中使用这些指令时出现异常。
2. **切换栈** （部分情况下）: 当CPU特权等级改变时，例如当一个用户态程序触发CPU异常时，会触发栈切换。该行为也可能被所谓的 _中断栈表_ 配置，在特定中断中触发，关于该表，我们会在下一篇文章做出讲解。
	- 当 CPL（当前特权等级） > DPL（目标中断门的特权等级），即用户态 → 内核态。
	- 或者当中断描述符（IDT entry）配置了 **IST (Interrupt Stack Table)**。
	- CPU 会从 **TSS（任务状态段）** 中读取目标栈指针（`RSP0` ~ `RSP2`），切换到合适的栈。
	- 若配置了 IST，则直接使用 IST 中指定的栈地址。
3. **压入旧的栈指针**: 当中断发生后，栈指针对齐之前，CPU会将栈指针寄存器（`rsp`）和栈段寄存器（`ss`）的数据入栈，由此可在中断处理函数返回后，恢复上一层的栈指针。
	- 只有在 CPL 改变（如用户态 → 内核态）时，才会保存。
	- 将旧的 `SS`（栈段选择子）和 `RSP` 压入新栈。
	- 中断返回时能恢复原有的用户栈。
4. **压入并更新 `RFLAGS` 寄存器**: [`RFLAGS`](https://en.wikipedia.org/wiki/FLAGS_register) 寄存器包含了各式各样的控制位和状态位，当中断发生时，CPU会改变其中的部分数值，并将旧值入栈。
	- CPU 会将进入中断前的 `RFLAGS` 压入栈。
	- `IF` (Interrupt Flag) 会被自动清零，禁止进一步的 maskable 中断。
	- `TF` (Trap Flag) 等调试标志也可能被修改。
5. **压入指令指针**: 在跳转中断处理函数之前，CPU会将指令指针寄存器（`rip`）和代码段寄存器（`cs`）的数据入栈，此过程与常规函数调用中返回地址入栈类似。
	- CPU 会将触发中断前的 `RIP` 和 `CS` 压栈。
	- 类似函数调用时保存返回地址，用于 `iretq` 恢复执行。
6. **压入错误码** （针对部分异常）: 对于部分特定的异常，比如 page faults ，CPU会推入一个错误码用于标记错误的成因。
	- 错误码标识了导致异常的原因（如缺页是读/写、缺页权限等）。
7. **执行中断处理函数**: CPU会读取对应IDT条目中描述的中断处理函数对应的地址和段描述符，将两者载入 `rip` 和 `cs` 以开始运行处理函数。
	- CPU 查找对应 **IDT entry**，获取目标 `RIP` 和 `CS`。
	- 加载到寄存器后跳转，进入中断处理函数执行。

所以 _中断栈帧_ 看起来是这样的：

![](asserts/Pasted%20image%2020250902105908.png)
在 `x86_64` crate 中，中断栈帧已经被 [`InterruptStackFrame`](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptStackFrame.html) 结构完整表达，该结构会以 `&mut` 的形式传入处理函数，并可以用于查询错误发生的更详细的原因。但该结构并不包含错误码字段，因为只有极少量的错误会传入错误码，所以对于这类需要传入 `error_code` 的错误，其函数类型变为了 [`HandlerFuncWithErrCode`](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFuncWithErrCode.html)。

### 幕后花絮
`x86-interrupt` 调用约定是一个十分厉害的抽象，它几乎隐藏了所有错误处理函数中的凌乱细节，但尽管如此，了解一下水面下发生的事情还是有用的。我们来简单介绍一下被 `x86-interrupt` 隐藏起来的行为：

- **传递参数**: 绝大多数指定参数的调用约定都是期望通过寄存器取得参数的，但事实上这是无法实现的，因为我们不能在备份寄存器数据之前就将其复写。`x86-interrupt` 的解决方案时，将参数以指定的偏移量放到栈上。
- **使用 `iretq` 返回**: 由于中断栈帧和普通函数调用的栈帧是完全不同的，我们无法通过 `ret` 指令直接返回，所以此时必须使用 `iretq` 指令。
- **处理错误码**: 部分异常传入的错误码会让错误处理更加复杂，它会造成栈指针对齐失效（见下一条），而且需要在返回之前从栈中弹出去。好在 `x86-interrupt` 为我们挡住了这些额外的复杂度。但是它无法判断哪个异常对应哪个处理函数，所以它需要从函数参数数量上推断一些信息，因此程序员需要为每个异常使用正确的函数类型。当然你已经不需要烦恼这些， `x86_64` crate 中的 `InterruptDescriptorTable` 已经帮助你完成了定义。
- **对齐栈**: 对于一些指令（尤其是SSE指令）而言，它们需要提前进行16字节边界对齐操作，通常而言CPU在异常发生之后就会自动完成这一步。但是部分异常会由于传入错误码而破坏掉本应完成的对齐操作，此时 `x86-interrupt` 会为我们重新完成对齐。

如果你对更多细节有兴趣：我们还有关于使用 [裸函数](https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md) 展开异常处理的一个系列章节，参见 [文末](https://os.phil-opp.com/zh-CN/cpu-exceptions/#hei-mo-fa-you-dian-duo)。




