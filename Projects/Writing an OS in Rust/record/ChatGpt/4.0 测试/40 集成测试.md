在Rust中，**集成测试**（[integration tests](https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests)）的约定是将其放到项目根目录中的 `tests` 目录下(即 `src` 的同级目录)。无论是默认测试框架还是自定义测试框架都将自动获取并执行该目录下所有的测试。

所有的集成测试都是它们自己的可执行文件，并且与我们的 `main.rs` 完全独立。这也就意味着每个测试都需要定义它们自己的函数入口点。让我们创建一个名为 `basic_boot` 的例子来看看集成测试的工作细节吧：

```rust
// in tests/basic_boot.rs

#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(crate::test_runner)]
#![reexport_test_harness_main = "test_main"]

use core::panic::PanicInfo;

#[unsafe(no_mangle)] // don't mangle the name of this function
pub extern "C" fn _start() -> ! {
    test_main();

    loop {}
}

fn test_runner(tests: &[&dyn Fn()]) {
    unimplemented!();
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    loop {}
}
```

由于集成测试都是单独的可执行文件，所以我们需要再次提供所有的crate属性(`no_std`, `no_main`, `test_runner`, 等等)。我们还需要创建一个新的入口点函数 `_start`，用于调用测试入口函数 `test_main`。我们不需要任何的 `cfg(test)` 属性，因为集成测试的二进制文件在非测试模式下根本不会被编译构建。

这里我们采用[`unimplemented`](https://doc.rust-lang.org/core/macro.unimplemented.html)宏，充当 `test_runner` 暂未实现的占位符；添加简单的 `loop {}` 循环，作为 `panic` 处理器的内容。理想情况下，我们希望能向我们在 `main.rs` 里所做的一样使用 `serial_println` 宏和 `exit_qemu` 函数来实现这个函数。但问题是，由于这些测试的构建和我们的 `main.rs` 的可执行文件是完全独立的，我们没有办法使用这些函数。

如果现阶段你运行 `cargo test`，你将进入一个无限循环，因为目前panic的处理就是进入无限循环。你需要使用快捷键 `Ctrl+c`，才可以退出QEMU。

###   创建一个库

为了让这些函数能在我们的集成测试中使用，我们需要从我们的 `main.rs` 中分割出一个库，这个库应当可以被其他的crate和集成测试可执行文件使用。为了达成这个目的，我们创建了一个新文件，`src/lib.rs`：
```rust
// src/lib.rs

#![no_std]
```
和 `main.rs` 一样，`lib.rs` 也是一个可以被cargo自动识别的特殊文件。该库是一个独立的编译单元，所以我们需要再次指定 `#![no_std]` 属性。

为了让我们的库可以和 `cargo test` 一起协同工作，我们还需要移动以下测试函数和属性:


为了能在可执行文件和集成测试中使用 `test_runner`，我们不对其应用 `cfg(test)` 属性，并将其设置为public。同时，我们还将panic的处理程序分解为public函数 `test_panic_handler`，这样一来它也可以用于可执行文件了。

由于我们的 `lib.rs` 是独立于 `main.rs` 进行测试的，因此当该库实在测试模式下编译时我们需要添加一个 `_start` 入口点和一个panic处理程序。通过使用[`cfg_attr`](https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute) ，我们可以在这种情况下有条件地启用 `no_main` 属性。
```rust
// in src/lib.rs

#![cfg_attr(test, no_main)]
#![feature(custom_test_frameworks)]
#![test_runner(crate::test_runner)]
#![reexport_test_harness_main = "test_main"]

use core::panic::PanicInfo;

pub trait Testable {
    fn run(&self) -> ();
}

impl<T> Testable for T
    where
        T: Fn(),
{
    fn run(&self) {
        serial_print!("{}...\t", core::any::type_name::<T>());
        self();
        serial_println!("[ok]");
    }
}

pub fn test_runner(tests: &[&dyn Testable]) {
    serial_println!("Running {} tests", tests.len());
    for test in tests {
        test.run();
    }
    exit_qemu(QemuExitCode::Success);
}

pub fn test_panic_handler(info: &PanicInfo) -> ! {
    serial_println!("[failed]\n");
    serial_println!("Error: {}\n", info);
    exit_qemu(QemuExitCode::Failed);
    loop {}
}

/// Entry point for `cargo test`
#[cfg(test)]
#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    test_main();
    loop {}
}

#[cfg(test)]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    test_panic_handler(info)
}
```
我们还将 `QemuExitCode` 枚举和 `exit_qemu` 函数从main.rs移动过来，并将其设置为公有函数：
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]

#[repr(u32)]

pub enum QemuExitCode {

    Success = 0x10,

    Failed = 0x11,

}

  

pub fn exit_qemu(exit_code: QemuExitCode) {

    use x86_64::instructions::port::Port;

  

    unsafe {

        let mut port = Port::new(0xf4);

        port.write(exit_code as u32);

    }

}
```
现在，可执行文件和集成测试都可以从库中导入这些函数，而不需要实现自己的定义。为了使 `println` 和 `serial_println` 可用，我们将以下的模块声明代码也移动到 `lib.rs` 中：
```rust
// in src/lib.rs

pub mod serial;
pub mod vga_buffer;
```
我们将这些模块设置为public(公有)，这样一来我们在库的外部也一样能使用它们了。由于这两者都用了该模块内的 `_print` 函数，所以这也是让 `println` 和 `serial_println` 宏可用的必要条件。

现在我们修改我们的 `main.rs` 代码来使用该库:
```rust
#![no_std] // 不链接 Rust 标准库

#![no_main] // 禁用所有 Rust 层级的入口点

#![feature(custom_test_frameworks)]

#![test_runner(os_rust::test_runner)]

#![reexport_test_harness_main = "test_main"]

  

use core::panic::PanicInfo;

  

use os_rust::println;

  

#[unsafe(no_mangle)] // 不重整函数名

pub extern "C" fn _start() -> ! {

    println!("Hello World{}", "!");

    #[cfg(test)]

    test_main();

    #[allow(clippy::empty_loop)]

    loop {}

}

  

/// 这个函数将在 panic 时被调用

#[cfg(not(test))] // new attribute

#[panic_handler]

fn panic(info: &PanicInfo) -> ! {

    println!("{}", info);

    loop {}

}

  

// our panic handler in test mode

#[cfg(test)]

#[panic_handler]

fn panic(info: &PanicInfo) -> ! {

    os_rust::test_panic_handler(info)

}
```

可以看到，这个库用起来就像一个普通的外部crate。它的调用方法与其它crate无异；在我们的这个例子中，位置可能为 `blog_os`。上述代码使用了 `test_runner` 属性中的 `blog_os::test_runner` 函数和 `cfg(test)` 的panic处理中的 `blog_os::test_panic_handler` 函数。它还导入了 `println` 宏，这样一来，我们可以在我们的 `_start` 和 `panic` 中使用它了。

与此同时，`cargo run` 和 `cargo test`可以再次正常工作了。当然了，`cargo test`仍然会进入无限循环（你可以通过`ctrl+c`来退出），接下来我们将在集成测试中通过所需要的库函数来修复这个问题。

### 完成集成测试
就像我们的 `src/main.rs`，我们的 `tests/basic_boot.rs` 可执行文件同样可以从我们的新库中导入类型。这也就意味着我们可以导入缺失的组件来完成我们的测试。

```rust
// in tests/basic_boot.rs

#![test_runner(blog_os::test_runner)]

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    blog_os::test_panic_handler(info)
}
```

这里我们使用我们的库中的 `test_runner` 函数，而不是重新实现一个test runner。至于panic处理，调用 `blog_os::test_panic_handler` 函数即可，就像我们之前在我们的 `main.rs` 里面做的一样。

现在，`cargo test`又可以正常退出了。当你运行该命令时，你会发现它为我们的 `lib.rs`, `main.rs`, 和 `basic_boot.rs` 分别构建并运行了测试。其中，对于 `main.rs` 和 `basic_boot` 的集成测试，它会报告“Running 0 tests“（正在运行0个测试），因为这些文件里面没有任何用 `#[test_case]`标注的函数。

现在我们可以在`basic_boot.rs`中添加测试了。举个例子，我们可以测试`println`是否能够正常工作而不panic，就像我们之前在vga缓冲区测试中做的那样:
```rust
use blog_os::println;

#[test_case]
fn test_println() {
    println!("test_println output");
}
```

现在当我们运行`cargo test`时，我们可以看到它会寻找并执行这些测试函数。

由于该测试和vga缓冲区测试中的一个几乎完全相同，所以目前它看起来似乎没什么用。然而在将来，我们的 `main.rs` 和 `lib.rs` 中的 `_start` 函数的内容会不断增长，并且在运行 `test_main` 之前需要调用一系列的初始化进程，所以这两个测试将会运行在完全不同的环境中(译者注:也就是说虽然现在看起来差不多，但是在将来该测试和vga buffer中的测试会很不一样，有必要单独拿出来，这两者并没有重复)。

通过在 `basic_boot` 环境里不调用任何初始化例程的 `_start` 中测试 `println` 函数，我们可以确保 `println` 在启动（boot）后可以正常工作。这一点非常重要，因为我们有很多部分依赖于 `println`，例如打印panic信息。


###   未来的测试

集成测试的强大之处在于，它们可以被看成是完全独立的可执行文件；**这也给了它们完全控制环境的能力，使得他们能够测试代码和CPU或是其他硬件的交互是否正确**。

我们的 `basic_boot` 测试正是集成测试的一个非常简单的例子。在将来，我们的内核的功能会变得更多，和硬件交互的方式也会变得多种多样。通过添加集成测试，我们可以保证这些交互按预期工作（并一直保持工作）。下面是一些对于未来的测试的设想：

- **CPU异常**：当代码执行无效操作（例如除以零）时，CPU就会抛出异常。内核会为这些异常注册处理函数。集成测试可以验证在CPU异常时是否调用了正确的异常处理程序，或者在可解析的异常之后程序是否能正确执行；
- **页表**：页表定义了哪些内存区域是有效且可访问的。通过修改页表，可以重新分配新的内存区域，例如，当你启动一个软件的时候。我们可以在集成测试中调整 `_start` 函数中的一些页表项，并确认这些改动是否会对 `#[test_case]` 的函数产生影响；
- **用户空间程序**：用户空间程序是只能访问有限的系统资源的程序。例如，他们无法访问内核数据结构或是其他应用程序的内存。集成测试可以启动执行禁止操作的用户空间程序验证认内核是否会将这些操作全都阻止。

可以想象，还有更多的测试可以进行。通过添加各种各样的测试，我们确保在为我们的内核添加新功能或是重构代码时，不会意外地破坏他们。这一点在我们的内核变得更大和更复杂的时候显得尤为重要。

### 那些应该Panic的测试
标准库的测试框架支持 [`#[should_panic]` 属性](https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testing-panics)，这允许我们构造理应失败的测试。这个功能对于验证传递无效参数时函数是否会失败非常有用。不幸的是，这个属性需要标准库的支持，因此，在 `#[no_std]` 环境下无法使用。

尽管我们不能在我们的内核中使用 `#[should_panic]` 属性，但是通过创建一个集成测试我们可以达到类似的效果——该集成测试可以从panic处理程序中返回一个成功错误代码。接下来让我一起来创建一个如上所述名为 `should_panic` 的测试吧：
```rust
// in tests/should_panic.rs

#![no_std]
#![no_main]

use core::panic::PanicInfo;
use blog_os::{QemuExitCode, exit_qemu, serial_println};

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    serial_println!("[ok]");
    exit_qemu(QemuExitCode::Success);
    loop {}
}
```
这个测试还没有完成，因为它尚未定义 `_start` 函数或是其他自定义的test runner属性。让我们来补充缺少的内容吧：

```rust
// in tests/should_panic.rs

#![feature(custom_test_frameworks)]
#![test_runner(test_runner)]
#![reexport_test_harness_main = "test_main"]

#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    test_main();

    loop {}
}

pub fn test_runner(tests: &[&dyn Fn()]) {
    serial_println!("Running {} tests", tests.len());
    for test in tests {
        test();
        serial_println!("[test did not panic]");
        exit_qemu(QemuExitCode::Failed);
    }
    exit_qemu(QemuExitCode::Success);
}
```
这个测试定义了自己的 `test_runner` 函数，而不是复用 `lib.rs` 中的 `test_runner`，该函数会在测试没有panic而是正常退出时返回一个错误退出代码(因为这里我们希望测试会panic)。如果没有定义测试函数，runner就会以一个成功错误代码退出。由于这个runner总是在执行完单个的测试后就退出，因此定义超过一个 `#[test_case]` 的函数都是没有意义的。

现在我们来创建一个应该失败的测试:
```rust
// in tests/should_panic.rs

use blog_os::serial_print;

#[test_case]
fn should_fail() {
    serial_print!("should_fail... ");
    assert_eq!(0, 1);
}
```

该测试用 `assert_eq`来断言（assert）`0` 和 `1` 是否相等。毫无疑问，这当然会失败(`0` 当然不等于 `1`)，所以我们的测试就会像我们想要的那样panic。

当我们通过 `cargo test --test should_panic` 运行该测试时，我们会发现测试成功，该测试如我们预期的那样panic了。当我们将断言部分（即 `assert_eq!(0, 1);`）注释掉后，我们就会发现测试失败，并返回了 _“test did not panic”_ 的信息。

这种方法的缺点是它只使用于单个的测试函数。对于多个 `#[test_case]` 函数，它只会执行第一个函数，因为程序无法在panic处理被调用后继续执行。我目前没有想到解决这个问题的方法，如果你有任何想法，请务必告诉我！

### 无约束测试
对于那些只有单个测试函数的集成测试而言(例如我们的 `should_panic` 测试)，其实并不需要test runner。对于这种情况，我们可以完全禁用test runner，直接在 `_start` 函数中直接运行我们的测试。

这里的关键就是在 `Cargo.toml` 中为测试禁用 `harness` flag，这个标志（flag）定义了是否将test runner用于集成测试中。如果该标志位被设置为 `false`，那么默认的test runner和自定义的test runner功能都将被禁用，这样一来该测试就可以像一个普通的可执行程序一样运行了。

现在为我们的 `should_panic` 测试禁用 `harness` flag吧：
```toml
# in Cargo.toml

[[test]]
name = "should_panic"
harness = false
```
现在我们通过移除test runner相关的代码，大大简化了我们的 `should_panic` 测试。结果看起来如下：
```rust
// in tests/should_panic.rs

#![no_std]
#![no_main]

use core::panic::PanicInfo;
use blog_os::{QemuExitCode, exit_qemu, serial_println, serial_print};

#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    should_fail();
    serial_println!("[test did not panic]");
    exit_qemu(QemuExitCode::Failed);
    loop{}
}

fn should_fail() {
    serial_print!("should_fail... ");
    assert_eq!(0, 1);
}

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    serial_println!("[ok]");
    exit_qemu(QemuExitCode::Success);
    loop {}
}
```

现在我们可以通过我们的 `_start` 函数来直接调用 `should_fail` 函数了，如果返回则返回一个失败退出代码并退出。现在当我们执行 `cargo test --test should_panic` 时，我们可以发现测试的行为和之前完全一样。

除了创建 `should_panic` 测试，禁用 `harness` 属性对复杂集成测试也很有用，例如，当单个测试函数会产生一些边际效应，需要通过特定的顺序执行时。

## 总结

测试是一种非常有用的技术，它能确保特定的部件拥有我们期望的行为。即使它们不能显示是否有bug，它们仍然是用来寻找bug的利器，尤其是用来避免回归。

本文讲述了如何为我们的Rust kernel创建一个测试框架。我们使用Rust的自定义框架功能为我们的裸机环境实现了一个简单的 `#[test_case]` 属性支持。通过使用QEMU的 `isa-debug-exit` 设备，我们的test runner可以在运行测试后退出QEMU并报告测试状态。我们还为串行端口实现了一个简单的驱动，使得错误信息可以被打印到控制台而不是VGA buffer中。

在为我们的 `println` 宏创建了一些测试后，我们在本文的后半部分还探索了集成测试。我们了解到它们位于 `tests` 目录中，并被视为完全独立的可执行文件。为了使他们能够使用 `exit_qemu` 函数和 `serial_println` 宏，我们将大部分代码移动到一个库里，使其能够被导入到所有可执行文件和集成测试中。由于集成测试在各自独立的环境中运行，所以能够测试与硬件的交互或是创建应该panic的测试。

我们现在有了一个在QEMU内部真是环境中运行的测试框架。在未来的文章里，我们会创建更多的测试，从而让我们的内核在变得更复杂的同时保持可维护性。

