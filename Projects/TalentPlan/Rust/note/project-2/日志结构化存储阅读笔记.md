# 核心概念
- 每当有新数据要写入时，您只需将其追加到日志的末尾，而不是在磁盘上为其查找位置。
	- 起源于 20 世纪 80 年代的[日志结构化文件系统](http://en.wikipedia.org/wiki/Log-structured_file_system)
- 例子
	- 添加元素导致旧索引条目失效，A仍存在，但不被使用
	- ![](Pasted%20image%2020250525191142.png)
	- 使用检查点来保存有效索引
	- 更新一个元素时会发生什么
		- ![](Pasted%20image%2020250525191443.png)
		- 在日志的末尾写一个全新的 Foo 副本。然后，我们再次更新索引节点（在这个例子中只有 A'），并将它们也写到日志的末尾。Foo 的旧副本仍然保留在日志中;只是更新后的索引不再引用它。
# 垃圾搜集
- 冷热数据友好：你不想因为清理少量无效数据，去重写一大段完全没变的新数据
	- 原理：首先，我们不限于首先删除最旧的段：如果中间段几乎为空，我们可以选择垃圾收集。这对于某些数据会停留很长时间（冷数据），并且某些数据会被重复覆盖的数据库特别有用（频繁更新，重写仍然被更新）：我们不想浪费太多时间重写相同的未修改数据。
	- 传统文件系统比较：的数据布局和更新机制是以 **“原地覆盖”（in-place update）** 为主
	- 使用场景：数据冷热分布明显、频繁重写、局部更新频繁的数据库。
- 择时垃圾搜集：对于何时进行垃圾收集，我们也有一些更大的灵活性：我们通常可以**等到一个段基本上过时了才进行垃圾收集**，进一步减少了我们必须做的额外工作。但是，如果我们使用日志结构化存储，则 Write Ahead Log _是_数据库文件，因此我们只需要写入数据一次。在恢复情况下，我们只需打开数据库，从最后记录的索引头开始，线性向前搜索，从数据中重建任何丢失的索引更新。
# 恢复机制
- 在恢复情况下，我们只需打开数据库，从最后记录的索引头开始，线性向前搜索，从数据中重建任何丢失的索引更新。
## 提前写入日志（WAL）
WAL友好：
- 为什么：使用日志结构化存储，则 **Write Ahead Log _是_数据库文件，因此我们只需要写入数据一次。**
	- 普通WAL机制：当数据库希望将事务持久化到磁盘时，它首先将所有更改写入 WAL，将这些更改刷新到磁盘，然后更新实际的数据库文件。这允许它通过重放 WAL 中记录的更改从崩溃中恢复。
## 使用恢复机制进一步优化我们的写入
- 大多数数据库使用锁来保证一致性级别，发生足够的并发读取->导致显著的性能下降
- 旧数据的版本的存在使我们可以用[多版本并发控制](http://en.wikipedia.org/wiki/Multiversion_concurrency_control) （MVCC）和写回使用乐观并发（无锁）
	- MVCC：
		- 来解决这个问题。每当一个节点想要从数据库中读取数据时，它都会查找当前的根索引节点，并将该节点用于其事务的剩余部分。因为在基于日志的存储系统中，现有数据永远不会被修改，所以进程现在在获取句柄时拥有数据库的快照：并发事务所做的任何事情都不会影响其数据库视图。就像这样，我们有无锁读取！
	- 写回使用乐观并发：
		- 在一个典型的读-修改-写周期中，我们首先执行读操作，如上所述。然后，为了写入更改，我们获取数据库的写锁，并验证我们在第一阶段读取的数据没有被修改。我们可以快速地做到这一点，通过查看索引，并检查我们关心的数据的地址是否与我们上次查看时相同。如果相同，则没有发生写入，我们可以继续自己修改它。如果不同，则发生了冲突事务，我们只需回滚并重新开始读取阶段。
# 现实场景
- 尽管最初的 [Berkeley DB](http://en.wikipedia.org/wiki/Berkeley_DB) 使用相当标准的体系结构（Java 端口），但 [BDB-JE](http://www.oracle.com/database/berkeley-db/je/index.html) 使用了我们刚才描述的所有组件。
- [PostgreSQL](http://www.postgresql.org/) 使用 MVCC，它的 writeahead 日志的结构允许我们描述的增量备份方法。
- [CouchDB](http://couchdb.apache.org/) 使用刚才描述的系统，只是它不是将日志分成段并进行垃圾收集，而是在积累了足够多的陈旧数据时重写整个数据库。
- [App Engine](http://code.google.com/appengine/)SDK 基于 Bigtable，它采用不同的磁盘存储方法，但事务层使用乐观并发。