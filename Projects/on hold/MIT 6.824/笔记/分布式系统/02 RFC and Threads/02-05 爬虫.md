实现目标：

- I/O concurrency：IO并发性  I/O 并发性：IO 并发性
- fetch once：保证每个url只爬一次
- exploit parallelism：利用并发行特性

![](../asserts/Pasted%20image%2020250708153434.png)
分享解决方案



![](../asserts/Pasted%20image%2020250708153828.png)
![](../asserts/Pasted%20image%2020250708154301.png)
- 获取锁
	- 标记准备
	- 标记被爬取
- 释放锁
- 准备好了直接返回
- 爬取页面
	- waitGroup:条件变量的内部实现
		- 爬取add
		- 结束 done
		- wait确保所有线程都结束

![](../asserts/Pasted%20image%2020250708154354.png)
通道版本
- 我们创建一个协调者线程
![](../asserts/Pasted%20image%2020250708154552.png)
- 不使用任何锁，没有实际共享的数据额机构
- ferched 跟踪哪些url被爬取过
- 看url是否获取
- 如果n==0 表示worker停止
- **worker是并行的，会将url写入通道**