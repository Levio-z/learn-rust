### 为什么用Go
- 对线程和Rpc有很好的支持，对分布式线程很友好
- 垃圾收集器，多个线程共享一个对象
- 类型安全
- 简单
- 编译型语言，运行时开销更低
### 线程
- 线程的基本概念
- [goroutine官网简介](https://golang.google.cn/doc/effective_go#goroutines)

- start/go：启动/运行一个线程
- exit：线程退出，一般从某个函数退出/结束执行后，会自动隐式退出
- stop：停止一个线程，比如向一个没有读者的channel写数据，那么channel阻塞，go可能会运行时暂时停止这个线程
- resume：恢复原本停止的线程重新执行，需要恢复程序计数器(program counter)、栈指针(stack pointer)、寄存器(register)状态，让处理器继续运行该线程。

### 为什么要用线程
- 并发性
	- io并发
	- 允许多核并行，提高整体吞吐量
	- 方便：方便，经常有需要异步执行or定时执行的任务，可以通过线程完成
### 挑战
#### 竞态条件
- 避免分享
- 使用锁
- 使用原子指令
#### 协调
- channels：通道允许同时通信和协调
- condition variables：配合互斥锁使用
#### 死锁
- deadlock：死锁问题，比如在go中简单的死锁场景，一个写线程往channel写数据，但是永远没有读线程从channel读数据，那么写线程被永久阻塞，即死锁，go会抓住这种场景，抛出运行时错误runtime error。
### go 如何对抗并发
- channels：通道
    - no-sharing场景：如果线程间不需要共享内存（变量等），一般偏向于使用channels完成线程间的通信
- locks + condition variables：锁和条件变量配套使用
    - shared-memory：如果线程间需要共享内存，则采用锁+条件变量的方案。比如键值对key-value服务，需要共享key-value table。
### 首先是一个模拟投票选举的go程序




![](../asserts/Pasted%20image%2020250708115151.png)

分析：
- 竞态条件

![](../asserts/Pasted%20image%2020250708120335.png)


![](../asserts/Pasted%20image%2020250708121427.png)
- 下面
	- cond.wait
		- 会释放与条件变量相关的锁，睡眠
		- 醒来后会再次获取锁，去检测共享变量
	- 不同进程的协调原语

![](../asserts/Pasted%20image%2020250708124031.png)
- 通道的方式
	- 多个线程并发写入通道，是线程安全的
	- 当写入通道，没人读取，通道会阻塞
- 没有共享，只有一个线程更新

- 在主线程退出后，其他线程可能继续运行

### 爬虫并发
- io并发性
	- 爬取通过低俗网络传输，再次期间
- 爬取一次
- 并发

### RPC

- 服务端需要应对多个客户端请求同时运行的情况，需要使用锁来控制对共享数据的访问

至少一次
最多一次
- 请求最多被执行0次或多次，服务器收到两个一样的请求，不能执行两次
正好一次
- 很难
### 问题

### 收获/总结

### TODO
