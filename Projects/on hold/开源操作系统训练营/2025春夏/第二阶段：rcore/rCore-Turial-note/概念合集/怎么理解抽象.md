**多层执行环境都是必需的吗？**

除了最上层的应用程序和最下层的硬件平台必须存在之外，作为中间层的函数库和操作系统内核并不是必须存在的： 它们都是对下层资源进行了 **抽象** (Abstraction/Indirection)，并为上层提供了一个执行环境（也可理解为一些服务功能）。
#### 抽象
**抽象的优点在于它让上层以较小的代价获得所需的功能，并同时可以提供一些保护。
抽象就是把复杂的底层资源包装起来，提供一个统一、简洁的接口。
- **简化开发**：应用程序无需关心寄存器、时钟中断，只需调用 `printf()`。
- **可移植性**：同样的应用程序换到 ARM、x86，只要有合适的库和 OS，就能运行。
- **保护**：操作系统可以限制进程访问内存，避免互相破坏。
比如：
- 没有 OS 的话，你要自己直接操作显卡寄存器才能在屏幕输出。
- 有了 OS 和函数库，你只要调用 `printf("hello")`。
这是“用较小代价获得功能”。

**但抽象同时也是一种限制，会丧失一些应有的灵活性。**
- **性能损失**：调用 `printf()` 会经过多层库函数、系统调用，效率比直接往显存写慢。
- **受限于接口**：如果操作系统不提供某种硬件特性（比如特殊的 CPU 指令、显卡加速模式），应用就没法直接使用。
- **不可控**：操作系统调度、内存管理策略可能不适合某些极端应用（比如实时系统）。
举例：
- 在 Linux 上，应用不能直接访问物理内存，必须通过系统调用 `mmap`。这保护了系统安全，但有时开发者希望直接写物理地址以获得更快速度，却被禁止了。
- 游戏主机开发（如 PlayStation）往往会去掉一部分 OS 抽象，让游戏直接控制 GPU，以获得更高性能。

比如，当你在考虑在项目中应该使用哪个函数库的时候，就常常需要这方面的权衡：过多的抽象和过少的抽象自然都是不合适的。理解应用的需求也很重要。一个能合理满足应用需求的操作系统设计是操作系统设计者需要深入考虑的问题。这也是一种权衡，过多的服务功能和过少的服务功能自然都是不合适的。

实际上，我们通过应用程序的特征和需求来判断操作系统需要什么程度的抽象和功能。

- 如果函数库和操作系统内核都不存在，那么我们就需要手写汇编代码来控制硬件，这种方式具有最高的灵活性，抽象能力则最低，基本等同于编写汇编代码来直接控制硬件。我们通常用这种方式来**实现一些架构相关且仅通过高级编程语言无法描述的小模块或者代码片段**。
    
- **如果仅存在函数库而不存在操作系统内核，意味着我们不需要操作系统内核提供过于通用的抽象。在那些功能单一的嵌入式场景就常常会出现这种情况**。嵌入式设备虽然也包含处理器、内存和 I/O 设备，但是它上面通常只会同时运行一个或几个功能非常简单的小应用程序，比如定时显示、实时采集数据、人脸识别打卡系统等。常见的解决方案是仅**使用函数库构建单独的应用程序或是用专为应用场景特别裁减过的轻量级函数库管理少数应用程序**。这就只需要一层函数库形态的执行环境。
    
- 如果存在函数库和操作系统内核，这意味着应用需求比较多样，会需要并发执行。常见的通用操作系统如 Windows/Linux/macOS 等都支持并发运行多个不同的应用程序。为此需要更加强大的操作系统抽象和功能，也就会需要多层执行环境。