
```java
(gdb) x/10i $pc
=> 0x1000:  auipc   t0,0x0
0x1004:     addi    a1,t0,32
0x1008:     csrr    a0,mhartid
0x100c:     ld      t0,24(t0)
0x1010:     jr      t0
0x1014:     unimp
0x1016:     unimp
0x1018:     unimp
0x101a:     0x8000
0x101c:     unimp
```



1. `x` 代表“examine”，即查看内存的意思。它是 GDB 中用于查看内存内容的基础命令。
2. `/10i`
	- `/10`：这是显示的数量，表示你想查看 **10 个内存单元**。它可以是任何正整数，比如 `x/20i` 表示查看 20 个指令。
	- `i`：指令（instructions）的意思，告诉 GDB 你想要查看 **反汇编** 的机器指令，而不是其他数据类型（比如整数、字符等）。
3. `$pc`
- `$pc` 是 GDB 中的一个寄存器，代表 **程序计数器（Program Counter）**，也叫做 **指令指针（Instruction Pointer）**。
- `$pc` 记录了当前正在执行的指令的地址，或者说是 CPU 当前位置的地址。

- `p/x $t0` 以 16 进制打印寄存器 `t0` 的值，注意当我们要打印寄存器的时候需要在寄存器的名字前面加上 `$` 。

#### 1. `0x1000: auipc t0,0x0`
- **作用**：`AUIPC` = “Add Upper Immediate to PC”。
- 将当前 PC 值加上 20 位的立即数（高 20 位，低 12 位为 0），结果存入 `t0`。
- 这里 `0x0`，所以实际上 `t0 = PC + 0`，即 `t0` = 0x1000。
- **用途**：为 PC 相对寻址准备基地址。
    

---

#### 2. `0x1004: addi a1,t0,32`
- **作用**：`ADDI` = “Add Immediate”。
- 将 `t0 + 32` 的结果存入 `a1`。
- 此处 `a1 = 0x1000 + 32 = 0x1020`。
- **用途**：准备一个地址指针，通常用于访问跳转表、栈顶或数据段。

---

#### 3. `0x1008: csrr a0,mhartid`

- **作用**：`CSRR` = “Control and Status Register Read”。
- 将当前硬件线程 ID (`mhartid`) 读入 `a0` 寄存器。
- **用途**：多核环境下，每个 hart（硬核线程）都有唯一 `mhartid`，可用于区分启动逻辑。
    

---

#### 4. `0x100c: ld t0,24(t0)`

- **作用**：`LD` = “Load Doubleword”。
- 从 `t0 + 24` 地址中读取 64-bit 数据，存入 `t0`。
- 当前 `t0` = 0x1000，所以加载地址 = 0x1018。
    
- **用途**：获取跳转目标地址（通常是函数指针或者启动入口地址）。
    

---

#### 5. `0x1010: jr t0`

- **作用**：`JR` = “Jump Register”。
    
- 跳转到 `t0` 指向的地址执行（PC = t0）。
    
- **用途**：间接跳转，用于启动实际内核或程序。
    

---

#### 6. `0x1014 ~ 0x101c: unimp` / `0x101a: 0x8000`

- **作用**：这些都是占位或未实现指令。
    
- `unimp` 通常触发非法指令异常。
    
- `0x8000` 是一个数据值或跳转表条目。
    
- **用途**：这里是 **跳转表或占位**，给 `ld t0,24(t0)` 指令读取。
    

---

### 总结分析

- **逻辑概览**：
    
    1. 用 `AUIPC` 获取当前 PC 基址。
        
    2. 通过 `ADDI` 计算跳转表或数据偏移。
        
    3. 读取 hart ID（多核适配）。
        
    4. 从偏移地址加载跳转目标。
        
    5. `JR` 跳转到实际执行代码。
        
- **典型用途**：引导/启动代码，尤其在 **SBI / 内核启动** 中常见
