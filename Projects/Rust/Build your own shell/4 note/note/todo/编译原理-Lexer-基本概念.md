---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层

**Lexer（词法分析）** 的职责是：

> **把“字符流”转换为“有边界、有类型的记号（Token）”**

它**只关心字符如何组合成最小语义单元**，不关心这些单元“是什么意思”。


### Ⅱ. 实现层



### Ⅲ. 原理层

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 初始设置：在 Shell 中，Lexer 关心什么？

在 shell 场景下，Lexer 只负责：

- 字符 → 单词边界
- 引号（`' "` ）如何影响字符合并
- 转义（`\`）如何影响字符含义
- 空白什么时候是分隔符
- 管道符 `|` 是一个独立 token
    

✅ **Lexer 的输出是“词法 token”**，例如：

```text
echo "hello  world" > out.txt
```

Lexer 输出（示意）：

```rust
[
    Word("echo"),
    Word("hello  world"),
    RedirectOut,
    Word("out.txt"),
]
```

---

### 初始设置：quote 规则只存在于 Lexer

**quote（引号）本质是“字符级规则”**：

- `'a b'`：空格不分词
- `"\""`：转义字符生效
- `'\"'`：转义字符不生效
- 引号本身不出现在最终参数中
    

这些规则的本质是：

> **“哪些字符会被合并进同一个 Word”**

👉 **这是字符流级别的事情，只可能属于 Lexer**

Parser 完全不应该知道：

- 这个 `Word("hello world")` 是怎么来的
- 中间有没有 quote / escape
    



## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
