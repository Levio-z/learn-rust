```rust
impl List {
    pub fn push(&mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: self.head,
        };
    }
}
```

```
error[E0507]: cannot move out of `self.head` which is behind a mutable reference
  --> src/first.rs:27:19
   |
27 |             next: self.head,
   |                   ^^^^^^^^^ move occurs because `self.head` has type `Link`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.

```
这是一个 **经典的 Rust 所有权错误**，编号是 `E0507`：你试图 **从一个可变引用后面移动一个值（`move out of &mut self`）**，但 Rust 默认不允许这么做，除非该类型实现了 `Copy` trait。
- `self.head`：你正在尝试从 `&mut self` 的字段中**移动（move）**一个值。
- `Link` 没有实现 `Copy` trait → 所以不能被“悄悄”复制，只能 move。
- 但 Rust 不允许你**直接 move 一个字段的值**，如果你是通过一个可变引用访问它。
为什么是非法的：
- Rust 的可变引用 `&mut self` 只是对对象的**独占访问**，而不是它的所有权。你不能在没有替代（replacement）的情况下，把它的字段**move 出去**。
- Rust 担心这样会导致 `self.head` 变成“空的”或“未定义的”，从而破坏类型的安全性。
### 方案一：`std::mem::take` 或 `std::mem::replace`
```rust
use std::mem;

let old_head = mem::take(&mut self.head);
```
等价于：
```rust
let old_head = std::mem::replace(&mut self.head, Link::Empty);
```
- `take()` 会将字段值替换为该类型的默认值（需实现 `Default`）
- `replace()` 允许你自定义替换值
