切片允许我们引用集合中部分连续的元素序列，而不是引用整个集合。
### 直接使用切片
```rust
let string: str = "banana";
```
结果：
```rust
error[E0277]: the size for values of type `str` cannot be known at compilation time --> src/main.rs:4:9 | 4 | let string: str = "banana"; | ^^^^^^ doesn't have a size known at compile-time
```
- doesn't have a size known at compile-time
	- **无法在编译期知道 `str` 类型的大小**，只有到了运行期才能动态获知，这对于强类型、强安全的 Rust 语言来说是不可接受的。
### 切片的底层原理
#### 为什么Rust要设计出切片
- 支持动态长度数组的只读或只写高效的非拥有引用
	- 动态长度：如果只有固定长度数组 `[T; N]`，就无法优雅地处理“部分数组”或“不定长数组”。
	- 为何不直接使用动态数组：我们只想读写数组或动态数组上的部分数据，而不想直接**操作动态数组和数组对象**。
		- `Vec<T>` 是拥有者（ownership container），包含 **容量(capacity)**、**长度(length)** 和 **堆分配的指针**。
	- 因此，我们有了切片， **指向现有内存的片段**，不涉及对象的分配和释放。
- 安全、高效、零开销地操作部分数组的内存或数据片段的零成本抽象。
	-  安全：
		- 这比直接暴露裸指针（`*const T`）更安全，因为：  
			✅ 带边界检查  
			✅ 不需要自己管理长度  
			✅ 编译器能推导生命周期和借用规则
	- 高效
		- 灵活/统一：
			- 切片 `[T]` 让你可以用统一、泛化的方式表达：
				- **静态数组的一部分** → `&array[1..3]`
				- **堆上动态分配的数组** → `Vec<T>` 的 `&vec[..]`
		- 高效的非拥有引用：
			- 我们只想**只读/只写部分数据**，而不想或不能复制或转移所有权。
			- 和动态数组的区别
	- 零开销：
		-  切片提供 **零拷贝、零分配** 的灵活接口。
			- 零拷贝：不需要复制数据，直接指向已有数据
			- 零分配：不需要申请新的内存


#### 切片的底层源码
##### 切片的底层结构：裸指针 + 长度
Rust 中，切片类型 `[T]` 是 **动态大小类型（DST）**，它本身不占空间。实际使用时，例如 `&[T]`，是一个 **fat pointer（宽指针）**，它包含：

- 一个裸指针，指向堆或者栈上元素的起始地址（类型是 `*const T` 或 `*mut T`）
- 一个长度（`usize`），表示切片中元素的数量
##### Rust 底层源码和标准库里的体现
Rust 的 `core::ptr` 模块中看到宽指针相关接口




- 动态变化的数据结构只能分配在堆上：
	- 底层的切片长度是可以动态变化的，而编译器无法在编译期得知它的具体的长度，因此该类型无法被分配在栈上，只能分配在堆上。
- 如何访问堆上的数据一般通过引用或指针来访问：
	-通过一个在栈上的引用来访问的，因为引用的大小是固定的。
- 切片的引用具体包含什么
	- 切片的起始位置和长度，而且最重要的是，类似于指针，**引用的大小是固定的(起始位置和长度都是整形)**，因此它才可以存储在栈上。
	- **胖指针**
		- thin pointer → 单一的内存地址（如 `*const T`、`&T`）
		- fat pointer → 包含地址 + 元信息的复合结构（如 `&[T]`、`&str`、`&dyn Trait`）
		- ![](Pasted%20image%2020250526104939.png)

# 附录
## 参考资料
- https://course.rs/difficulties/slice.html
- https://chatgpt.com
  