### 支持Borrow\<Q>
#### 现象：expected `&String`, found `&str`
```rust
...
30  |     if !book_reviews.contains_key("Les Misérables") {
    |                      ------------ ^^^^^^^^^^^^^^^^ expected `&String`, found `&str`
    |                      |
    |                      arguments to this method are incorrect
    |
    = note: expected reference `&String`
               found reference `&'static str`
note: method defined here
   --> D:\A02-code\rust\hashmap\src\lib.rs:102:12
    |
102 |     pub fn contains_key(&self, key: &K) -> bool {
    |            ^^^^^^^^^^^^

```

 - 官方测例，我们存入String，想要使用&str来查找，发现不行
before
- 看下[Borrow](Borrow.md)是什么？
	- 让K实现Borrow\<Q>，这样K就可以通过Borrow获取到Q的类型，并且本质上这两个引用的本质是一样的。
before
```rust
pub fn contains_key(&self, key: &K) -> bool {

        let index = self.bucket(key);

        self.buckets[index]

            .iter()

            .find(|&&(ref x, _)| x == key)

            .is_some()

    }
```

after
```rust
   pub fn contains_key<Q>(&self, key: &Q) -> bool

    where

        K: Borrow<Q>,

        Q: Hash + Eq + ?Sized,

    {

        let index = self.bucket(key);

        self.buckets[index]

            .iter()

            .find(|&&(ref x, _)| x.borrow() == key)

            .is_some()

    }
```
为什么使用Hash + Eq + ?[Sized](Sized.md)

| 约束          | 作用                       |
| ----------- | ------------------------ |
| `Q: Hash`   | 计算查询键的哈希值，用于定位桶。         |
| `Q: Eq`     | 比较查询键和已有键是否相等。           |
| `Q: ?Sized` | 支持 `str`、`[u8]` 等动态大小类型。 |
#### 测试用例
```rust
   #[test]

    fn borrow() {

        let mut map = HashMap::new();

        map.insert("foo".to_string(), 23);

        assert_eq!(map.get("foo"), Some(&23));

        assert_eq!(map.contains_key("foo"), true);

    }
```
结果：
```rust
test tests::borrow ... ok
```
- 现在存入String可以使用&str来查找

### 支持Index和IndexMut
#### Index
```rust
impl<K, V> Index<K> for HashMap<K, V>

where

    K: std::hash::Hash + Eq,

{

    type Output = V;

  

    fn index(&self, key: K) -> &Self::Output {

        self.get(&key).expect("Key not found")

    }

}
```
- 尝试在Index上引入Q，报错
```rust
method `index` has 1 type parameter but its trait declaration has 0 type parameters
```
- `impl<K, V> Index<K> for HashMap<K, V> { ... }`  
    → 这里声明：`K` 是索引类型。
- 但 `fn index<Q>(&self, key: &Q)` 又引入了一个新类型 `Q`，  
    这就 **不符合** trait 要求的签名：
- 换句话说，`Index` trait 要求 `index` 的参数必须是 `K`，不能在方法上再扩展一个 `Q`。

要实现：
`map[&key]`

其实你要为：
impl<K, V> Index<&Q> for HashMap<K, V> 也就是 `Index<&Q>`，而不是 `Index<K>` 由此写下
```rust
impl<K, Q, V> Index<&Q> for HashMap<K, V>

where

    K: Borrow<Q> + Eq + Hash,

    Q: Eq + Hash + ?Sized,

{

    type Output = V;

  

    fn index(&self, key: &Q) -> &Self::Output {

        self.get(key).expect("Key not found")

    }

}
```
#### IndexMut
`IndexMut` trait 本身定义为：
```rust
pub trait IndexMut<Idx: ?Sized>: Index<Idx> {
    // ...
}
```

所以实现IndexMut的基础是实现Index
```rust
impl<K, Q, V> IndexMut<&Q> for HashMap<K, V>

where

    K: Borrow<Q> + Eq + Hash,

    Q: Eq + Hash + ?Sized,

{

    fn index_mut(&mut self, key: &Q) -> &mut Self::Output {

        self.get_mut(key).expect("Key not found")

    }

}
```
- 实现IndexMut让我们获得通过索引直接修改元素的能力
#### 测试用例
```rust
 #[test]

    fn index() {

        let mut map = HashMap::new();

        map.insert("foo", 23);

        assert_eq!(map["foo"], 23);

        map["foo"]=3;

        assert_eq!(map["foo"], 3);

    }
```
结果：
```rust
running 1 test
test tests::index ... ok
```
### 支持entry
#### 先复制官网的API
- https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html
#### 在examples创建新例子：entry
```rust
extern crate hashmap;

use crate::hashmap::HashMap;

fn main() {

    let mut map: HashMap<&str, u32> = HashMap::new();
	 // 获取或者插入
    map.entry("poneyland").or_insert(3);
    assert_eq!(map["poneyland"], 3);
    // 获取或者插入，插入之后更新
    *map.entry("poneyland").or_insert(10) *= 2;
    assert_eq!(map["poneyland"], 6);

    let mut map = HashMap::new();
    let value = "hoho";
    // 获取或者插入，闭包和key无关
    map.entry("poneyland").or_insert_with(|| value);
    assert_eq!(map["poneyland"], "hoho");

    let mut map: HashMap<&str, usize> = HashMap::new();
    // 获取或者插入，闭包和key有关
    map.entry("poneyland")
        .or_insert_with_key(|key| key.chars().count());
    assert_eq!(map["poneyland"], 9);
  

    let mut map: HashMap<&str, u32> = HashMap::new();
    // 获取key
    assert_eq!(map.entry("poneyland").key(), &"poneyland");
    
    let mut map: HashMap<&str, u32> = HashMap::new();
    // 修改或插入
    map.entry("poneyland").and_modify(|e| *e += 1).or_insert(42);
    assert_eq!(map["poneyland"], 42);

	// 直接插入，有就覆盖
    let mut map: HashMap<&str, String> = HashMap::new();
    let entry = map.entry("poneyland").insert_entry("hoho".to_string());
    
    // 获取，不存在插入Option<u32>::default()
    let mut map: HashMap<&str, Option<u32>> = HashMap::new();
    map.entry("poneyland").or_default();
    assert_eq!(map["poneyland"], None);

}
```
