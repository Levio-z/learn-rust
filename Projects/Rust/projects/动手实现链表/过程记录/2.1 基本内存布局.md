### 函数式编程链表的定义
什么是链表呢？函数式编程中重要的基础工具，函数式中的定义
```
List a = Empty | Elem a (List a)
```
- 列表要么是空的，要么是元素后跟列表
- 这是一个递归定义，表示为总和类型 ，又称“代数数据类型”的一种。 
	- 即：一个类型可以有多个**不同的构造方式（variants）**，而每个方式可能携带不同的数据。
- Rust 中将“sum 类型”用 `enum` 实现。

避免使用泛型，以保持简单。我们只支持存储有符号的 32 位整数：
```rust
// in first.rs

// pub says we want people outside this module to be able to use List
pub enum List {
    Empty,
    Elem(i32, List),
}

```
编译：
```rust
error[E0072]: recursive type `List` has infinite size
  --> src/lib.rs:15:1
   |
15 | pub enum List {
   | ^^^^^^^^^^^^^
16 |     Empty,
17 |     Elem(i32, List),
   |               ---- recursive without indirection
   |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
   |
17 |     Elem(i32, Box<List>),
   |               ++++    +

For more information about this error, try `rustc --explain E0072`.
error: could not compile `lists` (lib) due to 1 previous error

```
- Rust 编译器给出的一个非常**经典的错误**：你定义了一个**递归类型**，但没有使用**间接引用**（indirection）来打破递归，从而导致类型具有“无限大小”（infinite size），编译器无法为其分配内存空间。
- List 的大小取决于列表中的元素数量，因此我们不知道要为 Cons 分配多少内存。通过引入具有定义大小的Box类型，我们知道 Cons 需要多大。
```rust
pub enum List {
    Empty,
    Elem(i32, Box<List>),
}
```
编译通过..但这实际上是对列表的一个非常愚蠢的定义，原因如下：
考虑一个包含两个元素的列表：
```rust
[] = Stack
() = Heap
[Elem A, ptr] -> (Elem B, ptr) -> (Empty, *junk*)
```
有两个关键问题：
- 我们分配了一个节点，它只是说“我实际上不是节点”
- 我们的一个节点根本没有堆分配。
- 从表面上看，这两者似乎相互抵消。我们堆分配一个额外的节点，但我们的一个节点根本不需要堆分配。但是，请考虑我们列表的以下潜在布局：
```rust
[ptr] -> (Elem A, ptr) -> (Elem B, *null*)
```
在这种布局下，我们无条件的在堆上创建所有节点，最大的区别就是这里不再有 `junk`。那么什么是 `junk`？为了理解这个概念，先来看看枚举类型的内存布局( Layout )长什么样:



一般来说，如果我们有一个像这样的枚举：
```rust
enum Foo {
    D1(T1),
    D2(T2),
    ...
    Dn(Tn),
}
```

- 枚举内容
	- 标签：需要使用整数作为标签标记哪个变体
	- 预留空间：需要足够的空间来存储最大的变体

>Foo 需要存储一些整数来指示它表示枚举的哪个变体（`D1`， `D2`， ..`Dn`）。这是枚举的标签 。它还需要足够的空间来存储最大的 `T1`、`T2` 等。`Tn`（加上一些额外的空间以满足对齐要求）。


`Empty`充满了未使用的空间。
>这里最大的收获是，尽管 `Empty` 是单个比特信息，但它必然会为指针和元素消耗足够的空间，因为它必须随时准备好成为 `Elem`。因此，第一个布局堆分配了一个额外的元素，该元素充满了未使用的空间，比第二个布局消耗更多的空间。

节点处理就不一样
>我们的**一个节点根本没有被堆分配**，也许令人惊讶的是， 比总是分配它更糟糕。这是因为它给了我们一个不均匀的节点布局。这对推动和弹出节点没有什么影响，但**它确实对拆分和合并列表**有影响。

改进：
Some(Box) None

- 如果我没有节点，只会消耗枚举+Box指针空间
- 之前只有一个指针空间，但是一定会消耗一个链表元素的结构体的大小

为了所有数据统一处理，引入一个指针来指向堆上的数据


考虑在两种布局中拆分列表：
```
layout 1:

[Elem A, ptr] -> (Elem B, ptr) -> (Elem C, ptr) -> (Empty *junk*)

split off C:

[Elem A, ptr] -> (Elem B, ptr) -> (Empty *junk*)
[Elem C, ptr] -> (Empty *junk*)

layout 2:

[ptr] -> (Elem A, ptr) -> (Elem B, ptr) -> (Elem C, *null*)

split off C:

[ptr] -> (Elem A, ptr) -> (Elem B, *null*)
[ptr] -> (Elem C, *null*)

```
布局 2 的拆分仅涉及**将 B 的指针复制到栈并将旧值归零**。布局 1 最终会做同样的事情，但必须将 C 从堆复制到栈中，并将B的指针归零。合并是相反的相同过程。

链表为数不多的好处之一是，**您可以在节点本身中构造元素，然后在列表中自由打乱它，而无需移动它。你只需摆弄指针，东西就会被“移动”**。布局 1 会丢弃此属性。

现在，我们应该都相信布局 1 更糟糕了，而且不幸的是，我们之前的实现就是布局 1， 那么该如何实现新的布局呢 ？也许，我们可以实现类似如下的 `List` :
```rust
pub enum List {
    Empty,
    ElemThenEmpty(i32),
    ElemThenNotEmpty(i32, Box<List>),
}
```
- 语义冗余：更糟糕了，现在有一个完全无效的状态`ElemThenNotEmpty(0, Box(Empty))`
- 它还仍然受到不均匀分配我们的元素的问题。

```rust
let a = List::ElemThenEmpty(1); // 栈上含 i32，无堆分配
let b = List::ElemThenNotEmpty(1, Box::new(List::Empty)); // 栈 + 堆上有 List::Empty
```

然而，它确实有一个有趣的属性：它完全避免分配 Empty 情况，将堆分配总数减少 1。不幸的是，这样做会浪费更多的空间！这是因为之前的布局利用了空指针优化 。

我们之前看到，每个枚举都必须存储一个_标签_来指定其位代表枚举的哪个变体。但是，如果我们有一个特殊的枚举：
```rust
enum Foo {
    A,
    B(ContainsANonNullPtr),
}
```
[2 空指针优化](../ChatGPT/2%20空指针优化.md)
Rust 会为我们做一些更复杂的枚举布局优化，但空指针绝对是最重要的！这意味着 `&`、`&mut`、`Box`、`Rc`、`Arc`、`Vec` 和 Rust 中的其他几个重要类型在放入 `Option` 时没有开销！（我们将在适当的时候讨论其中的大部分内容

枚举让我们声明一个_可以包含多个_值之一的类型，而结构让我们声明一个同时包含_多个_值的类型。让我们将列表分为两种类型：列表和节点。

和以前一样，一个 List 要么是空的，要么有一个元素后跟另一个 List。通过用一个完全独立的类型表示“有一个元素后跟另一个列表”的情况，我们可以将 Box 提升到一个更优化的位置：
```rust
struct Node {
    elem: i32,
    next: List,
}

pub enum List {
    Empty,
    More(Box<Node>),
}
```
- Tail of a list never allocates extra junk: check!  
    列表的尾部永远不会分配额外的垃圾：检查！
- `enum` is in delicious null-pointer-optimized form: check!  
    `enum` 采用美味的空指针优化形式：check！
- All elements are uniformly allocated: check!  
    所有元素都统一分配：检查！

好！实际上，我们只是构建了我们用来证明我们的第一个布局（正如官方 Rust 文档所建议的那样）有问题的布局。
```rust
warning: type `Node` is more private than the item `List::More::0`
 --> src/first.rs:8:10
  |
8 |     More(Box<Node>),
  |          ^^^^^^^^^ field `List::More::0` is reachable at visibility `pub`
  |
note: but type `Node` is only usable at visibility `pub(self)`
 --> src/first.rs:1:1
  |
1 | struct Node {
  | ^^^^^^^^^^^
  = note: `#[warn(private_interfaces)]` on by default

warning: fields `elem` and `next` are never read
 --> src/first.rs:2:5
  |
1 | struct Node {
  |        ---- fields in this struct
2 |     elem: i32,
  |     ^^^^
3 |     next: List,
  |     ^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: `lists` (lib) generated 2 warnings
```
Rust 的可见性系统要求：**如果某个字段类型是公开的，它本身也必须是可访问的。**
#### 解释：
- 你定义了一个 `pub enum List`（公共枚举），并将其暴露给模块外部使用。
	- `List::More` 变体中包含一个 `Box<Node>`，这个字段也是公共的（默认枚举变体字段是公开的）。
	- **但是 `Node` 结构体本身是私有的**（默认是 `pub(self)`），这就造成了不一致性。
主要原因在于 `pub enum` 会要求它的所有成员必须是 `pub`，但是由于 `Node` 没有声明为 `pub`，因此产生了冲突。
这里最简单的解决方法就是将 `Node` 结构体和它的所有字段都标记为 `pub` :
```rust
pub struct Node {
    pub elem: i32,
    pub next: List,
}
```
但是从编程的角度而言，我们还是希望让实现细节只保留在内部，而不是对外公开，因此以下代码相对会更加适合：
```rust
pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box<Node>),
}

struct Node {
    elem: i32,
    next: Link,
}
```

因为 `List` 是一个具有单个字段的结构体，所以它的大小与该字段相同。耶，零成本抽象！
```rust
warning: field `head` is never read
 --> src/first.rs:2:5
  |
1 | pub struct List {
  |            ---- field in this struct
2 |     head: Link,
  |     ^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: variants `Empty` and `More` are never constructed
 --> src/first.rs:6:5
  |
5 | enum Link {
  |      ---- variants in this enum
6 |     Empty,
  |     ^^^^^
7 |     More(Box<Node>),
  |     ^^^^

warning: fields `elem` and `next` are never read
  --> src/first.rs:11:5
   |
10 | struct Node {
   |        ---- fields in this struct
11 |     elem: i32,
   |     ^^^^
12 |     next: Link,
   |     ^^^^

warning: `lists` (lib) generated 3 warnings
```

好了，编译完毕！Rust 非常疯狂，因为据它所知，我们编写的所有内容都完全无用：我们从不使用 `head`，使用我们库的人也无法使用，因为它是私有的。传递地，这意味着 Link 和 Node 也毫无用处。那么让我们解决这个问题吧！让我们为我们的列表实现一些代码！

### 总结
#### 演变
- 函数式编程，要么是空，要么是一个元素后面接着列表
	-  List 的大小取决于列表中的元素数量，因此我们不知道要为 Cons 分配多少内存。所以编译不通过
```rust
pub enum List {
    Empty,
    Elem(i32, Box<List>),
}
```
- `[Elem A, ptr] -> (Elem B, ptr) -> (Empty, *junk*)`
	- 缺点：
		- 浪费内存：ptr是结构体，无论用不用，都需要分配一个结构体，使用一个枚举代表一个空节点，我们分配了一个节点，它只是说“我实际上不是节点”
		- 内存不均：一个节点在栈上，一半在堆上，处理数据格式不统一
		- 拆分和合并：需要将堆上的数据，复制一份移动到栈上
- `[ptr] -> (Elem A, ptr) -> (Elem B, ptr) -> (Elem C, *null*)`
	- 改进：
		- 统一数据分布，指针放在栈上，数据放在堆上
		- 使用Some和None和指针而不直接使用结构体指针
			- 措施：使用（空指针和非空指针枚举优化下一个节点的存储结构）
			- 结果：
				- 当节点为空不必浪费空间存储完整结构体的数据
				- 将存在和不存在的状态和链表数据解耦
```rust
struct Node {
    elem: i32,
    next: List,
}

pub enum List {
    Empty,
    More(Box<Node>),
}
```
为了不暴露内部数据结构，使用结构体封装
```rust
pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box<Node>),
}

struct Node {
    elem: i32,
    next: Link,
}
```