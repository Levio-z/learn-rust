与 push 一样，pop 想要更改列表。与 push 不同，我们实际上想要返回一些东西。但pop也必须处理一个棘手的角落 case：如果列表为空怎么办？为了表示这种情况，我们使用 Option 类型：
```rust
pub fn pop(&mut self) -> Option<i32> {
    // TODO
}
```
我们有了这个 `Link` 这个东西，我们如何确定它是 Empty 还是 More
```rust
pub fn pop(&mut self) -> Option<i32> {
    match self.head {
        Link::Empty => {
            // TODO
        }
        Link::More(node) => {
            // TODO
        }
    };
}
```

哎呀，pop 必须返回一个值，我们还没有这样做。 我们可以 return None，但在这种情况下，返回 unimplemented!()， 以指示我们还没有完成该函数的实现。unimplemented!() 是一个宏 （！ 表示宏），当我们到达它时，它会使程序 panic （~以受控方式崩溃它）。

```
> cargo build

error[E0507]: cannot move out of borrowed content
  --> src/first.rs:28:15
   |
28 |         match self.head {
   |               ^^^^^^^^^
   |               |
   |               cannot move out of borrowed content
   |               help: consider borrowing here: `&self.head`
...
32 |             Link::More(node) => {
   |                        ---- data moved here
   |
note: move occurs because `node` has type `std::boxed::Box<first::Node>`, which does not implement the `Copy` trait
  --> src/first.rs:32:24
   |
32 |             Link::More(node) => {
   |                        ^^^^

```

Rust 说我们应该添加对 `match` 的引用来解决这个问题。🤷 ♀️ 让我们试一试：
编写逻辑
```rust
pub fn pop(&mut self) -> Option<i32> {
    let result;
    match &self.head {
        Link::Empty => {
            result = None;
        }
        Link::More(node) => {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
```

```
> cargo build
   Compiling lists v0.1.0 (/Users/ADesires/dev/temp/lists)
error[E0507]: cannot move out of borrowed content
  --> src/first.rs:35:29
   |
35 |                 self.head = node.next;
   |                             ^^^^^^^^^ cannot move out of borrowed content

```
当我们所拥有的只是对 node 的共享引用时，我们正试图移出 `node`。










来吧 Rust，从我们的背上下来！一如既往，Rust 对我们很生气。值得庆幸的是，这一次它也给了我们完整的独家新闻！默认情况下，模式匹配将尝试将其内容移动到新分支中，但我们不能这样做，因为我们在这里没有 self by-value。
我们可能应该退后一步，想想我们正在努力做什么。我们希望：

- Check if the list is empty.  
    检查列表是否为空。
- If it's empty, just return None  
    如果为空，则返回 None
- If it's _not_ empty  
    如果它_不_为空
    - remove the head of the list  
        删除列表的头部
    - remove its `elem`  删除其 `elem`
    - replace the list's head with its `next`  
        将列表的 head 替换为 `next`
    - return `Some(elem)`  
        返回 `Some（elem）`






关键的见解是我们想_删除_一些东西，这意味着我们想_按值_获取列表的头部。我们当然不能通过我们通过 `&self.head` 获取的共享引用来做到这一点。我们也 “只” 有一个对 `self` 的可变引用，所以我们唯一能移动东西的方法是_替换它_ 。！
```rust
pub fn pop(&mut self) -> Option<i32> {
    let result;
    match mem::replace(&mut self.head, Link::Empty) {
        Link::Empty => {
            result = None;
        }
        Link::More(node) => {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
		}
```

实际上，我将在这里应用我自己的个人 lint：我们做出了这个`result` value 返回，但实际上我们根本不需要这样做！就像一个 function 计算结果为最后一个表达式，则每个块的计算结果也会为 它的最后一个表达式。通常我们用分号来抑制这种行为， 这会使块计算为空元组 `（）。` 这是 实际上是不声明返回值的函数的值 —— 比如 `push` -- 返回。
因此，我们可以将 `pop` 写成：
```rust
pub fn pop(&mut self) -> Option<i32> {
    match mem::replace(&mut self.head, Link::Empty) {
        Link::Empty => None,
        Link::More(node) => {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
```
这更简洁、更地道。请注意，Link：：Empty 分支完全丢失了大括号，因为我们只有一个表达式要计算。只是简单情况的一个很好的简写。
```rust
cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s

```