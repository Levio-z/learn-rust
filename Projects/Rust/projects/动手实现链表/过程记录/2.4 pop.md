ä¸ push ä¸€æ ·ï¼Œpop æƒ³è¦æ›´æ”¹åˆ—è¡¨ã€‚ä¸ push ä¸åŒï¼Œæˆ‘ä»¬å®é™…ä¸Šæƒ³è¦è¿”å›ä¸€äº›ä¸œè¥¿ã€‚ä½†popä¹Ÿå¿…é¡»å¤„ç†ä¸€ä¸ªæ£˜æ‰‹çš„è§’è½ caseï¼šå¦‚æœåˆ—è¡¨ä¸ºç©ºæ€ä¹ˆåŠï¼Ÿä¸ºäº†è¡¨ç¤ºè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬ä½¿ç”¨ Option ç±»å‹ï¼š
```rust
pub fn pop(&mut self) -> Option<i32> {
    // TODO
}
```
æˆ‘ä»¬æœ‰äº†è¿™ä¸ªÂ `Link`Â è¿™ä¸ªä¸œè¥¿ï¼Œæˆ‘ä»¬å¦‚ä½•ç¡®å®šå®ƒæ˜¯ Empty è¿˜æ˜¯ More
```rust
pub fn pop(&mut self) -> Option<i32> {
    match self.head {
        Link::Empty => {
            // TODO
        }
        Link::More(node) => {
            // TODO
        }
    };
}
```

å“å‘€ï¼Œpop å¿…é¡»è¿”å›ä¸€ä¸ªå€¼ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰è¿™æ ·åšã€‚ æˆ‘ä»¬å¯ä»¥ return Noneï¼Œä½†åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿”å› unimplemented!()ï¼Œ ä»¥æŒ‡ç¤ºæˆ‘ä»¬è¿˜æ²¡æœ‰å®Œæˆè¯¥å‡½æ•°çš„å®ç°ã€‚unimplemented!() æ˜¯ä¸€ä¸ªå® ï¼ˆï¼ è¡¨ç¤ºå®ï¼‰ï¼Œå½“æˆ‘ä»¬åˆ°è¾¾å®ƒæ—¶ï¼Œå®ƒä¼šä½¿ç¨‹åº panic ï¼ˆ~ä»¥å—æ§æ–¹å¼å´©æºƒå®ƒï¼‰ã€‚

```
> cargo build

error[E0507]: cannot move out of borrowed content
  --> src/first.rs:28:15
   |
28 |         match self.head {
   |               ^^^^^^^^^
   |               |
   |               cannot move out of borrowed content
   |               help: consider borrowing here: `&self.head`
...
32 |             Link::More(node) => {
   |                        ---- data moved here
   |
note: move occurs because `node` has type `std::boxed::Box<first::Node>`, which does not implement the `Copy` trait
  --> src/first.rs:32:24
   |
32 |             Link::More(node) => {
   |                        ^^^^

```

Rust è¯´æˆ‘ä»¬åº”è¯¥æ·»åŠ å¯¹Â `match`Â çš„å¼•ç”¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ğŸ¤· â™€ï¸ è®©æˆ‘ä»¬è¯•ä¸€è¯•ï¼š
ç¼–å†™é€»è¾‘
```rust
pub fn pop(&mut self) -> Option<i32> {
    let result;
    match &self.head {
        Link::Empty => {
            result = None;
        }
        Link::More(node) => {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
```

```
> cargo build
   Compiling lists v0.1.0 (/Users/ADesires/dev/temp/lists)
error[E0507]: cannot move out of borrowed content
  --> src/first.rs:35:29
   |
35 |                 self.head = node.next;
   |                             ^^^^^^^^^ cannot move out of borrowed content

```
å½“æˆ‘ä»¬æ‰€æ‹¥æœ‰çš„åªæ˜¯å¯¹ node çš„å…±äº«å¼•ç”¨æ—¶ï¼Œæˆ‘ä»¬æ­£è¯•å›¾ç§»å‡ºÂ `node`ã€‚










æ¥å§ Rustï¼Œä»æˆ‘ä»¬çš„èƒŒä¸Šä¸‹æ¥ï¼ä¸€å¦‚æ—¢å¾€ï¼ŒRust å¯¹æˆ‘ä»¬å¾ˆç”Ÿæ°”ã€‚å€¼å¾—åº†å¹¸çš„æ˜¯ï¼Œè¿™ä¸€æ¬¡å®ƒä¹Ÿç»™äº†æˆ‘ä»¬å®Œæ•´çš„ç‹¬å®¶æ–°é—»ï¼é»˜è®¤æƒ…å†µä¸‹ï¼Œæ¨¡å¼åŒ¹é…å°†å°è¯•å°†å…¶å†…å®¹ç§»åŠ¨åˆ°æ–°åˆ†æ”¯ä¸­ï¼Œä½†æˆ‘ä»¬ä¸èƒ½è¿™æ ·åšï¼Œå› ä¸ºæˆ‘ä»¬åœ¨è¿™é‡Œæ²¡æœ‰ self by-valueã€‚
æˆ‘ä»¬å¯èƒ½åº”è¯¥é€€åä¸€æ­¥ï¼Œæƒ³æƒ³æˆ‘ä»¬æ­£åœ¨åŠªåŠ›åšä»€ä¹ˆã€‚æˆ‘ä»¬å¸Œæœ›ï¼š

- Check if the list is empty.  
    æ£€æŸ¥åˆ—è¡¨æ˜¯å¦ä¸ºç©ºã€‚
- If it's empty, just return None  
    å¦‚æœä¸ºç©ºï¼Œåˆ™è¿”å› None
- If it'sÂ _not_Â empty  
    å¦‚æœå®ƒ_ä¸_ä¸ºç©º
    - remove the head of the list  
        åˆ é™¤åˆ—è¡¨çš„å¤´éƒ¨
    - remove itsÂ `elem`Â Â åˆ é™¤å…¶Â `elem`
    - replace the list's head with itsÂ `next`  
        å°†åˆ—è¡¨çš„ head æ›¿æ¢ä¸ºÂ `next`
    - returnÂ `Some(elem)`  
        è¿”å›Â `Someï¼ˆelemï¼‰`






å…³é”®çš„è§è§£æ˜¯æˆ‘ä»¬æƒ³_åˆ é™¤_ä¸€äº›ä¸œè¥¿ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬æƒ³_æŒ‰å€¼_è·å–åˆ—è¡¨çš„å¤´éƒ¨ã€‚æˆ‘ä»¬å½“ç„¶ä¸èƒ½é€šè¿‡æˆ‘ä»¬é€šè¿‡Â `&self.head`Â è·å–çš„å…±äº«å¼•ç”¨æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬ä¹Ÿ â€œåªâ€ æœ‰ä¸€ä¸ªå¯¹Â `self`Â çš„å¯å˜å¼•ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å”¯ä¸€èƒ½ç§»åŠ¨ä¸œè¥¿çš„æ–¹æ³•æ˜¯_æ›¿æ¢å®ƒ_Â ã€‚ï¼
```rust
pub fn pop(&mut self) -> Option<i32> {
    let result;
    match mem::replace(&mut self.head, Link::Empty) {
        Link::Empty => {
            result = None;
        }
        Link::More(node) => {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
		}
```

å®é™…ä¸Šï¼Œæˆ‘å°†åœ¨è¿™é‡Œåº”ç”¨æˆ‘è‡ªå·±çš„ä¸ªäºº lintï¼šæˆ‘ä»¬åšå‡ºäº†è¿™ä¸ª`result`Â value è¿”å›ï¼Œä½†å®é™…ä¸Šæˆ‘ä»¬æ ¹æœ¬ä¸éœ€è¦è¿™æ ·åšï¼å°±åƒä¸€ä¸ª function è®¡ç®—ç»“æœä¸ºæœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œåˆ™æ¯ä¸ªå—çš„è®¡ç®—ç»“æœä¹Ÿä¼šä¸º å®ƒçš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚é€šå¸¸æˆ‘ä»¬ç”¨åˆ†å·æ¥æŠ‘åˆ¶è¿™ç§è¡Œä¸ºï¼Œ è¿™ä¼šä½¿å—è®¡ç®—ä¸ºç©ºå…ƒç»„Â `ï¼ˆï¼‰ã€‚`Â è¿™æ˜¯ å®é™…ä¸Šæ˜¯ä¸å£°æ˜è¿”å›å€¼çš„å‡½æ•°çš„å€¼ â€”â€” æ¯”å¦‚Â `push`Â -- è¿”å›ã€‚
å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†Â `pop`Â å†™æˆï¼š
```rust
pub fn pop(&mut self) -> Option<i32> {
    match mem::replace(&mut self.head, Link::Empty) {
        Link::Empty => None,
        Link::More(node) => {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
```
è¿™æ›´ç®€æ´ã€æ›´åœ°é“ã€‚è¯·æ³¨æ„ï¼ŒLinkï¼šï¼šEmpty åˆ†æ”¯å®Œå…¨ä¸¢å¤±äº†å¤§æ‹¬å·ï¼Œå› ä¸ºæˆ‘ä»¬åªæœ‰ä¸€ä¸ªè¡¨è¾¾å¼è¦è®¡ç®—ã€‚åªæ˜¯ç®€å•æƒ…å†µçš„ä¸€ä¸ªå¾ˆå¥½çš„ç®€å†™ã€‚
```rust
cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s

```