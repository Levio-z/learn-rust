试试
```rust
pub struct Iter<T> {
    next: Option<&Node<T>>,
}

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter { next: self.head.map(|node| &node) }
    }
}

impl<T> Iterator for Iter<T> {
    type Item = &T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.map(|node| &node);
            &node.elem
        })
    }
}

```

让我们尝试一些新的东西：看到`那个错误[E0106]` 了吗？这是编译器错误代码。我们可以要求 rustc 用 `--`explain 来解释这些：

```rust
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

// 这里无需生命周期，因为 List 没有使用生命周期的关联项
impl<T> List<T> {
    // 这里我们为 `iter` 声明一个生命周期 'a , 此时 `&self` 需要至少和 `Iter` 活得一样久
    pub fn iter<'a>(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.map(|node| &node) }
    }
}

// 这里声明生命周期是因为下面的关联类型 Item 需要
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    // 这里无需更改，因为上面已经处理了.
    // Self 依然是这么棒
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.map(|node| &node);
            &node.elem
        })
    }
}

```

这么看，生命周期的问题解决了，但是又引入了新的错误。原因在于，我们希望存储 `&Node` 但是获取的却是 `&Box<Node>`。嗯，小问题，解引用搞定：
```rust
impl<T> List<T> {
    pub fn iter<'a>(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.map(|node| &*node) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.map(|node| &*node);
            &node.elem
        })
    }
}

```
大家还记得之前章节的内容吗？原因是这里我们忘记了 `as_ref` ，然后值的所有权被转移到了 `map` 中，结果我们在内部引用了一个局部值，造成一个悬垂引用：
```rust
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<T> List<T> {
    pub fn iter<'a>(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.as_ref().map(|node| &*node) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &*node);
            &node.elem
        })
    }
}

```
使用asref
```rust
pub struct Iter<'a,T> {

    next: Option<&'a Node<T>>,

}

  

// 这里无需生命周期，因为 List 没有使用生命周期的关联项

impl<T> List<T> {

  

    // 这里我们为 `iter` 声明一个生命周期 'a , 此时 `&self` 需要至少和 `Iter` 活得一样久

    pub fn iter<'a>(&'a self) -> Iter<'a,T> {

        Iter { next: self.head.as_ref().map(|node| &**node) }

    }

}

  

// 这里声明生命周期是因为下面的关联类型 Item 需要

impl<'a,T> Iterator for Iter<'a,T> {

    type Item = &'a T;

  

    fn next(&mut self) -> Option<Self::Item> {

        self.next.map(|node| {

            self.next = node.next.as_ref().map(|node| &**node);

            &node.elem

        })

    }

	}

```
as_deref 和 as_deref_mut 函数从 Rust 1.40 开始是稳定的。在此之前，您需要执行 `map（|node| &**node）` 和 `map（|node| &mut**node）。` 你可能会想“哇 `，那个东西`真的很卡顿”，你没有错，但就像美酒一样，Rust 会随着时间的推移而变得更好，我们不再需要这样做。通常 Rust 非常擅长通过称为 _deref 强制_的过程隐式地进行这种转换，基本上它可以在整个代码中插入 * 以使其进行类型检查。它可以做到这一点，因为我们有借用检查器来确保我们永远不会弄乱指针！

但在这种情况下，闭包与我们有一个 `Option<&T>` 而不是 `&T` 的事实相结合，有点太复杂了，无法解决，所以我们需要通过显式来帮助它。值得庆幸的是，根据我的经验，这种情况非常罕见。