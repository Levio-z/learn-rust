集合在 Rust 中使用 _Iterator_ 特征进行迭代。它比 `Drop` 复杂一点：
```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

这里的新来者是type Item 。这是声明迭代器的每个实现都有一个名为 Item 的_关联类型_ 。在这种情况下，这是您next调用时它可以吐出的类型。

迭代器产生 Option<Self：：Item> 的原因是该接口合并了 has_next 和 get_next 概念。当你有下一个值时，  Some（value）， 当你不这样做时，你会产生 None。这使得 API 通常更符合人体工程学，使用和实现更安全，同时避免 has_next 和 get_next 之间的冗余检查和逻辑。好！
- IntoIter - `T`
- IterMut - `&mut T`  
    IterMut - `&T`
- Iter - `&T`

实际上，我们已经拥有了使用 List 的接口实现 IntoIter 的所有工具：只需一遍又一遍地调用 `pop`。因此，我们将 IntoIter 实现为 List 周围的 newtype 包装器：
```rust
// Tuple structs are an alternative form of struct,

// useful for trivial wrappers around other types.

pub struct IntoIter<T>(List<T>);

  

impl<T> List<T> {

    pub fn into_iter(self) -> IntoIter<T> {

        IntoIter(self)

    }

}

  

impl<T> Iterator for IntoIter<T> {

    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {

        // access fields of a tuple struct numerically

        self.0.pop()

    }

}
```
让我们写一个测试：
```rust
#[test]
fn into_iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), None);
}

```