上次我们甚至懒得实施的一件事就是偷看。让我们继续这样做。我们需要做的就是返回对列表头部元素的引用（如果存在）。听起来很容易，让我们试试：
```rust
    pub fn peek(&self) -> Option<&T>{

        self.head.map(

            |node|{

                &node.elem

            }

        )

    }
```
Map 按值取 `self`，这会将 Option 移出它所在的事物。以前这很好，因为我们刚刚`把它拿出来` ，但现在我们实际上想把它留在原处。处理此问题的_正确_方法是使用 `as_ref` Option 上的方法，其定义如下：

```rust
error[E0515]: cannot return reference to local data `node.elem`
  --> src/second.rs:41:17
   |
41 |                 &node.elem
   |                 ^^^^^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of `self.head` which is behind a shared reference
  --> src/second.rs:39:9
   |
39 |           self.head.map(
   |  _________^^^^^^^^^_-
   | |         |
   | |         help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents
   | |         move occurs because `self.head` has type `Option<Box<second::Node<T>>>`, which does not implement the `Copy` trait
40 | |             |node|{
41 | |                 &node.elem
42 | |             }
43 | |         )
   | |_________- `self.head` moved due to this method call
```
**本质上都是因为在只持有不可变借用（`&self`）的情况下，试图**：
1. **移动（move）`Option<Box<Node<T>>>` 的所有权**
2. **返回对局部临时变量的引用**

Map 按值取 `self`，这会将 Option 移出它所在的事物。以前这很好，因为我们刚刚`把它拿出来` ，但现在我们实际上想把它留在原处。处理此问题的_正确_方法是使用 `as_ref` Option 上的方法，其定义如
```
impl<T> Option<T> { pub fn as_ref(&self) -> Option<&T>; }
```
- `Option<T>` 通过 `.as_ref()` 被**降级**为 `Option<&T>`；
- 你**本可以用 match 自己拆解和借用**，但这么做啰嗦；
- 虽然借用了 `Box<Node<T>>` 之后访问内部字段会增加“间接性”；
- 但 Rust 的 `.` 运算符 **自动帮你做了解引用**，所以写起来仍然很简洁。
```rust
pub fn peek(&self) -> Option<&T> {
    self.head.as_ref().map(|node| {
        &node.elem
    })
}
```

```
cargo build

    Finished dev [unoptimized + debuginfo] target(s) in 0.32s

```

我们还可以使用`以下方法`制作此方法的_可变_版本 as_mut：
```
    pub fn peek_mut(&mut self) -> Option<&mut T> {

        self.head.as_mut().map(|node| &mut node.elem)

    }
```
这很好，但我们并没有真正测试是否可以改变 `peek_mut` 返回值，不是吗？如果一个引用是可变的，但没有人对其进行变异，我们真的测试了可变性吗？让我们尝试在这个 `Option<&mut T>` 上使用 `map` 来放置一个深刻的值：

```rust
        list.peek_mut().map(|&mut mut value| {

            value = 42

        });
```

你写了一个闭包参数：`|&mut value|`，你以为这样写能让闭包参数是可变引用 `&mut i32`，然后直接修改它；  
但实际上，这个模式会 **解构这个可变引用**，得到 `value: i32`，即是 `i32` 的一个拷贝（如果类型实现了 `Copy`），你改动的是拷贝而非原值。
实际上改变头部：
```
    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&3));
        assert_eq!(list.peek_mut(), Some(&mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&42));
        assert_eq!(list.pop(), Some(42));
    }

```