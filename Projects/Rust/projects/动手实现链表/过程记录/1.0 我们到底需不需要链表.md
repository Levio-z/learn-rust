
### 链表的场景

- 大量的拆分和合并
- 无锁并发
- 内核，想要使用一个侵入性列表
- 你使用的是纯函数式语言，有限的语义和没有 mutation 使链表更容易使用
- 热点代码
但是所有这些情况对于编写 Rust 程序的人来说都是_非常罕见_的。99% 的时间你应该只使用 Vec （数组堆栈），而另外 99% 的时间你应该使用 VecDeque （数组 deque）。对于大多数工作负载来说，这些数据结构非常优越，因为它们的分配频率较低、内存开销较低、真正的随机访问和缓存局部性。

作为一个社区，我们都应该对链表作为 “标准” 数据结构说_不_ 。这是一个很好的数据结构，有几个很棒的用例，但这些用例是_例外_的，并不常见。

#### 性能并不总是很重要

非热点代码，如果性能无关紧要，那么应用数组的自然默认值_肯定_是可以的。
#### 链表有 O(1) 的分割、合并、插入、移除性能

| 条件                    | 数据结构推荐                     |
| --------------------- | -------------------------- |
| 操作集中在末尾 / 随机访问多       | `Vec<T>` ✅                 |
| 双端 push/pop，低频中间操作    | `VecDeque<T>` ✅            |
| 需要 O(1) 分割、拼接，并且节点持久化 | 自定义链表（可能 unsafe）✅          |
| 需要插入删除频繁且节点地址不能失效     | intrusive list（需手动管理生命周期）✅ |
| 非热点路径、初始化逻辑           | 用什么都无所谓；优先选易读性好的 ✅         |
|                       |                            |
**工作负载主要分割、合并为主体**，否则由于缓存效应和代码复杂性而_每隔一个_作都会受到惩罚，这将抵消任何理论上的收益。
#### 内存重新分配

`Vec` 当 [`capacity`](https://practice-zh.course.rs/collections/vector.html#capacity) 不够时，会重新分配一块内存，然后将之前的 `Vec` 全部拷贝过去
- 可以预测负载，`Vec::with_capacity` 提前分配足够的空间即可
- 如果您无法预测负载，那么在最坏的情况下可以节省延迟！
**无法预测负载，延迟敏感**
#### 链表更节省内存

增加或减少数组的长度使数组最多有一半为空，例如 capacity 增长是翻倍的策略。这确实会导致内存空间的浪费

而且链表实际上也有内存浪费，例如链表中的每个元素都会占用额外的内存：单向链表浪费一个指针，双向链表浪费两个指针。

- 如果你的链表中每个元素都很大，那相对来说，这种浪费也微不足道，但是如果链表的元素较小且数量很多呢？那浪费的空间就相当可观了！

内存分配器有关( allocator )：对链表节点的分配和回收会经常发生，这样就不会浪费内存。链表的元素较大，你也无法预测数组的空间，同时还有一个不错的内存分配器，那链表确实可以节省空间。

**大块元素，不确定大小，且频繁插入/删除**
#### 函数语言

伟大！链表在函数式语言中使用起来非常优雅，因为你可以在没有任何变化的情况下作它们，可以递归地描述它们，并且由于懒惰的魔力，还可以处理无限列表。
- 函数式语言鼓励“数据不可变”，而链表的结构非常契合不可变范式：
- 递归定义天然适合链表结构
	- 正好适配函数式语言中的递归处理思维方式
- 懒惰求值支持无限列表
	- 链表 + 惰性求值 = 无限数据结构，例如：


缺点
- **遍历成本高**（cache miss 明显）
- **无随机访问能力**
- **频繁分配（如果不使用内存池）**
- **指针操作易错，尤其在多线程或异步中**

Rust 的选择是：**除非你真的需要“节点解耦”或“持久引用”，否则用 `Vec`、`VecDeque`、`Box<[T]>`，甚至 `Iterator`。**


不可变语义下，链表确实是最合适的结构之一
#### 并发
链表支撑无锁并发
#### 侵入性
[侵入式链表](../ChatGPT/侵入式链表.md)
# 收获
# 拓展&计划
- 问题
- todo
