特别细心的读者可能已经注意到，我们实际上重新发明了一个非常糟糕的 Option 版本：
```
enum Link {
    Empty,
    More(Box<Node>),
}
```
`Link` 实际上只是 `Option<Box<Node>>` 的别名。这样做的好处是避免了在代码中频繁书写冗长的 `Option<Box<Node>>`，尤其是在这个结构未对外暴露时，与 `pop` 不同，封装起来是可以接受的。不过，`Option` 本身提供了许多非常实用的方法，而我们此前却手动实现了这些逻辑。为了简化代码并提升可读性，我们应该直接使用 `Option` 的功能。首先，我们可以通过直接将原来的 `Link::Empty` 和 `Link::More` 重命名为 `None` 和 `Some(...)` 来进行初步替换。


首先，`mem::replace(&mut option, None)` 是一个非常常见的用法，频繁程度之高，以至于 `Option` 类型干脆直接为它提供了一个专门的方法：`take`。

其次， `match option { None => None, Some(x) => Some(y) }` 是一个非常常见的成语，因此它被称为 `map`。`map` 接受一个函数在 `Some（x）` 中的 `x` 上执行，以生成 `Some（y）` 中的 `y`。我们可以编写一个合适的 `fn` 并将其传递给 `map`，但我们更愿意编写_内联_做什么。

做到这一点的方法是使用 _closure_。**闭包是具有额外超能力的匿名函数：它们可以引用闭包_之外_的局部变量**！这使得它们对于执行各种条件逻辑非常有用。我们唯一进行`匹配`的地方是在 `pop` 中，所以让我们重写一下：
```rust
pub fn pop(&mut self) -> Option<i32> {
    self.head.take().map(|node| {
        self.head = node.next;
        node.elem
    })
}
```
啊，好多了。让我们确保我们没有破坏任何东西：
```rust
> cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured


```