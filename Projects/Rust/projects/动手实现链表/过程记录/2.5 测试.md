通常，我们尝试将测试放在 Rust 社区中正在测试的代码旁边。但是，我们通常会为测试创建一个新的命名空间，以避免与 “真实” 代码冲突。正如我们使用 `mod` 来指定 `first.rs` 应该包含在 `lib.rs` 中，我们可以使用 `mod` 基本上内联创建一个_全新的文件：
```rust
// in first.rs

mod test {
    #[test]
    fn basics() {
        // TODO
    }
}
```

是的，我们的无所作为测试通过了！让我们让它不是什么都不做。我们将使用 `assert_eq！` 宏来执行此作。这并不是什么特殊的测试魔法。它所做的只是比较你给它的两件事，如果它们不匹配，程序就会恐慌。是的，你吓坏了，表明测试工具失败了！
```rust
mod test {
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}

```
哎呀！因为我们做了一个新的模块，所以我们需要显式地拉取 List 来使用它。
```rust
mod test {
    use super::List;
    // everything else the same
}
```


```
warning: unused import: `super::List`
  --> src/first.rs:45:9
   |
45 |     use super::List;
   |         ^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: `lists` (lib) generated 1 warning (run `cargo fix --lib -p lists` to apply 1 suggestion)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.11s
     Running unittests src/lib.rs (/home/l/projects/too-many-linked-lists/target/debug/deps/lists-b3c8f875bb536ccd)
```
...但仅限于测试时！为了安抚编译器（并对我们的消费者友好），我们应该指出整个`测试`模块只有在我们运行测试时才应该被编译。
```rust
#[cfg(test)]
mod test {
    use super::List;
    // 其它代码保持不变
}
```