### 数据布局
双向链表意味着每一个节点将同时指向前一个和下一个节点，因此我们的数据结构可能会变成这样：
```
use std::rc::Rc;
use std::cell::RefCell;

pub struct List<T> {
    head: Link<T>,
    tail: Link<T>,
}

type Link<T> = Option<Rc<RefCell<Node<T>>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
    prev: Link<T>,
}
```
### 构建
```
impl<T> Node<T> {
    fn new(elem: T) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }
}
```
### Push
很好，再来向链表的头部推入一个元素。由于双向链表的数据结构和操作逻辑明显更加复杂，因此相比单向链表的单行实现，双向链表的 `push` 操作也要复杂的多。

除此之外，我们还需要处理一些关于空链表的边界问题：对于绝大部分操作而言，可能只需要使用 `head` 或 `tail` 指针，但是对于空链表，则需要同时使用它们。

一个验证方法 `methods` 是否有效的办法就是看它是否能保持不变性, 每个节点都应该有两个指针指向它: 中间的节点被它前后的节点所指向，而头部的节点除了被它后面的节点所指向外，还会被链表本身所指向，尾部的节点亦是如此。

```
pub fn push_front(&mut self, elem: T) {
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) => {
            // 非空链表，将新的节点跟老的头部相链接
            old_head.prev = Some(new_head.clone()); 
            new_head.next = Some(old_head);         
            self.head = Some(new_head);      
        }
        None => {
            // 空链表，需要设置 tail 和 head
            self.tail = Some(new_head.clone());
            self.head = Some(new_head); 
        }
    }
}
```
> cargo build

从报错来看，我们无法直接去访问 `prev` 和 `next`，回想一下 `RefCell` 的使用方式，修改代码如下:
```
pub fn push_front(&mut self,elem: T){

        let new_head = Node::new(elem);

        match self.head.take(){

            Some(old_head) =>{

                old_head.borrow_mut().prev = Some(new_head.clone());

                new_head.borrow_mut().next = Some(old_head);

                self.head = Some(new_head);

            }

            None =>{

                self.tail = Some(new_head.clone());

                self.head = Some(new_head);

            }

        }

    }
```

### pop
如果说 `new` 和 `push` 是在构建链表，那 `pop` 显然就是一个破坏者。

何为完美的破坏？按照构建的过程逆着来一遍就是完美的！



```
// 原始代码
Rc::try_unwrap(old_head).unwrap().into_inner().elem

// 报错信息解释：
// error[E0599]: no method named `unwrap` found for type `Result<RefCell<Node<T>>, Rc<RefCell<Node<T>>>>`
// 这是因为 Result<T, E> 中的 Err 变体 Rc<RefCell<Node<T>>> 没有实现 Debug，而 unwrap() 会在出错时报出 debug 信息
// 所以 T 和 E 都必须实现 Debug，才能使用 unwrap()

// 解决方案一：为 Node<T> 实现 Debug
// impl<T: std::fmt::Debug> Debug for Node<T> { ... } 或 derive(Debug)

// 解决方案二：用 ok()
Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem

// 解释：
// Rc::try_unwrap() 返回 Result<T, Rc<T>>
// .ok() 把 Result 转换为 Option<T>：
//   - Ok(val) -> Some(val)
//   - Err(_)  -> None (忽略了 Err 中的 Rc)
// 因为 Option::unwrap() 不需要 T: Debug，所以可以通过

// 推荐更安全的写法：
let node = Rc::try_unwrap(old_head)
    .unwrap_or_else(|rc| panic!("Multiple references exist: {:?}", rc.as_ptr()))
    .into_inner();
```



### 知识点
- 使用into_inner(self)来拿走 `RefCell<T>` 的所有权
- 使用Rc::try_unwrap(old_head)来拿走Rc的所有权