### [IntoIter](https://course.rs/too-many-lists/deque/iterator.html#intoiter)
由于是转移所有权，因此 `IntoIter` 一直都是最好实现的:
```rust
pub struct IntoIter<T>(List<T>);

  

impl<T> List<T> {

    pub fn into_iter(self) -> IntoIter<T> {

        IntoIter(self)

    }

}

impl<T> Iterator for IntoIter<T> {

    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {

        self.0.pop_front()

    }

}
```
但是关于双向链表，有一个有趣的事实，它不仅可以从前向后迭代，还能反过来。前面实现的是传统的从前到后，那问题来了，反过来该如何实现呢？

答案是: `DoubleEndedIterator`，它继承自 `Iterator`( 通过 [`supertrait`](https://course.rs/basic/trait/advance-trait.html?highlight=supertrait#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F) )，因此意味着要实现该特征，首先需要实现 `Iterator`。

这样只要为 `DoubleEndedIterator` 实现 `next_back` 方法，就可以支持双向迭代了: `Iterator` 的 `next` 方法从前往后，而 `next_back` 从后向前。
```rust
impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<T> {
        self.0.pop_back()
    }
}
```

测试下:
```rust
#[test]
fn into_iter() {
    let mut list = List::new();
    list.push_front(1); list.push_front(2); list.push_front(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next_back(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next_back(), None);
    assert_eq!(iter.next(), None);
}

```

### [Iter](https://course.rs/too-many-lists/deque/iterator.html#iter)

```rust
```rust
pub struct Iter<'a, T>(Option<Ref<'a, Node<T>>>);

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter(self.head.as_ref().map(|head| head.borrow()))
    }
}
```

迄今为止一切运行正常，接下来的 `next` 实现起来会有些麻烦:
```rust
impl<'a, T> Iterator for Iter<'a, T> {

    type Item = Ref<'a, T>;

    fn next(&mut self) -> Option<Self::Item> {

        self.0.take().map(|node_ref| {

            self.0 = node_ref.next.as_ref().map(|head| head.borrow());

            Ref::map(node_ref, |node| &node.elem)

        })

    }

}
```

```rust
error[E0597]: `node_ref` does not live long enough
   --> src/fourth.rs:253:22
    |
251 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- lifetime `'1` appears in the type of `self`
252 |         self.0.take().map(|node_ref| {
    |                            -------- binding `node_ref` declared here
253 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |                      ^^^^^^^^                          ------------- returning this value requires that `node_ref` is borrowed for `'1`
    |                      |
    |                      borrowed value does not live long enough
254 |             Ref::map(node_ref, |node| &node.elem)
255 |         })
    |         - `node_ref` dropped here while still borrowed

error[E0505]: cannot move out of `node_ref` because it is borrowed
   --> src/fourth.rs:254:22
    |
251 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- lifetime `'1` appears in the type of `self`
252 |         self.0.take().map(|node_ref| {
    |                            -------- binding `node_ref` declared here
253 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |                      --------                          ------------- returning this value requires that `node_ref` is borrowed for `'1`
    |                      |
    |                      borrow of `node_ref` occurs here
254 |             Ref::map(node_ref, |node| &node.elem)
    |                      ^^^^^^^^ move out of `node_ref` occurs here

Some errors have detailed explanations: E0505, E0597.
For more information about an error, try `rustc --explain E0505`.
error: could not compile `lists` (lib) due to 2 previous errors
```
- 这里 `head.borrow()` 返回一个 `Ref<Node<T>>`。
- 它的生命周期由 `head` 决定，但你把它存在 `self.0` 里，要求它活到下一次调用 `next`。
- 然而：`head.borrow()` 返回的 `Ref` **依赖于 `node_ref` 还活着**（因为 `next` 字段来自 `node_ref` 的内部）。
- 但是 `node_ref` 在这个闭包结束时会被 drop → 借用令牌丢失 → 生命周期不够长 → 编译器报 `does not live long enough`。



-  `Ref::map` 需要 **消费掉** `node_ref`，并产生一个新的 `Ref`。
- 但是你在上一行已经对 `node_ref.next` 做了借用（`node_ref` 还没 drop），所以编译器说：“你不能 move 一个仍然被借用的值”。



`node_ref` 活得不够久，跟一般的引用不同，Rust 不允许我们这样分割 `Ref`，从 `head.borrow()` 中取出的 `Ref` 只允许跟 `node_ref` 活得一样久。


而我们想要的函数是存在的:
```rust
pub fn map_split<U, V, F>(orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>) where F: FnOnce(&T) -> (&U, &V), U: ?Sized, V: ?Sized,
```
喔，这个函数定义的泛型直接晃瞎了我的眼睛。。
```rust
impl<'a, T> Iterator for Iter<'a, T> {

    type Item = Ref<'a, T>;

    fn next(&mut self) -> Option<Self::Item> {

        self.0.take().map(|node_ref| {

            let (next, elem) = Ref::map_split(node_ref, |node| (&node.next, &node.elem));

  
			
            self.0 = next.as_ref().map(|head| head.borrow());

  

            elem

        })

    }

}
```

```rust
error[E0597]: `next` does not live long enough
   --> src/fourth.rs:255:22
    |
251 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- lifetime `'1` appears in the type of `self`
252 |         self.0.take().map(|node_ref| {
253 |             let (next, elem) = Ref::map_split(node_ref, |node| (&node.next, &node.elem));
    |                  ---- binding `next` declared here
254 |
255 |             self.0 = next.as_ref().map(|head| head.borrow());
    |                      ^^^^                     ------------- returning this value requires that `next` is borrowed for `'1`
    |                      |
    |                      borrowed value does not live long enough
...
258 |         })
    |         - `next` dropped here while still borrowed

For more information about this error, try `rustc --explain E0597`.
```

- error[E0597]: `next` does not live long enough
	- 这说明 **变量 `next` 的生命周期太短**，不足以满足 `self.0` 的需求。
- lifetime `'1` appears in the type of `self`
	- **`self` 的生命周期是 `'1`**。
	- 凡是你放进 `self.0` 里的东西，都必须至少活到 `'1`。
	- **迭代器内部状态（self.0）必须绑定到迭代器本身的生命周期**。
-  ---- binding `next` declared here
	- `next` 是从 `node_ref` 拆出来的。
	- 但是注意：**`Ref::map_split` 出来的两个 Ref（next, elem）生命周期都不能超过原始的 `node_ref`**。
	- 原因：`Ref::map_split` 只是对 `Ref` 做“子借用”，并没有独立的借用令牌。它们依赖 `node_ref` 的存在。
- `self.0` 的生命周期 = `'1`
	- 你把 `next` 放进去，相当于告诉编译器：
	- “嘿，`next` 的借用足够长，可以活到 `'1`”。
	- 但是 `next` 实际上只活到 **闭包结束**。
	- 所以编译器拒绝：“你需要 `'1`，但 `next` 只有临时生命周期”。
-  - `next` dropped here while still borrowed
	- 最后点明：闭包结束时，`next` 被 drop。  
	- 但是 `self.0` 还想继续用 `next`。 → **悬垂引用风险**。

额，借用的内容只允许在闭包体中使用，看起来我们还是得用 `Ref::map` 来解决问题:
```rust
impl<'a, T> Iterator for Iter<'a, T> {

    type Item = Ref<'a, T>;

    fn next(&mut self) -> Option<Self::Item> {

        self.0.take().map(|node_ref| {

            let (next, elem) = Ref::map_split(node_ref, |node| (&node.next, &node.elem));

  

            self.0 = if next.is_some() {

                Some(Ref::map(next, |next| &**next.as_ref().unwrap()))

            } else {

                None

            };

  

            elem

        })

    }

}
```


```rust
error[E0308]: mismatched types
   --> src/fourth.rs:256:22
    |
256 |                 Some(Ref::map(next, |next| &**next.as_ref().unwrap()))
    |                 ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ref<'_, Node<T>>`, found `Ref<'_, RefCell<Node<T>>>`
    |                 |
    |                 arguments to this enum variant are incorrect
    |
    = note: expected struct `Ref<'_, fourth::Node<_>>`
               found struct `Ref<'_, RefCell<fourth::Node<_>>>`
help: the type constructed contains `Ref<'_, RefCell<fourth::Node<T>>>` due to the type of the argument passed
   --> src/fourth.rs:256:17
    |
256 |                 Some(Ref::map(next, |next| &**next.as_ref().unwrap()))
    |                 ^^^^^------------------------------------------------^
    |                      |
    |                      this argument influences the type of `Some`
note: tuple variant defined here
   --> /home/l/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:601:5
    |
601 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

For more information about this error, try `rustc --explain E0308`.
```



- `Some(...)` 的内部值类型不匹配，所以整个 `Option` 类型也不对。

- `next` 是 `Option<Rc<RefCell<Node<T>>>>`
- `next.as_ref()` → `Option<&Rc<RefCell<Node<T>>>>`
- `unwrap()` → `&Rc<RefCell<Node<T>>>`
- `**` → `RefCell<Node<T>>`
- `&` → `&RefCell<Node<T>>`
- 所以闭包返回的是 **`&RefCell<Node<T>>`**。  
→ 于是 `Ref::map` 的结果是 `Ref<RefCell<Node<T>>>`，而不是 `Ref<Node<T>>`。



晕, 多了一个 `RefCell` ，随着我们的对链表的逐步深入，`RefCell` 的代码嵌套变成了不可忽视的问题。

看起来我们已经无能为力了，只能试着去摆脱 `RefCell` 了。`Rc` 怎么样？我们完全可以对 `Rc` 进行完整的克隆:

```rust
pub struct Iter<T>(Option<Rc<Node<T>>>);

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter(self.head.as_ref().map(|head| head.clone()))
    }
}

impl<T> Iterator for Iter<T> {
    type Item =

```
在你的 `Iter<T>(Option<Rc<Node<T>>>)` 设计里：
#### 不是 `&T 
- **不是 `&T`**  
    因为 `Iter` 没有生命周期参数 `'a`，Rust 无法保证“这个 `&T` 活多久”。  
    `&T` 只能存在于一个被借用的上下文里，而 `Rc` 是引用计数智能指针，它脱离了借用系统的生命周期追踪。
    
- **也不是 `Ref<T>`**  
    `Ref<T>` 是 `RefCell<T>` 的运行时借用令牌，它必须和一个具体的 `RefCell` 借用绑定生命周期。  
    但是你的 `Iter` 里面已经没有 `RefCell` 的借用，而是持有 `Rc<Node<T>>`，所以 `Ref<T>` 无从谈起。
    

👉 所以结果是：**你的迭代器返回的本质上是某种拥有者类型（`Rc<Node<T>>`），而不是借用类型**。
#### 为什么不能直接变成 `Rc<T>`
把 `Rc<Node<T>>` 变成 `Rc<T>`。  
但 **标准库没有提供 `Rc::map`**，因为这会带来极其微妙的生命周期与析构时机问题：

- `Rc<Node<T>>` 的内存布局并不能安全地被“部分投影”为 `Rc<T>`。
    
- 例如 `Node<T>` 包含多个字段，**`Rc` 无法只针对某一个字段创建独立的引用计数块**。
    
- 这就是为什么你会发现有第三方库（如 `rc::RcExt`) 提供了类似功能，但标准库宁可保守，也不暴露这种“危险 API”。
#### 迭代器幽灵问题

这就是你说的 **迭代器合法性** 崩塌：

- 当 `Iter<'a, T>` 返回 `&'a T` 或 `Ref<'a, T>` 时，编译器/运行时借用检查器可以保证：
    - 在持有迭代器的同时，链表不能被同时修改（比如 `pop`/`push` 会被拒绝）。
- 当 `Iter<T>` 返回 `Rc<Node<T>>` 时：
    - `Rc` 完全绕过了借用检查 → 允许你“持有子链表的某个节点”，同时在链表上做结构性修改。
    - 如果此时 **pop 掉的正好是你持有的 Rc 节点**，那链表的内部状态就和迭代器的 Rc 不再一致了。
    - 如果再调用 `Rc::try_unwrap` 之类的函数去“解包唯一所有权”，程序可能直接 `panic`。
也就是说：
- **有生命周期的迭代器 → 安全，但限制多**。
- **无生命周期、基于 Rc 的迭代器 → 灵活，但可能出现幽灵引用（dangling logical reference）**。


```rust
pub struct Iter<'a, T> {
    next: Option<Ref<'a, Node<T>>>,
}
```

- **借用持续时间太长**
    - 一旦你在迭代器里存了 `Ref<Node<T>>`，就意味着整个迭代器生命周期内，这个 `Node` 永远被借用着。
    - 那么当你尝试迭代到下一个节点时，还要再借用下一个 `Ref<Node<T>>`，结果 runtime 检查会 panic（因为 `RefCell` 检测到“重入借用”）。
- **生命周期难以表达**
    - `Ref` 的生命周期 `'a` 必须和迭代器自身 `'iter` 一致。
    - 这意味着编译器会要求 `Ref` 活得和 `Iter` 一样久，但实际上你只需要它活到 `next()` 调用返回就够了。
    - 这就是经典的 **E0597 (borrow does not live long enough)** 错误。

严格来说，`push` 问题不大，因为链表两端的增长不会对我们正在关注的某个子链表造成影响。

但是 `pop` 就是另一个故事了，如果在我们关注的子链表之外 `pop`, 那问题不大。但是如果是 `pop` 一个正在引用的子链表中的节点呢？那一切就完了，特别是，如果大家还试图去 unwrap `try_unwrap` 返回的 `Result` ，会直接造成整个程序的 `panic`。

仔细想一想，好像也不错，程序一切正常，除非去 `pop` 我们正在引用的节点，最美的是，就算遇到这种情况，程序也会直接崩溃，提示我们错误的发生。

其实我们大部分的努力都是为了实现隐藏的细节和优雅的 API，典型的二八原则，八成时间花在二成的细节上。但是如果不关心这些细节，可以接受自己的平凡的话，那把节点简单的到处传递就行。

总之，可以看出，内部可变性非常适合写一个安全性的应用程序，但是如果是安全性高的库，那内部可变性就有些捉襟见肘了。