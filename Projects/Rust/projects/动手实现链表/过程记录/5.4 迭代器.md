### [IntoIter](https://course.rs/too-many-lists/deque/iterator.html#intoiter)
ç”±äºæ˜¯è½¬ç§»æ‰€æœ‰æƒï¼Œå› æ­¤Â `IntoIter`Â ä¸€ç›´éƒ½æ˜¯æœ€å¥½å®ç°çš„:
```rust
pub struct IntoIter<T>(List<T>);

  

impl<T> List<T> {

Â  Â  pub fn into_iter(self) -> IntoIter<T> {

Â  Â  Â  Â  IntoIter(self)

Â  Â  }

}

impl<T> Iterator for IntoIter<T> {

Â  Â  type Item = T;

Â  Â  fn next(&mut self) -> Option<Self::Item> {

Â  Â  Â  Â  self.0.pop_front()

Â  Â  }

}
```
ä½†æ˜¯å…³äºåŒå‘é“¾è¡¨ï¼Œæœ‰ä¸€ä¸ªæœ‰è¶£çš„äº‹å®ï¼Œå®ƒä¸ä»…å¯ä»¥ä»å‰å‘åè¿­ä»£ï¼Œè¿˜èƒ½åè¿‡æ¥ã€‚å‰é¢å®ç°çš„æ˜¯ä¼ ç»Ÿçš„ä»å‰åˆ°åï¼Œé‚£é—®é¢˜æ¥äº†ï¼Œåè¿‡æ¥è¯¥å¦‚ä½•å®ç°å‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯:Â `DoubleEndedIterator`ï¼Œå®ƒç»§æ‰¿è‡ªÂ `Iterator`( é€šè¿‡Â [`supertrait`](https://course.rs/basic/trait/advance-trait.html?highlight=supertrait#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F)Â )ï¼Œå› æ­¤æ„å‘³ç€è¦å®ç°è¯¥ç‰¹å¾ï¼Œé¦–å…ˆéœ€è¦å®ç°Â `Iterator`ã€‚

è¿™æ ·åªè¦ä¸ºÂ `DoubleEndedIterator`Â å®ç°Â `next_back`Â æ–¹æ³•ï¼Œå°±å¯ä»¥æ”¯æŒåŒå‘è¿­ä»£äº†:Â `Iterator`Â çš„Â `next`Â æ–¹æ³•ä»å‰å¾€åï¼Œè€ŒÂ `next_back`Â ä»åå‘å‰ã€‚
```rust
impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<T> {
        self.0.pop_back()
    }
}
```

æµ‹è¯•ä¸‹:
```rust
#[test]
fn into_iter() {
    let mut list = List::new();
    list.push_front(1); list.push_front(2); list.push_front(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next_back(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next_back(), None);
    assert_eq!(iter.next(), None);
}

```

### [Iter](https://course.rs/too-many-lists/deque/iterator.html#iter)

```rust
```rust
pub struct Iter<'a, T>(Option<Ref<'a, Node<T>>>);

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter(self.head.as_ref().map(|head| head.borrow()))
    }
}
```

è¿„ä»Šä¸ºæ­¢ä¸€åˆ‡è¿è¡Œæ­£å¸¸ï¼Œæ¥ä¸‹æ¥çš„Â `next`Â å®ç°èµ·æ¥ä¼šæœ‰äº›éº»çƒ¦:
```rust
impl<'a, T> Iterator for Iter<'a, T> {

Â  Â  type Item = Ref<'a, T>;

Â  Â  fn next(&mut self) -> Option<Self::Item> {

Â  Â  Â  Â  self.0.take().map(|node_ref| {

Â  Â  Â  Â  Â  Â  self.0 = node_ref.next.as_ref().map(|head| head.borrow());

Â  Â  Â  Â  Â  Â  Ref::map(node_ref, |node| &node.elem)

Â  Â  Â  Â  })

Â  Â  }

}
```

```rust
error[E0597]: `node_ref` does not live long enough
   --> src/fourth.rs:253:22
    |
251 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- lifetime `'1` appears in the type of `self`
252 |         self.0.take().map(|node_ref| {
    |                            -------- binding `node_ref` declared here
253 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |                      ^^^^^^^^                          ------------- returning this value requires that `node_ref` is borrowed for `'1`
    |                      |
    |                      borrowed value does not live long enough
254 |             Ref::map(node_ref, |node| &node.elem)
255 |         })
    |         - `node_ref` dropped here while still borrowed

error[E0505]: cannot move out of `node_ref` because it is borrowed
   --> src/fourth.rs:254:22
    |
251 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- lifetime `'1` appears in the type of `self`
252 |         self.0.take().map(|node_ref| {
    |                            -------- binding `node_ref` declared here
253 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |                      --------                          ------------- returning this value requires that `node_ref` is borrowed for `'1`
    |                      |
    |                      borrow of `node_ref` occurs here
254 |             Ref::map(node_ref, |node| &node.elem)
    |                      ^^^^^^^^ move out of `node_ref` occurs here

Some errors have detailed explanations: E0505, E0597.
For more information about an error, try `rustc --explain E0505`.
error: could not compile `lists` (lib) due to 2 previous errors
```
- è¿™é‡Œ `head.borrow()` è¿”å›ä¸€ä¸ª `Ref<Node<T>>`ã€‚
- å®ƒçš„ç”Ÿå‘½å‘¨æœŸç”± `head` å†³å®šï¼Œä½†ä½ æŠŠå®ƒå­˜åœ¨ `self.0` é‡Œï¼Œè¦æ±‚å®ƒæ´»åˆ°ä¸‹ä¸€æ¬¡è°ƒç”¨ `next`ã€‚
- ç„¶è€Œï¼š`head.borrow()` è¿”å›çš„ `Ref` **ä¾èµ–äº `node_ref` è¿˜æ´»ç€**ï¼ˆå› ä¸º `next` å­—æ®µæ¥è‡ª `node_ref` çš„å†…éƒ¨ï¼‰ã€‚
- ä½†æ˜¯ `node_ref` åœ¨è¿™ä¸ªé—­åŒ…ç»“æŸæ—¶ä¼šè¢« drop â†’ å€Ÿç”¨ä»¤ç‰Œä¸¢å¤± â†’ ç”Ÿå‘½å‘¨æœŸä¸å¤Ÿé•¿ â†’ ç¼–è¯‘å™¨æŠ¥ `does not live long enough`ã€‚



-  `Ref::map` éœ€è¦ **æ¶ˆè´¹æ‰** `node_ref`ï¼Œå¹¶äº§ç”Ÿä¸€ä¸ªæ–°çš„ `Ref`ã€‚
- ä½†æ˜¯ä½ åœ¨ä¸Šä¸€è¡Œå·²ç»å¯¹ `node_ref.next` åšäº†å€Ÿç”¨ï¼ˆ`node_ref` è¿˜æ²¡ dropï¼‰ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨è¯´ï¼šâ€œä½ ä¸èƒ½ move ä¸€ä¸ªä»ç„¶è¢«å€Ÿç”¨çš„å€¼â€ã€‚



`node_ref`Â æ´»å¾—ä¸å¤Ÿä¹…ï¼Œè·Ÿä¸€èˆ¬çš„å¼•ç”¨ä¸åŒï¼ŒRust ä¸å…è®¸æˆ‘ä»¬è¿™æ ·åˆ†å‰²Â `Ref`ï¼Œä»Â `head.borrow()`Â ä¸­å–å‡ºçš„Â `Ref`Â åªå…è®¸è·ŸÂ `node_ref`Â æ´»å¾—ä¸€æ ·ä¹…ã€‚


è€Œæˆ‘ä»¬æƒ³è¦çš„å‡½æ•°æ˜¯å­˜åœ¨çš„:
```rust
pub fn map_split<U, V, F>(orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>) where F: FnOnce(&T) -> (&U, &V), U: ?Sized, V: ?Sized,
```
å–”ï¼Œè¿™ä¸ªå‡½æ•°å®šä¹‰çš„æ³›å‹ç›´æ¥æ™ƒçäº†æˆ‘çš„çœ¼ç›ã€‚ã€‚
```rust
impl<'a, T> Iterator for Iter<'a, T> {

Â  Â  type Item = Ref<'a, T>;

Â  Â  fn next(&mut self) -> Option<Self::Item> {

Â  Â  Â  Â  self.0.take().map(|node_ref| {

Â  Â  Â  Â  Â  Â  let (next, elem) = Ref::map_split(node_ref, |node| (&node.next, &node.elem));

  
			
Â  Â  Â  Â  Â  Â  self.0 = next.as_ref().map(|head| head.borrow());

  

Â  Â  Â  Â  Â  Â  elem

Â  Â  Â  Â  })

Â  Â  }

}
```

```rust
error[E0597]: `next` does not live long enough
   --> src/fourth.rs:255:22
    |
251 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- lifetime `'1` appears in the type of `self`
252 |         self.0.take().map(|node_ref| {
253 |             let (next, elem) = Ref::map_split(node_ref, |node| (&node.next, &node.elem));
    |                  ---- binding `next` declared here
254 |
255 |             self.0 = next.as_ref().map(|head| head.borrow());
    |                      ^^^^                     ------------- returning this value requires that `next` is borrowed for `'1`
    |                      |
    |                      borrowed value does not live long enough
...
258 |         })
    |         - `next` dropped here while still borrowed

For more information about this error, try `rustc --explain E0597`.
```

- error[E0597]: `next` does not live long enough
	- è¿™è¯´æ˜ **å˜é‡ `next` çš„ç”Ÿå‘½å‘¨æœŸå¤ªçŸ­**ï¼Œä¸è¶³ä»¥æ»¡è¶³ `self.0` çš„éœ€æ±‚ã€‚
- lifetime `'1` appears in the type of `self`
	- **`self` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `'1`**ã€‚
	- å‡¡æ˜¯ä½ æ”¾è¿› `self.0` é‡Œçš„ä¸œè¥¿ï¼Œéƒ½å¿…é¡»è‡³å°‘æ´»åˆ° `'1`ã€‚
	- **è¿­ä»£å™¨å†…éƒ¨çŠ¶æ€ï¼ˆself.0ï¼‰å¿…é¡»ç»‘å®šåˆ°è¿­ä»£å™¨æœ¬èº«çš„ç”Ÿå‘½å‘¨æœŸ**ã€‚
-  ---- binding `next` declared here
	- `next` æ˜¯ä» `node_ref` æ‹†å‡ºæ¥çš„ã€‚
	- ä½†æ˜¯æ³¨æ„ï¼š**`Ref::map_split` å‡ºæ¥çš„ä¸¤ä¸ª Refï¼ˆnext, elemï¼‰ç”Ÿå‘½å‘¨æœŸéƒ½ä¸èƒ½è¶…è¿‡åŸå§‹çš„ `node_ref`**ã€‚
	- åŸå› ï¼š`Ref::map_split` åªæ˜¯å¯¹ `Ref` åšâ€œå­å€Ÿç”¨â€ï¼Œå¹¶æ²¡æœ‰ç‹¬ç«‹çš„å€Ÿç”¨ä»¤ç‰Œã€‚å®ƒä»¬ä¾èµ– `node_ref` çš„å­˜åœ¨ã€‚
- `self.0` çš„ç”Ÿå‘½å‘¨æœŸ = `'1`
	- ä½ æŠŠ `next` æ”¾è¿›å»ï¼Œç›¸å½“äºå‘Šè¯‰ç¼–è¯‘å™¨ï¼š
	- â€œå˜¿ï¼Œ`next` çš„å€Ÿç”¨è¶³å¤Ÿé•¿ï¼Œå¯ä»¥æ´»åˆ° `'1`â€ã€‚
	- ä½†æ˜¯ `next` å®é™…ä¸Šåªæ´»åˆ° **é—­åŒ…ç»“æŸ**ã€‚
	- æ‰€ä»¥ç¼–è¯‘å™¨æ‹’ç»ï¼šâ€œä½ éœ€è¦ `'1`ï¼Œä½† `next` åªæœ‰ä¸´æ—¶ç”Ÿå‘½å‘¨æœŸâ€ã€‚
-  - `next` dropped here while still borrowed
	- æœ€åç‚¹æ˜ï¼šé—­åŒ…ç»“æŸæ—¶ï¼Œ`next` è¢« dropã€‚  
	- ä½†æ˜¯ `self.0` è¿˜æƒ³ç»§ç»­ç”¨ `next`ã€‚ â†’ **æ‚¬å‚å¼•ç”¨é£é™©**ã€‚

é¢ï¼Œå€Ÿç”¨çš„å†…å®¹åªå…è®¸åœ¨é—­åŒ…ä½“ä¸­ä½¿ç”¨ï¼Œçœ‹èµ·æ¥æˆ‘ä»¬è¿˜æ˜¯å¾—ç”¨Â `Ref::map`Â æ¥è§£å†³é—®é¢˜:
```rust
impl<'a, T> Iterator for Iter<'a, T> {

Â  Â  type Item = Ref<'a, T>;

Â  Â  fn next(&mut self) -> Option<Self::Item> {

Â  Â  Â  Â  self.0.take().map(|node_ref| {

Â  Â  Â  Â  Â  Â  let (next, elem) = Ref::map_split(node_ref, |node| (&node.next, &node.elem));

  

Â  Â  Â  Â  Â  Â  self.0 = if next.is_some() {

Â  Â  Â  Â  Â  Â  Â  Â  Some(Ref::map(next, |next| &**next.as_ref().unwrap()))

Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  None

Â  Â  Â  Â  Â  Â  };

  

Â  Â  Â  Â  Â  Â  elem

Â  Â  Â  Â  })

Â  Â  }

}
```


```rust
error[E0308]: mismatched types
   --> src/fourth.rs:256:22
    |
256 |                 Some(Ref::map(next, |next| &**next.as_ref().unwrap()))
    |                 ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ref<'_, Node<T>>`, found `Ref<'_, RefCell<Node<T>>>`
    |                 |
    |                 arguments to this enum variant are incorrect
    |
    = note: expected struct `Ref<'_, fourth::Node<_>>`
               found struct `Ref<'_, RefCell<fourth::Node<_>>>`
help: the type constructed contains `Ref<'_, RefCell<fourth::Node<T>>>` due to the type of the argument passed
   --> src/fourth.rs:256:17
    |
256 |                 Some(Ref::map(next, |next| &**next.as_ref().unwrap()))
    |                 ^^^^^------------------------------------------------^
    |                      |
    |                      this argument influences the type of `Some`
note: tuple variant defined here
   --> /home/l/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:601:5
    |
601 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

For more information about this error, try `rustc --explain E0308`.
```



- `Some(...)` çš„å†…éƒ¨å€¼ç±»å‹ä¸åŒ¹é…ï¼Œæ‰€ä»¥æ•´ä¸ª `Option` ç±»å‹ä¹Ÿä¸å¯¹ã€‚

- `next` æ˜¯ `Option<Rc<RefCell<Node<T>>>>`
- `next.as_ref()` â†’ `Option<&Rc<RefCell<Node<T>>>>`
- `unwrap()` â†’ `&Rc<RefCell<Node<T>>>`
- `**` â†’ `RefCell<Node<T>>`
- `&` â†’ `&RefCell<Node<T>>`
- æ‰€ä»¥é—­åŒ…è¿”å›çš„æ˜¯ **`&RefCell<Node<T>>`**ã€‚  
â†’ äºæ˜¯ `Ref::map` çš„ç»“æœæ˜¯ `Ref<RefCell<Node<T>>>`ï¼Œè€Œä¸æ˜¯ `Ref<Node<T>>`ã€‚



æ™•, å¤šäº†ä¸€ä¸ªÂ `RefCell`Â ï¼Œéšç€æˆ‘ä»¬çš„å¯¹é“¾è¡¨çš„é€æ­¥æ·±å…¥ï¼Œ`RefCell`Â çš„ä»£ç åµŒå¥—å˜æˆäº†ä¸å¯å¿½è§†çš„é—®é¢˜ã€‚

çœ‹èµ·æ¥æˆ‘ä»¬å·²ç»æ— èƒ½ä¸ºåŠ›äº†ï¼Œåªèƒ½è¯•ç€å»æ‘†è„±Â `RefCell`Â äº†ã€‚`Rc`Â æ€ä¹ˆæ ·ï¼Ÿæˆ‘ä»¬å®Œå…¨å¯ä»¥å¯¹Â `Rc`Â è¿›è¡Œå®Œæ•´çš„å…‹éš†:

```rust
pub struct Iter<T>(Option<Rc<Node<T>>>);

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter(self.head.as_ref().map(|head| head.clone()))
    }
}

impl<T> Iterator for Iter<T> {
    type Item =

```
åœ¨ä½ çš„ `Iter<T>(Option<Rc<Node<T>>>)` è®¾è®¡é‡Œï¼š
#### ä¸æ˜¯ `&T 
- **ä¸æ˜¯ `&T`**  
    å› ä¸º `Iter` æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸå‚æ•° `'a`ï¼ŒRust æ— æ³•ä¿è¯â€œè¿™ä¸ª `&T` æ´»å¤šä¹…â€ã€‚  
    `&T` åªèƒ½å­˜åœ¨äºä¸€ä¸ªè¢«å€Ÿç”¨çš„ä¸Šä¸‹æ–‡é‡Œï¼Œè€Œ `Rc` æ˜¯å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒè„±ç¦»äº†å€Ÿç”¨ç³»ç»Ÿçš„ç”Ÿå‘½å‘¨æœŸè¿½è¸ªã€‚
    
- **ä¹Ÿä¸æ˜¯ `Ref<T>`**  
    `Ref<T>` æ˜¯ `RefCell<T>` çš„è¿è¡Œæ—¶å€Ÿç”¨ä»¤ç‰Œï¼Œå®ƒå¿…é¡»å’Œä¸€ä¸ªå…·ä½“çš„ `RefCell` å€Ÿç”¨ç»‘å®šç”Ÿå‘½å‘¨æœŸã€‚  
    ä½†æ˜¯ä½ çš„ `Iter` é‡Œé¢å·²ç»æ²¡æœ‰ `RefCell` çš„å€Ÿç”¨ï¼Œè€Œæ˜¯æŒæœ‰ `Rc<Node<T>>`ï¼Œæ‰€ä»¥ `Ref<T>` æ— ä»è°ˆèµ·ã€‚
    

ğŸ‘‰ æ‰€ä»¥ç»“æœæ˜¯ï¼š**ä½ çš„è¿­ä»£å™¨è¿”å›çš„æœ¬è´¨ä¸Šæ˜¯æŸç§æ‹¥æœ‰è€…ç±»å‹ï¼ˆ`Rc<Node<T>>`ï¼‰ï¼Œè€Œä¸æ˜¯å€Ÿç”¨ç±»å‹**ã€‚
#### ä¸ºä»€ä¹ˆä¸èƒ½ç›´æ¥å˜æˆ `Rc<T>`
æŠŠ `Rc<Node<T>>` å˜æˆ `Rc<T>`ã€‚  
ä½† **æ ‡å‡†åº“æ²¡æœ‰æä¾› `Rc::map`**ï¼Œå› ä¸ºè¿™ä¼šå¸¦æ¥æå…¶å¾®å¦™çš„ç”Ÿå‘½å‘¨æœŸä¸ææ„æ—¶æœºé—®é¢˜ï¼š

- `Rc<Node<T>>` çš„å†…å­˜å¸ƒå±€å¹¶ä¸èƒ½å®‰å…¨åœ°è¢«â€œéƒ¨åˆ†æŠ•å½±â€ä¸º `Rc<T>`ã€‚
    
- ä¾‹å¦‚ `Node<T>` åŒ…å«å¤šä¸ªå­—æ®µï¼Œ**`Rc` æ— æ³•åªé’ˆå¯¹æŸä¸€ä¸ªå­—æ®µåˆ›å»ºç‹¬ç«‹çš„å¼•ç”¨è®¡æ•°å—**ã€‚
    
- è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ ä¼šå‘ç°æœ‰ç¬¬ä¸‰æ–¹åº“ï¼ˆå¦‚ `rc::RcExt`) æä¾›äº†ç±»ä¼¼åŠŸèƒ½ï¼Œä½†æ ‡å‡†åº“å®å¯ä¿å®ˆï¼Œä¹Ÿä¸æš´éœ²è¿™ç§â€œå±é™© APIâ€ã€‚
#### è¿­ä»£å™¨å¹½çµé—®é¢˜

è¿™å°±æ˜¯ä½ è¯´çš„ **è¿­ä»£å™¨åˆæ³•æ€§** å´©å¡Œï¼š

- å½“ `Iter<'a, T>` è¿”å› `&'a T` æˆ– `Ref<'a, T>` æ—¶ï¼Œç¼–è¯‘å™¨/è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥å™¨å¯ä»¥ä¿è¯ï¼š
    - åœ¨æŒæœ‰è¿­ä»£å™¨çš„åŒæ—¶ï¼Œé“¾è¡¨ä¸èƒ½è¢«åŒæ—¶ä¿®æ”¹ï¼ˆæ¯”å¦‚ `pop`/`push` ä¼šè¢«æ‹’ç»ï¼‰ã€‚
- å½“ `Iter<T>` è¿”å› `Rc<Node<T>>` æ—¶ï¼š
    - `Rc` å®Œå…¨ç»•è¿‡äº†å€Ÿç”¨æ£€æŸ¥ â†’ å…è®¸ä½ â€œæŒæœ‰å­é“¾è¡¨çš„æŸä¸ªèŠ‚ç‚¹â€ï¼ŒåŒæ—¶åœ¨é“¾è¡¨ä¸Šåšç»“æ„æ€§ä¿®æ”¹ã€‚
    - å¦‚æœæ­¤æ—¶ **pop æ‰çš„æ­£å¥½æ˜¯ä½ æŒæœ‰çš„ Rc èŠ‚ç‚¹**ï¼Œé‚£é“¾è¡¨çš„å†…éƒ¨çŠ¶æ€å°±å’Œè¿­ä»£å™¨çš„ Rc ä¸å†ä¸€è‡´äº†ã€‚
    - å¦‚æœå†è°ƒç”¨ `Rc::try_unwrap` ä¹‹ç±»çš„å‡½æ•°å»â€œè§£åŒ…å”¯ä¸€æ‰€æœ‰æƒâ€ï¼Œç¨‹åºå¯èƒ½ç›´æ¥ `panic`ã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼š
- **æœ‰ç”Ÿå‘½å‘¨æœŸçš„è¿­ä»£å™¨ â†’ å®‰å…¨ï¼Œä½†é™åˆ¶å¤š**ã€‚
- **æ— ç”Ÿå‘½å‘¨æœŸã€åŸºäº Rc çš„è¿­ä»£å™¨ â†’ çµæ´»ï¼Œä½†å¯èƒ½å‡ºç°å¹½çµå¼•ç”¨ï¼ˆdangling logical referenceï¼‰**ã€‚


```rust
pub struct Iter<'a, T> {
    next: Option<Ref<'a, Node<T>>>,
}
```

- **å€Ÿç”¨æŒç»­æ—¶é—´å¤ªé•¿**
    - ä¸€æ—¦ä½ åœ¨è¿­ä»£å™¨é‡Œå­˜äº† `Ref<Node<T>>`ï¼Œå°±æ„å‘³ç€æ•´ä¸ªè¿­ä»£å™¨ç”Ÿå‘½å‘¨æœŸå†…ï¼Œè¿™ä¸ª `Node` æ°¸è¿œè¢«å€Ÿç”¨ç€ã€‚
    - é‚£ä¹ˆå½“ä½ å°è¯•è¿­ä»£åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œè¿˜è¦å†å€Ÿç”¨ä¸‹ä¸€ä¸ª `Ref<Node<T>>`ï¼Œç»“æœ runtime æ£€æŸ¥ä¼š panicï¼ˆå› ä¸º `RefCell` æ£€æµ‹åˆ°â€œé‡å…¥å€Ÿç”¨â€ï¼‰ã€‚
- **ç”Ÿå‘½å‘¨æœŸéš¾ä»¥è¡¨è¾¾**
    - `Ref` çš„ç”Ÿå‘½å‘¨æœŸ `'a` å¿…é¡»å’Œè¿­ä»£å™¨è‡ªèº« `'iter` ä¸€è‡´ã€‚
    - è¿™æ„å‘³ç€ç¼–è¯‘å™¨ä¼šè¦æ±‚ `Ref` æ´»å¾—å’Œ `Iter` ä¸€æ ·ä¹…ï¼Œä½†å®é™…ä¸Šä½ åªéœ€è¦å®ƒæ´»åˆ° `next()` è°ƒç”¨è¿”å›å°±å¤Ÿäº†ã€‚
    - è¿™å°±æ˜¯ç»å…¸çš„ **E0597 (borrow does not live long enough)** é”™è¯¯ã€‚

ä¸¥æ ¼æ¥è¯´ï¼Œ`push`Â é—®é¢˜ä¸å¤§ï¼Œå› ä¸ºé“¾è¡¨ä¸¤ç«¯çš„å¢é•¿ä¸ä¼šå¯¹æˆ‘ä»¬æ­£åœ¨å…³æ³¨çš„æŸä¸ªå­é“¾è¡¨é€ æˆå½±å“ã€‚

ä½†æ˜¯Â `pop`Â å°±æ˜¯å¦ä¸€ä¸ªæ•…äº‹äº†ï¼Œå¦‚æœåœ¨æˆ‘ä»¬å…³æ³¨çš„å­é“¾è¡¨ä¹‹å¤–Â `pop`, é‚£é—®é¢˜ä¸å¤§ã€‚ä½†æ˜¯å¦‚æœæ˜¯Â `pop`Â ä¸€ä¸ªæ­£åœ¨å¼•ç”¨çš„å­é“¾è¡¨ä¸­çš„èŠ‚ç‚¹å‘¢ï¼Ÿé‚£ä¸€åˆ‡å°±å®Œäº†ï¼Œç‰¹åˆ«æ˜¯ï¼Œå¦‚æœå¤§å®¶è¿˜è¯•å›¾å» unwrapÂ `try_unwrap`Â è¿”å›çš„Â `Result`Â ï¼Œä¼šç›´æ¥é€ æˆæ•´ä¸ªç¨‹åºçš„Â `panic`ã€‚

ä»”ç»†æƒ³ä¸€æƒ³ï¼Œå¥½åƒä¹Ÿä¸é”™ï¼Œç¨‹åºä¸€åˆ‡æ­£å¸¸ï¼Œé™¤éå»Â `pop`Â æˆ‘ä»¬æ­£åœ¨å¼•ç”¨çš„èŠ‚ç‚¹ï¼Œæœ€ç¾çš„æ˜¯ï¼Œå°±ç®—é‡åˆ°è¿™ç§æƒ…å†µï¼Œç¨‹åºä¹Ÿä¼šç›´æ¥å´©æºƒï¼Œæç¤ºæˆ‘ä»¬é”™è¯¯çš„å‘ç”Ÿã€‚

å…¶å®æˆ‘ä»¬å¤§éƒ¨åˆ†çš„åŠªåŠ›éƒ½æ˜¯ä¸ºäº†å®ç°éšè—çš„ç»†èŠ‚å’Œä¼˜é›…çš„ APIï¼Œå…¸å‹çš„äºŒå…«åŸåˆ™ï¼Œå…«æˆæ—¶é—´èŠ±åœ¨äºŒæˆçš„ç»†èŠ‚ä¸Šã€‚ä½†æ˜¯å¦‚æœä¸å…³å¿ƒè¿™äº›ç»†èŠ‚ï¼Œå¯ä»¥æ¥å—è‡ªå·±çš„å¹³å‡¡çš„è¯ï¼Œé‚£æŠŠèŠ‚ç‚¹ç®€å•çš„åˆ°å¤„ä¼ é€’å°±è¡Œã€‚

æ€»ä¹‹ï¼Œå¯ä»¥çœ‹å‡ºï¼Œå†…éƒ¨å¯å˜æ€§éå¸¸é€‚åˆå†™ä¸€ä¸ªå®‰å…¨æ€§çš„åº”ç”¨ç¨‹åºï¼Œä½†æ˜¯å¦‚æœæ˜¯å®‰å…¨æ€§é«˜çš„åº“ï¼Œé‚£å†…éƒ¨å¯å˜æ€§å°±æœ‰äº›æ‰è¥Ÿè§è‚˜äº†ã€‚