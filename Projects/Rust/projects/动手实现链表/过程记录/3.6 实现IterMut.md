再来回顾下 `Iter` 的实现：
```rust
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> { /* stuff */ }
}
```
这段代码可以进行下脱糖( desugar ):
```rust
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next<'b>(&'b mut self) -> Option<&'a T> { /* stuff */ }
}
```
可以看出 `next` 方法的输入和输出之间的生命周期并没有关联，这样我们就可以无条件的一遍又一遍地调用 `next`:
对于不可变借用而言，这种方式没有任何问题，因为不可变借用可以同时存在多个，但是如果是可变引用呢？因此，大家可能会以为使用安全代码来写 `IterMut` 是一件相当困难的事。但是令人诧异的是，事实上，我们可以使用安全的代码来为很多数据结构实现 `IterMut`。

先将之前的代码修改成可变的：
```rust
pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<T> List<T> {
    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref_mut();
            &mut node.elem
        })
    }
}

```

```
error[E0507]: cannot move out of `self.next` which is behind a mutable reference
    --> src/second.rs:117:9
     |
117  |           self.next.map(|node| {
     |  _________^^^^^^^^^_-
     | |         |
     | |         help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents
     | |         move occurs because `self.next` has type `Option<&mut second::Node<T>>`, which does not implement the `Copy` trait
118  | |             self.next = node.next.as_deref_mut();
119  | |             &mut node.elem
120  | |         })
     | |__________- `self.next` moved due to this method call
     |
note: `Option::<T>::map` takes ownership of the receiver `self`, which moves `self.next`
```

原因在于有些类型可以 [Copy](https://course.rs/basic/ownership/ownership.html#%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D)，有些不行。而`Option` 和不可变引用 `&T` 恰恰是可以 Copy 的，但尴尬的是，可变引用 `&mut T` 不可以，因此这里报错了。
```rust
fn next(&mut self) -> Option<Self::Item> {
    self.next.take().map(|node| {
        self.next = node.next.as_deref_mut();
        &mut node.elem
    })
}
```