我们需要担心清理我们的清单吗？从技术上讲，不，一点也不！与 C++ 一样，Rust 使用析构函数在资源完成后自动清理资源。如果类型实现了名为 Drop 的_特征_ ，则它有一个析构函数。特征是 Rust 对接口的奇特术语。此 Drop 特征具有以下接口：
```rust
pub trait Drop {
    fn drop(&mut self);
}
```

基本上，“当你超出范围时，我会给你一秒钟来清理你的事务”。

事实上，我们无需手动为自定义类型实现 `Drop` 特征，原因是 Rust 自动为几乎所有类型都实现了 `Drop`，例如我们自定义的结构体，只要结构体的所有字段都实现了 `Drop`，那结构体也会自动实现 `Drop` !

但是，有的时候这种自动实现可能不够优秀，例如考虑以下链表:

```rust
list -> A -> B -> C
```
当 `List` 被自动 `drop` 后，接着会去尝试 `Drop` A，然后是 `B`，最后是 `C`。这个时候，其中一部分读者可能会紧张起来，因此这其实是一段递归代码，可能会直接撑爆我们的 stack 栈。

**展开过程：**
```rust
Drop(List) -> Drop(Link::More(Box<Node>)) -> Drop(Box<Node>)
           -> Drop(Node) -> Drop(next: Link::More(Box<Node>))
           -> ...
```
因此：
- 每个 `Node` 的 drop 会导致下一个 `Node` 被 drop，
- 直到 `Link::Empty` 为止。
这就是典型的**线性递归**析构过程。

**为何会栈溢出？**
递归 drop 的问题在于：**每次 drop 一个节点时，都会在栈上多压入一帧（frame）**。
例如，drop 100,000 个节点，就会递归 100,000 层。
而**现代操作系统对线程栈大小是有限制的**，例如：
- 默认线程栈大小为 1MB ~ 8MB
- 每次函数调用（drop）占用几百字节
所以，长链表（如长度 100,000）在自动 drop 时就会：

### 重写Drop避免递归
Rust 提供了一种方式：**手动实现 Drop trait，使用迭代而不是递归释放节点**。
示例代码如下：
```rust
impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = std::mem::replace(&mut self.head, Link::Empty);
        while let Link::More(mut boxed_node) = cur_link {
            cur_link = std::mem::replace(&mut boxed_node.next, Link::Empty);
            // boxed_node goes out of scope and gets dropped here
        }
    }
}
```
### 分析：
- 使用 `std::mem::replace` 断开节点之间的链接，防止递归 drop。
- 每次 loop 只 drop 一个节点，且不保留递归调用栈。
- 本质是“手动 drop”，**线性地释放堆内存**。
- 
我们对 drop 的实现实际上与`while let Some(_) = self.pop() { }` 十分相似，这当然更简单。它有何不同，一旦我们开始泛化列表以存储整数以外的内容，可能会导致哪些性能问题？

`self.pop()` 的会返回 `Option<i32>`, 而我们之前的实现仅仅对智能指针 `Box<Node>` 进行操作。前者会对值进行拷贝，而后者仅仅使用的是指针类型。

当链表中包含的值是其他较大的类型时，那这个拷贝的开销将变得非常高昂。
### 问题
#### 为什么不实现drop，也不会出错
但在你当前这个测试用例中，链表元素非常少（最多只有 5 个），所以：

> **即使走默认的递归析构，也不会爆栈，自然也不会出错。**