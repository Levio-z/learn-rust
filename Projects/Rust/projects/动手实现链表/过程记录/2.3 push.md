### 知识点：
- 对于可变引用不能直接移动出来
- 方法概念
- 使用mem::replace完成修改可变引用的字段，从而实现移动出字段的效果但是不波及所有权


因此，让我们编写将值推送到列表上。`push` _会改变_列表，所以我们要采用 `&mut self`。我们还需要使用 i32 来推送：
### 定义方法
```rust
impl List {
    pub fn push(&mut self, elem: i32) {
        // TODO
    }
}
```
### 实现方法
首先，我们需要创建一个节点来存储我们的元素：
```rust
    pub fn push(&mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: ?????
        };
    }
```
`接下来`是什么？嗯，整个旧列表！我们能...就这样吗？
```rust
impl List {
    pub fn push(&mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: self.head,
        };
    }
}
```

```
error[E0507]: cannot move out of `self.head` which is behind a mutable reference
  --> src/first.rs:27:19
   |
27 |             next: self.head,
   |                   ^^^^^^^^^ move occurs because `self.head` has type `Link`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
```
[1 从可变借用中怎么移出字段](../../../../../Areas/Rust/Area/1%20基本概念/2%20进阶/2.1%20所有权、生命周期和内存系统/2.1.2%20所有权系统/借用报错场景积累/1%20从可变借用中怎么移出字段.md)

但是，如上所示，这段代码会报错，因为试图将借用的值 `self` 中的 `head` 字段的所有权转移给 `next` ，在 Rust 中这是不被允许的。那如果我们试图将值再放回去呢
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: self.head,
    });

    self.head = Link::More(new_node);
}
```

则上，这是 Rust 实际上可以接受的，但它不会（出于各种原因 —— 最严重的是[异常安全](https://doc.rust-lang.org/nightly/nomicon/exception-safety.html) ）。我们需要一些方法来获取头部，而不会让 Rust 注意到它已经消失了。为了获得建议，我们求助于臭名昭著的 Rust 黑客 Indiana Jones：
 
 什么是异常安全？

虽然 Rust 没有“抛出异常”的传统机制，但它有 **panic**，它可能会在某个地方触发 **提前退出**。

> 假设 Rust 允许你 move 出一个字段，但是在 move 过程中 panic 了 —— 那结构体就会“处于部分失效的状态”，这会导致内存不一致或者 double free 等 UB（未定义行为）。

为了防止这种情况，Rust 会禁止你从可变借用中 move 出字段，这是一种**编译期防御性设计**。


使用replace实现

```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: mem::replace(&mut self.head, Link::Empty),
    });

    self.head = Link::More(new_node);
}


```

在这里，我们暂时用 Link：：Empty `替换` self.head，然后再用新的列表 head 替换它。我不会撒谎：这是一件非常不幸的事情。可悲的是，我们必须（目前）。

但是，嘿， `一切都`完成了！可能。老实说，我们可能应该测试一下。现在最简单的方法可能是编写 `pop`，并确保它产生正确的结果。