### 数据布局
```
list1 = A -> B -> C -> D
list2 = tail(list1) = B -> C -> D
list3 = push(list2, X) = X -> B -> C -> D
```

```
list1 -> A ---+
              |
              v
list2 ------> B -> C -> D
              ^
              |
list3 -> X ---+

```

这里大家可能会看出一些端倪：**节点 `B` 被多个链表所共享，这造成了我们无法通过 `Box` 的方式来实现，因为如果使用 `Box`，还存在一个问题，谁来负责清理释放？如果 drop `list2`，那 `B` 节点会被清理释放吗**？

函数式语言或者说其它绝大多数语言，并不存在这个问题，因为 GC 垃圾回收解千愁，但是 Rust 并没有。

好在标准库为我们提供了引用计数的数据结构: `Rc / Arc`，引用计数可以被认为是一种简单的 GC，对于很多场景来说，引用计数的数据吞吐量要远小于垃圾回收，而且引用计数还存在循环引用的风险！但... 我们有其它选择吗？ :(

不过使用 Rc 意味着我们的数据将无法被改变，因为它不具备内部可变性，关于 Rc/Arc 的详细介绍请看[这里](https://course.rs/advance/smart-pointer/rc-arc.html)。

下面，简单的将我们的数据结构通过 `Rc` 来实现：
```
// in third.rs
use std::rc::Rc;

pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Rc<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

```
需要注意的是, `Rc` 在 Rust 中并不是一等公民，它没有被包含在 `std::prelude` 中，因此我们必须手动引入 `use std::rc::Rc` (混得好失败 - , -)

### 基本操作
首先，对于 List 的构造器，可以直接复制粘贴:
```
pub fn tail(&self) -> List<T> { 
  List { head: self.head.as_ref().map(|node| node.next.clone()) }
}
```

```
$ cargo build
```
看起来这里的 `map` 多套了一层 `Option`，可以用 `and_then` 替代：
```
    // 将现有链表的首个元素移除，并返回剩余的链表

    pub fn tail(&self) -> List<T> {

        List {

            head: self.head.as_ref().and_then(|node| node.next.clone()),

        }

    }
```
顺利通过编译，很棒！最后就是实现 `head` 方法，它返回首个元素的引用，跟之前链表的 `peek` 方法一样:
```
pub fn head(&self) -> Option<&T> {
    self.head.as_ref().map(|node| &node.elem )
}
```

哦对了... 我们好像忘了一个重要特性：对链表的迭代。
```
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<T> List<T> {
    pub fn iter(&self) -> Iter<'_, T> {
        Iter { next: self.head.as_deref() }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}

```

测试通过