### ⚠️ 风险 1：吞吐性能低于 GC

虽然 `Rc` 不需要追踪整堆内存，但它仍然：

- 在每次 clone/drop 时执行原子/非原子的计数加减
    
- 存在 **频繁更新引用计数** 的开销
    
- 在高吞吐、高并发下，GC 更适合**批量收集，而引用计数是实时回收**
    

这也是为什么：

- **Rust 高性能场景仍优先用所有权+借用**
    
- `Rc`/`Arc` 常用于结构共享场景，如 AST、图结构、函数式持久结构等，而非大规模吞吐处理
### 风险 2：**循环引用 (Reference Cycle)**
```
use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    next: RefCell<Option<Rc<Node>>>,
}

fn main() {
    let a = Rc::new(Node { value: 1, next: RefCell::new(None) });
    let b = Rc::new(Node { value: 2, next: RefCell::new(Some(a.clone())) });

    *a.next.borrow_mut() = Some(b.clone()); // 循环引用！

    // a 和 b 相互持有，不会 drop，内存泄漏
}

```

此时：

- `a` → `b`
    
- `b` → `a`
    

两者引用计数都 > 0，永远不会 drop → **逻辑上已死，内存却活着** → **泄漏**

解决方式：使用 `Weak`
```
struct Node {
    value: i32,
    next: RefCell<Option<Weak<Node>>>,
}

```
用 `Weak<T>` 替代 `Rc<T>`，即：**不增加引用计数，只是观测者角色**

### rust 使用GC
需要 GC 行为（复杂图结构 + 多变 + 不关心 drop）