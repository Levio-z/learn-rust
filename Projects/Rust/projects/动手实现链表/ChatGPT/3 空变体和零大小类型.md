## 🧩 一、定义区分：空变体 vs 零大小类型（ZST）

| 项目    | 空变体（Empty Variant）                | Unit 类型 / 零大小类型（ZST）                   |
| ----- | --------------------------------- | -------------------------------------- |
| 定义    | 枚举中的某个变体，不带任何数据字段（如 `A`）          | 类型，其实例在内存中不占用空间（如 `()`、`struct Foo;`）  |
| 示例    | `enum E { A, B(u8) }` 中的 `A`      | `()`、`struct Marker;`、`PhantomData<T>` |
| 内存占用  | 仍需占用空间表示 **哪个变体**（即 discriminant） | 真正的 Zero-Sized Type，在内存布局中可被优化为 0 字节   |
| 编译器行为 | 编译器仍需要为枚举分配空间区分变体                 | 编译器可消除所有内存分配，彻底零开销                     |
## 🧪 二、示例说明

### 示例 1：空变体（empty variant）

```rust
enum MyEnum {
    A,            // 空变体
    B(u8),        // 非空变体
}
```

-   `A` 是一个“**空变体**”。
    
-   虽然 `A` 本身没有数据，但 **整个 `MyEnum`** 至少要存储一个 discriminant（变体标记），用来区分 `A` 和 `B(_)`。
    
-   即使你只用 `A`，`MyEnum` 在布局上也不可能是 ZST。
    

### 示例 2：零大小类型（ZST）

```rust
struct Foo;            // 零大小 struct
let x = Foo;
let y = ();            // unit 类型
```

-   `Foo` 和 `()` 都是 **真正的 ZST**。
-   它们的实例不会在栈上分配实际空间（在优化后），只是类型级别的标识。
-   在泛型编程中常用于“类型占位符”、“标记 trait”等。
    
🔧 LLVM 在优化阶段会**完全移除**这类实例的内存分配，也就是说：

- 即使你 `let x = Empty;`，它也不会真正存在于内存中；
    
- 它只存在于**类型系统**中，用于检查/推导/约束，而不涉及运行时负担。
---

## ⚙️ 三、应用与使用场景

### ✅ 空变体（empty variant）

-   用于枚举中表示 **特定状态或类型标签**。
    
-   示例：
    
    ```rust
    enum State {
        Idle,
        Running(u32),
        Error(String),
    }
    ```
    
    `Idle` 就是空变体，用于代表一种状态。
    

### ✅ 零大小类型（ZST）

-   用于“类型级别信息表达”，无运行时成本。
    
-   应用：
    
    -   `PhantomData<T>`：用于告诉编译器存在 T 类型的所有权或生命周期。
        
    -   空标记结构体作为 trait bound 标记或状态机标识：
        
        ```rust
        struct Connected;
        struct Disconnected;
        
        struct Socket<State> {
            state: PhantomData<State>,
        }
        ```
        

---

## 🧠 四、深入底层机制

### 🔸 空变体的 discriminant

```rust
#[repr(u8)]
enum E {
    A,       // 0
    B(u8),   // 1
}
```

-   编译器为枚举生成 discriminant 字段。
    
-   即使 `A` 不占数据空间，`E` 的实例也需要至少 1 字节来存放 discriminant。
    

### 🔸 ZST 内存布局

```rust
use std::mem::size_of;

println!("{}", size_of::<()>());
// 输出：0

struct Marker;
println!("{}", size_of::<Marker>());
// 输出：0
```

-   编译器能完全去除它们在代码中的实际空间占用。
    

---

## 🧮 五、总结类比

| 类别 | 概念类比 | 是否为 ZST | 是否需 discriminant | 编译器布局关键点 |
| --- | --- | --- | --- | --- |
| 空变体 | 枚举状态标签 | ❌ 否 | ✅ 是 | 需要辨别是哪种变体 |
| Unit / ZST | 类型标识 / 无需值 | ✅ 是 | ❌ 否 | 编译器可优化为无分配 |

---

## 🧵 拓展阅读建议

-   Rust Reference: Enums
    
-   Rustnomicon: Zero Sized Types
    
-   Rust Playground 验证：使用 `std::mem::size_of` 检查结构体或枚举的大小布局
    

---
