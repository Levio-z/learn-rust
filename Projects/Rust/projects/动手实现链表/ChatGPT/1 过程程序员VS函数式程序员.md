### 链表
- 对于过程式程序员来说，链表因为涉及大量指针操作、内存管理、易出错等复杂性，通常被视为难以驾驭、不值得轻易使用的数据结构，就像十尺长的杆子那样“远离”它。
    
- 而函数式程序员则擅长用递归和代数数据类型优雅地定义和操作链表，使其成为函数式编程中非常自然且重要的基础工具，几乎“万能”的数据结构。
### 特点

| 维度        | 过程式程序员                        | 函数式程序员                                     |
| --------- | ----------------------------- | ------------------------------------------ |
| **编程范式**  | 过程式编程（Procedural Programming） | 函数式编程（Functional Programming）              |
| **核心思想**  | 通过执行一系列指令（过程）改变程序状态           | 使用纯函数表达计算，避免可变状态和副作用                       |
| **状态管理**  | 依赖变量的赋值和修改，状态可变               | 避免状态变化，数据不可变，使用函数参数传递状态                    |
| **副作用**   | 副作用普遍存在，函数可能读写外部状态            | 尽量避免副作用，副作用用类型系统隔离（如 Haskell 的 `IO`）       |
| **控制流**   | 循环、条件分支、跳转（如 goto）控制程序流程      | 递归和高阶函数（如 map、fold）代替显式循环和跳转               |
| **数据结构**  | 通常使用可变数据结构，如数组、链表、指针          | 使用不可变数据结构，递归定义数据类型（代数数据类型）                 |
| **代码表达**  | 命令式风格，描述“怎么做”                 | 声明式风格，描述“是什么”                              |
| **函数特性**  | 函数可能有副作用，不一定是纯函数              | 强调纯函数，函数的输出仅依赖输入，不改变外部状态                   |
| **错误处理**  | 异常处理机制或错误码                    | 使用代数数据类型（如 `Option`、`Either`）安全处理错误        |
| **并发/并行** | 共享可变状态导致竞态条件，需要锁等同步机制         | 由于无状态和不可变，天然支持并发且易于推理                      |
| **语言示例**  | C、Pascal、BASIC、早期的 Java（部分）   | Haskell、Erlang、Scala（混合）、部分支持 FP 的 Rust、F# |

---

## 简单总结

-   **过程式程序员**关注的是**执行过程和状态变化**，代码像一条指令流水线，告诉计算机一步步怎么做，重点是“控制流程”和“状态管理”。
    
-   **函数式程序员**关注的是用**纯函数和不可变数据**描述问题，强调代码的数学性质和组合性，重点是“表达计算的本质”和“避免副作用”。
    

---

## 举个例子对比

**计算列表元素和：**

### 过程式写法（C风格伪代码）

```c
int sum = 0;
for (int i = 0; i < length; i++) {
    sum += array[i];
}
return sum;
```

### 函数式写法（Haskell）

```haskell
sumList :: [Int] -> Int
sumList [] = 0
sumList (x:xs) = x + sumList xs
```

或者用高阶函数：

```haskell
sumList = foldr (+) 0
```

---

## 额外补充

-   两者并非绝对对立，现代语言（如 Rust、Scala、F#）都融合了两种范式的优点。
    
-   过程式编程擅长底层系统开发，函数式编程擅长并发、大数据、领域建模等领域。