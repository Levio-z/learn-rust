在我们讨论 TCP 的操作之前，我们需要介绍一些详细的术语。**TCP 连接的维护需要记住几个变量。**
我们设想将这些变量存储在称为传输控制块或 TCB 的连接记录中。存储在 TCB 中的变量包括本地和远程套接字号、连接的安全性和优先级、指向用户发送和接收缓冲区的指针、指向 HTTP 队列和当前段的指针。此外，TCB 中还存储了与发送和接收序列号相关的多个变量。
 #### Send Sequence Variables   发送序列变量  
      SND.UNA - send unacknowledged  -发送未确认的
      SND.NXT - send next -发送下一个
      SND.WND - send window -发送窗口-允许发送的数量
      SND.UP  - send urgent pointer SND.UP -发送紧急指针
      SND.WL1 - segment sequence number used for last window update 
				      用于上次窗口更新的段序列号
      SND.WL2 - segment acknowledgment number used for last window 
                update SND.WL2 -用于上次窗口更新的段确认号
      ISS     - initial send sequence number -初始发送序列号
   
   #### 接收序列变量
      RCV.NXT - receive next  -接收下一个
      RCV.WND - receive window RCV.WND -接收窗口
      RCV.UP  - receive urgent pointer RCV.UP -接收紧急指针
      IRS     - initial receive sequence number IRS -初始接收序列号
####  发送序列空间
```
      Send Sequence Space   发送序列空间  
  
                   1         2          3          4
              ----------|----------|----------|----------
                     SND.UNA    SND.NXT    SND.UNA
										 +SND.WND
```
1 -已经确认的旧序列号
2 -未确认数据的序列号
3 -允许用于新数据传输的序列号
4 -还不允许的未来序列号

#### Receive Sequence Space   接收序列空间

```
					  1          2          3
                   ----------|----------|----------
                          RCV.NXT    RCV.NXT
                                    +RCV.WND
```
 1 -已确认的旧序列号
 2 -允许新接收的序列号
 3 -尚不允许的未来序列号
 
 接收窗口是图5中标记为2的序列空间的部分。
 
还有一些在讨论中经常使用的变量，它们的值来自当前段的字段。

Current Segment Variables 当前段变量

SEG.SEQ -段序列号
SEG.ACK -段确认号
SEG.LEN -段长度
SEG.WND -段窗口 
SEG.UP -段紧急指针
 SEG.PRC -段优先级值
 
 连接在其生命周期中经历一系列状态。这些是：LISTEN、SYN-SENT、SYN-RECEIVED、ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT 和虚构状态 CLOSED。
 
 CLOSED 是虚构的，因为它表示没有 TCB 时的状态，因此没有连接。简单地说，状态的含义是：
 LISTEN -表示等待来自任何远程 TCP 和端口的连接请求。
 SYN-SENT -表示在发送连接请求后等待匹配的连接请求。
  SYN-RECEIVED -表示在接收和发送连接请求后等待确认连接请求确认。
  ESTABLISHED -表示一个开放的连接，接收到的数据可以传递给用户。连接的数据传输阶段的正常状态。
### 3.3 序列号

设计中的一个基本概念是，通过 TCP 连接发送的每个八位字节数据都有一个序列号。由于每个二进制八位数都是有序的，因此每个二进制八位数都可以被确认。所采用的确认机制是累积的，使得序列号 X 的确认指示已经接收到**直到不包括 X** 的所有八位字节。该机制允许在存在重传的情况下直接进行重复检测。

- 除了带有 SYN 标志的段之外，段中第一个数据八位字节（byte）的序列号，就是 TCP 报文段头部里的 `Sequence Number` 字段。后续数据八位字节的编号，依次递增。
- 重要的是要记住，实际的序列号空间是有限的，尽管非常大。该空间的范围为0到2**32 - 1。
- 由于空间是有限的，所有处理序列号的算术运算都必须以2**32为模来执行。这种无符号算术保留了序列号从2**32 - 1循环到0时的关系。计算机模运算有一些微妙之处，因此在对此类值的比较进行编程时应非常小心。符号“=<”表示“小于或等于”（模2**32）。

TCP 必须执行的典型序列号比较包括：
	 作为对发送数据的响应，TCP 将接收数据包。需要进行(a)，(b)比较以处理数据集
	 收到数据后，需要进行(c)比较：
- (a)**确定一个确认号所指的是某个已发送但尚未被确认的序列号**
	- 当 TCP 接收到一个 ACK（确认号），它要检查：这个 ACK 是否确认了某个我们曾经发送出去、但还没收到确认的字节？
		- 新的确认（称为“可接受的 ack”）是一个下面的不等式成立的确认：
			- `SND.UNA < ACK <= SND.NXT`
		- `SND.UNA`：发送但未确认的最小序列号
		- `SND.NXT`：下一个要发送的序列号
		- SEG.ACK =来自接收 TCP 的确认（接收 TCP 期望的下一个序列号）
	- 只有在我有数据需要确认才需要这么做，当我接受了fin的ack，我不会发出信号，这时不需要检查
- (b) 确定由段占用的所有序列号都已被确认
	-  如果重传队列上的数据段的序列号和长度之和小于或等于传入数据段中的确认值，则该数据段被完全确认。
		- SEG.SEQ + SEG.LEN - 1<SND.UNA 
	- 意思是：段的最后一个字节序列号已经被 ACK 过去。
	- SEG.SEQ+SEG.LEN-1 = 一个区段的最后序列号
- (c)确定输入段包含预期的序列号
	- 如果满足以下条件，则判断一个段占用了有效接收序列空间的一部分
	    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND  
	  or  
	    RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
	    seq=1 len=1
	    
	- RCV.NXT =传入段上预期的下一个序列号，是接收窗口的左边缘或下边缘
	- RCV.NXT+RCV.WND-1 =传入段上预期的最后一个序列号，是接收窗口的右边缘或上边缘
	- SEG.LEN =数据段中数据占用的八位字节数（包括 SYN 和 FIN）
	- SEG.SEQ+SEG.LEN-1 = 一个区段的最后序列号
	- 此测试的第一部分检查区段的开头是否位于窗口中，测试的第二部分检查区段的末尾是否位于窗口中;如果区段通过了测试的任一部分，则它会在窗口中包含 data。
	- 接收方维护
		- RCV.NXT <= SEG.SEQ < RCV.NXT + RCV.WND
		- 意思是：段必须落在接收窗口内，才能被接受。否则：
		- **太早到（左边）**：已经收到过（可能是重复包）。
		- **太晚到（右边）**：超出窗口，暂时不接受。
	- 接收方基于窗口管理流量，避免接收太多还没处理完的数据。  
	- 滑动窗口（sliding window）通过移动 `RCV.NXT` 实现：一旦确认部分数据，新窗口就向前滑动。

四种 TCP 段接收测试（来自 RFC 793）

| Segment Length (`SEG.LEN`) | Window Size (`RCV.WND`) | 接收判断条件                                                                                                   |
| -------------------------- | ----------------------- | -------------------------------------------------------------------------------------------------------- |
| 0                          | 0                       | `SEG.SEQ == RCV.NXT`                                                                                     |
| 0                          | >0                      | `RCV.NXT <= SEG.SEQ < RCV.NXT + RCV.WND`                                                                 |
| >0                         | 0                       | 不合法（被丢弃）                                                                                                 |
| >0                         | >0                      | `RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND  <br>or  <br>	    `RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND` |
|                            |                         |                                                                                                          |

>零窗口 + 零长度段时，为什么 `SEG.SEQ == RCV.NXT` 被接受？

- `RCV.WND == 0`（接收窗口为零，接收方通知对端**不要再发数据**）
- `SEG.LEN == 0`（报文段中没有数据）
- `SEG.SEQ == RCV.NXT`（报文段序列号正好是接收方的下一个期待序列号）
 原因：
这个条件是为了允许在零窗口情况下：
1. 传递纯 ACK 报文（零长度）
2. **探测窗口是否打开**（“Zero Window Probe”）
因为：
- TCP 是一个可靠流协议，即使窗口为零，**确认号也要继续返回**
- 若不允许这样的段通过，就永远无法唤醒发送方等待窗口打开的状态
```
客户端：SEQ=1000, LEN=1  (Zero Window Probe)
服务端：窗口为 0，但仍然发送：
        ACK=1000, WIN=0  → 表示我仍不能接收，但我还活着
```


>`RCV.WND > 0`（正常窗口）

常见用途包括：
- 纯 ACK 报文（确认收到数据）
- 仅含 FIN/SYN 的段（逻辑上占 1 字节，但无 payload）
- 控制信息（如窗口更新）

我们还利用了编号方案来保护某些控制信息。这是通过在序列空间中隐式包含一些控制标志来实现的，这样它们就可以被重新传输和确认而不会造成混淆（即，将对控制的一个且只有一个副本进行作）。控制信息不会以物理方式在 segment 数据空间中传输。因此，我们必须采用规则来隐式地将序列号分配给 control。SYN 和 FIN 是唯一需要此保护的控件，并且这些控件仅在连接打开和关闭时使用。出于序列号目的，SYN 被视为发生在它所在的段的第一个实际数据八位字节之前，而 FIN 被视为发生在它所在的段中的最后一个实际数据八位字节之后。段长度 （SEG.LEN） 包括占用数据和序列空间的控件。当 SYN 存在时，则 SEG.SEQ 是 SYN 的序列号。

### 初始的随机序列号

 该协议对反复使用的特定连接没有任何限制。连接由一对套接字定义。连接的新实例将被称为连接的化身。由此产生的问题是--"TCP 如何从以前的连接中识别重复的段？"如果连接被快速连续地打开和关闭，或者如果连接因内存丢失而中断，然后重新建立，则此问题会变得明显。
  
但协议**允许同一四元组反复使用**（即多个“化身”incarnations）。这就带来问题：
- 如果连接 A 在短时间内关闭，马上又用同一对四元组建立连接 B，  
    那么：
    - 老连接 A 的包可能还在网络里（因为网络不是完全可靠、即时的）。
    - 新连接 B 用到相同的序列号时，接收方会分不清这是谁的包。
**→ 必须保证：新连接的序列号与老连接的不冲突！


为了确保 TCP 不会创建带有序列号的段，而该序列号可能会被网络中剩余的旧段重复，TCP 必须在启动或从正在使用的序列号内存丢失的崩溃中恢复之前，在分配任何序列号之前保持安静。对于此规范，MSL 取为 2 分钟。这是一种工程选择，如果经验表明需要这样做，则可以更改。请注意，如果 TCP 在某种意义上被重新初始化，但保留了其正在使用的序列号的内存，那么它根本不需要等待;它必须确保仅使用大于最近使用的序列号。
>**MSL** 是指 **一个 TCP 报文段在网络中最多可能存活的时间**。


 **ISN 选择机制**
ISN 是 32 位数（0 ~ 2³²-1）。
- 每个主机维护一个 **ISN 生成器**，它绑定到一个虚拟的 32 位“时钟”。
- 这个时钟的最低位 **每约 4 微秒加 1**。
这样：
- 全范围回绕（2³² 次）大约需要 **4.55 小时**。
- 假设网络中段的最大存活时间（MSL, Maximum Segment Lifetime）小于 4.55 小时（RFC 793 设定 MSL = 2 分钟），  
    那么，只要两次连接之间隔了一点时间，ISN 就不会重叠。
换句话说：
```
只要两次连接之间的 ISN 差值 > MSL 内的传输窗口，
即使旧段还在网络里，也不会被误认。

```
**连接建立过程（握手细节）

每个连接都有一个发送序列号和一个接收序列号。初始发送序列号（ISS）由数据发送 TCP 选择，并且初始接收序列号（IRS）在连接建立过程期间被学习。
 
 **对于要建立或初始化的连接，两个 TCP 必须在彼此的初始序列号上同步**。
 - 这是在交换连接建立段时完成的，该连接建立段携带称为“SYN”（用于同步）的控制位和初始序列号。作为简写，携带 SYN 位的段也称为“SYN”。因此，该解决方案需要一个合适的机制来挑选初始序列号和稍微涉及的握手来交换 ISN。
 >**始序列号（ISN, Initial Sequence Number）选择与握手机制**，这是 TCP 保证可靠性和连接唯一性的基础之一。

 **同步要求每一方发送自己的初始序列号，并从另一方接收确认。每一方还必须接收另一方的初始序列号，并发送确认。**
- 经典 **三次握手**（three-way handshake）其实就是：  
	-  A → B：SYN, ISN = X  
	- B → A：SYN, ISN = Y; ACK = X + 1  
	-  A → B：ACK = Y + 1
- 每一方都：  
	- 告诉对方自己的 ISN，  
	- 确认收到对方的 ISN。
```
    1) A --> B  SYN my sequence number is X
    2) A <-- B  ACK your sequence number is X
    3) A <-- B  SYN my sequence number is Y
    4) A --> B  ACK your sequence number is Y
```
1） A --> B SYN 我的序列号是 X 
2） A <-- B 确认您的序列号是 X 
3） A <-- B SYN 我的序列号是 Y 
4） A --> B 确认您的序列号是 Y

由于步骤 2 和 3 可以合并到一条消息中，因此称为三向（或三条消息）握手。

三次握手是必要的，因为序列号不与网络中的全局时钟绑定，并且 TCP 可能具有不同的 ISN 选择机制。第一个 SYN 的接收者无法知道该 segment 是否是旧的延迟 Segment，除非它记得连接上使用的最后一个序列号（这并不总是可能的），因此它必须要求发送方验证这个 SYN。[[3](https://datatracker.ietf.org/doc/html/rfc793-#ref-3)] 中讨论了三次握手和 clock-driven scheme 的优势。
### 知道何时保持沉默

为了确保 TCP 不会创建带有序列号的段，而该序列号可能会被网络中剩余的旧段重复，TCP 必须在启动或从正在使用的序列号内存丢失的崩溃中恢复之前，在分配任何序列号之前保持安静。对于此规范，MSL 取为 2 分钟。这是一种工程选择，如果经验表明需要这样做，则可以更改。请注意，如果 TCP 在某种意义上被重新初始化，但保留了其正在使用的序列号的内存，那么它根本不需要等待;它必须确保仅使用大于最近使用的序列号。

### TCP 静默时间概念
本规范规定，如果主机“崩溃”而不保留每个活动（即未关闭）连接上传输的最后一个序列号的任何信息，则应至少在主机所属的 Internet 系统中延迟发出任何 TCP 段，延迟发送任何 TCP 段。在下面的段落中，对该规范进行了解释。TCP 实施者可能会违反“静默时间”限制，但前提是导致一些旧数据被接受为新数据，或者新数据被 Internet 系统中的某些接收者拒绝为旧数据。
每次形成分段并将其输入到源主机的网络输出队列中时，TCP 都会占用序列号空间。TCP 协议中的重复检测和排序算法依赖于 Segment 数据与序列空间的唯一绑定，以至于在绑定到这些序列号的 Segment 数据被交付并由接收者确认之前，序列号不会循环遍历所有 2**32 值，并且 Segments 的所有重复副本都已从 Internet 上“耗尽”。如果没有这样的假设，可以想象两个不同的 TCP 段是分配相同或重叠的序列号，导致接收方混淆哪些数据是新数据，哪些数据是旧数据。请记住，每个 segment 都绑定到与 segment 中数据的八位字节一样多的连续序列号。
在正常情况下，TCP 会跟踪下一个要发出的序列号和等待确认的最早的序列号，以避免在第一次使用序列号被确认之前错误地使用序列号。仅凭这一点并不能保证旧的重复数据会从网络中排出，因此序列空间变得非常大，以减少游荡重复数据在到达时造成麻烦的可能性。以 2 兆位/秒的速度，需要 4.5 小时才能用完 2**32 个八位字节的序列空间。由于网络中的最大段生存期不太可能超过几十秒，因此即使数据速率升级到 l0 的 MB/sec，这也被认为是对可预见的网络的充分保护。在 100 MB/秒时，循环时间为 5.4 分钟，这可能有点短，但仍在合理范围内。

但是，如果源 TCP 没有上次在给定连接上使用的序列号的任何内存，则 TCP 中的基本重复检测和排序算法可能会失效。例如，如果 TCP 要启动序列号为 0 的所有连接，那么在崩溃并重新启动时，TCP 可能会重新形成较早的连接（可能在半开连接解析之后），并发出序列号与仍在网络中的数据包相同或重叠的数据包，这些数据包是在同一连接的早期版本上发出的。在不知道特定连接上使用的序列号的情况下，TCP 规范建议在连接上发出段之前将源延迟 MSL 秒，以便为早期连接化身的段留出时间从系统中排出。

即使是能够记住一天中的时间并使用它来选择初始序列号值的主机也不能幸免于这个问题（即，即使使用一天中的时间为每个新的连接化身选择初始序列号）。

例如，假设一个连接以序列号 S 开头打开。假设这个连接没有被经常使用，并且最终初始序列号函数 （ISN（t）） 的值等于这个 TCP 在特定连接上发送的最后一个 Segment 的序列号，比如 S1。现在假设，在这一刻，主机崩溃、恢复并建立连接的新化身。选择的初始序列号是 S1 = ISN（t） -- 在旧的 connection 化身上最后一次使用的序列号！如果恢复发生得足够快，则任何旧的S1 附近的网络承载序列号中的重复数据包可能会到达并被新连接的接收方视为新数据包。

问题在于，正在恢复的主机可能不知道它崩溃了多长时间，也不知道系统中是否仍有来自早期连接化身的旧重复项。解决这个问题的一种方法是在从崩溃中恢复后故意延迟发出一个 MSL 的 Segment——这就是 “quite time” 规范。喜欢避免等待的主机愿意冒着在给定目的地可能混淆新旧数据包的风险，可以选择不等待 “相当时间”。实现者可以为 TCP 用户提供按连接选择是否在崩溃后等待的能力，或者可以非正式地为所有连接实现“quite time”。显然，即使用户选择“等待”，在主机“启动”至少 MSL 秒后，也不需要这样做。

总结一下：发出的每个段都占据序列空间中的一个或多个序列号，段占用的数字是“忙”或“正在使用”，直到 MSL 秒过去，在崩溃时，一个时空块被最后一个发出的段的八位字节占据，如果新连接启动得太早并使用前一个连接化身的最后一段的时空足迹中的任何序列号， 存在潜在的序列号重叠区域，这可能会导致接收方混淆。









