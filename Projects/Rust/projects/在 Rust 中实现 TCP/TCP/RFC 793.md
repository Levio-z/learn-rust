### 格式
```
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
                            TCP Header Format  
  
          Note that one tick mark represents one bit position.  
  
                               Figure 3.  
  
  Source Port:  16 bits  
  
    The source port number.  
  
  Destination Port:  16 bits  
  
    The destination port number.
```

### [3.2](https://www.rfc-editor.org/rfc/rfc793.html#section-3.2).  术语

在我们讨论 TCP 的操作之前，我们需要介绍一些详细的术语。**TCP 连接的维护需要记住几个变量。**
我们设想将这些变量存储在称为传输控制块或 TCB 的连接记录中。存储在 TCB 中的变量包括本地和远程套接字号、连接的安全性和优先级、指向用户发送和接收缓冲区的指针、指向 HTTP 队列和当前段的指针。此外，TCB 中还存储了与发送和接收序列号相关的多个变量。
 #### Send Sequence Variables   发送序列变量  
      SND.UNA - send unacknowledged  -发送未确认的
      SND.NXT - send next -发送下一个
      SND.WND - send window -发送窗口
      SND.UP  - send urgent pointer SND.UP -发送紧急指针
      SND.WL1 - segment sequence number used for last window update SND.WL1 -用于上次窗口更新的段序列号
      SND.WL2 - segment acknowledgment number used for last window 
                update SND.WL2 -用于上次窗口更新的段确认号
      ISS     - initial send sequence number -初始发送序列号
   #### 接收序列变量
     RCV.NXT - receive next  -接收下一个
      RCV.WND - receive window RCV.WND -接收窗口
      RCV.UP  - receive urgent pointer RCV.UP -接收紧急指针
      IRS     - initial receive sequence number IRS -初始接收序列号
####  发送序列空间
```
      Send Sequence Space   发送序列空间  
  
                   1         2          3          4
              ----------|----------|----------|----------
                     SND.UNA    SND.NXT    SND.UNA
										 +SND.WND
```
1 -已经确认的旧序列号
2 -未确认数据的序列号
3 -允许用于新数据传输的序列号
4 -还不允许的未来序列号

#### Receive Sequence Space   接收序列空间

```
					  1          2          3
                   ----------|----------|----------
                          RCV.NXT    RCV.NXT
                                    +RCV.WND
```
 1 -已确认的旧序列号2 -允许新接收的序列号3 -尚不允许的未来序列号
 
 接收窗口是图5中标记为2的序列空间的部分。
 
还有一些在讨论中经常使用的变量，它们的值来自当前段的字段。

Current Segment Variables 当前段变量

SEG.SEQ -段序列号
SEG.ACK -段确认号
SEG.LEN -段长度
SEG.WND -段窗口 
SEG.UP -段紧急指针
 SEG.PRC -段优先级值
 
 连接在其生命周期中经历一系列状态。这些国家是：LISTEN、SYN-SENT、SYN-RECEIVED、ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT 和虚构状态 CLOSED。CLOSED 是虚构的，因为它表示没有 TCB 时的状态，因此没有连接。简单地说，状态的含义是：
 LISTEN -表示等待来自任何远程 TCP 和端口的连接请求。
 SYN-SENT -表示在发送连接请求后等待匹配的连接请求。
  SYN-RECEIVED -表示在接收和发送连接请求后等待确认连接请求确认。
  ESTABLISHED -表示一个开放的连接，接收到的数据可以传递给用户。连接的数据传输阶段的正常状态。
### 3.3 序列号

设计中的一个基本概念是，通过 TCP 连接发送的每个八位字节数据都有一个序列号。由于每个二进制八位数都是有序的，因此每个二进制八位数都可以被确认。所采用的确认机制是累积的，使得序列号 X 的确认指示已经接收到**直到不包括 X** 的所有八位字节。该机制允许在存在重传的情况下直接进行重复检测。
- 除了带有 SYN 标志的段之外，段中第一个数据八位字节（byte）的序列号，就是 TCP 报文段头部里的 `Sequence Number` 字段。后续数据八位字节的编号，依次递增。
- 重要的是要记住，实际的序列号空间是有限的，尽管非常大。该空间的范围为0到2**32 - 1。由于空间是有限的，所有处理序列号的算术运算都必须以2**32为模来执行。这种无符号算术保留了序列号从2**32 - 1循环到0时的关系。计算机模运算有一些微妙之处，因此在对此类值的比较进行编程时应非常小心。符号“=<”表示“小于或等于”（模2**32）。
TCP 必须执行的典型序列号比较包括：
- (a)确定确认是指已发送但尚未确认的某个序列号
- 当 TCP 接收到一个 ACK（确认号），它要检查：这个 ACK 是否确认了某个我们曾经发送出去、但还没收到确认的字节？
	- `SND.UNA < ACK <= SND.NXT`
	- `SND.UNA`：发送但未确认的最小序列号
	- `SND.NXT`：下一个要发送的序列号
- (b) 确定由段占用的所有序列号都已被确认
	- 这个操作通常用于重传队列（retransmission queue）。当一个段被完全确认，就可以安全地从重传队列中移除。
	- SND.UNA > SEG.SEQ + SEG.LEN - 1
	- 意思是：段的最后一个字节序列号已经被 ACK 过去。
- (c)确定输入段包含预期的序列号
	- 接收方维护
		- RCV.NXT <= SEG.SEQ < RCV.NXT + RCV.WND
		- 意思是：段必须落在接收窗口内，才能被接受。否则：
		- **太早到（左边）**：已经收到过（可能是重复包）。
		- **太晚到（右边）**：超出窗口，暂时不接受。
	- 接收方基于窗口管理流量，避免接收太多还没处理完的数据。  
	- 滑动窗口（sliding window）通过移动 `RCV.NXT` 实现：一旦确认部分数据，新窗口就向前滑动。
 作为对发送数据的响应，TCP 将接收数据包。需要进行以下比较以处理数据集。
 
   SND.UNA = oldest unacknowledged sequence number 
   SND.UNA =最早的未确认序列号  
   
  SND.NXT = next sequence number to be sent 
  SND.NXT =要发送的下一个序列号  
  
 SEG.ACK = acknowledgment from the receiving TCP (next sequence number expected by the receiving TCP)
  SEG.ACK =来自接收 TCP 的确认（接收 TCP 期望的下一个序列号）  
  
  SEG.SEQ = first sequence number of a segment 
  SEG.SEQ =片段的第一个序列号  
  
 SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN) SEG.LEN =数据段中数据占用的八位字节数（包括 SYN 和 FIN）

SEG.SEQ+SEG.LEN-1 = last sequence number of a segment（一个区段的最后序列号）
个新的确认（称为“可接受的 ack”）是一个下面的不等式成立的确认：
  SND.UNA < SEG.ACK =< SND.NXT
  - 未确认的
  
 A segment on the retransmission queue is fully acknowledged if the sum
  of its sequence number and length is less or equal than the
  acknowledgment value in the incoming segment. 
  如果重传队列上的数据段的序列号和长度之和小于或等于传入数据段中的确认值，则该数据段被完全确认。
 收到数据后，需要进行以下比较：
 
RCV.NXT =传入段上预期的下一个序列号，是接收窗口的左边缘或下边缘
RCV.NXT+RCV.WND-1 =传入段上预期的最后一个序列号，是接收窗口的右边缘或上边缘
SEG.SEQ =传入段占用的第一个序列号
SEG.SEQ+SEG.LEN-1 =传入段占用的最后一个序列号
如果满足以下条件，则判断一个段占用了有效接收序列空间的一部分
    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND  
  or  
    RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

#### 初始的随机序列号

 该协议对反复使用的特定连接没有任何限制。连接由一对套接字定义。连接的新实例将被称为连接的化身。由此产生的问题是--"TCP 如何从以前的连接中识别重复的段？"如果连接被快速连续地打开和关闭，或者如果连接因内存丢失而中断，然后重新建立，则此问题会变得明显。
  
  
 

但协议**允许同一四元组反复使用**（即多个“化身”incarnations）。这就带来问题：

- 如果连接 A 在短时间内关闭，马上又用同一对四元组建立连接 B，  
    那么：
    
    - 老连接 A 的包可能还在网络里（因为网络不是完全可靠、即时的）。
        
    - 新连接 B 用到相同的序列号时，接收方会分不清这是谁的包。
        

**→ 必须保证：新连接的序列号与老连接的不冲突！**

🛠 **ISN 选择机制**
ISN 是 32 位数（0 ~ 2³²-1）。
- 每个主机维护一个 **ISN 生成器**，它绑定到一个虚拟的 32 位“时钟”。
- 这个时钟的最低位 **每约 4 微秒加 1**。
这样：
- 全范围回绕（2³² 次）大约需要 **4.55 小时**。
- 假设网络中段的最大存活时间（MSL, Maximum Segment Lifetime）小于 4.55 小时（RFC 793 设定 MSL = 2 分钟），  
    那么，只要两次连接之间隔了一点时间，ISN 就不会重叠。
换句话说：
```
只要两次连接之间的 ISN 差值 > MSL 内的传输窗口，
即使旧段还在网络里，也不会被误认。

```
**连接建立过程（握手细节）
**
每个连接都有一个发送序列号和一个接收序列号。初始发送序列号（ISS）由数据发送 TCP 选择，并且初始接收序列号（IRS）在连接建立过程期间被学习。
 
 对于要建立或初始化的连接，两个 TCP 必须在彼此的初始序列号上同步。这是在交换连接建立段时完成的，该连接建立段携带称为“SYN”（用于同步）的控制位和初始序列号。作为简写，携带 SYN 位的段也称为“SYN”。因此，该解决方案需要一个合适的机制来挑选初始序列号和稍微涉及的握手来交换 ISN。
 
**始序列号（ISN, Initial Sequence Number）选择与握手机制**，这是 TCP 保证可靠性和连接唯一性的基础之一。

 同步要求每一方发送自己的初始序列号，并从另一方接收确认。每一方还必须接收另一方的初始序列号，并发送确认。
经典 **三次握手**（three-way handshake）其实就是：  
1️⃣ A → B：SYN, ISN = X  
2️⃣ B → A：SYN, ISN = Y; ACK = X + 1  
3️⃣ A → B：ACK = Y + 1

每一方都：  
✅ 告诉对方自己的 ISN，  
✅ 确认收到对方的 ISN。

