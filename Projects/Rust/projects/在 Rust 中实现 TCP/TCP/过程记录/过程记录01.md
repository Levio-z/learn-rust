### 初始化项目
#### step1:在wsl2新建项目
```
cargo new rust-tcp
cargo add tun_tap
```
main.rs
```rust
use tun_tap::{Iface, Mode};

fn main() {

    let iface = tun_tap::Iface::new("tun0", Mode::Tun).unwrap();

    println!("Hello, world!");

    loop {

    let mut buf = [0u8; 1500];

    let len = iface.recv(&mut buf).unwrap();

    println!("Received {} bytes", len);

    println!("{:?}", buf);

    }

}
```
#### step2:设置权限
```
sudo modprobe tun
sudo setcap cap_net_admin=+ep  tcp-rust
getcap tcp-rust
```
- sudo modprobe tun
	- **`tun`**：指定加载 `tun` 模块，也就是 **TUN/TAP 虚拟网络设备驱动**。
- sudo setcap cap_net_admin=+ep  tcp-rust
	- 为文件 `./target/release/my_rust_app` 赋予 `cap_net_admin` 能力，并把它加入 `effective` (e) 和 `permitted` (p) 集。
	- 如果只在 permitted 而不在 effective：  
	- ⚠ 程序要调用 `cap_set_proc()` 等接口，手动启用。

> **`+ep` 是直接启用，程序无需手动提权。

Linux capability 分为三个主要集：

| 集合名                 | 作用                                                |
| ------------------- | ------------------------------------------------- |
| **Permitted (p)**   | 程序被允许使用的能力范围，定义了它有资格执行哪些特权操作。                     |
| **Effective (e)**   | 当前正在生效的能力，只有同时在 permitted 和 effective 中的能力才能实际生效。 |
| **Inheritable (i)** | 当执行 execve() 时，哪些能力可以传递给新程序。                      |
#### step3:启动程序
```rust
cargo run --release
```
#### step4:启动另一个窗口，将tun0绑定到IP地址，运行程序

```
ip addr
9: tun0: <POINTOPOINT,MULTICAST,NOARP> mtu 1500 qdisc noop state DOWN group default qlen 500
    link/none 
```

```
sudo ip addr add 192.168.0.1/24  dev tun0
```
该命令的作用是**给网络接口 `tun0` 添加一个 IP 地址 `192.168.0.1`，子网掩码为 `/24`（即 255.255.255.0）**。
通过这个命令，你将该虚拟接口分配了一个 IP，系统和应用就可以通过 `tun0` 发送/接收数据包。
```
sudo ip link set dev tun0 up
```
该命令的作用是**将网络接口 `tun0` 启用（激活）**，也就是把该设备从“关闭”状态切换到“开启”状态，允许它进行网络通信。
结果：
可以看到程序运行的终端中收到了数据
新建run.sh
```
cargo run --release
sudo setcap cap_net_admin=+ep  target/release/tcp-rust
target/release/tcp-rust &
sudo ip addr add 192.168.0.1/24  dev tun0
sudo ip link set dev tun0 up
fg
```
当你之前用 `&` 把 `tcp-rust` 放后台后，用 `fg` 可以把它重新切回前台，方便交互或查看实时日志。
**作用**：在终端将后台任务（用 `&` 放到后台的程序）**调回前台**运行。

```
chmod +x run.sh
```
给文件 `run.sh` 添加**可执行权限**（`+x`）。
- 你写了一个 Bash 脚本 `run.sh`，默认它只有读写权限，运行会提示权限不足。
    
- 用 `chmod +x run.sh` 后，你可以直接通过 `./run.sh` 执行它。
    
- 这也是让脚本变成“小可执行文件”的标准做法。
启动：
```
./run.sh
```
#### step5:将上面命令设置成脚本文件
```
#!/bin/bash
set -e  # 遇错立即退出，避免执行错误后继续

# 只编译不运行
cargo build --release
sudo ip link delete tun0
# 只需第一次运行时执行，后续可注释
sudo setcap cap_net_admin=+ep target/release/tcp-rust

# 使用 `ip` 命令删除整个设备
if ip link show tun0 > /dev/null 2>&1; then
  echo "tun0 存在，正在删除..."
  sudo ip link delete tun0
else
  echo "tun0 不存在，无需删除"
fi
# 启动程序放后台
./target/release/tcp-rust &
# 把最近启动的后台进程的 PID 存入变量 pid。
pid=$

# 给 tun0 配置 IP
sudo ip addr del 192.168.0.1/24 dev tun0
sudo ip addr add 192.168.0.1/24 dev tun0
sudo ip link set dev tun0 up
# 禁用特定接口上的 IPv6 支持，阻止该接口收发 IPv6 数据包
sudo sysctl -w net.ipv6.conf.tun0.disable_ipv6=1
sudo sysctl -p

# 脚本运行完毕，后台程序继续执行
echo "程序已后台启动，tun0 配置完成"
echo "如果需要查看程序日志，请用: fg 或 jobs 命令"
wait $pid
fg
```
- - `> /dev/null` 把标准输出丢弃了。
	- `/dev/null` 是 Linux/Unix 系统中的“黑洞”设备，所有写入它的内容都会被丢弃（相当于扔进了宇宙黑洞）。
	- 常用来屏蔽不想看到的输出。
- `2>&1` 把标准错误重定向到标准输出。
	- - `2` 代表标准错误（stderr）的文件描述符。
	- `1` 代表标准输出（stdout）的文件描述符。
- 分号 `;` 在 shell 脚本和命令行中的作用，简单来说就是**命令分隔符**，用来把多条命令写在同一行，依次顺序执行。
- `then` 是 **shell 脚本中的关键字**，用在条件判断语句里，作用是标记 **if 判断条件成立后要执行的命令块的开始**。
>查看进程
```
ps aux
```
- `a`：显示所有用户的进程。
    
- `u`：以用户为中心显示（包含用户名、CPU、内存）。
    
- `x`：显示没有控制终端的进程（如守护进程）。
```
top
```


#### step6:安装tshark
```
apt install tshark
```
阿里云
```
sudo yum install -y wireshark-cli
```
- `tshark` 包含在 `wireshark-cli`
抓包：
```
tshark -i tun0
```
问题：抓包表明在ipv6通讯，应该使用ipv4
- 尝试
	- sudo sysctl -w net.ipv6.conf.tun0.disable_ipv6=1
	- 禁用，无作用，抓包失效
- 完全关闭v6
	- /etc/default/grub找到 GRUB_CMDLINE_LINUX
		- 添加参数：ipv6.disable=1
	- sudo grub2-mkconfig -o /boot/grub2/grub.cfg
- 完全禁用
	- sudo sysctl -w net.ipv6.conf.all.disable_ipv6=0
	- sudo sysctl -w net.ipv6.conf.default.disable_ipv6=0
##### 解决抓包是ipv6的问题
1、临时修改优先级
- 查看优先级
```
sysctl net.ipv6.conf.all.disable_ipv6
0
```
- 未禁用
**解决方法：**  
临时降低 IPv6 优先级（无需禁用 IPv6）：
```
echo "precedence ::ffff:0:0/96  100" | sudo tee -a /etc/gai.conf
```
显式还是ipv6通信
2、### **检查 TUN 设备的路由和邻居表**
```
ip -4 addr show dev <tun设备名>    # 确认 IPv4 地址存在
ip -4 route show                  # 检查 IPv4 路由是否指向 TUN
ip -6 route show                  # 检查是否有 IPv6 路由干扰
ip neigh show dev <tun设备名>     # 查看邻居表（ARP/NDP）
```
- ip -4 route show  
	- - **192.168.0.0/24**  
    表示一个 `/24` 网络段，子网掩码 `255.255.255.0`，IP 范围：192.168.0.0–192.168.0.255。
	- **dev tun0**  
	    指定通过 `tun0` 虚拟接口（通常是 VPN 隧道或虚拟网卡）发送。
	- **proto kernel**  
	    同样是内核生成的。
	- **scope link**  
	    链路层范围，仅适用于直接连接。
	- **src 192.168.0.1**  
	    这个虚拟接口分配的源地址。
- ip -6 route show  
	fe80::/64 dev eth0 proto kernel metric 256 pref medium
	fe80::/64 dev tun0 proto kernel metric 256 pref medium
	- 这表示 **IPv6 链路本地地址（Link-Local Address）**，范围是 `fe80::` 到 `fe80::ffff:ffff:ffff:ffff`，子网掩码 `/64`。  注意：链路本地地址 **仅在本链路内有效**，不能被路由器转发，用于本地通信，比如邻居发现（Neighbor Discovery, ND）、路由器通告（RA）。
- ip neigh show dev tun0
	- 没有显式
3、### **禁用 TUN 设备的 IPv6 功能**
```
# 禁用该设备的 IPv6
echo 1 | sudo tee /proc/sys/net/ipv6/conf/<tun设备名>/disable_ipv6

# 禁止接收 IPv6 路由通告
echo 0 | sudo tee /proc/sys/net/ipv6/conf/<tun设备名>/accept_ra
```
- **写入值 `1`**  
	表示关闭（禁用）IPv6 协议在该接口上的功能。
	-  该接口将不再为自身分配 IPv6 地址（包括链路本地 `fe80::`）。  
	- 内核会丢弃经过该接口的 IPv6 流量（即使存在全局 IPv6 路由）。  
	- 相关的 IPv6 协议栈操作（如邻居发现、ICMPv6 处理、SLAAC）会被关闭。
- 测试
```
# 禁用该设备的 IPv6
echo 1 | sudo tee /proc/sys/net/ipv6/conf/tun0/disable_ipv6

# 禁止接收 IPv6 路由通告
echo 0 | sudo tee /proc/sys/net/ipv6/conf/tun0/accept_ra
```
- 结果
	- 成功禁用，但是没有流量了，也没抓到v4的包
4、### **抓包分析实际流量**
```
sudo tcpdump -i <tun设备名> -n
```
- 测试
```
sudo tcpdump -i tun0 -n
```
- 结果
```
[root@iZ0jlfjlrx98bdumf8sdt6Z tcp-rust]# sudo tcpdump -i tun0 -n
dropped privs to tcpdump
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on tun0, link-type RAW (Raw IP), capture size 262144 bytes
```
- dropped privs to tcpdump
	- 安全提示：`tcpdump` 启动时会提权抓包，但随后主动降权到普通用户，以减少被攻击利用的风险。
- listening on tun0, link-type RAW (Raw IP), capture size 262144 bytes
	-  接口 `tun0` 正在监听。  
	- 抓取的包类型是 `RAW`（直接裸 IP 数据包，没有链路层，如以太网帧头）。  
	- 单包最大抓取字节数 262144（可通过 `-s` 参数修改）。
	- 到这里为止，这个输出只是启动信息。⚠️ 它并不表示已经抓到包。
	- 如果一直卡在 `listening on tun0 ...` 后什么都不显示，说明： 
		- `tun0` 上当前没有流量。
		- 或者流量类型没被默认过滤器捕捉到（例如，你只抓 ICMP，但 tun0 上只有 TCP）。
- ping -I tun0 192.168.0.2

| 部分            | 说明                      |
| ------------- | ----------------------- |
| `ping`        | ICMP 回显请求命令，用于测试网络连通性。  |
| `-I tun0`     | 指定网络接口 `tun0` 作为发送源接口。  |
| `192.168.0.2` | 目标 IP 地址，即你希望测试能否到达的对端。 |


- **为什么对端 IP 通常是 192.168.0.2？**
	- 你本地 `tun0` 的 IP 是 `192.168.0.1`，它属于 `192.168.0.0/24` 网段，理论上同网段里可以有 254 个可用 
	- 因为 `tun0` 是点对点，只有两个端点：
		- 本端是 `192.168.0.1`
		- 另一端就是“对端”，通常给 `192.168.0.2`，代表隧道另一侧的设备。
	-  1. 命令结构
- 抓包内容
```
	137 139.264047400 192.168.0.1 → 192.168.0.2 ICMP 84 Echo (ping) request id=0x0003, seq=141/36096, ttl=64
```
- 分析
1. **通信方向**
    
    - `192.168.0.1`（源IP，可能是你的 `tun0` 接口）向 `192.168.0.2`（目标IP）发送了 **ICMP Echo Request（ping 请求）**。
        
2. **协议和细节**
    
    - **ICMP 84**：表示这是一个 84 字节的 ICMP 包（包含 IP 头 + ICMP 负载）。
        
    - **id=0x0003, seq=141**：这是 ping 请求的标识符和序列号，用于匹配请求和响应。
        
    - **ttl=64**：数据包的生存时间（Time To Live），表示该包最多可经过 64 跳（路由器）后丢弃。
        
3. **时间戳**
    
    - `139.264047400` 是该数据包捕获时的相对时间（秒+微秒）。
### 设置脚本收到终止信号同时杀死子进程
#### 脚本里面加入
```
# 捕获 TERM 信号，终止后台进程
trap "kill $pid" TERM
```
#### **使用 `kill` 命令**
找到脚本的进程 ID（PID），然后发送信号：
```
# 查找脚本的 PID（假设脚本名为 my_script.sh）
pgrep -f my_script.sh

# 发送 TERM 信号（默认信号，可省略 -TERM）
kill -TERM <PID>

# 或直接使用 pkill
pkill -f my_script.sh
```

- 上面脚本里面设置了捕获 TERM 信号，终止后台进程，接下来只需要使用这个命令就能关闭程序
```
pkill -f run.sh
```
#### 其他指令
- pgrep -af target
- 查询正在运行的进制
```
root@WIN-UJFSJCVTJTV:~/tcp-rust# pgrep -af target
58273 ./target/release/tcp-rust
```
**逐部分拆解：**

| 部分       | 含义                                                     |
| -------- | ------------------------------------------------------ |
| `pgrep`  | 用于查找符合条件的正在运行的进程，返回匹配的进程号（PID）。                        |
| `-a`     | 显示完整命令行（不仅仅是进程名，还包括执行命令和参数）。                           |
| `-f`     | 用完整命令行匹配关键词，而不仅是进程名。比如：如果命令行中包含 `target`，即使进程名不同也会被匹配。 |
| `target` | 你要搜索的关键词。它可以是二进制文件名、执行参数中的字符串，或者 shell 脚本名字等。          |
#### 修改main函数，测试
1、启动脚本run.sh
```
#!/bin/bash

set -e  # 遇错立即退出，避免执行错误后继续

  

# 只编译不运行

cargo build --release

  

# 只需第一次运行时执行，后续可注释

sudo setcap cap_net_admin=+ep target/release/tcp-rust

  

# 使用 `ip` 命令删除整个设备

if ip link show tun0 > /dev/null 2>&1; then

  echo "tun0 存在，正在删除..."

  sudo ip link delete tun0

else

  echo "tun0 不存在，无需删除"

fi

  

# 启动程序放后台

./target/release/tcp-rust &

# $!最近一个后台执行的命令的 进程 ID（PID）。

# 把最近启动的后台进程的 PID 存入变量 pid。

pid=$!

  
  

# 禁用特定接口上的 IPv6 支持，阻止该接口收发 IPv6 数据包

# 等待 tun0 创建（可适当延迟或轮询）

echo "等待 tun0 设备创建..."

while ! ip link show tun0 > /dev/null 2>&1; do

  sleep 0.1

done

  
  

# 禁用该设备的 IPv6

echo 1 | sudo tee /proc/sys/net/ipv6/conf/tun0/disable_ipv6

  

# 禁止接收 IPv6 路由通告

echo 0 | sudo tee /proc/sys/net/ipv6/conf/tun0/accept_ra

  

# 给 tun0 配置 IP

sudo ip addr add 192.168.0.1/24 dev tun0

sudo ip link set dev tun0 up

# 捕获 TERM 信号，终止后台进程

trap "kill $pid" TERM

  

# 脚本运行完毕，后台程序继续执行

echo ""

echo "程序已后台启动，tun0 配置完成"

echo "fg放到前台执行 bg放到后台执行"

# 等待后台程序结束

wait $pid
```
2、ping -I tun0 192.168.0.2
3、修改main程序
- 获取flags和proto
```rust
use tun_tap::{Iface, Mode};

fn main() {

    let iface = tun_tap::Iface::new("tun0", Mode::Tun).unwrap();

    println!("Hello, world!");

    loop {

        let mut buf = [0u8; 1500];

        let len = iface.recv(&mut buf).unwrap();

        let flags = u16::from_be_bytes([buf[0],buf[1]]);

        let proto = u16::from_be_bytes([buf[2],buf[3]]);

        println!("Received {:?}  flags:{:x}  proto:{:x} bytes,{:?}", len-4,flags,proto,&buf[4..len]);

    }

}
```
4、观察结果
```
Received 84  flags:0  proto:800 bytes,[69, 0, 0, 84, 71, 216, 64, 0, 64, 1, 113, 125, 192, 168, 0, 1, 192, 168, 0, 2, 8, 0, 64, 157, 0, 12, 1, 9, 62, 43, 61, 104, 0, 0, 0, 0, 115, 231, 8, 0, 0, 0, 0, 0, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55]
```
- flags:0
- proto:800
	- IPV4
- - **前两字节 (`buf[0..2]`) → flags**  
    → Linux 内核用来表示该包的额外信息，如是否是多播、广播等。
    
- **接下来的两字节 (`buf[2..4]`) → proto**  
    → 表示包中实际承载的协议类型（EtherType 风格值）。
main.rs 忽略所有不是ipv4的数据包
- 发送时不需要链路层标记

```rust
use tun_tap::Mode;

use std::io;

  

fn main() -> io::Result<()>{

    let iface = tun_tap::Iface::without_packet_info("tun0", Mode::Tun)?;

    let mut buf = [0u8; 1504];

    loop {

        let nbytes = iface.recv(&mut buf).unwrap();

        match etherparse::Ipv4HeaderSlice::from_slice(&buf[..nbytes]) {

            Ok(iph) => {

                let src = iph.source_addr();

                let dst = iph.destination_addr();

                eprintln!("src:{:?}dst:{:?}iph.protocol:{:?}",src.to_string(),dst.to_string(),iph.protocol());

                if iph.protocol() != etherparse::IpNumber::TCP {

                    eprintln!("BAD PROTOCOL");

                    // not tcp

                    continue;

                }

            }

            Err(e) => {

                eprintln!("ignoring weird packet {:?}", e);

            }

        }

    }

}
```
- 使用ping 192.168.0.2
- 协议是1，也就是TCMP协议，ping

✅ `nc`（netcat）是一个万能网络工具，用于在 TCP/UDP 上建立连接、传输数据、监听端口、测试服务。
使用nc发起TCP连接
- nc 192.168.0.2 80
	- 主机向 `192.168.0.2:80` 发起一个 TCP 连接。  
	- 如果连接成功，标准输入（stdin）和该 TCP 连接绑定，你输入的内容会直接发给对端，收到的数据也直接打印在终端。
- 结果
```
src:"192.168.0.1"dst:"192.168.0.2"iph.protocol:6 (TCP - Transmission Control)
```
- 现在我们已经从数据中获取协议的数据
### 为了实现协议我们需要做什么
从报头停止的地方开始，其他地方就是数据

#### 1、编译命令是否成功脚本修改
```
ext=$?           # 保存上一个命令的退出码
echo "Exit code: $ext"

if [[ $ext != 0 ]]; then
    exit $ext    # 如果失败，以相同状态码退出
fi
```
- ext=$?
	- **`$?`** 是 Bash 的特殊变量，表示 **上一个命令的退出状态码**：
		- - `0`：表示成功。  `第 0` 章：
		- 非 `0`（通常是 `1` 或更高）：表示失败。
- **`echo "$ext"`**
	-  **`回显“$ext”
		- - 打印变量 `ext` 的值
- if \[\[ $ext -ne 0 ]];
	- \[\[ ]]是 Bash 的条件测试语法
		- **`[[ ]]` 无需引号包裹变量**
			- `[ ]` 是传统 `test` 命令的别名，对未定义的变量或含空格的值会报错，必须加引号：
		- `[[ ]]` 自动处理特殊字符和空格：
			- ` [[ $name == hello world ]]`   # 无需引号，直接支持
			- 
		- `[[ ]]` 支持 `==`、`!=` 和正则匹配 `=~`：
			- `[ ]` 仅支持基础的 `=` 和 `!=`，且模式匹配需借助外部工具（如 `grep`）。
		- **逻辑运算符更直观**
			- `[[ ]]` 支持 `&&` 和 `||`：  
				- ` [[ $x -gt 1 && $y -lt 10 ]]  # 逻辑 AND`
			- `[ ]` 必须用 `-a` 和 `-o`，且容易与文件测试混淆：
		- `[[ ]]` 内无需转义比较符号`[ ]` 需转义：
			- ` [[ 3 > 2 ]] 前者
			- `[ 3 \> 2 ]` 后者
- 如果失败
	-  **`exit $ext`**
	-  以 `ext` 的值作为脚本的退出状态码终止脚本。
> # set -e  # 遇错立即退出，避免执行错误后继续，适用于简单脚本，上面的内容适用于精确
### 2、分析参加三次握手的过程

- 收到一个接受包会做什么
	- 如果是关闭直接return，但是现在没有关闭
	- 如果是
	- 监听状态
		- 只接受SYN 
	- 发送
		-  snd SYN,ACK
		- 我们首先需要创建TcpHeader
	- 我们首先实现接受者的逻辑
#### 2.1 对状态枚举编码
```
enum State {

    //Listen,

    SynRcvd,

    Estab,

    FinWait1,

    FinWait2,

    TimeWait,

}
```"
:?
