看起来多线程已经完全满足我们的需求，并且它使用也很简单，那么为什么我们还要继续呢？

您也许听说过线程很“重”、上下文切换非常“昂贵”等说法，但是现在，这并不准确，现代的服务器能毫不费力地处理上万的线程。

问题在于阻塞 I/O 将程序的控制权完全交给了操作系统内核，在程序执行完成之前，我们没有任何的干预手段可用，这让我们实现某些操作变得非常困难，比如取消操作和选择操作。
假设我们要实现优雅的服务关停操作。当我们按下 ctrl+c，程序不会马上退出，而是立刻停止接受新的连接请求，当前已建立连接的任务会继续执行，直到完成，或者是 30 秒后被强行终止，最后服务才退出。

在阻塞 I/O 模式下，这里的问题是：**我们的 accept 循环会阻塞，直到下一个连接到来。我们可以在新连接请求被接受之前或之后检查 ctrl+c 信号，如果在处理 accept 时信号进来，我们必须等待下一次连接被接受，这期间只有内核拥有程序完全的控制权。**
- 这是一个 **核心问题**。你无法“半路喊停”一个 `accept()`，也不能用一种干净的方式终止它。
- 操作系统内核拥有控制权，你的程序处于**挂起**状态；
	- 想取消操作？只能借助“黑魔法”：如关闭监听 socket、发信号打断系统调用等，**代价高、逻辑复杂**；
```rust
loop {
    // 调用accept之前检查ctrl+c信号
    if got_ctrl_c() {
        break;
    }

    // **如果ctrl+c在这里发生，会出现什么情况?**
    let (connection, _) = listener.accept().unwrap();

    // 在新的连接被接受之前，这不会被调用
    if got_ctrl_c() {
        break;
    }

    std::thread::spawn(|| /* ... */);
}

```
我们想要的是像 match 操作一样，针对 I/O，同时侦听连接请求和 ctrl+c 信号：