ååº”å™¨æœ‰äº†ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªä»»åŠ¡è°ƒåº¦å™¨æ¥æ‰§è¡Œæˆ‘ä»¬çš„ä»»åŠ¡ã€‚

éœ€è¦è®°ä½çš„æ˜¯ï¼Œä»»åŠ¡è°ƒåº¦å™¨å¿…é¡»æ˜¯å…¨å±€ï¼Œå¹¶ä¸”æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå› ä¸ºå”¤é†’ç¨‹åºæ˜¯ Send çš„ï¼Œè¿™æ„å‘³ç€ wake æ–¹æ³•å¯ä»¥ä»å…¶ä»–çº¿ç¨‹åŒæ—¶è°ƒç”¨ã€‚
```rust
static SCHEDULER: Scheduler = Scheduler { /* ... */ };

#[derive(Default)]
struct Scheduler {
    // ...
}

```
æˆ‘ä»¬å¸Œæœ›èƒ½åƒåˆ›å»ºçº¿ç¨‹é‚£æ ·åœ¨è°ƒåº¦å™¨ä¸Šåˆ›å»ºä»»åŠ¡ã€‚ç›®å‰ï¼Œæˆ‘ä»¬å°†åªç”Ÿæˆä¸è¿”å›ä»»ä½•å†…å®¹çš„ä»»åŠ¡ï¼Œä»¥é¿å…å¿…é¡»å®ç° JoinHandleã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æŒ‰ä¸€å®šçš„é¡ºåºæ’åˆ—è¦æ‰§è¡Œçš„ä»»åŠ¡ï¼Œç”¨ Mutex æ¥ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚
```rust
struct Scheduler {
    tasks: Mutex<Vec<Box<dyn Future + Send>>>
}

impl Scheduler {
    pub fn spawn(&self, task: impl Future<Output = ()> + Send + 'static) {
        self.tasks.lock().unwrap().push(Box::new(task));
    }

    pub fn run(&self) {
        for task in tasks.lock().unwrap().borrow_mut().iter_mut() {
            // ...
        }
    }
}

```
è®°ä½ï¼Œfuture åªåœ¨å®ƒå¯ä»¥æ¨è¿›çš„æ—¶å€™æ‰ä¼šè¢«è½®è¯¢ã€‚å®ƒä»¬åœ¨åˆ›å»ºæ—¶æ€»æ˜¯ä¼šæ¨è¿›ä¸€æ¬¡ï¼Œç„¶åç›´åˆ° wake æ–¹æ³•è¢«è°ƒç”¨æ‰ä¼šè¢«å”¤é†’ã€‚

å®ç°æ–¹æ³•æœ‰å¾ˆå¤šï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä»»åŠ¡åˆ—è¡¨ä¸­å­˜å‚¨ä¸€ä¸ªæ ‡è®°ï¼Œè¡¨ç¤ºä»»åŠ¡æ˜¯å¦å·²è¢«å”¤é†’ï¼Œä½†è¿™æ„å‘³ç€å¿…é¡»éå†ä»»åŠ¡åˆ—è¡¨æ‰èƒ½æ‰¾åˆ°å¯æ‰§è¡Œçš„ä»»åŠ¡ï¼Œè¿™ä»£ä»·å¤ªå¤§äº†ï¼Œè‚¯å®šæœ‰æ›´å¥½çš„æ–¹å¼ã€‚

æˆ‘ä»¬å¯ä»¥åœ¨é˜Ÿåˆ—ä¸­åªä¿å­˜å¯æ‰§è¡Œçš„ä»»åŠ¡ï¼Œè€Œä¸æ˜¯æ‰€æœ‰è¢«åˆ›å»ºçš„ã€‚
```rust
use std::collections::VecDeque;

type SharedTask = Arc<Mutex<dyn Future<Output = ()> + Send>>;

#[derive(Default)]
struct Scheduler {
    runnable: Mutex<VecDeque<SharedTask>>,
}

```
è¿™äº›ç±»å‹å¾ˆå¿«å°±ä¼šæœ‰æ„ä¹‰ã€‚

å½“ä»»åŠ¡è¢«åˆ›å»ºåï¼Œå®ƒå°†ä¼šè¢«åŠ å…¥åˆ°é˜Ÿå°¾ï¼š
```rust
impl Scheduler {
    pub fn spawn(&self, task: impl Future<Output = ()> + Send + 'static) {
        self.runnable.lock().unwrap().push_back(Arc::new(Mutex::new(task)));
    }
}

```
è°ƒåº¦å™¨æŒ¨ä¸ªå¼¹å‡ºä»»åŠ¡å¹¶è°ƒç”¨å®ƒä»¬çš„ poll æ–¹æ³•ï¼š
```rust
impl Scheduler {
    fn run(&self) {
        loop {
            // ä»é˜Ÿåˆ—ä¸­å¼¹å‡ºä¸€ä¸ªå¯æ‰§è¡Œçš„ä»»åŠ¡
            let task = self.runnable.lock().unwrap().pop_front();

            if let Some(task) = task {
                // è°ƒç”¨å®ƒçš„ poll æ–¹æ³•
                task.try_lock().unwrap().poll(waker);
            }
        }
    }

```
è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ç”šè‡³ä¸éœ€è¦äº’æ–¥é”æ¥é”å®šä»»åŠ¡ï¼Œå› ä¸ºä»»åŠ¡åªä¼šç”±ä¸»çº¿ç¨‹è®¿é—®ï¼Œä½†åˆ é™¤å®ƒæ„å‘³ç€ä¸å®‰å…¨ï¼Œä½¿ç”¨ try_lock().unwrap() æ¥å¤„ç†ã€‚
ç°åœ¨ï¼Œæœ€é‡è¦çš„ä¸€ç‚¹ï¼šå”¤é†’å™¨ã€‚æˆ‘ä»¬çš„æ‰§è¡Œé˜Ÿåˆ—æœ€ç²¾åçš„éƒ¨åˆ†å°±æ˜¯ï¼šå½“ä¸€ä¸ªä»»åŠ¡è¢«å”¤é†’ï¼Œå®ƒåªæ˜¯ç®€å•åœ°è¢«æ¨å›é˜Ÿåˆ—ã€‚
```rust
impl Scheduler {
    fn run(&self) {
        loop {
            // ä»é˜Ÿåˆ—ä¸­å¼¹å‡ºä¸€ä¸ªå¯æ‰§è¡Œçš„ä»»åŠ¡
            let task = self.runnable.lock().unwrap().pop_front();

            if let Some(task) = task {
                let t2 = task.clone();

                // åˆ›å»ºä¸€ä¸ªå”¤é†’å™¨ï¼Œå®ƒçš„ä½œç”¨æ˜¯æŠŠä»»åŠ¡æ¨å›é˜Ÿåˆ—
                let wake = Arc::new(move || {
                    SCHEDULER.runnable.lock().unwrap().push_back(t2.clone());
                });

                // è°ƒç”¨è¯¥ä»»åŠ¡çš„ poll æ–¹æ³•
                task.try_lock().unwrap().poll(Waker(wake));
            }
        }
    }
}
****
```
**è¿™å°±æ˜¯ä¸ºä»€ä¹ˆéœ€è¦å¯¹ä»»åŠ¡è¿›è¡Œå¼•ç”¨è®¡æ•°â€”â€”å®ƒçš„æ‰€æœ‰æƒä¸å±äºè°ƒåº¦ç¨‹åºï¼Œå®ƒè¢«é˜Ÿåˆ—å¼•ç”¨ï¼Œä¹Ÿè¢«å­˜å‚¨å”¤é†’ç¨‹åºçš„ä»»ä½•åœ°æ–¹å¼•ç”¨ã€‚**å®é™…ä¸ŠåŒä¸€ä¸ªä»»åŠ¡å¯èƒ½ä¼šåŠ å…¥é˜Ÿåˆ—å¤šæ¬¡ï¼Œå”¤é†’å™¨ä¹Ÿå¯èƒ½åœ¨ä»»ä½•åœ°æ–¹è¢«å…‹éš†ã€‚

ä¸€æ—¦å¤„ç†å®Œäº†æ‰€æœ‰å¯æ‰§è¡Œçš„ä»»åŠ¡ï¼Œååº”å™¨å°†ä¼šè¢«é˜»å¡ï¼Œç›´åˆ°æœ‰å…¶ä»–ä»»åŠ¡å°±ç»ª[5](https://blog.windeye.top/rust_async/learningrustasyncwithwebserver/#%E2%91%A4)ã€‚å½“æ–°çš„ä»»åŠ¡å˜å¾—å°±ç»ªï¼Œååº”å™¨å°†è°ƒç”¨ wake æ–¹æ³•å¹¶å°†è¯¥ future æ¨å…¥ä»»åŠ¡é˜Ÿåˆ—å¹¶æ‰§è¡Œå®ƒï¼Œç»§ç»­å¾ªç¯ã€‚
```rust
pub fn run(&self) {
    loop {
        loop {
            // ä»é˜Ÿåˆ—ä¸­å¼¹å‡ºä¸€ä¸ªå¯æ‰§è¡Œçš„ä»»åŠ¡
            let Some(task) = self.runnable.lock().unwrap().pop_front() else { break };
            let t2 = task.clone();

            // åˆ›å»ºä¸€ä¸ªå”¤é†’å™¨ï¼Œå®ƒçš„ä½œç”¨æ˜¯æŠŠä»»åŠ¡æ¨å›é˜Ÿåˆ—
            let wake = Arc::new(move || {
                SCHEDULER.runnable.lock().unwrap().push_back(t2.clone());
            });

            // è°ƒç”¨è¯¥ä»»åŠ¡çš„ poll æ–¹æ³•
            task.lock().unwrap().poll(Waker(wake));
        }

        // å¦‚æœæ²¡æœ‰å¯æ‰§è¡Œçš„ä»»åŠ¡ï¼Œé˜»å¡ epoll ç›´åˆ°æŸäº›ä»»åŠ¡å˜å¾—å°±ç»ª
        REACTOR.with(|reactor| reactor.wait()); // ğŸ‘ˆ
    }
}


```
æ¼‚äº®ï¼

â€¦â€¦å¿½ç•¥æ··ä¹±çš„ Arc<\Mutex>ã€‚

å¥½ï¼è°ƒåº¦å™¨å’Œååº”å™¨å…±åŒæ„æˆäº†ä¸€ä¸ª future çš„è¿è¡Œæ—¶ã€‚è°ƒåº¦å™¨ä¼šè·Ÿè¸ªå“ªäº›ä»»åŠ¡æ˜¯å¯è¿è¡Œçš„ï¼Œå¹¶è½®è¯¢å®ƒä»¬ï¼Œå½“ epoll å‘Šè¯‰æˆ‘ä»¬å®ƒä»¬æ„Ÿå…´è¶£çš„å†…å®¹å‡†å¤‡å°±ç»ªæ—¶ï¼Œååº”å™¨ä¼šå°†ä»»åŠ¡æ ‡è®°ä¸ºå¯è¿è¡Œã€‚

```rust
trait Future {
    type Output;
    fn poll(&mut self, waker: Waker) -> Option<Self::Output>;
}

static SCHEDULER: Scheduler = Scheduler { /* ... */ };

// è°ƒåº¦å™¨
#[derive(Default)]
struct Scheduler {
    runnable: Mutex<VecDeque<SharedTask>>,
}

type SharedTask = Arc<Mutex<dyn Future<Output = ()> + Send>>;

impl Scheduler {
    pub fn spawn(&self, task: impl Future<Output = ()> + Send + 'static);
    pub fn run(&self);
}

thread_local! {
    static REACTOR: Reactor = Reactor::new();
}

// ååº”å™¨
struct Reactor {
    epoll: RawFd,
    tasks: RefCell<HashMap<RawFd, Waker>>,
}

impl Reactor {
    pub fn new() -> Reactor;
    pub fn add(&self, fd: RawFd, waker: Waker);
    pub fn remove(&self, fd: RawFd);
    pub fn wait(&self);
}

```
æˆ‘ä»¬å·²ç»å†™å¥½äº†è¿è¡Œæ—¶ï¼Œä¸‹é¢å°è¯•ä½¿ç”¨å®ƒã€‚