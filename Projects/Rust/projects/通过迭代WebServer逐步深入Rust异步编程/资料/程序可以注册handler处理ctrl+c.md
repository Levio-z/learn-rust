在操作系统层面：处理信号的定义
>程序为该信号 **注册了一个 handler（处理函数）**，操作系统在发送信号时，不是直接杀死程序，而是先调用这个 handler 让程序自己决定怎么应对。

操作系统 **不需要“猜”程序有没有处理信号**，它只要看程序有没有通过系统调用**注册**过 handler 函数（处理器）。这是一种显式的注册机制。
### ▶ Linux：用 `signal(SIGINT, handler)` 或 `sigaction(...)`

如果没有注册，操作系统采用**默认处理方式** —— 对于 `SIGINT` 就是终止进程。

### ▶ Windows：用 `SetConsoleCtrlHandler(...)`

如果没有设置 handler 来处理 `CTRL_C_EVENT`，操作系统就默认直接终止进程。

### 如何判断程序是否“处理”了 Ctrl+C？
#### 1. Rust 层判断（你写的代码中是否注册了 handler）

**你是否调用了以下任一操作？**

| 方式                                                  | 说明                           |
| --------------------------------------------------- | ---------------------------- |
| `ctrlc::set_handler(...)`                           | 设置了 Ctrl+C 的用户态 handler（跨平台） |
| `tokio::signal::ctrl_c().await`                     | 异步监听 Ctrl+C（使用 Tokio 内部封装）   |
| 调用 `signal_hook` 或 C FFI 手动注册 `signal(SIGINT, ...)` |                              |
如果**你没有注册任何 handler**，就可以断定：
> 程序没有处理该信号，按下 Ctrl+C 时将被操作系统强行终止。

#### 2. 程序运行时观察判断
以下行为说明程序“没有处理 Ctrl+C”：
- 按下 Ctrl+C 后程序 **立即退出**；
- 没有打印任何与 Ctrl+C 相关的日志；
- 没有进行任何资源释放、连接关闭或清理逻辑；
- 没有进入你设定的“优雅退出流程”；
- 调试时发现没有自定义 Ctrl+C handler 被调用。

#### 3. 实际检测方法
### 操作系统如何记录？
- 每个进程都有一个 **signal handler table**（信号处理表），也叫 **signal disposition table**。
- 内核会在这个表中记录：对每个信号（如 SIGINT），是否使用默认动作、忽略、还是调用某个函数地址。
-当收到信号时，内核查表，如果是函数指针，就调用 handler；如果是 `SIG_DFL`（默认），就直接终止；如果是 `SIG_IGN`（忽略），就跳过。