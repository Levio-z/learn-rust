## 🔹1. Goroutine 的定义与本质

### ✅ 定义：

> **Goroutine 是 Go 语言中执行并发任务的基本单位**。它是一个 **由 Go 运行时管理的轻量级线程**，运行于同一地址空间中。

* 通过关键字 `go` 启动
* 自动由 Go runtime 调度到多个 OS 线程上
* 栈很小（初始 2KB），可动态增长（最大 1GB）

 Goroutine 是 Go 并发的基本执行单位
📌 关键词：“基本单位”
每一个并发任务（如处理一个连接、一个请求、一个子任务）都可以在一个 goroutine 中执行。

goroutine 是 Go 的最小调度单元（类似线程对操作系统的最小调度单元）。
 运行于同一地址空间中

- goroutine 共享地址空间，即：
    
    - 所有 goroutine 可以访问相同的变量、堆、堆栈空间。
        
    - 所以它们不是 **多进程**（process）模型，而是更接近线程（但更轻量）。
        
- 因此：
    
    - 不同 goroutine 间要避免共享数据的竞态，推荐使用 **channel** 通信。
        
    - Go 设计哲学：“**不要通过共享内存来通信；要通过通信来共享内存**”。
栈很小（初始 2KB），可动态增长（最大 1GB）
- 每个 goroutine 在创建时只分配 **约 2KB 栈内存**
    
- Go 使用 **分段栈/连续栈机制（当前版本是连续栈）**，在需要时 **自动扩容**
    
- 避免了像 C 语言中线程使用固定栈大小的问题（容易爆栈或浪费内存）
实现细节（简要）
- 栈增长依靠运行时探测机制（函数调用时检查是否还有空间）
    
- 调用深度变大时，会触发 `morestack` 的栈拷贝逻辑
    
- 栈内数据会被**移动**，指针会被修正

不是说 goroutine 就是一个线程，而是它具备“线程的大部分语义能力”，但却更加轻量：

|方面|含义|
|---|---|
|轻量的创建|创建成本低，无需系统调用|
|轻量的切换|切换代价低，不需要陷入内核|
|轻量的栈|栈很小，可按需自动增长|
|轻量的通信|使用 channel，天然支持 CSP 并发模式|

* * *

## 🔹2. 为什么不是叫 Thread 或 Coroutine？

传统术语含义不准：

| 术语                   | 含义或典型实现                   | 为什么不准确用于 Go                 |
| -------------------- | ------------------------- | --------------------------- |
| Thread               | OS 级线程，一般几 MB 栈，调度成本高     | Goroutines 栈更小，可成千上万个       |
| Coroutine            | 通常手动 yield，协作式调度          | Go 是 **抢占式调度**（从 Go 1.14 起） |
| Fiber / Green Thread | 用户空间调度线程，通常与 coroutine 接近 | Go 更抽象、自动调度                 |

所以 Go 发明了“**goroutine**”这个新词，强调其 **并发模型的独特性与轻量级**。

* * *

## 🔹3. 工作原理：M:N 调度模型



Go 使用 **M:N 调度模型**：

> 多个 Goroutines (G) 会被调度到更少的 OS Threads (M) 上，这些线程由若干个调度器 (P) 协助管理。

#### Go 调度器的三部分结构：

* **G（Goroutine）**：要运行的协程任务
    
* **M（Machine）**：实际的操作系统线程
    
* **P（Processor）**：调度器上下文，决定当前线程运行哪些 G
    

这个模型称为 **GMP 模型**，由 `runtime` 包中的调度器负责实现。
- Go 会自动将多个 goroutines 分配到可用的 M 上运行。
    
- 一个 M 在任一时刻只能执行一个 G。
    
- 多个 M 可以运行在多核 CPU 上，实现**真正并发**。
* * *

## 🔹4. 启动 Goroutine 的语法和示例

```go
go list.Sort()  // 异步执行 list.Sort，不等待
```
- 该函数会“异步”执行
    
- 当前函数不会等待它完成
    
- goroutine 结束时**自动销毁**（除非泄露）

### 函数字面量 + goroutine：

```go
go func() {
    time.Sleep(delay)
    fmt.Println(message)
}()
```

* 结尾的 `()` 很关键，表示**立即调用匿名函数**
    
* 匿名函数闭包可捕获外部变量
    

* * *

## 🔹5. Goroutine 是闭包（Closure）

在 Go 中，**函数字面量就是闭包**，意味着：

* 外部变量的引用会被“捕获”
    
* 捕获的变量在 goroutine 存活期间不会被释放
    

例子：

```go
func Announce(msg string) {
    go func() {
        fmt.Println(msg)  // msg 被闭包捕获
    }()
}
```

注意：

* 被捕获的是**变量引用**，不是值拷贝
    
* 并发访问可能引起 **数据竞争**
    

* * *

## 🔹6. 通常还需要 Channels

如文中所说，goroutine 默认**没有返回值**，无法通知外部“我执行完了”，所以需要：

> **Channels**：用于 goroutine 之间的同步、通信、完成信号传递

示例：

```go
done := make(chan bool)

go func() {
    time.Sleep(1 * time.Second)
    fmt.Println("Done!")
    done <- true
}()

<-done  // 等待 goroutine 完成
```

* * *

## 🔹7. 使用场景

* 并发网络服务（如 HTTP 服务器中的每个连接）
    
* 并发数据处理（如 map-reduce）
    
* 延迟异步任务（如缓存失效后刷新）
    
* 可组合并发组件（配合 channel 构建 pipeline）
    

* * *

## 🔹8. 源码及调度机制分析（简要）

Go 的调度器实现于 `runtime/proc.go`，核心包括：

* **`newproc`**：启动 goroutine 的入口
    
* **`schedule`**：调度器主循环，选择哪个 G 运行
    
* **`gosched`**：主动让出 CPU（让其他 G 有机会运行）
    
* **`findrunnable`**：寻找下一个可以运行的 G
    

调度器通过 P 中的本地队列、全局队列、抢占机制、work stealing 等策略，保证高并发时依然高效。

* * *

## 🔹9. 扩展对比：Goroutine vs 其他模型

| 模型 | 栈大小 | 调度方式 | 是否抢占 | 启动成本 | 是否用户空间 |
| --- | --- | --- | --- | --- | --- |
| Goroutine | 起始2KB，可增长 | GMP调度器 | 是 | 非常低 | 是 |
| Thread (C/Java) | 通常几MB | OS调度 | 是 | 较高 | 否 |
| Coroutine (Python) | 固定小栈 | 手动yield | 否 | 较低 | 是 |
| async/await (JS) | 无栈 | 事件循环 | 否 | 较低 | 是 |

* * *

## 🔹10. 小结与记忆要点

| 点位 | 内容 |
| --- | --- |
| 🧠 名称 | goroutine ≠ thread ≠ coroutine |
| ⚙️ 模型 | GMP调度器，M:N映射 |
| 📦 栈 | 起始2KB，按需增长至最大1GB |
| 🧵 调度 | 抢占式调度，从 Go 1.14 起默认启用 |
| 🔄 通信 | 推荐配合 channel 使用 |
| 💡 特点 | 启动快、内存省、百万并发非梦 |

* * *

如你有兴趣，我可以继续深入讲解以下内容（可选择）：

1. `runtime.newproc` 源码分析（启动 goroutine 的底层机制）
    
2. GMP 模型的模拟调度图与具体栈切换过程
    
3. Go 调度器的抢占点插入原理（从 Go 1.14 开始的 signal-based 抢占）
    
4. `channel` 的底层结构及 select 语义
    

欢迎指定深入方向！