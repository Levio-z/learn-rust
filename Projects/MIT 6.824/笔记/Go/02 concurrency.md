由于实现对共享变量的正确访问所需的微妙之处，许多环境中的并发编程变得困难。Go 鼓励一种不同的方法，在这种方法中，**共享值在通道上传递，事实上，从不由单独的执行线程主动共享**。**在任何给定的时间，只有一个协程可以访问该值。根据设计，数据争用不会发生**。为了鼓励这种思维方式，我们将其简化为一句口号：

不要通过共享内存进行通信;相反，通过通信共享内存。

这种方法可能走得太远了。例如，最好通过在整数变量周围放置一个互斥锁来完成引用计数。但作为一种高级方法，使用通道来控制访问可以更轻松地编写清晰、正确的程序。

考虑此模型的一种方法是考虑在一个 CPU 上运行的典型单线程程序。它不需要同步原语。现在运行另一个这样的实例;它也不需要同步。现在让这两个人交流;如果通信是同步器，则仍然不需要其他同步。例如，Unix 管道非常适合此模型。尽管 Go 的并发方法起源于 Hoare 的 Communicating Sequential Processes （CSP），但它也可以看作是 Unix 管道的类型安全泛化。

- 在单核 CPU 上，一个程序是顺序执行的。变量之间的操作天然是**严格有序**的：
	- 没有并发，就没有共享状态的问题，所以也不需要锁或原子操作。
- 「多个单线程程序之间也不需要同步（如果不共享内存）」
	- 即使你跑 10 个这样的程序，只要它们**不共享内存或资源**，也仍然不需要同步：
	- // 每个进程维护自己的私有内存、计数器、文件描述符等
	- 这就是 **并发中的隔离性（isolation）原则**。
- 「只要通信机制本身是同步器，就不需要额外同步」
	- `chan` 本身就是同步点（阻塞点）
	- 所以无需其他锁、条件变量、信号量
	- 通信完成的瞬间，就是**数据一致性点**
	- 这种机制是 **同步通信（synchronous communication）**，天然就解决了**数据同步、内存可见性、状态一致性**等问题。
- Go 的并发模型：类型安全的 Unix 管道泛化
	- Unix 管道本质上是这样的模型：
		- 模型：`[进程1 stdout] → pipe → [进程2 stdin]`
		- 数据以字节流的形式，在进程间同步传递。你无法误传指针、结构体；你也无法控制数据结构或类型。\
	- 而 **Go 的 channel 更进一步**：
		- 强类型化：`chan int` vs `chan string`
		- goroutine 轻量协程：可千万级别
		- channel 是语言内建的一等类型
		- 通信和同步是一体的，不可分割
	- Go 中的 channel 是「**类型安全的、在内存中的、轻量的、内建的同步管道**」，也是 CSP（Communicating Sequential Processes）模型的现代实现。
	- 如果你设计 Go 并发程序，**优先使用 channel** 来组织 goroutine 之间的协作。
		- 避免过度共享变量，尽量通过 channel 传递数据和控制信息。
	- 不用担心“锁死、资源一致性、并发写入”等传统并发问题，channel 自带同步。