- 什么是分布式系统？
	- 为大型网站、MapReduce、点对点共享和大量关键基础设施分配的多台协作计算机存储
- 人们为什么要构建分布式系统？
	- 通过并行性增加容量 通过复制容忍故障 将计算物理上靠近外部实体 通过隔离实现安全性
- 但是：许多并发部分，复杂的交互必须应对棘手的部分故障才能实现性能潜力
- 为什么要参加这门课程？
	- 有趣 -- 难题
	- 真实系统使用的强大解决方案 -- 由大型网站的兴起推动 
	- 活跃的研究领域 -- 重要的未解决的问题 
	- 动手实践 -- 你将在实验室中构建真实的系统
- 课程结构
	- 课程内容：讲座试卷、两篇考试、实验、期末项目（可选）
	- 讲座：大创意、论文讨论和实验将录制视频，可在线获取
	- 论文：研究论文，一些经典，一些新问题，思路，实现细节，评价 很多讲座重点论文 请在课前阅读论文！每篇论文都有一个简短的问题供您回答，我们要求您在讲座开始前向我们发送您关于论文 submit Question&Answer 的问题
	- 考试： 课堂期中考试 期末考试 期末考试周 主要关于论文和实验
	- 实验： 目标： 对一些重要技术有更深入的理解 目标： 分布式编程经验 第一个实验的截止日期为从周五开始的一周内，之后每周一次，持续一段时间
		- 实验 1：MapReduce 实验 2：使用 Raft 进行容错复制 实验 3：容错键/值存储 实验 4：分片键/值存储
		- 最后的可选期末项目，以 2 或 3 人为一组。最终项目将替代 Lab 4。您考虑一个项目并与我们一起完成它。最后一天的代码、短文、短演示。
		- 实验室成绩取决于您通过的测试用例数量，我们会为您提供测试，以便您知道自己是否会取得好成绩
		- 调试实验室可能很耗时 尽早开始 来到 TA 办公时间 在 Piazza 上提问
	- 这是一门关于应用程序基础设施的课程。*存储。*通信。*计算。
	- 大目标：隐藏分发复杂性的抽象。在我们的搜索中，有几个主题会反复出现。
		- 主题：容错 1000 多台服务器，大网络 -> 总是有问题 我们想向应用程序隐藏这些故障。我们经常希望： 可用性 -- 应用程序可以在故障中继续前进 可恢复性 -- 当故障得到修复时，应用程序将恢复生机 大创意：复制服务器。如果一个服务器崩溃，可以使用另一个服务器继续。非常难以找到合适的服务器可能没有崩溃，但对于某些人来说无法访问，但仍为来自客户端的请求提供服务 实验 1、2 和 3
		- 主题：一致性 通用基础设施需要明确定义的行为。例如，“Get（k） 产生来自最近 Put（k，v） 的值。实现良好的行为是很难的！“副本” 服务器很难保持相同。
		- 主题：性能 目标：可扩展的吞吐量 Nx 服务器 -> 通过并行 CPU、磁盘、网络实现 Nx 总吞吐量。随着 N 的增长，扩展变得越来越困难：负载不平衡、落后、N 延迟中最慢。不可并行化的代码：初始化、交互。来自共享资源（例如网络）的瓶颈。一些性能问题不容易通过扩展来解决，例如，单个用户请求的快速响应时间，例如，所有用户都希望更新相同的数据，通常需要更好的设计，而不仅仅是更多的计算机 实验室 4
		- 主题：容错、一致性和性能是敌人。强容错性需要通信，例如，将数据发送到备份 强一致性需要通信，例如 Get（） 必须检查最近的 Put（）。许多设计仅提供弱一致性以提高速度。例如，Get（） 不会生成最新的 Put（）！这对应用程序程序员来说很痛苦，但可能是一个很好的权衡。在一致性/性能范围内，许多设计点都是可能的！
		- 主题：实现 RPC、线程、并发控制。实验室...
- 背景
	- 史背景 局域网和互联网应用程序（自 1980 年代以来） 10-100 年代的机器： AFS 互联网规模的应用程序：DNS 和电子邮件 数据中心（1990 年代末/2000 年代初） 拥有众多用户（数百万）和大量数据的网站 Google、Yahoo、Facebook、Amazon、Microsoft 等。早期应用：网页搜索、电子邮件、购物等。酷炫有趣的系统爆炸式增长 > 1000 多台机器 系统主要用于内部使用，工程师撰写了有关它们的研究论文 云计算 用户将计算/存储外包给云提供商 用户在云上运行自己的大型网站 用户运行大量数据的大型计算（例如，机器学习） => 许多面向用户的新分布式系统基础设施 当前状态： 学术界和工业界非常活跃的研发领域很难跟上！6.824 论文中的一些系统已经过时，但概念仍然相关 6.824：重容错/存储，但也涉及通信和计算
	- 让我们以 MapReduce （MR） 为例来讨论，它很好地说明了 6.824 的主要主题，对实验 1 的重点产生了巨大影响
	- MapReduce 概述 上下文：对数 TB 数据集进行数小时计算，例如构建、搜索、索引、排序或分析 Web 结构，仅适用于 1000 多台计算机 应用程序不是由分布式系统专家编写 总体目标：对于非专业程序员来说很容易 程序员只定义 Map 和 Reduce 函数 通常相当简单 顺序代码 MR 负责和隐藏， 分发的所有方面！
	- MapReduce 作业输入的抽象视图（已经）拆分为 M 个文件 Input1 -> Map -> a，1 b，1 Input2 -> Map -> b，1 Input3 -> Map -> a，1 c，1 | | | |-> 减少 -> c，1 |-----> Reduce -> b，2 ---------> Reduce -> a，2 MR 为每个输入文件调用 Map（），生成一组 k2，v2 “中间”数据 每个 Map（） 调用都是一个“任务” MR 收集给定 k2 的所有中间 v2，并将每个键 + 值传递给 Reduce 调用，最终输出是来自 Reduce（） 的 <k2，v3> 对的集合
		- 示例：字数输入是数千个文本文件 Map（k， v） 将 v 拆分为每个单词的单词 w emit（w， “1”） Reduce（k， v） emit（len（v））
	- MapReduce 扩展性好：N 台“worker”计算机可为您提供 Nx 吞吐量。Maps（） 可以并行运行，因为它们不交互。Reduce（） 也是如此。因此，您可以通过购买更多计算机来获得更多吞吐量。
	- MapReduce 隐藏了许多细节： 将应用程序代码发送到服务器，跟踪已完成哪些任务 将数据从 Maps 移动到 Reducing 平衡服务器之间的负载，从故障中恢复
	- 但是，MapReduce 限制了应用程序可以做的事情：没有交互或状态（除了通过中间输出）。无需迭代，无需多阶段管道。没有实时或流式处理。
	- 输入和输出存储在 GFS 集群文件系统上，MR 需要巨大的并行输入和输出吞吐量。GFS 将文件拆分到多个服务器上，以 64 MB 的块为单位 并行读取地图 减少并行写入 GFS 还可以在 2 或 3 台服务器上复制每个文件 拥有 GFS 是 MapReduce 的一大胜利