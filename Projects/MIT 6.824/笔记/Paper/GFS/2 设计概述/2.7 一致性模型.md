GFS 有一个宽松的一致性模型，可以很好地支持我们高度分布式的应用程序，但实现起来仍然相对简单和高效。现在我们讨论 GFS 的保证及其对应用程序的意义。 我们还强调了 GFS 如何维护这些保证，但将细节留给论文的其他部分。

### 2.7.1  GFS 的保证
文件命名空间突变（例如，文件创建）是原子的。
它们由主节点独占处理：
- 命名空间锁定保证原子性和正确性（第 4.1 节）;
- 主操作日志定义了这些操作的全局总顺序（第 2.6.3 节）。

数据突变后文件区域的状态取决于突变的类型、是否成功或失败以及是否存在并发突变。表 1 总结了结果。如果所有客户端始终看到相同的数据，则无论它们从哪个副本读取，则文件区域是一致的。如果文件数据突变一致，则在文件数据突变之后定义区域，客户端将看到突变写入的完整内容。
- 当突变成功而不受并发写入器的干扰时，**将定义受影响的区域（并且隐含一致）：所有客户端将始终看到突变写入的内容。**
- 并发成功的突变使区域未定义但一致：**所有客户端都看到相同的数据，但它可能无法反映任何一个突变所写的内容。通常，它由来自多个突变的混合片段组成。**？？
- 失败的突变会使区域不一致（因此也是未定义的）：不同的客户端可能会在不同的时间看到不同的数据。


![](asserts/Pasted%20image%2020250808205904.png)

我们在下面描述我们的应用程序如何区分已定义区域和未定义区域，但它可能无法反映任何一个突变所写的区域。应用程序不需要进一步区分不同类型的未定义区域。

数据突变可以是写入或记录追加。
- 写入会导致在应用程序指定的文件偏移量处写入数据。记录附加会导致数据（“记录”）至少以原子方式附加一次，即使在存在并发突变的情况下，但与 GFS 的选择相偏（第 3.3 节）。
- （相反，“常规”追加只是客户端认为是文件当前末尾的偏移量的写入。
- 偏移量将返回给客户端，并标记包含记录的已定义区域的开始。此外，GFS 可能会在两者之间插入填充或记录重复项。它们占据被认为不一致的区域，并且通常与用户数据量相比相形见绌。

在一系列成功的突变之后，可以保证定义突变的文件区域并包含最后一个突变写入的数据。GFS 通过 （a） 在其所有副本上以相同的顺序将突变应用于块（第 3.1 节），以及 （b） 使用块版本号来检测任何因在其块服务器关闭时错过突变而变得过时的副本（第 4.5 节）来实现这一点。过时的副本永远不会参与突变或提供给请求主服务器块位置的客户端。 它们是尽早收集的垃圾。

**由于客户端缓存块位置，因此它们可能会在刷新该信息之前从过时的副本中读取**。此窗口受缓存条目的超时和文件的下一次打开的限制，该文件会从缓存中清除该文件的所有块信息。**此外，由于我们的大多数文件都是仅附加的，因此过时的副本通常会返回过早的块结束，而不是过时的数据。 当读取器重试并联系主服务器时，它将立即获取当前块位置。**


**在成功突变很久之后，组件故障当然仍然会损坏或破坏数据。GFS 通过主服务器和所有块服务器之间的定期握手来识别失败的块服务器，并通过校验和检测数据损坏（第 5.2 节）**。一旦出现问题，数据就会尽快从有效副本中恢复（第 4.3 节）。只有当块的所有副本在 GFS 做出反应之前（通常在几分钟内）丢失时，块才会不可逆地丢失。即使在这种情况下，它也会变得不可用，而不是损坏：应用程序收到明显的错误而不是损坏的数据。

### 2.7.2 对应用的影响
GFS 应用程序可以通过一些其他目的已经需要的简单技术来适应宽松的一致性模型：依赖追加而不是覆盖、检查点和写入自我验证、自我识别的记录。

几乎我们所有的应用程序都通过附加而不是覆盖来改变文件。在一种典型用法中，写入器从头到尾生成文件。它在写入所有数据后以原子方式将文件重命名为永久名称，或定期检查已成功写入的数量。

检查点还可以包括应用程序级校验和？？。 **读取器仅验证和处理文件区域，直到最后一个检查点，已知该检查点处于定义状态**。无论一致性和并发性问题如何，这种方法都对我们很有帮助。 与随机写入相比，追加效率更高，对应用程序故障的复原能力也更强

检查点允许写入器以增量方式重启，并防止读取器处理从应用程序的角度来看仍然不完整的成功写入的文件数据。

在另一种典型用法中，许多写入器同时追加到文件以获得合并结果或作为生产者-使用者队列。Record append 的至少一次追加语义保留每个编写器的输出。 读者处理偶尔的填充和重复项如下。编写器准备的每条记录都包含校验和等额外信息，以便可以验证其有效性。 读取器可以使用校验和来识别和丢弃额外的填充并记录片段。 如果它不能容忍偶尔出现的重复（例如，如果它们会触发非幂等作），它可以使用记录中的唯一标识符过滤掉它们，无论如何，通常都需要这些标识符来命名相应的应用程序实体，例如 Web 文档。这些记录 I/O 功能（重复移除除外）位于我们的应用共享的库代码中，适用于 Google 的其他文件界面实现。这样，相同的记录序列以及罕见的重复项始终被传送到记录阅读器。

