删除文件后，GFS 不会立即回收可用的物理存储。它仅在文件和块级别的常规垃圾回收期间延迟执行此作。我们发现这种方法使系统更加简单和可靠。

### 4.4.1 机制
当应用程序删除文件时，主服务器会像其他更改一样立即记录删除。但是，该文件不会立即回收资源，而是将文件重命名为包含删除时间戳的隐藏名称。在主服务器对文件系统命名空间的定期扫描期间，如果这些文件已经存在超过三天，它会删除任何此类隐藏文件（间隔是可配置的）。在此之前，该文件仍可以新的特殊名称读取，并且可以通过将其重命名回正常名称来取消删除。从命名空间中删除隐藏文件时，其内存中元数据将被删除。这有效地切断了它与所有块的链接。

在对块命名空间的类似常规扫描中，主节点识别孤立块（即无法从任何文件访问的块）并擦除这些块的元数据。在定期与主服务器交换的 HeartBeat 消息中，每个块服务器都会报告其拥有的块的子集，并且主服务器会回复主服务器元数据中不再存在的所有块的标识。chunkserver 可以自由删除其此类块的副本。

### 4.4.2 讨论

尽管分布式垃圾收集是一个难题，需要在编程语言的上下文中进行复杂的解决方案，但在我们的例子中它非常简单。**我们可以轻松识别对块的所有引用：它们位于由主服务器独占维护的文件到块映射中**。我们还可以轻松识别所有块副本：它们是每个块服务器上指定目录下的 Linux 文件。任何主服务器不知道的此类复制品都是“垃圾”。

与预先删除相比，存储回收的垃圾回收方法具有多种优势。
首先，**在组件故障常见的大规模分布式系统中，它简单可靠**。**垃圾回收提供了一种统一且可靠的方法来清理任何未知的副本。**
- 块创建可能在某些块服务器上成功，但在其他块服务器上则不成功，从而留下主服务器不知道存在的副本。
- 副本删除消息可能会丢失，主服务器必须记住在失败时重新发送它们，包括它自己的和块服务器的。


**其次，它将存储回收合并到主服务器的常规后台活动中，例如命名空间的定期扫描和与块服务器的握手**。
- **因此，它是分批完成的，成本是摊销的。而且，只有在主人相对自由的时候才会这样做。主设备可以更及时地响应需要及时关注的客户请求**。

第三，**回收存储的延迟提供了防止意外、不可逆转删除的安全网**。

根据我们的经验，主要缺点是**延迟有时会阻碍用户在存储紧张时微调使用情况的努力**。重复创建和删除临时文件的应用程序可能无法立即重复使用存储。

策略：
- 如果再次显式删除已删除的文件，我们通过加快存储回收来解决这些问题。
- 我们还允许用户将**不同的复制和回收策略**应用于命名空间的不同部分。
	- 例如，用户可以指定将某个目录树中文件中的所有块存储而不复制，并且任何已删除的文件都会立即不可撤销地从文件系统状态中删除。
