主服务器执行所有命名空间操作。此外，它还管理整个系统的块副本：它做出放置决策，创建新块，从而创建副本，并协调各种系统范围的活动以保持块完全复制，平衡所有块服务器之间的负载，并回收未使用的存储。我们现在讨论这些主题中的每一个。

许多主作可能需要很长时间：例如，快照作必须撤销快照覆盖的所有块的块服务器租约。我们不想在其他主作运行时延迟它们。因此，我们允许多个作处于活动状态，并对命名空间的区域使用锁来确保正确的序列化。

与许多传统文件系统不同，GFS 没有列出该目录中所有文件的每个目录数据结构。它也不支持同一文件或目录的别名（即 Unix 术语中的硬链接或符号链接）。**GFS 在逻辑上将其命名空间表示为将完整路径名映射到元数据的查找表。通过前缀压缩，可以在内存中有效地表示此表。命名空间树中的每个节点（绝对文件名或绝对目录名）都有一个关联的读写锁。**

每个主操作在运行之前都会获取一组锁。通常，如果它涉及 /d1/d2/.../dn/leaf，它将获取目录名称 /d1、/d1/d2、...、/d1/d2/.../dn 的读锁，以及完整路径名 /d1/d2/.../dn/leaf 的读锁或写锁。请注意，叶可能是文件或目录，具体取决于作。

现在，我们说明了这种锁定机制如何防止在将 /home/user 快照到 /save/user 时创建文件 /home/user/foo。 快照作获取 /home 和 /save 上的读取锁，以及 /home/user 和 /save/user 上的写入锁。文件创建获取 /home 和 /home/user 上的读取锁，以及 /home/user/foo 上的写入锁。这两个作将正确序列化，因为它们试图获取 /home/user 上的冲突锁。文件创建不需要对父目录进行写锁，因为没有“目录”或类似 inode 的数据结构可以防止修改。名称上的读取锁足以保护父目录不被删除。

**这种锁定方案的一个很好的属性是它允许在同一目录中并发突变**。例如，可以在同一目录中同时执行多个文件创建：每个文件创建都获取目录名的读锁和文件名的写锁。目**录名称的读取锁足以防止删除、重命名或快照目录。写锁定**多个文件创建可以在同一目录中同时执行：每个文件创建都获取目录名的读锁和文件名的写锁 File Names Serialize 尝试创建具有相同名称的文件两次。

由于命名空间可以有许多节点，因此读写锁对象会延迟分配，并在不使用时删除。 此外，锁以一致的总顺序获取，以防止死锁：它们首先在命名空间树中按级别排序，并在同一级别内按字典顺序排序。



