我们设计该系统是为了最大限度地减少船长对所有作的参与。有了这个背景，我们现在描述客户端、主服务器和块服务器如何交互以实现数据突变、原子记录追加和快照。

**突变是更改块的内容或元数据的操作，例如写入或追加操作。每个突变都在块的所有副本上执行**。我们**使用租约来保持副本之间的一致突变顺序。主服务器向其中一个副本授予块租约，我们称之为主副本**。**主数据库为块的所有突变选择一个序列顺序。应用突变时，所有副本都遵循此顺序**。因此，全局突变顺序首先由主服务器选择的租赁授予顺序定义，并在租赁中由主服务器分配的序列号定义。

租约机制旨在最大程度地减少主机的管理开销。**租约的初始超时为 60 秒。但是，只要块正在变异，主节点就可以无限期地请求并通常接收来自主节点的扩展**。这些扩展请求和授权是根据主服务器和所有块服务器之间定期交换的 HeartBeat 消息进行的。主节点有时可能会尝试在租约到期之前撤销租约（例如，当主节点想要禁用正在重命名的文件上的突变时）。即使主服务器失去与主服务器的通信，它也可以在旧租约到期后安全地向另一个副本授予新租约。

在图 2 中，我们通过遵循这些编号步骤的写入控制流来说明此过程。
![](asserts/Pasted%20image%2020250808212300.png)
1. 客户端询问主服务器哪个块服务器持有该块的当前租约以及其他副本的位置。如果没有人有租约，则主将租约授予它选择的副本（未显示）。
2. 主副本回复主副本的身份和其他（辅助）副本的位置。 客户端缓存此数据以备将来突变。只有当主服务器变得无法访问或回复它不再持有租约。
3. 客户端将数据推送到所有副本。客户端可以按任何顺序执行此作。每个块服务器都会将数据存储在内部 LRU 缓冲区缓存中，直到数据被使用或老化。通过将数据流与控制流解耦，我们可以通过根据网络拓扑调度昂贵的数据流来提高性能，而不管哪个块服务器是主块服务器。第 3.2 节进一步讨论了这一点。
4. 一旦所有副本都确认接收数据，客户端就会向主副本发送写入请求。该请求标识之前推送到所有副本的数据。 主服务器为它接收的所有突变分配连续的序列号，可能来自多个客户端，这提供了必要的序列化。它按序列号顺序将突变应用于自己的本地状态。
5. 主副本将写入请求转发到所有次要副本。每个次要副本都按照主副本分配的相同序列号顺序应用突变。
6. 辅助服务器都回复主服务器，表示他们已经完成了操作。
7. 对客户的主要回复。在任何副本上遇到的任何错误都会报告给客户端。如果出现错误，写入可能在主副本和次要副本的任意子集上成功。 （如果它在主服务器上失败，则不会为其分配序列号并转发。客户端请求被视为失败，修改后的区域处于不一致状态。 我们的客户端代码通过重试失败的突变来处理此类错误。 它将在步骤 （3） 到 （7） 中进行几次尝试，然后从写入开始回退到重试。

如果应用程序的写入很大或跨越一个块，主服务器将一个块授予它选择的（未显示）边界，GFS 客户端代码会将其分解为多个写入操作。它们都遵循上述控制流，但可能会与其他客户端的并发作交错并被覆盖。因此共享文件区域最终可能包含来自不同客户端的片段，尽管副本将是相同的，因为各个操作在所有副本上以相同的顺序成功完成。这会使文件区域处于一致但未定义的状态，如第 2.7 节中所述。



