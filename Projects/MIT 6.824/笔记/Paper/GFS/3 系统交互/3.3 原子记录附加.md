GFS 提供了一个称为 record append 的原子追加操作。在传统写入中，客户端指定要写入数据的偏移量。 对同一区域的并发写入不可序列化：该区域最终可能包含来自多个客户端的数据片段。但是，在记录追加中，客户端仅指定数据。**GFS 以 GFS 选择的偏移量将其至少原子地附加到文件中一次（即，作为一个连续的字节序列），并将该偏移量返回给客户端。这类似于在 Unix 中写入以 O APPEND 模式打开的文件，当多个写入器同时这样做时，没有竞争条件。**

我们的分布式应用程序大量使用记录追加，其中不同计算机上的许多客户端同时附加到同一个文件。 客户端将需要额外复杂且昂贵的同步，例如，如果他们**使用传统写入进行同步，则通过分布式锁管理器。在我们的工作负载中，此类文件通常客户端将需要额外的复杂且昂贵的同步**，充当多生产者/单消费者队列，或包含来自许多不同客户端的合并结果。

记录追加是一种突变，遵循第 3.1 节中的控制流，在主节点上只有一点额外的逻辑。
- 客户端将数据推送到文件最后一个块的所有副本然后，将其请求发送到主数据库。
- 主检查将记录追加到当前块是否会导致块超过最大大小 （64 MB） 。
	- 如果是这样，它会将块填充到最大大小，告诉辅助数据库执行相同的操作，并回复客户端，指示应在下一个块上重试操作。（记录追加被限制为最多为最大块大小的四分之一，以将最坏情况的碎片保持在可接受的水平。 如果记录适合最大大小（这是常见情况），则主数据库将数据追加到其副本，告诉辅助数据库以它所在的确切偏移量写入数据，最后向客户端回复成功。

**如果记录追加在任何副本上失败，则客户端将重试该作**。因此，同一块的副本可能包含不同的数据，可能包括同一记录的全部或部分重复项。**GFS 不保证所有副本在字节上都是相同的。它只保证数据至少写入一次作为原子单元**。此属性很容易得出以下简单观察结果：要使作报告成功，数据必须以相同的偏移量写入某个块的所有副本上。此外，在此之后，所有副本的长度至少与记录的末尾一样长，因此，即使不同的副本稍后成为主副本，任何未来的记录都将被分配更高的偏移量或不同的块。就我们的一致性保证而言，成功的记录追加作写入其数据的区域是定义的（因此是一致的），而中间的区域是不一致的（因此是未定义的）。我们的应用程序可以处理不一致的区域，正如我们在第 2.7.2 节中讨论的那样。