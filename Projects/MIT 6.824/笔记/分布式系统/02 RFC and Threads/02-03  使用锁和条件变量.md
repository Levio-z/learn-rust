```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

func requestVote() bool {
	time.Sleep(time.Millisecond * time.Duration(rand.Intn(200)))
	return rand.Intn(2) == 1
}

func main() {
	var mu sync.Mutex
	cond := sync.NewCond(&mu)

	count := 0      // 收到的有效票数
	finished := 0   // 完成投票的总线程数

	const total = 10
	const majority = 5

	for i := 0; i < total; i++ {
		go func() {
			vote := requestVote() // 模拟投票（随机返回 true/false）

			mu.Lock()
			defer mu.Unlock()

			if vote {
				count++
			}
			finished++

			// 唤醒所有 Wait 中的 goroutine（这里只有主线程一个 waiter，Signal 也可）
			cond.Broadcast()
		}()
	}

	mu.Lock()
	for count < majority && finished < total {
		// 等待条件满足（票数过半 或 投票全部完成）
		cond.Wait()
	}
	if count >= majority {
		fmt.Println("Received 5+ votes! ")
	} else {
		fmt.Println("Lost ")
	}
	mu.Unlock()
}

```
###  `sync.Mutex`

用于保护临界资源（`count`, `finished`）的并发访问。

###  `sync.Cond`

条件变量用于：

- 当主线程等待“状态达到特定条件”时阻塞；
    
- 当后台 goroutine 更新状态后通知主线程唤醒继续判断。
### 🎯 条件判断逻辑


复制编辑

`for count < 5 && finished < 10 {     cond.Wait() }`

- 如果当前票数不足 5 且未投完，则主线程进入阻塞；
    
- 被 `Broadcast()` 唤醒后，重新判断票数是否达标；
    
- 若 10 个线程都执行完仍未达标，则直接判负。

## cond.Broadcast vs cond.Signal

- `Broadcast()`：唤醒**所有**在 `.Wait()` 上阻塞的 goroutine；
    
- `Signal()`：只唤醒**一个**（随机选择）阻塞的 goroutine。
    

本例中：

- 主线程是**唯一的 `Wait()` 实例**；
    
- 所以 `Signal()` / `Broadcast()` **都可**，用 `Broadcast()` 更保险一点。


- **Go 的条件变量协作模型**
    
- **单生产者-多消费者** 或 **多 worker 同步协调**
    
- **并发编程中的条件唤醒模式**