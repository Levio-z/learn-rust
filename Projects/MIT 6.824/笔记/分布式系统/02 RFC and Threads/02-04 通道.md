```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func requestVote() bool {
	time.Sleep(time.Millisecond * time.Duration(rand.Intn(200)))
	return rand.Intn(2) == 1
}

func main() {
	rand.Seed(time.Now().UnixNano())

	const total = 10
	const majority = 5

	ch := make(chan bool, total) // 使用缓冲通道，避免 goroutine 阻塞

	for i := 0; i < total; i++ {
		go func() {
			ch <- requestVote()
		}()
	}

	count := 0
	finished := 0

	for finished < total && count < majority {
		v := <-ch
		finished++
		if v {
			count++
		}
	}

	if count >= majority {
		fmt.Println("received 5+ votes!")
	} else {
		fmt.Println("lost")
	}
}

```
**问题：看上去count和finished是主线程的本地变量，它们在主函数退出后应该会被销毁，那此时如果主线程推出后，新建的go线程还在使用这些变量，会怎么样？**

**回答：这里根据go语言的逃逸分析可知，被共享的变量实际上go会在堆中进行分配，而不是在主线程的栈中，所以可以安全的在多个线程之间共享。

问题：channel代码示例中，channel是自带了buffer吗？

回答：是的，通常你往channel写入数据时，如果没有人从channel读取数据，那么channel写者会阻塞。这里用的不是缓存channel。
- 无缓冲区的channel，需要写者和读者都同时就绪才能通信。
- 带缓冲 channel：你可以显式添加缓冲区
	- `ch <- x` 会立即写入缓冲区，只要缓冲区没满，不阻塞  
	- `x := <- ch` 会从缓冲区读取，只要缓冲区非空，不阻塞

问题：有无办法在不退出主线程的情况下kill其他子线程？

回答：你可以往channel发送一个变量，示意子线程exit。但你必须自己去实现这个流程。


 问题：**主线程一旦退出 `for count < 5 && finished < 10`，就不再从 channel 读取数据，从而导致部分 goroutine 永久阻塞在 `ch <-` 上。**
 - **线程泄漏（goroutine 卡住不退出）**
- **资源无法回收**
- **潜在的死锁/崩溃风险（channel 填满）**
回答：
这里channel不会阻塞运行时，如果使用的是同步的，需要清理剩余结果
```
	// ✅ 清理剩余结果（非必须，但优雅）
	for i := finished; i < total; i++ {
		<-ch
	}
```