### 一致性的定义与直观理解

**强一致性（Strong Consistency）**的核心是：

> 对外表现就像是系统只有一台单线程服务器，所有请求严格串行执行，任何读请求都能看到前面所有写请求的结果。

- 这使得系统对客户端而言是**线性化的（linearizable）**，即操作看起来像是原子且有全序的。
    
- 单机单线程服务器模型是最简单的强一致性示意模型，且容易理解：请求排队，一个接一个执行。

### 单机强一致模型的行为示例

- 多个客户端（如C1、C2）并发写入不同的值。
    
- 服务器依次处理写请求，先处理哪个写哪个值，后处理哪个覆盖之前值。
    
- 读请求总是看到“最后执行的写请求”的结果。
    
- 因此，客户端C3、C4读到的数据应该一致。
    

这是强一致性的基本保障，也是我们期望的“好”的一致性。

### 多副本系统中的一致性难题

现实中为了容错，数据被复制到多台服务器（副本）上。理论上，这些副本应该“同步”执行所有写操作，保持**状态一致**。  当然，直观上我们希望这两个表单是完全一致的，这样，一台服务器故障了，我们可以切换到另一台服务器去做读写。

>两个表单完全一致意味着，每一个写请求都必须在两台服务器上执行，而读请求只需要在一台服务器上执行，否则就没有容错性了。因为如果读请求也需要从两台服务器读数据，那么一台服务器故障我们就没法提供服务了。现在问题来了，假设客户端C1和C2都想执行写请求，其中一个要写X为1，另一个写X为2。C1会将写X为1的请求发送个两个服务器，因为我们想要更新两台服务器上的数据。C2也会将写X为2的请求发送给两个服务器。
![](asserts/Pasted%20image%2020250808201126.png)

但在下面的“最糟糕设计”中：

- 两台服务器S1、S2独立收到同样的写请求，但处理顺序可能不一致。没有做任何事情来保障两台服务器以相同的顺序处理这2个请求。
    
- S1先处理写X=1，再处理写X=2；S2顺序相反。
    
- 这样导致状态不一致，读取时不同客户端看到不同的结果。

>之后，如果另外一些客户端，假设C3从S1读数据，C4从S2读数据，我们就会面临一个可怕的场景：这两个客户端读取的数据不一样。但是从前一个例子中的简单模型可以看出，相连的读请求应该读出相同的数据。
    
- 进一步如果客户端读数据只从一台服务器读取，且这台服务器故障切换到另一台，会导致客户端看到数据突然“回退”。客户端读X得到的数据将会从2变成1。

这正是**一致性缺失导致的数据异常**。

当然，这里的问题是可以修复的，修复需要服务器之间更多的通信，并且复杂度也会提升。由于获取强一致会带来不可避免的复杂性的提升，有大量的方法可以在好的一致性和一些小瑕疵行为之间追求一个平衡。

## 拓展
### 为什么“只一次处理一个请求”如此重要？

- 这是实现强一致性的核心原则之一，保证请求执行的全序性。
- 多请求并行执行，尤其是跨多副本并发处理，会带来状态竞态和顺序不确定。
- 只能通过协调（同步协议）保证全序，才能确保一致性。

### 解决方案的方向与复杂度

为了解决多副本一致性问题，通常会：
- 引入分布式一致性协议（如 Paxos、Raft 等），在副本间达成写请求的顺序共识。
- 通过协调写请求的提交顺序保证所有副本以相同顺序应用写操作。
- 读请求也需根据协议保证读取到最新或一致的数据视图。

但这会带来：
- 网络通信延迟、协议复杂度增加。
- 服务器负载增大。
- 容错和性能之间的权衡。