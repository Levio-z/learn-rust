---
tags:
  - misc
---
## 1. 核心观点  
### Ⅰ. 概念层



### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  


### 创建项目
- cargo generate tyr-rust-bootcamp/template 生成新项目
- pre-commit安装：每次clone新仓库后需执行pre-commit install添加hook
	- 提交信息规范：
    - 前缀分类：chore/feat/fix/doc/perf等
    - 示例：chore: init repo for 2nd week
	- commit分类：
	    - feat → Features
	    - fix → Bug Fixes
	    - chore → Miscellaneous Chores
	- 特殊处理：
	    - [skip]开头的提交会被跳过
	    - 中文提交(\p{Han})默认跳过
- 仓库URL替换：在postprocessors中配置$REPO的替换规则
-  版本发布：
    - 每个重要功能变更生成一个release
    - 示例：v1-13-trait-and-enum-dispatch
- 变更说明：
    - 自动生成清晰的分类日志
    - 包含commit哈希和作者信息
###### 1）创建线程
- 基本方法：使用std::thread::spawn创建新线程
- 函数签名：`pub fn spawn<F, T>(f: F) -> JoinHandle<T> where F: FnOnce() -> T + Send + 'static, T: Send + 'static`
- 泛型约束：
    - FnOnce：闭包只能执行一次
    - Send：数据可跨线程安全传递
	    - 可变引用和指针不能send，还有rc，其他基本都实现了
		- 并且非send具有传染性（todo 待整理）
    - 'static：生命周期需持续整个程序执行期
- 返回值：返回`JoinHandle<T>`用于等待线程结束
	- 返回的可能要传回给线程，所以也是send


![](asserts/Pasted%20image%2020260104194049.png)
###### 2）等待线程
- join方法：通过JoinHandle的join()方法等待线程完成
- 返回值处理：返回Result`<T>`，需使用unwrap()或错误处理
- 资源泄漏：若不join或detach线程会导致资源泄漏
- 自动detach：当JoinHandle被drop时线程会自动detach

###### 3）线程同步

﻿共享内存﻿20:31
 - 只读共享：使用`Arc<T>`（原子引用计数）
    - 可写共享：使用`Arc<Mutex<T>>`组合
    - 原子操作：使用atomics进行无锁同步
    - 注意事项：`Rc<T>`不能跨线程使用，因其非原子操作
- CSP﻿21:03﻿
    - channel通信：通过消息传递进行线程间通信
    - 类型：
        - mpsc：多生产者单消费者
        - oneshot：单次通信
    - 所有权转移：使用move关键字转移数据所有权到线程
    - 示例模式：主线程创建channel，子线程通过tx发送，主线程通过rx接收
- Actor﻿21:37﻿
    - 模型特点：每个actor有自己的邮箱(mailbox)，通过消息传递通信
    - 工作方式：
        - 接收并处理消息
        - 可发送消息给其他actor
        - 维护自身状态
    - 适用场景：Erlang/Elixir等语言常用此模型
##### 2. Send trait详解

- 作用：标记类型可安全跨线程传递
- 自动实现：编译器在安全时自动为类型实现Send
- 非Send示例：
    - `Rc<T>`：非原子引用计数
    - 裸指针：可能产生数据竞争
- Send示例：
    - `Arc<T>`：原子引用计数
    - 基本类型如String等
- 传染性：包含非Send类型的复合类型也会自动变为非Send

##### 3. 线程通信示例
- 创建channel：let (tx, rx) = channel();
- move语义：将tx移动到发送线程，rx移动到接收线程
- 消息发送：tx.send(value).expect("发送失败");
- 消息接收：let value = rx.recv().expect("接收失败");
- 线程结束：执行完所有代码后线程自动退出
- 等待线程：使用join()确保主线程等待子线程完成
##### 4. 并发编程基础
###### 1）线程创建与消息传递
- 基本结构：每个示例需要独立的main函数作为入口点
- 错误处理：使用anyhow crate处理Result类型错误，添加依赖：cargo add anyhow
- 线程创建：通过thread::spawn创建新线程，使用move关键字转移所有权

###### 2）生产者-消费者模型实现

- 通道创建：使用mpsc::channel()创建多生产者单消费者通道
- 生产者设计：
    - 定义常量NUM_PRODUCERS控制生产者数量（示例中为4）
    - 每个生产者循环发送随机数：`let value = rand::random::<usize>()`
    - 添加间隔：thread::sleep(Duration::from_millis(100))
- 消息结构：定义包含生产者索引和值的Msg结构体，实现Debug trait
###### 3）消费者线程处理

- 消息接收：使用for循环从接收端rx迭代消息
- 线程同步：通过join()等待消费者线程完成
- 错误处理技巧：
    - 当问号操作符无法自动转换错误类型时，使用map_err显式转换
    - 处理线程join错误：map_err(|e| anyhow!("Thread join error: {:?}", e))

###### 4）所有权转移注意事项
- move语义：闭包中使用move会捕获所用变量的所有权
- 常见错误：通道接收端rx被move到线程后，主线程不能再访问
- 解决方案：确保每个接收端只被一个线程使用，或使用Arc共享所有权

#### 四、Rust 并发处理简介
##### 1. 编译错误处理
- 错误类型：E0382 borrow of moved value错误
- 产生原因：
    - 当rx被移动到thread::spawn闭包后，主线程再次尝试使用它
    - `Receiver<Msg>`类型未实现Copy trait，导致值被移动而非复制
- 编译器保护：
    - Rust通过所有权系统在编译时捕获这类线程安全问题
    - 错误明确指出值在闭包中被移动的位置（line 22）和非法使用的位置（line 28）
##### 2. 编译警告处理
- 警告处理方式：
    - 使用`#[allow(dead_code)]`属性抑制未使用代码的警告
    - 显式标注比隐式忽略更安全，明确表达开发意图
- 设计哲学：
    - Rust要求显式处理所有潜在问题，避免隐式转换或忽略
    - 这种严格性防止了因警告积累导致的实际问题被掩盖

##### 3. 应用案例
- 核心组件：
    - mpsc::channel()创建消息通道（发送端tx和接收端rx）
    - thread::spawn创建生产者/消费者线程
- 随机延迟实现：
    - 使用`rand::random::<u8>()*10`生成10-2550毫秒的随机延迟
    - 必须显式转换为u64：sleep_time as u64或`rand::random::<u8>() as u64 *10`
- 类型安全机制：
    - Rust禁止隐式类型转换，必须显式使用as进行类型转换
    - 设计目的：确保转换是程序员有意为之，避免意外逻辑错误
    - 示例中u8乘以10可能溢出（>255），应使用u64避免此问题
- 正确实现要点：
    - 生产者线程定期生成随机消息并通过通道发送
    - 消费者线程通过for msg in rx循环接收处理消息
    - 主线程通过join()等待子线程结束
- 运行效果：
    - 消息按随机间隔产生，不再固定每秒四个
    - 输出显示不同生产者线程(idx)和随机生成的值(value)

不写move，没实现copy的直接捕获不管有没有move关键字
其他实现copy的一般是借用





## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
