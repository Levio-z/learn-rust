---
tags:
  - misc
---
## 1. 核心观点  
### Ⅰ. 概念层

### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 总览
- 如何使用Base64进行编解码
- 如何处理不同的返回类型
- 如何从标准输入获取数据并进行处理
- 技术栈:
    - Hash库：blake3 (keyed hash)
    - 非对称加密库：ed25519_dalek
    - Trait: Signer/Verifier
    - rcli text sign -key sk.pem
    - rcli text verify -key pk.pem
    - rcli text generate-key
- 作业要求:
    - 阅读rust-cc/awesome-cryptography-rust了解Rust加密生态
    - 了解 rust cryptography生态
    - 实现chacha20poly1305文档，了解其使用方法
	    - 并构建CLI加密/解密CLI功能
	    - rcli text sign encrypt -key "xxx"=>加密并输出base64
	    - rcli text sign decrypt -key "xxx"=>base64 ->binary->解密文本
### AWS签名机制
- 签名目的:
    - 验证请求者身份
    - 防止传输过程中数据篡改
    - 防止请求重放攻击(15分钟有效期)
###### HMAC-SHA256
- 实现原理:
    - 从HTTP请求提取特定内容
    - 使用HMAC-SHA256算法计算哈希
    - 将哈希结果作为签名放入请求
- 安全特性:
    - 签名包含时间戳防止重放攻击
    - 使用派生签名密钥(非直接使用密钥)
    - 支持HTTPS传输增强安全性
- 验证流程:
    - 服务端重新计算签名
    - 比对接收签名与计算签名
    - 验证时间戳有效性(15分钟窗口)
- 密钥管理:
    - 不使用原始密钥直接签名
    - 根据日期/服务/区域派生签名密钥
    - 支持临时安全凭证(带token)
- 请求保护:
    - 建议签名请求头和请求体
    - 强制使用HTTPS传输
    - 通过条件键要求签名请求体

- [ ] 创建原子笔记
- 非对称加密原理﻿11:03﻿
    - 密钥体系：
        - 包含secret key（签名用）和public key（验证用）
        - public key可从secret key派生获得
    - 算法对比：
        - 同属椭圆曲线加密家族（与ECDSA/RSA并列）
        - 相比RSA具有更短的密钥长度（256bit）

- [ ] 抽象为子笔记：rust-设计-代码中有相同的行为就需要抽象出来作为trait，尽可能对行为进行编程而不是数据结构编程，任何具有行为的数据结构都可以被这个代码使用。同一份代码可以被无限的广泛的使用。
	- 设计动机:
	    - 避免为不同加密库重复实现相同行为(sign/verify)
	    - 通过trait抽象签名验证的通用行为
	- 行为抽象:
	    - 通过trait定义通用接口(如Read/Write)
	    - 只关心类型是否实现特定行为，不关心具体类型
	- 静态分派:
		- 使用泛型约束where R: Read, W: Write
		- 编译时确定具体实现，无运行时开销
	- 代码复用:
		- 如copy函数可处理任何实现Read/Write的类型
		- 支持文件、套接字等不同数据源
	- 扩展性:
		- 新增加密算法只需实现相同trait
		- 无需修改核心业务逻辑代码
	- 实践建议:
		- 优先对行为编程而非数据结构编程
		- 发现重复行为模式时应考虑trait抽象
		- 通过trait bound约束泛型类型的能力
- 实现方案:
	- 定义Signer和Verifier两个核心trait
	- 支持多种加密库(如ed25519_dalek)和哈希库(如blake3)
	- 统一CLI接口：rcli text sign/verify/generate-key
### 实现
### 接口设计考量
- [ ] 原子笔记
- 设计要点:
    - 避免依赖外部方法如get_reader
    - 使用Reader接口提高灵活性
    - 支持流式处理大数据
- 优势:
    - 测试更方便（可利用u8实现Read特性）
    - 性能更好（避免一次性读取全部数据） 
```
trait Textsign {

    fn sign(&self, input: &str) -> Self;

}
```
其他地方实现这个trait，就会依赖这个里面的getreader方法，这个方法也要暴露到更公共的地方去。

- 假设这里是data：`&[u8]`是不是可以呢？
- 需要一个完整的data传给它
- Read有更好的灵活性

- [ ] temporary value dropped while borrowed  
creates a temporary value which is freed while still in userustc[Click for full compiler diagnostic](rust-analyzer-diagnostics-view:/diagnostic%20message%20[9]?9#file:///home/l/projects/rcli/src/process/text.rs)
- 这句话的生命周期在这里就结束了，但是使用它的生命周期还没有结束
- 常见错误: temporary value dropped while borrowed
- 解决方法:
    - 使用let绑定延长值生命周期
    - 示例：let hash = blake3::hash(&buf); let hash_ref = hash.as_bytes();
- 原理: 确保引用的生命周期不短于被引用值
### impl Read trait不需要加mut，因为是owned value
- 关键点:
    - Read trait方法需要&mut self
    - 函数参数需声明为mut reader
- 编译器提示: 当忘记mut时会提示"consider changing this to be mutable"
##### 静态与动态分派
- 静态分派:
    - 使用impl Read参数
    - 优点：性能更好
    - 缺点：代码体积更大
- 动态分派:
    - 使用&dyn Read参数
    - 优点：更灵活
    - 缺点：有运行时开销
- 选择建议: IO密集型场景无需过度优化分派方式
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 - [ ] 完成原子笔记：文本哈希签名的意义
	 - [ ] [加密技术-文本哈希签名-意义](../../../../Areas/basic/加密技术/note/atomic/加密技术-文本哈希签名-意义.md)
	 - [ ] [加密技术-文本哈希签名-基本概念](../../../../Areas/basic/加密技术/note/atomic/加密技术-文本哈希签名-基本概念.md)
 - [ ]  完成原子笔记：Blake3
	 - [ ] [Rust-crate-Blake3-基本概念](../../../../Areas/Rust/Area/3%20库&应用场景/库/crate/Blake3/Rust-crate-Blake3-基本概念.md)
	 - [ ] [Rust-crate-Blake3-基本概念-TOC](../../../../Areas/Rust/Area/3%20库&应用场景/库/crate/Blake3/Rust-crate-Blake3-基本概念-TOC.md)
 - [ ] 完成原则笔记
	 - [ ] [Rust-crate-ed25519_dalek-基本概念](../../../../Areas/Rust/Area/3%20库&应用场景/库/crate/ed25519_dalek/Rust-crate-ed25519_dalek-基本概念.md)
 - [ ] hash中常见用法的流式运用
 - [ ] [Rust-Display 是因，ToString 是果](../../4%20note/note/inbox/Rust-Display%20是因，ToString%20是果.md)
 - [ ] 在clap中枚举一定使用子命令定义
 - [ ] 命令行开发流程
	 - [ ] 对于枚举参数，如何处理
	 - [ ] 先打印参数
	 - [ ] 在mod和处理main中导入子命令枚举和参数枚举
 - [ ] 重构的逻辑，泛化，公共方法抽取到公共的地方
 