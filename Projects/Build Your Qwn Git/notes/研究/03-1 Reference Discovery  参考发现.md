

[Rust-Git want - have-请求实例](../Reference/Rust-Git%20want%20-%20have-请求实例.md)

### 解析软件包文件
软件包文件大多是自包含的。事实上，即使没有索引文件，也可以解析软件包文件——索引文件仅仅是为了方便和提高性能。

打包文件以 12 字节的元信息开头，以 20 字节的校验和结尾，这些信息都可用于验证我们的结果。
前四个字节是“PACK”
接下来的四个字节包含版本号——在本例中为 `[0, 0, 0, 2]`。
再接下来的四个字节表示打包文件中包含的对象数量。
因此，单个打包文件最多只能包含 2 ^32 个对象，但一个仓库可以包含多个打包文件。文件的最后 20 字节是文件中所有先前数据的 SHA-1 校验和。

**打包文件的核心是一系列数据块，每个数据块前面都有一些元信息**。有趣的地方就在这里！元信息的格式会根据后面的数据块是否被删除而略有不同。无论哪种情况，它们都以告知打包文件包含的对象的大小作为开头。这个大小被编码为一个具有特殊格式的可变长度整数。

由于整数的长度是可变的**，每个字节的第一位（也称为最高有效位，MSB）被保留**。这一位告诉我们下一个字节是否属于我们正在解码的可变长度整数的一部分。如果是 1，我们就应该读取下一个字节。一个简单的检查方法是检查该字节是否小于 128，128 的二进制表示为 `10000000` 。


该**整数的第一个字节包含一条额外信息**：后面对象的类型。
- 共有六种已定义的类型，这意味着该信息需要三个比特才能表达清楚，最高有效位 (MSB) 之后的三个比特用于指定该信息
![](asserts/Pasted%20image%2020251206150959.png)
对于非删除类型，元信息之后的数据是经过 zlib 压缩的对象数据，我们可以像处理普通 Git 对象一样处理它。可变长度整数表示对象解压缩后的预期大小。


如果我们不知道要读取多少数据，该如何解压缩对象呢？事实证明，zlib 非常健壮， [它会忽略添加到有效 zlib 压缩数据流末尾的任何额外字节](https://play.golang.org/p/z4xue6V0tv) 。**zlib 之所以能够做到这一点，是因为压缩数据本身就带有头部信息，但由于我们并没有从头开始实现 zlib 的 inflate 函数，所以我们可以将这些二进制数据视为黑盒。**

然而，这里存在一个问题。只要我们给 zlib 提供比它需要的数据更多的数据，我们就可以解压缩第一个对象。但是我们如何知道第二个对象从哪里开始呢？

事实证明，我们目前采用的方法行不通！Go 的 zlib 库会贪婪地缓存我们输入的数据。因此，我们无法简单地测量 zlib 库输入的字节数——它请求读取的字节数可能比最终实际使用的字节数更多。（这并非 Go 独有的问题； [其他语言也存在类似的问题](https://stackoverflow.com/questions/28640738/how-can-i-deflate-zlib-data-and-find-out-how-many-input-bytes-there-were) 。）


这时就需要用到 IDX 文件了——它告诉我们每个对象从哪里开始。
### IDX files  IDX 文件

**虽然可以绕过上述缓冲问题，在不读取 IDX 文件的情况下解析软件包文件，但索引文件让这一切变得更加简单**。与软件包文件类似，版本 2 的索引文件也以文件头开头，但索引文件头只有 8 个字节，而不是 12 个字节。前四个字节始终为 `255, 116, 79, 99` ，之所以选择这四个字节，是因为第一个版本的索引文件没有任何文件头信息，而这四个字节对于版本 1 的索引文件来说是一个无效的开头。接下来的四个字节明确地表示版本号——在本例中为版本 2。
![](asserts/Pasted%20image%2020251207131608.png)

[fan-out 表](../../notes/Reference/fan-out%20表.md)
- **第一层**（fan-out 表）：
    - 已知：每个条目记录了 **首字节 ≤ N 的对象数量**。
    - 通过最后一个条目（第 255 个条目）可以得到索引中 **对象总数**。
- **第二层**（对象名称表）：
    - 每个对象名称占用 20 字节（SHA-1）或 32 字节（SHA-256，视 Git 版本而定）。
    - 对象名称 **按字典序排列**（即 SHA-1 的字节顺序）。
    - 存储顺序与 fan-out 表一致：
        - 首字节为 0 的对象排在前面。
        - 首字节为 1 的对象排在其后。
        - …依次到首字节为 255 的对象。
    - 数量就是 **fan-out 表最后一条的值**，也就是对象总数。
	- **使用方法**：
		- 已知 fan-out 表，可以快速定位某首字节的对象：
		    `起始索引 = fan_out[b-1]  （如果 b > 0） 结束索引 = fan_out[b]`
		- 第二层表在这个范围内的连续 20 字节块就是首字节为 `b` 的对象名称。
- **第三层**为每个对象提供了一个四字节的[循环冗余校验](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)值。请记住，打包文件针对网络传输进行了优化，因此能够检查数据在传输过程中是否损坏至关重要。
- **第四层**
	- 包含我们一直在寻找的信息：**每个对象的包文件偏移量。每个条目也占用四个字节**。如果包文件小于 2 GB，则所有这些值的最高有效位 (MSB) 为 `0` ，其余位包含包文件偏移量。否则，偏移量可能太大，无法用 4 个字节表示。在这种情况下，偏移量实际上将存储在第五层，该对象在第四层的最高有效位 (MSB) 为 `1` ，其余位是第五层中该对象在包文件中的偏移量。
- 第五层（也是最后一层）仅存在于大于 2GB 的包文件中。
	- 如果存在，它将包含一系列 8 字节的条目，用于编码包文件中的偏移量。如前所述，第四层将指示第五层中的哪些条目对应于每个对象——如果第四层中的某个元素的最高有效位 (MSB) 被置位，则该元素中的其余位指定第五层中的哪个元素包含该对象的包文件偏移量。



### 参考
- https://i27ae15.github.io/git-protocol-doc/docs/git-protocol/git-upload
	- 参考实现步骤
	- https://codewords.recurse.com/issues/three/unpacking-git-packfiles
	- 解析使用 z-lib 算法压缩的 pack 文件。
- https://git-scm.com/docs/gitformat-pack
- [Git Packfile 对象长度编码机制解析](../../notes/Reference/Git%20Packfile%20对象长度编码机制解析.md)
- [Git 对象长度的计算移位公式](../../notes/Reference/Git%20对象长度的计算移位公式.md)