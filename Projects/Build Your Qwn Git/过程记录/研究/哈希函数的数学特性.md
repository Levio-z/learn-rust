#### 1. 哈希函数的数学特性

像 **SHA1 / SHA256 / MD5 / Blake3** 这样的哈希算法，本质是 **迭代函数**（iterative function）：

- 内部维护一个 **state（状态寄存器）**。
    
- 每次输入一个数据块（通常 512bit = 64 字节）。
    
- 状态更新后，可以继续接收下一个块。
    
- 最终 `finalize()` 才会把状态压缩成固定长度的摘要（例如 20 字节的 SHA1）。
```rust
hasher = Sha1::new()
hasher.update("hello")   // 更新内部状态
hasher.update(" world")  // 累积更新
digest = hasher.finalize()  // 输出最终哈希值
```
👉 因此，无需一次性提供完整数据，**分块输入是完全等价的**。

#### 2. 为什么能边写边哈希？

因为哈希算法满足：

H(M1∥M2)=f(f(IV,M1),M2)H(M_1 \| M_2) = f(f(IV, M_1), M_2)H(M1​∥M2​)=f(f(IV,M1​),M2​)

其中 IVIVIV 是初始向量，fff 是哈希压缩函数。

- 输入可以按任意块大小拆分。
    
- 处理顺序是线性的。
    
- 不会丢失信息，也不依赖未来的数据。
    

这就是 **流式哈希（streaming hash）** 的原理。


#### 3. 对应到 `HashWriter`

- 每写入一段数据：
    
    - 先交给底层 `writer`（比如写文件/Socket）。
        
    - 同时调用 `hasher.update(buf)` 更新哈希状态。
        
- 不需要缓存全部内容。
    
- 最后 `finalize()` 得到摘要。
    

这就是 **边写边哈希**。