### 违法->实现
#### 违反案例
```rust
enum PaymentMethod {
    Alipay,
    WeChatPay,
    CreditCard,
}

fn pay(method: PaymentMethod, amount: f64) {
    match method {
        PaymentMethod::Alipay => println!("Alipay paid {:.2} yuan", amount),
        PaymentMethod::WeChatPay => println!("WeChatPay paid {:.2} yuan", amount),
        PaymentMethod::CreditCard => println!("CreditCard paid {:.2} yuan", amount),
    }
}

```

### 具体实现
- Step 1 和Step 2就是利用多态、基于接口而非实现编程
- Step 3：使用依赖注入


#### Step 1：定义抽象
```rust
trait Payment {
    fn pay(&self, amount: f64);
}

```
#### Step 2：实现具体支付方式
```rust
struct Alipay;

impl Payment for Alipay {
    fn pay(&self, amount: f64) {
        println!("Alipay paid {:.2} yuan", amount);
    }
}

struct WeChatPay;

impl Payment for WeChatPay {
    fn pay(&self, amount: f64) {
        println!("WeChatPay paid {:.2} yuan", amount);
    }
}


```
我们没有修改 `Payment` trait  
只是增加新的 `struct` 和 `impl`
#### Step 3：编写主处理器（Processor）
```rust
fn process_payment(p: &dyn Payment, amount: f64) {
    p.pay(amount);
}

```
这个函数只依赖抽象，不关心具体实现。  
扩展新支付方式？它完全不需要改。
#### Step 4：使用代码
```rust
fn main() {
    let alipay = Alipay;
    let wechat = WeChatPay;

    process_payment(&alipay, 100.0);
    process_payment(&wechat, 200.0);
}

```
现在，如果你要支持 `CreditCard`：  
增加 `struct CreditCard;`  
增加 `impl Payment for CreditCard {}`  
✅其他地方 **零修改**