Factory Design Pattern
### **简单工厂（****Simple Factory****）**
 - 代码中有根据条件创建不同对象
 - 为了代码清晰可读，将这部分创建对象的代码封装成函数
 - 为了让类的职责更单一，进一步将这个函数剥离到一个独立的类中，这个类只负责对象的创建

- 工厂类命名
	- reateParser()，但有的也命名为 getInstance()、createInstance()、newInstance()

- createParser() 的时候，都要创建一个新的 parser。如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。
	- 静态初始化一个hashmap
	- 通过名称去取对象

- if else分支是不是必须使用多态和设计模式来替代，不是很多，可以接受的，应用多态和设计模式来替代if分支也有缺点，增加了类的个数，牺牲了代码的可读性。

### **工厂方法（****Factory Method****）**
- 创建对象工厂：不同对象创建使用不同类，不同类实现同一个方法创建不同对象来实现多态
- 将关键字和对应的对象工厂联系起来，使用一个类来封装关系，hashmap

- 维护：对象和对象工厂，还有对象工厂和ParserFactoryMap中维护对象工厂和key的关系

### **那什么时候该用工厂方法模式，而非简单工厂模式呢？**
- 代码块的逻辑过于复杂，剥离之后能让代码更加清晰
- 当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式
- 只是避免if和else

### **抽象工厂（****Abstract Factory****）**

让一个工厂创建不同的对象

### **重点回顾**
- 当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，**将对象的创建和使用相分离**。
- 场景
	- 代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。
	- 单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。
- 创建逻辑简单
	- 简单工厂
- 创建逻辑复杂
	- 工厂方法
- 封装变化，创建逻辑有可能变化，封装成工厂，创建逻辑的变更对调用者透明
- 代码复用：创建代码抽取后可以服用
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责单一，代码更简洁
