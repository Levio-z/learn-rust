### 总结

- 装饰模式通过“将对象包入另一个对象”来**增强行为**。
	- 代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。
- **新行为在装饰器中实现，而不是修改原对象。**
- 装饰器链可以自由组合，灵活扩展。
	- 装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。
- 是避免继承膨胀、提升可组合性的关键结构模式。

### 装饰模式的本质定义

装饰模式（Decorator Pattern）是一种**结构型设计模式**，它通过一个“封装对象”——即装饰器（Decorator）——**在不修改原有类、不影响原有对象的情况下，为对象动态添加额外行为**。

关键点是：

- **你不是继承来扩展行为，而是把原对象“包”进另一个对象里**
- 这个“封装对象”对外表现为同样的接口
- **调用会沿着包装链传递 → 一层层叠加行为**

因此，这里的“将对象放入包含行为的特殊封装对象中”，就意味着：

> **你把原对象放进一个装饰器对象里，通过装饰器在原对象前后增加新行为。**

### 装饰器类图
![](asserts/Pasted%20image%2020251115095117.png)
### 图示解释（抽象流程）
```
┌────────────────┐
│ 原对象 A        │
│ Operation()     │
└────────────────┘
          ↓ 包起来
┌───────────────────────────┐
│ 装饰器 D 包含原对象 A       │
│ Operation():               │
│   前置新行为               │
│   A.Operation()            │
│   后置新行为               │
└───────────────────────────┘

```
调用链变成：
```
client → D → A
```
而你随时可以继续包：
```
client → D2 → D1 → A
```
无需修改 A，也不需要产生大量子类。

### 更直观类比（最常用的类比）

**给咖啡加配料就是装饰器模式的现实版本。**

- “纯咖啡”是 ConcreteComponent
- “加奶”、“加糖”、“加巧克力”是 Decorators

每个配料都是独立的装饰器，它只需要：

1. 实现与咖啡相同的接口（比如 getCost()、getDescription()）
2. 内部保存“被包装的咖啡对象”
3. 在方法前后添加附加内容（加价、加描述）

不需要继承很多 CoffeeWithMilkAndSugar 这种类，避免类爆炸。

### 为什么说“是一种结构型设计模式”？

因为它主要改变的是**对象之间的结构关系（即：包装链）**，而不是算法逻辑本身。
结构特征：
- 装饰器继承 Component（接口一致）
- 装饰器聚合 Component（内部持有对象）
- 装饰器对外完全透明（你不知道里面包了多少层）

### 总结

- 装饰模式通过“将对象包入另一个对象”来增强行为。
- **新行为在装饰器中实现，而不是修改原对象。**
- 装饰器链可以自由组合，灵活扩展。
- 是避免继承膨胀、提升可组合性的关键结构模式。

### 相关内容
- [03-clone-4. read the pack file footer and compute hash](../../../../Build%20Your%20Qwn%20Git/开发日志/03-clone-4.%20read%20the%20pack%20file%20footer%20and%20compute%20hash.md)