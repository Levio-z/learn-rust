### 方案一
我们先来看最简单的一种解决办法。在迭代器类中定义一个成员变量 snapshot 来存储快
照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。

- 深拷贝，互相不影响
- 浅拷贝，互相影响
### 解决方案二


每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足addTimestamp<snapshotTimestamp<delTimestamp 的元素，才是属于这个迭代器的
快照。
- 每个元素都有时间戳，删除就是更新时间戳

如何解决遍历就不是o(1)？
- 我们可以在 ArrayList 中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问。
删除元素只是被标记删除。被删除的元素即便在没有迭代器使用的情况下，也不会从数组中真正移除
- 查看所有迭代器的时间戳，如果当前没有时间戳是小于它的，就物理删除这个元素