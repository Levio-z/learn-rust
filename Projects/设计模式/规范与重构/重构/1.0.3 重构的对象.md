### 1. 小型重构（Low-Level Refactoring）

目标是**改善代码的“表层可维护性”**，通常无需修改系统设计。主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小。你只需要熟练掌握各种编码规范，就可以做到得心应手。

|重构对象|典型手法|工具辅助|
|---|---|---|
|函数/方法|函数抽取、函数合并、参数简化、命名优化|IDEA/Rust Analyzer 自动重构|
|类/结构体|拆分类、合并类、提取接口、合并重复字段|UML 工具、重构插件|
|变量/常量|统一命名风格、消除神秘数字、消除全局变量|Linter、Prettier 等|
|注释/文档|用清晰代码替代注释、统一格式、避免过度注释|DocLint、Doxygen|
|重复代码|提取公用方法、模板模式、策略模式等|模板提取工具|
特点：
- 操作粒度小，可随写随改；
- 风险低；
- 避免形成**技术债务堆积**。
### 🔹 2. 大型重构（High-Level Refactoring）
大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系
等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。需要基础知识设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大。

| 重构对象 | 重构策略                       | 对应设计思想或原则   |
| ---- | -------------------------- | ----------- |
| 模块结构 | 拆分、合并模块，消除隐式依赖             | 模块化、SRP、DIP |
| 系统架构 | 分层架构、微服务化、DDD 重构           | DDD、分层架构模式  |
| 数据模型 | 消除冗余、抽象统一、分库分表             | 数据建模范式      |
| 服务边界 | 确定 Bounded Context，防止跨模块调用 | DDD、限界上下文   |
| 技术选型 | 更换底层依赖（如缓存方案、消息队列、存储引擎）    | 可插拔架构、抽象工厂  |

特点：
- 组织复杂度高；
- 风险和收益成正比；
- 通常需要 **重构计划、灰度发布、自动化测试**等支撑。