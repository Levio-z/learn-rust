### 为什么要进行重构
#### 代码质量问题

| 类别       | 重构动因             | 典型表现                       |
| -------- | ---------------- | -------------------------- |
| 代码腐化     | 代码变得难以阅读、修改      | 命名随意、复制粘贴、if/else 过多、注释像迷宫 |
| 业务演进     | 原有架构不适应新需求       | 新功能开发成本陡增，改一个地方牵一发动全身      |
| 技术债务     | 为快速上线而妥协的代码积累过多  | 技术栈老旧、缺少单测、接口层级混乱          |
| 性能优化     | 局部模块存在瓶颈或冗余      | 查询慢、内存泄露、接口超时              |
| 团队协作     | 项目缺乏结构化，影响团队协作效率 | 新人上手慢，代码交接困难，模块分界模糊        |
| 安全合规     | 存在潜在的安全问题        | 明文密码、未加校验的数据流、权限控制薄弱       |
| 自动化/测试驱动 | 方便进行单元测试、集成测试    | 代码耦合严重，不可测试                |
#### 个人成长
提升个人技术壁垒，重构一般是为了解决大部分人解决不了的问题，性能优化，架构演进，提高代码的质量
### 重构的具体触发场景

#### 场景 1：代码读不懂

> “This code works, but I have no idea how.”  
> ➡ 重构是恢复代码可理解性的唯一办法。

#### 场景 2：新增功能举步维艰

> 加个字段需要改 10 个类，测一轮出 3 个 bug。  
> ➡ 表示设计与职责分离严重失衡，需要抽象化、分层重构。

#### 场景 3：模块职责混乱

> Controller 里既查库、又拼逻辑、又打印日志。  
> ➡ 应该拆分为 service、repository、domain service 等。

#### 场景 4：技术演进与架构切换

> 从单体服务 → 微服务 / Serverless；MySQL → 分布式存储。  
> ➡ 老代码不重构，接口无法迁移，状态不透明。