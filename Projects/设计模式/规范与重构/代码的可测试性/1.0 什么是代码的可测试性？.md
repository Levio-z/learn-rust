### 定义
粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级不需要测试所依赖的外部系统的逻辑正确性。所以如果代码中依赖了外部系统或者不可控组件，需要mock。
### mock的常见方案
- 创建一个mock类，实现接口
- 类通过new方法创建，我们无法动态地对其进行替换，造成可测试性很差
	- 依赖注入，通过构造方法或**set方法**，将对象的创建反转给上层逻辑（定义接口，重写接口实现为直接返回true）
- 一些过于简单的方法不用写单元测试
### 测试性 Anti-Pattern（反模式）
#### 1. 未决行为
指：**依赖“当前状态不可控”的行为输出**，如时间、随机数、线程 ID、全局变量、外部 I/O 等。
##### 本质问题
- 输出无法预测 → 无法断言期望结果
- 无法模拟边界场景（如时间过期、极端随机值）
- 难以回归测试 / 重复测试
##### 解决
- 将未决行为包装为接口，不直接调用系统 API。
	- 第一步：抽象“环境依赖”接口
	- 第二步：通过依赖注入替代直接访问，而不是直接访问系统方法。
	- 第三步：控制行为 ——使用 mock 或固定值注入
		- 封装“过期策略”为独立逻辑 ：mock 直接返回一个你需要的固定值，比如过期，直接定义一个方法，返回true
		- mock 就是
			- .currentTimeMillis(); 抽象到一个接口中，默认实现调用系统
			- mock中重写实现
#### 2. 全局变量（Global State）
```rust
private static AtomicInteger position = new AtomicInteger(0);
```
- **测试污染**：多个测试间状态互相干扰（顺序敏感 / 并发不安全）
- 提供重置能力：当静态状态无法避免（例如性能或框架要求），务必提供重置能力，保证测试前后状态可控。
### 3. 静态方法
- 静态方法很难mock,什么时候需要mock：在写单元测试的时候，**是否需要 mock 它**，取决于它的行为是否具有副作用或非确定性。
	- 依赖外部资源，逻辑复杂才需要mock
		- 将使用全局变量的整个调用过程封装到一个方法中，然后重写这个方法的逻辑，直接返回结果。
	- 不影响测试不用mock


| 技术方案          | 示例                                             | 说明         |
| ------------- | ---------------------------------------------- | ---------- |
| **封装成实例接口**   | 将 `IdGenerator.generate()` 封装为 `IdProvider` 接口 | 方便注入与 mock |
| **重构为依赖注入架构** | `Demo(clock: ClockProvider)`                   | 控制权转移，便于测试 |
### 4.复杂继承
- 父类需要mock对象，子类也需要，层次很深的子类需要mock很多对象
- 底层子类在写单元测试的时候，要一个一个mock 很多依赖对象，而且还需要查看父类代码，去了解该如何 mock 这些依赖对象。
### 5.高耦合代码
如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，**可能需要 mock 这十几个依赖的对象**。
