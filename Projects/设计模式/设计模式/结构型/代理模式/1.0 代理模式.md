### 定义: 
代理模式（Proxy Pattern）是一种结构型设计模式，它为其他对象提供一种代理以控制对这个对象的访问。代理模式通常用于为某个对象提供一个替身，以控制对该对象的访问、增强功能或者延迟实例化等。也就是说再不改变原始类的情况下，引入代理类给原始类附加功能。
### 问题
在业务代码上添加性能框架代码，如果直接写入到业务代码中会带来什么问题？
- 和业务高度耦合
- 收集接口请求的代码和业务代码无关，本就不应该放到一个类中
### 结构组成


### 代理类的实现


#### 代理模式实现和原始类相同的接口
1. **Subject（抽象主题角色）**：定义真实对象和代理对象的公共接口。
2. **RealSubject（真实主题角色）**：实现了Subject接口，是真正需要访问的对象。
3. **Proxy（代理主题角色）**：持有RealSubject的引用，通过代理对象访问真实对象，可以在访问前后添加额外操作。
#### 当原始类没有接口，或者类代码不是们维护的怎么处理 
- 让代理类继承原始类，然后扩展附加功能。
### 动态代理的原理解析
上面存在的问题
- 为每个方法都附加相似的代码逻辑
- 附加功能的类有不止一个，我们需要针对每个类都创建一个代理类

动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

SpringAop的底层：用户配置给哪些类增加代理，并定义好执行原始类的业务代码的前后附加功能。Spring创建动态代理对象，在JVM中替换原始对象。
### 应用场景
 - 控制对象的访问（如权限、缓存、懒加载、远程代理等）
- 可以在访问对象时加入额外的逻辑（如日志、统计、计时等）
#### 业务系统的非功能性需求开发
最常用的场景就是在业务系统中开发一些非功能性需求，比如监控、统计、鉴权、限流、事务、幂等、日志。将附加功能和业务需求解构。
#### 代理模式在RPC、缓存中的应用
使用远程代理，将网络通信、编解码细节隐藏起来，客户端使用RPC服务时候，就像本地函数一样，无需了解细节。
代理模式在缓存中的应用。在 AOP 切面中完成接口缓存的功能。在应用启动的时候，配置需要支持缓存的接口、缓存策略等。
