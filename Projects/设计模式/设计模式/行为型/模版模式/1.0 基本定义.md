### 基本定义
模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。
**关键词解释**：
- 算法骨架：业务流程的固定结构（不变部分）
- 延迟实现：可变部分由子类负责
- 不改变结构：面向扩展开放（Open），对修改关闭（Closed）
- 算法骨架方法：包含算法骨架的方法就是模版方法
### 解决什么问题
- 复用
	- 将不变的流程抽象到父类的模板方法中，将可变部分留给子类实现。所有的子类都可以复用父类中模板方法定义的流程代码。
- 扩展
	- 框架的扩展性，不修改源码的情况下，定制框架的功能

### 核心原理和结构图
在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。

|角色|说明|
|---|---|
|抽象类（AbstractClass）|定义模板方法，规定算法结构，包含若干抽象/钩子方法|
|具体子类（ConcreteClass）|实现抽象类中定义的“待定步骤”方法（即具体业务实现）|
```
         ┌────────────────────┐
         │  AbstractClass     │
         │--------------------│
         │ + templateMethod() │  → 模板方法，定义业务流程
         │ + step1()          │  → 可是抽象、钩子或具体实现
         │ + step2()          │
         └────────────────────┘
                    ▲
                    │
         ┌────────────────────┐
         │  ConcreteClassA    │
         │--------------------│
         │ + step1()          │ → 实现细节
         │ + step2()          │
         └────────────────────┘

```
### 示例代码
```rust
trait AbstractProcessor {
    fn step1(&self);
    fn step2(&self);

    fn template_method(&self) {
        println!("== Start Processing ==");
        self.step1();       // 延迟到子类实现
        self.step2();       // 延迟到子类实现
        println!("== End Processing ==");
    }
}

struct ConcreteProcessor;

impl AbstractProcessor for ConcreteProcessor {
    fn step1(&self) {
        println!("执行第一步逻辑");
    }

    fn step2(&self) {
        println!("执行第二步逻辑");
    }
}

// 使用
fn main() {
    let p = ConcreteProcessor;
    p.template_method(); // 调用骨架流程
}

```
- `template_method()` 是模板方法，控制流程。
- `step1()` 与 `step2()` 是可变部分，由子类实现。
- 整体流程不可更改，但局部实现灵活可变。
### 使用场景

| 使用情境                   | 描述                               |
| ---------------------- | -------------------------------- |
| 多个类有相似的业务流程，但其中某些步骤不同  | 如：数据导入处理、文档转换、网络请求前置处理等          |
| 希望固定算法流程，不希望外部修改整体控制逻辑 | 如：事务控制（begin→do→commit/rollback） |
| 需要对算法执行过程中的特定步骤做钩子处理   | 可配合钩子方法实现灵活扩展                    |
模板方法中的“钩子函数”：
可以提供默认实现供子类**可选重写**，在 Rust 中可通过 trait default 方法模拟：
```rust
fn optional_hook(&self) {
    // 默认什么都不做
}

```
### 总结：模板方法设计模式

| 特性         | 内容                          |
| ---------- | --------------------------- |
| 关键词        | "控制流程，延迟实现"                 |
| 优点         | 固定骨架、扩展灵活、符合开闭原则            |
| 缺点         | 基于继承不够灵活（Rust 解决：trait +组合） |
| 实现方式（Rust） | trait + 默认实现 + 调用者封装流程      |
