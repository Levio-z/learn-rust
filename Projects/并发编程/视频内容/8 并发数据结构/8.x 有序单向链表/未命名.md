### 链表节点结构

- 每个节点由 **key、value、next** 三部分组成
- 链表按照 **key 升序** 排列
- [https://github.com/kaist-cp/cs431/blob/main/src/lockfree/list.rs](https://github.com/kaist-cp/cs431/blob/main/src/lockfree/list.rs)
#### 查找节点 (Finding a node)

- 通过 **遍历链表** 来查找目标节点
- 查找操作被 **lookup、insert、delete** 使用
#### 删除节点 (Deleting a node)

- **逻辑删除 (logical deletion)**：将节点的 `next` 指针打上标记位（如 `0x1`）
- **物理删除 (physical deletion)**：在后续迭代中将该节点从链表中真正摘除
#### 迭代策略 (Iteration strategies)
逻辑删除的节点如何处理，不同算法有不同策略：
1. **Harris’s**
    - 一次性摘除连续的逻辑删除节点
2. **Harris-Michael’s**
    - 逐个摘除逻辑删除节点
3. **Harris-Herlihy-Shavit’s (wait-free)**
    - 在遍历时 **忽略逻辑删除的节点**
    - 只能用于 **lookup**，不能用于 **insert/delete**

### **有序单向链表（sorted singly linked list）** 的关键问题点

#### Logical deletion → Physical deletion
- **原因**：在并发环境下，若直接物理删除节点，可能与同时执行的插入操作产生冲突。
- **做法**：
    1. **逻辑删除**：先通过在 `next` 指针上打标记（如设置最低位 bit = 1），表示该节点已失效。这样，其他线程在遍历时可以识别该节点已删除。
    2. **物理删除**：在后续遍历时，真正将该节点从链表中跳过并释放。
- **好处**：逻辑删除立即对外可见，保证一致性；物理删除延迟处理，避免与插入冲突，保证安全。
---
#### Harris-Michael’s list (HM list) 的动机
- **动机**：为支持 **hazard pointers**（危险指针内存回收机制）。
- **关键点**：节点在逻辑删除后不会立即回收，而是依赖 hazard pointers 确保没有线程访问后再释放。
- **特征**：简化了与内存管理相关的并发问题，适配实际的内存回收策略。
---

#### Harris-Herlihy-Shavit’s list (HHS list) 的动机
- **动机**：实现 **wait-free lookup**。
- **机制**：通过遍历过程中的保证，使得查找操作不会被阻塞，即使其他线程在进行删除或插入。
- **优点**：查询操作进度独立，不受其他操作的影响。
---
#### 为什么 HHS 不能用于 insert/delete
- **原因**：HHS 使用了 cursor（光标）来维护遍历位置：
    - 光标包含 `prev` 指针（指向前驱节点）。
    - 如果 `prev` 节点在并发过程中被删除，cursor 的 `prev` 将失效。
    - 这样就无法安全地更新链表结构，因此不能直接支持插入和删除。