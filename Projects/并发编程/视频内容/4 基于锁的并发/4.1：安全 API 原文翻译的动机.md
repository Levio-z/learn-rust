并发上下文：共享内存并发  （cpu和内存）
![](asserts/Pasted%20image%2020250828223219.png)


线程：**对共享内存（资源）进行读写的执行代理**  
共享内存：数据的共享存储

其他类型的并发：

- CPU 与 CPU
	- 多个计算机连接，有一些共享资源
- CPU 与内存
- GPU / FPGAGPU/FPGA
- 持久化内存
- 分布式节点
### 基于锁的共享内存并发

定义：在任何时刻，**一个内存位置只能被单个执行代理访问**  ，在基于锁的并发中，处于压力下的多个线程不会同时访问同一位置

优缺点：**简单，但可能效率低下** 
机制：锁（在任何时刻，只有一个线程持有锁）

示例：
```
r1 = X       ||    r2 = X
X = r1 + 1   ||    X = r2 + 1
// 不一定总是 X=2：不幸的交错可能导致 X=1

```
使用锁后的示例：
```
L.acquire()  ||    L.acquire()
r1 = X       ||    r2 = X
X = r1 + 1   ||    X = r2 + 1
L.release()  ||    L.release()
// 现在总是 X=2：锁防止了不幸的交错

```
- 有其他锁访问，你必须等待，实际上这消除了所有的并发
### 为什么锁是简单的

回顾：并发的挑战在于非确定性
- 线程交错
- 指令重排

锁将线程交错限制在 acquire/release 点之间
- acquire 与 release 之间不会发生交错
- 结构至于徐我们进行这样的推理，一个代理同时访问一个资源，不幸的交错不会发生，我们也不需要对交错分析
    

锁消除了指令重排
- 线程 A 的 release 必然严格发生在线程 B 的 acquire 之前
- 线程的执行就好像它们是同一个线程一样

**锁将非确定性降到最低。**

###  几月锁的并发低级API
`Lock.acquire()`：阻塞直到获取锁。  
`Lock.try_acquire()`：返回锁是否被获取，不会阻塞。 
`Lock.release()`：释放已获取的锁。

挑战：该 API 极易出错。

- 锁与资源的关联：用户应仅在持有锁 `L` 时访问资源 `X`。
- acquire/release 配对：用户应仅释放已获取的锁。

后果：该 API 带来高成本。  滥用api非常容易，环境可以被破坏。

- 挑战1：锁和资源没有明确的标记，获取错误的锁，使用不同的资源
- 挑战2：获取和释放应该配对

成本很高
- **程序员始终需要关注该 API 的使用。**  
	- 始终考虑这个复杂不变量，带来了非常高的认知负荷
潜在 Bug：通常存在许多潜在错误未被发现。
- 没人理解不变量，也很难测试，错误率是几亿倍之一
### 基于锁的并发高级API
编译器保持，程序员忘记这个不变量。

我们希望拥有一个易用、始终安全的高级 API。
- acquire/release 自动匹配
- 锁与资源明确关联

高级 API 的好处：低成本，同时减少关注点和 Bug
- 减少关注：程序员无需担心 API 使用错误
- 减少 Bug：使用该 API 的程序出现错误的可能性极低
    

高级 API 的设计（借鉴 C++/RAII）
- `LockGuard`：通过 RAII 类型自动释放锁
	- `Lock.acquire()` 返回一个“锁守护对象”（lock guard）
	- 当锁守护对象被析构时，对应的锁被释放
- `Lock<T>`（即 `(Lock, T)`）：用新类型将锁与资源关联起来

RAII 指 将资源的生命周期绑定到对象的生命周期，当对象被创建（初始化）时，它获取所需的资源（如内存、文件句柄、锁等）。当对象被销毁时，它自动释放这些资源。

### Lock-based concurrency’s safe(ish) API: lock guard
- Lock guard: holding a lock
- [https://en.cppreference.com/w/cpp/thread/lock_guard](https://en.cppreference.com/w/cpp/thread/lock_guard)

**![](https://lh7-rt.googleusercontent.com/slidesz/AGV_vUdTCYk7YWqEm5w9cupbjoQz8P2UNCDKVJ1sAx1MVlrTW_7LqLRq86YFkyQi9WYocHBStcNun-R4PbZiN0dQT-atHRFLny8nXCXp8kVIXzhFGI2F-oOEQJIfL5pZ2ZJ3Gvt0OoD4HWGtNTpjV3lbArfqTsQ7QVk=s2048?key=pFI0iQIu-AUwhliN9TiC1w)**

### 锁定数据（Locked Data）

**概念**

-   一个锁定数据对象是 **锁 + 数据** 的组合。
    
-   优势：API 保证内部数据在访问时由锁（Lock）保护，从而相对安全。
    

// 类型定义  
`template<typename T> class Lock<T> { RawLock lock; T data; }`

// 获取锁并创建锁守护对象  
`LockGuard<T> Lock<T>::lock(this) { this->lock.acquire(); LockGuard { this } }`

// 从锁守护对象解引用数据  
`&T LockGuard<T>::operator->(this) { &this->0.data }`

// 析构时自动释放锁  
`LockGuard<T>::~LockGuard() { this->0.lock.release(); }`

### 基于锁的并发的“相对安全”API：其实并不安全！
示例说明（C++ 风格）
```
// data: Lock<int>
auto data_guard = data.lock();          // 获取锁，创建锁守护对象
auto data_ptr = (int *) &data_guard;    // 获取指针
…
// data_guard 离开作用域，被析构，锁自动释放
*data_ptr = 666;                        // 不安全操作！UNSAFE

```
- `data_ptr` 的生命周期超过了 `data_guard`
	- 数据指针的生命周期不应该超过数据守护的生命周i去
- 这个 API 很容易出错：在生产代码中，这类错误很容易发生，导致严重问题（数据竞争、未定义行为等）

 解决方案
- Rust 通过 **所有权（Ownership）和生命周期（Lifetime）** 的类型系统避免此类问题
- Rust 中的锁实现提供 **经过验证的安全（论文验证） API**
    - 示例参考：[Rust Lock API 实现](https://github.com/kaist-cp/cs431/blob/main/src/lock/api.rs?utm_source=chatgpt.com)

