## 核心挑战：组合爆炸式不确定性(nondeterminism)

### 根源 1：指令交错（Interleaving）

例如，执行 “X=1 || X=2”（“||” 表示并发执行）时，**最终的内存状态（即变量 X 的最终值）取决于两条指令的执行顺序**：

- 若先执行 “X=1” 再执行 “X=2”，最终 X=2；
- 若先执行 “X=2” 再执行 “X=1”，最终 X=1。  
这种因执行顺序不同导致结果差异的现象，就是指令交错引发的不确定性。

### 根源 2：硬件 / 编译器优化

现代计算机体系结构或编译器会通过**指令重排序**优化性能，可能导致看似 “不符合逻辑” 的结果，例如：  
假设有两组代码并发执行：

|并发代码组 1|并发代码组 2|
|---|---|
|X = 1|Y = 1|
|a = Y|b = X|


在未优化的逻辑中，可能认为 “a=0 且 b=0” 是不可能的（因为直觉上 “X=1” 和 “Y=1” 应先执行），但编译器 / 硬件可能对指令重排序（如交换 “a=Y” 与 “X=1” 的执行顺序、交换 “b=X” 与 “Y=1” 的执行顺序），最终可能出现 “a=Y（此时 Y 未赋值，为初始值 0）” 且 “b=X（此时 X 未赋值，为初始值 0）” 的结果，即 “a=b=0”。

### 核心目标：驯服不确定性

（指通过同步机制、内存模型约束等技术，控制并发程序的执行行为，减少或消除不确定性，确保程序输出可预测、符合设计逻辑。）