## 1\. “Easy” Lock-Based Concurrency（锁机制并发）

#### 定义与实现手段

-   **Locks（锁）**：互斥锁（mutex）、读写锁（rwlock）
    
-   **Conditional variables（条件变量）**：用于线程间同步，等待某个条件成立再执行
    
-   常见 API：
    
    -   `std::mutex` + `std::unique_lock` / `std::lock_guard` (C++/Rust)
        
    -   `pthread_mutex_t` / `pthread_cond_t` (C)
        

#### 优缺点

| 优点           | 缺点                        |
| ------------ | ------------------------- |
| 简单直观，容易理解和实现 | **可扩展性低（Scalability）**    |
| 保护共享资源安全     | **丢失并行机会**：线程等待锁会阻塞，降低吞吐量 |
| 避免复杂的内存语义问题  | 死锁、饥饿问题风险                 |

#### 适用场景

-   覆盖大部分日常应用（“in terms of # of lines”指大多数代码行涉及的典型用例）
    
-   当性能要求不是极端高或并发量适中时，锁方案足够可靠且易维护
    

💡 核心理解：**锁方案牺牲部分并行性换取简单性**，适合多数工程场景。

---

## 2\. “Difficult” Lock-Free Concurrency（无锁并发）

#### 理论（Theory）

-   **语义与推理原则（Semantics and reasoning principles）**：
    
    -   如何在不使用锁的情况下保证操作的原子性和一致性
        
    -   **非确定性特征（nondeterminism）**：多个线程同时访问数据，顺序不可预测
        
    -   需要理解线性化（linearizability）、ABA 问题、内存序（memory order）
        

#### 工具（Tools）

-   **同步模式（Synchronization patterns）**：
    
    -   CAS（Compare-And-Swap） / FAA（Fetch-And-Add）
        
    -   原子变量（atomic types）
        
    -   双宽 CAS / 链表标记（marking）
        
-   这些是**构建无锁数据结构的基石**
    

#### 实践（Practice）

-   **无锁数据结构实现**：
    
    -   栈（Stack）、队列（Queue）、链表（List）、哈希表（Hash Table）
        
    -   高级树结构：基数树（Radix Tree）、平衡树（Balanced Tree）
        
-   API 层面需要保证：
    
    -   并发安全
        
    -   高吞吐量
        
    -   允许一定的非确定性（例如入队顺序、出队顺序可能不固定，但数据不丢失）
        

#### 优缺点

| 优点 | 缺点 |
| --- | --- |
| 高可扩展性，充分利用并行硬件 | 理论复杂，容易出错 |
| 无阻塞，减少等待 | 调试困难，内存语义和 ABA 问题需处理 |
| 性能高（吞吐量大） | 实现和验证成本高 |

💡 核心理解：**无锁方案牺牲**