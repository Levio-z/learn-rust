## 1\. “Easy” concurrency first

-   **核心理念**：先掌握锁机制、条件变量等简单并发手段。
    
-   **原因**：
    
    -   易于理解和实现
        
    -   能覆盖大多数业务场景
        
    -   快速见效，不会过早陷入复杂理论
        

> **原则**：只在真正成为性能瓶颈时，才考虑无锁或更复杂的并发技术。

对应格言：

> *“Premature optimization is the root of all evil”*  
> 过早优化会增加复杂性、调试难度，而收益可能微乎其微。

---

## 2\. “Difficult” concurrency is not that difficult once theory is understood
>一旦理解了理论，“复杂”并发其实并不难。  换句话说，理解理论本身可能是困难的……
-   **理论先行**：理解无锁并发需要掌握：
    
    -   原子操作（CAS、FAA）
        
    -   线性化（linearizability）
        
    -   内存顺序与可见性（memory order）
        
    -   非确定性特征（nondeterminism）
        
-   关键在于控制适量的非确定性：
    
    -   **太多非确定性** → 扩展性问题
        
    -   **太少非确定性** → 正确性问题
        

💡 核心：理论掌握了，复杂实现就不再神秘；难的是**知道如何控制非确定性**。

---

## 3\. 实践挑战

-   **代码量不大，但调试困难**：
    
    -   并发 bug 难以重现
        
    -   race condition、死锁、ABA 问题很棘手
        
-   **工具**：
    
    -   **Sanitizer**（ThreadSanitizer / AddressSanitizer）
        
    -   **Stress testing**（压力测试）
        
    -   **Assert & line-by-line debugging**（断言 + 逐行调试）
        
-   **思维方式**：
    
    -   数学思维：证明操作原子性、推导非确定性范围
        
    -   编程语言理论思维（PL thinking）：理解内存模型、可见性和同步语义

	- 考虑程序的正确性，我们处理所有的极端情况，考虑所有的案例

---

## 4\. 总结原则

1.  **先易后难**：锁并发先学，无锁并发只在必要时用
    
2.  **理论为王**：掌握原理后，复杂性就可控
    
3.  **调控非确定性**：平衡性能和正确性
    
4.  **调试工具不可少**：sanitizer、压力测试、断言、精细调试
    
5.  **思维方式重要**：数学 + PL 思维帮助设计和验证高质量并发代码
    

---

💡 **一句话总结**：

> 学锁并发积累经验，理论掌握非确定性，无锁并发才真正不难，但调试永远是硬核挑战。

---