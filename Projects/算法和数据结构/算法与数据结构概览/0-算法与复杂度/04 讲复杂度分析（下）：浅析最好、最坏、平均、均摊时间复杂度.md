### 最好、最坏情况时间复杂度
```
// 在长度为 n 的数组 array 中查找元素 x，返回 x 最后出现的位置索引，未找到返回 -1
int find(int array[], int n, int x) {
    int pos = -1;  // 记录元素 x 最后出现的位置，初始化为 -1 表示未找到
    for (int i = 0; i < n; ++i) {
        if (array[i] == x) {
            pos = i;  // 更新位置，继续遍历寻找最后一次出现
        }
    }
    return pos;
}
```
时间复杂度为O(n)
```
// 在长度为 n 的数组 array 中查找元素 x，返回 x 第一次出现的位置索引，未找到返回 -1
int find(int array[], int n, int x) {
    for (int i = 0; i < n; ++i) {
        if (array[i] == x) {
            return i;  // 找到第一个匹配元素，立即返回索引
        }
    }
    return -1;  // 未找到返回 -1
}
```
- **最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度**。
- **最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度**。
- 平均情况时间复杂度 
	- 要查找的变量x在数组中的位置，有n+1种情况：**在数组的0～n-1位置中**和**不在数组中**。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以n+1，就可以得到需要遍历的元素个数的平均值，即：
	![](asserts/Pasted%20image%2020250725200026.png)
	系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是O(n)。

我们知道，要查找的变量x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为1/2。另外，要查找的数据出现在0～n-1这n个位置的概率也是一样的，为1/n。所以，根据概率乘法法则，要查找的数据出现在0～n-1中任意位置的概率就是1/(2n)。

因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：
![](asserts/Pasted%20image%2020250725200237.png)

这个值就是概率论中的**加权平均值**，也叫作**期望值**，所以平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**。
- 加权平均：每个值都有一个“权重” pip_ipi​（表示它出现的“重要性”或“概率”）

引入概率之后，前面那段代码的加权平均值为(3n+1)/4。用大O表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是O(n)。

你可能会说，平均时间复杂度分析好复杂啊，还要涉及概率论的知识。**实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分**。

### 均摊时间复杂度
大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。
```
// 定长数组 array 表示容量为 n 的缓存容器
int[] array = new int[n];
int count = 0;

/**
 * 向数组中插入一个整数 val。
 * 如果数组已满，则将现有数组求和写入 array[0]，并重置 count。
 */
void insert(int val) {
    if (count == array.length) {
        // 当数组满了：先求所有元素之和
        int sum = 0;
        for (int i = 0; i < array.length; ++i) {
            sum += array[i];
        }
        // 将总和写入 array[0]，其余位置清空（逻辑上）
        array[0] = sum;
        count = 1;
    }

    // 插入新值
    array[count] = val;
    ++count;
}

```
最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为count的位置就可以了，所以最好情况时间复杂度为O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为O(n)。

那平均时间复杂度是多少呢？答案是O(1)。我们还是可以通过前面讲的概率论的方法来分析。

假设数组的长度是n，根据数据插入的位置的不同，我们可以分为n种情况，每种情况的时间复杂度是O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是O(n)。而且，这n+1种情况发生的概率一样，都是1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：
![](asserts/Pasted%20image%2020250725201356.png)
首先，find()函数在极端情况下，复杂度才为O(1)。但insert()在大部分情况下，时间复杂度都为O(1)。只有个别情况下，复杂度才比较高，为O(n)。这是insert()**第一个**区别于find()的地方。

我们再来看**第二个**不同的地方。对于insert()函数来说，O(1)时间复杂度的插入和O(n)时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个O(n)插入之后，紧跟着n-1个O(1)的插入操作，循环往复。

所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。

针对这种特殊的场景，我们引入了一种更加简单的分析方法：**摊还分析法**，通过摊还分析得到的时间复杂度我们起了一个名字，叫**均摊时间复杂度**。

那究竟**如何使用摊还分析法来分析算法的均摊时间复杂度**呢？

- 我们还是继续看在数组中插入数据的这个例子。每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。这就是均摊分析的大致思路。你都理解了吗？
- 均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但其实我个人认为，**均摊时间复杂度就是一种特殊的平均时间复杂度**，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。

### 内容小结

今天我们学习了几个复杂度分析相关的概念，分别有：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。之所以引入这几个复杂度概念，是因为，同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。

在引入这几个概念之后，我们可以更加全面地表示一段代码的执行效率。而且，这几个概念理解起来都不难。最好、最坏情况下的时间复杂度分析起来比较简单，但平均、均摊两个复杂度分析相对比较复杂。如果你觉得理解得还不是很深入，不用担心，在后续具体的数据结构和算法学习中，我们可以继续慢慢实践！

### 分析一下下面这个add()函数的时间复杂度
```
// 全局变量
int array[] = new int[10];  // 初始数组，长度为10
int len = 10;               // 当前数组容量
int i = 0;                  // 当前已使用的长度（下一个插入位置）

// 向数组中添加一个元素，若空间不足则自动扩容
void add(int element) {
    if (i >= len) {
        // 1. 分配新的数组，容量为原来的2倍
        int new_array[] = new int[len * 2];
        
        // 2. 将旧数组内容复制到新数组中
        for (int j = 0; j < len; ++j) {
            new_array[j] = array[j];
        }

        // 3. 替换原数组指针为新数组
        array = new_array;
        
        // 4. 更新数组容量
        len = len * 2;
    }

    // 添加新元素
    array[i] = element;
    ++i;
}
```
### 总结
- 最好
- 最坏
- **加权平均时间复杂度**
	- 加权平均：每个值都有一个“权重” pip_ipi​（表示它出现的“重要性”或“概率”）
- 均摊时间复杂度
	- 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。
- **实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分**