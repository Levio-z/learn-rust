针对有序数据集合的查找算法，⼆分查找的思想⾮常简单，很多⾮计算机专业的同学很容易就能理解，但是看似越简单的东⻄往往越难掌握好，想要灵活应⽤就更加困难。

⽼规矩，我们还是来看⼀道思考题。 假设我们有1000万个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万数据 中？ 我们希望这个功能不要占⽤太多的内存空间，最多不要超过100MB，你会怎么做呢？带着这个问题，让我们进⼊今天的 内容吧！

### 二分思想

假设有1000条订单数据，已经按照订单⾦额从⼩到⼤排序，每个 订单⾦额都不同，并且最⼩单位是元。我们现在想知道是否存在⾦额等于19元的订单。如果存在，则返回订单数据，如果不 存在则返回null。

最简单的办法当然是从第⼀个订单开始，⼀个⼀个遍历这1000个订单，直到找到⾦额等于19元的订单为⽌。但这样查找会⽐ 较慢，最坏情况下，可能要遍历完这1000条记录才能找到。那⽤⼆分查找能不能更快速地解决呢？

假设只有10个订单，订单⾦额分别是：8，11，19，23，27，33，45，55，67，98。

还是利⽤⼆分思想，每次都与区间的中间数据⽐对⼤⼩，缩⼩查找区间的范围。为了更加直观，我画了⼀张查找过程的图。其 中，low和high表示待查找区间的下标，mid表示待查找区间的中间元素下标。
![](asserts/Pasted%20image%2020250810233445.png)

二分查找的核心思想
- **⼆分查找针对的是⼀个有序的数据集 合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对⽐，将待查找的区间缩⼩为之前的⼀半，直到找到要查找的 元素，或者区间被缩⼩为0。**


### O(logn)惊⼈的查找速度

我们假设数据⼤⼩是n，每次查找后数据都会缩⼩为原来的⼀半，也就是会除以2。最坏情况下，直到查找区间被缩⼩为空， 才停⽌。


![](asserts/Pasted%20image%2020250810233601.png)


可以看出来，这是⼀个等⽐数列。其中n/2^k =1时，k的值就是总共缩⼩的次数。⽽每⼀次缩⼩操作只涉及两个数据的⼤⼩⽐ 较，所以，经过了k次区间缩⼩操作，时间复杂度就是O(k)。可以求得k=log n

**极其高效**：O(logn)这种对数时间复杂度。这是⼀种极其⾼效的时间复杂度，有的时候甚⾄ ⽐时间复杂度是常量级O(1)的算法还要⾼效。
- 原理：**因为logn是⼀个⾮常“恐怖”的数量级，即便n⾮常⾮常⼤，对应的logn也很⼩**。
- 例子：⽐如n等于2的32次⽅，这个数很⼤了吧？⼤约 是42亿。也就是说，如果我们在42亿个数据中⽤⼆分查找⼀个数据，最多需要⽐较32次。
- **VS常量级时间复杂度**
	- 我们前⾯讲过，⽤⼤O标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是⼀个⾮常⼤的常量值，⽐如O(1000)、O(10000)。所以，**常量级时间复杂度的算法有时候可能还没有O(logn) 的算法执⾏效率⾼**。

反过来，对数对应的就是指数。有⼀个⾮常著名的“阿基⽶德与国王下棋的故事”，你可以⾃⾏搜索⼀下，感受⼀下指数的“恐怖”。这也是为什么我们说，指数时间复杂度的算法在⼤规模数据⾯前是⽆效的。


### ⼆分查找的递归与⾮递归实现

实际上，简单的⼆分查找并不难写，注意我这⾥的“简单”⼆字。下⼀节，我们会讲到⼆分查找的变体问题，那才是真正烧脑的。今天，我们来看如何来写最简单的⼆分查找。 最简单的情况就是有序数组中不存在重复元素，我们在其中⽤⼆分查找值等于给定值的数据。我⽤Java代码实现了⼀个最简 单的⼆分查找算法。
```java
public int search(int[] a, int n,int value){
	 int low = 0;
	 int high = n-1;
	 while (low<=high){
		 int mid = (low+high)/2;
		 if(a[mid] ==value){
			 return mid
		 }else if (a[mid]<value){
			 low = mid +1;
		 }else{
			high = mid -1;	 
		 }
 }
 return -1;

}

```
这个代码我稍微解释⼀下，low、high、mid都是指数组下标，其中low和high表示当前查找的区间范围，初始low=0， high=n1。mid表示`[low, high]`的中间位置。我们通过对⽐a`[mid]`与value的⼤⼩，来更新接下来要查找的区间范围，直到找到或者区间 缩⼩为0，就退出。如果你有⼀些编程基础，看懂这些应该不成问题。现在，我就着重强调⼀下容易出错的3个地⽅。

1.循环退出条件
注意是low<=high，⽽不是low

2.mid的取值
实际上，mid=(low+high)/2这种写法是有问题的。因为如果low和high⽐较⼤的话，两者之和就有可能会溢出。改进的⽅法是将 mid的计算⽅式写成low+(high-low)/2。更进⼀步，如果要将性能优化到极致的话，我们可以将这⾥的除以2操作转化成位运算 low+((high-low)>>1)。因为相⽐除法运算来说，计算机处理位运算要快得多。

3.low和high的更新
low=mid+1，high=mid-1。注意这⾥的+1和-1，如果直接写成low=mid或者high=mid，就可能会发⽣死循环。⽐如，当 high=3，low=3时，如果a`[3]`不等于value，就会导致⼀直循环不退出。

如果你留意我刚讲的这三点，我想⼀个简单的⼆分查找你已经可以实现了。实际上，⼆分查找除了⽤循环来实现，还可以⽤递 归来实现，过程也⾮常简单。

我⽤Java语⾔实现了⼀下这个过程，正好你可以借此机会回顾⼀下写递归代码的技巧。

```
// 二分查找的过程
public int bsearch(int[] a,int n,int val){
	return bsearchInternally(a,0,n-1,val);
}

private bsearchInternally(int[] a, int low, int high, int value) {
	if (low > high) return -1;

	int mid = low + ((high - low)>>1));
	if (a[mid] == value){
		return mid;
	}else if (a[mid] < value){
		return bsearchInternally(a,mid+1,high,value);
	}else{
		return bsearchInternally(a, low, mid-1, value);
	}

}

```

### ⼆分查找应⽤场景的局限性

前⾯我们分析过，⼆分查找的时间复杂度是O(logn)，查找数据的效率⾮常⾼。不过，并不是什么情况下都可以⽤⼆分查找， 它的应⽤场景是有很⼤局限性的。那什么情况下适合⽤⼆分查找，什么情况下不适合呢？


- ⼆分查找依赖的是顺序表结构，简单点说就是数组。
	- 那⼆分查找能否依赖其他数据结构呢？⽐如链表。答案是不可以的，主要原因是⼆分查找算法需要按照下标随机访问元素。我 们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是O(1)，⽽链表随机访问的时间复杂度是O(n)。所以， 如果数据使⽤链表存储，⼆分查找的时间复杂就会变得很⾼。
- 其次，⼆分查找针对的是有序数据。
	- ⼆分查找对这⼀点的要求⽐较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。前⾯章节⾥我们讲到，排序的时 间复杂度最低是O(nlogn)。所以，如果我们针对的是⼀组静态的数据，没有频繁地插⼊、删除，我们可以进⾏⼀次排序，多次 ⼆分查找。这样排序的成本可被均摊，⼆分查找的边际成本就会⽐较低。
	- 但是，如果我们的数据集合有频繁的插⼊和删除操作，要想⽤⼆分查找，要么每次插⼊、删除操作之后保证数据仍然有序，要 么在每次⼆分查找之前都先进⾏排序。针对这种动态数据集合，⽆论哪种⽅法，维护有序的成本都是很⾼的。
	- **所以，⼆分查找只能⽤在插⼊、删除操作不频繁，⼀次排序多次查找的场景中**。针对动态变化的数据集合，⼆分查找将不再适 ⽤。那针对动态数据集合，如何在其中快速查找某个数据呢？别急，等到⼆叉树那⼀节我会详细讲。
- 再次，数据量太⼩不适合⼆分查找。
	- 如果要处理的数据量很⼩，完全没有必要⽤⼆分查找，顺序遍历就⾜够了。⽐如我们在⼀个⼤⼩为10的数组中查找⼀个元 素，不管⽤⼆分查找还是顺序遍历，查找速度都差不多。只有数据量⽐较⼤的时候，⼆分查找的优势才会⽐较明显。 不过，这⾥有⼀个例外。**如果数据之间的⽐较操作⾮常耗时，不管数据量⼤⼩，我都推荐使⽤⼆分查找。⽐如，数组中存储的 都是⻓度超过300的字符串，如此⻓的两个字符串之间⽐对⼤⼩，就会⾮常耗时。我们需要尽可能地减少⽐较次数，⽽⽐较次 数的减少会⼤⼤提⾼性能，这个时候⼆分查找就⽐顺序遍历更有优势**。
- 最后，数据量太⼤也不适合⼆分查找。
	- **⼆分查找的底层需要依赖数组这种数据结构，⽽数组为了⽀持随机访问的特性，要求内存空间连续，对内存的要求⽐较苛刻。 ⽐如，我们有1GB⼤⼩的数据，如果希望⽤数组来存储，那就需要1GB的连续内存空间**。 注意这⾥的“连续”⼆字，也就是说，即便有2GB的内存空间剩余，但是如果这剩余的2GB内存空间都是零散的，没有连续的 1GB⼤⼩的内存空间，那照样⽆法申请⼀个1GB⼤⼩的数组。⽽我们的⼆分查找是作⽤在数组这种数据结构之上的，所以太⼤ 的数据⽤数组存储就⽐较吃⼒了，也就不能⽤⼆分查找了。

总结
- 依赖数组结构，且静态的数据，没有频繁地插⼊、删除，我们可以进⾏⼀次排序，多次 ⼆分查找，数据量太小没必要用二分查找，除非数据之间的比较比较耗时。数据量太大也不适合用二分查找，因为为了支持随机访问的特性，要求内存连续，非常占用内存。