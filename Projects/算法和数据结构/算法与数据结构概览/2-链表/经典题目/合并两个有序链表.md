使用一个头几点
### 原理
- 两个有序队列如何合并的数学问题
- **合并的时候找出所有内容的最小值，可以利用有序来简化**
	- 两链表都不为空
		- 从链表的头部找，有两个，比较两个链表的最小值，将最小值添加到新链表里面
		-  循环
			- 条件：两链表都有元素的时候
			- 内容：找到最小的，接入新链表
			- 维护状态：提供了最小元素的链表的表头就要向后移动
	- 其中一个链表为空的情况
		- 退出循环，将不为空的接入新链表

- 初始状态维护问题
	- 一开始不知道哪个元素是新链表的头部，就要单独判断这种情况
	- 头部为空就要设置头部，并且保存这个头部
	- 不为空就接入链表的尾部，直接引入一个虚拟头部，去掉这个判断逻辑

### java实现
```java
class Solution {

    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        ListNode dummy = new ListNode(); // 用哨兵节点简化代码逻辑

        ListNode cur = dummy; // cur 指向新链表的末尾

        while (list1 != null && list2 != null) {

            if (list1.val < list2.val) {

                cur.next = list1; // 把 list1 加到新链表中

                list1 = list1.next;

            } else { // 注：相等的情况加哪个节点都是可以的

                cur.next = list2; // 把 list2 加到新链表中

                list2 = list2.next;

            }

            cur = cur.next;

        }

        cur.next = list1 != null ? list1 : list2;

        return dummy.next;

    }

}
```

不用辅助头节点
```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 处理初始 head：选出第一个节点作为新链表的头部
        if (list1 == null) return list2;
        if (list2 == null) return list1;

        ListNode head; // 合并链表的头
        ListNode cur;  // 当前指针，指向新链表的末尾

        // 初始化 head 和 cur
        if (list1.val < list2.val) {
            head = list1;
            list1 = list1.next;
        } else {
            head = list2;
            list2 = list2.next;
        }
        cur = head;

        // 遍历两个链表，按顺序合并
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cur.next = list1;
                list1 = list1.next;
            } else {
                cur.next = list2;
                list2 = list2.next;
            }
            cur = cur.next;
        }

        // 拼接剩余部分
        cur.next = (list1 != null) ? list1 : list2;

        return head;
    }
}
```
### Rust


## Rust中专有内容
### 如何同时拥有头节点和尾节点
构造新链表，需要用到头节点，java中都是指针，所以一个指向头节点，一个指向尾节点，但是rust不行。
rust中只有一个指向头节点，一个可变引用指向尾节点。
>rust中因为所有权的关系，链表的头节点始终拥有整个链表的所有权的

