![](asserts/Pasted%20image%2020250807085957.png)
从第一性原理考虑

从本质上讲，“反转链表”就是**把每个指针的方向反过来**：
```
原链表：
head -> A -> B -> C -> null

目标链表：
null <- A <- B <- C <- head

```
- 遍历链表
	- 当前节点不为空，将链表反转
对于每个节点，我们要做：
- 核心操作
```
当前节点的 next 指针，原来指向下一个节点；
现在要指向前一个节点。
```
- 为了保证循环继续进行，需要动态维护什么变量
	- 维护之前节点(可变)：每轮操作之后，当前节点会变为前一个节点
	- 维护当前节点（可变）：让当前节点的下一个节点成为当前节点
	- 初始的状态？
由上可知
```
初始状态维护
pre =
cur =
循环：
核心操作：反转
维护状态
```

```rust
// head = Option<Box<ListNode>>
let mut pre = None;
let mut cur = head;
while let Some(node) = cur{
	// 维护状态
	cur = node.next;
	// 核心操作
	node.next = pre;
	// 维护状态
	pre = Some(node);
}
```
- 循环
	- rust里面会有什么不同，rust没有NULL指针，用Option来包装
	- 用解构的方式来遍历，这里取出了cur的里面的node，cur是移动语义，cur就不能再使用了
- 维护状态
	- 移动语义来实现，比较难以理解的地方


## Rust需要注意的地方
### 部分结构
```
while let Some(node) = cur
```
是 Rust 在编译时发现了你对一个**不可复制的类型（如 `Box<T>`）执行了部分解构（partial move）**之后，还试图再使用原变量，这违反了所有权规则。
- cur的值被移动了，cur就不能使用了，可以重新赋值
```
error[E0382]: use of partially moved value: `cur`
  --> main.rs:xx:xx
   |
xx |     let Box(cur_val) = cur;
   |         -----------    ^^^ value used here after partial move
   |         |
   |         value partially moved here
   |
   = note: partial move occurs because value has type `Box<i32>`, which does not implement the `Copy` trait
```
#### 移动的语义
- **被移动的字段（非 `Copy` 类型）不再可用，访问会编译报错。**
- **其他未移动字段仍然有效且可以正常访问。**
- **整体结构体仍然存在，但其状态处于部分“已移动”状态。**
- **此时只能访问未移动的字段，不能将整体结构体当作完整值继续使用。**
#### 解构和移动的关系
- **当你解构部分字段时，如果该字段是非 `Copy` 类型，字段的所有权被“移动”出去了**。