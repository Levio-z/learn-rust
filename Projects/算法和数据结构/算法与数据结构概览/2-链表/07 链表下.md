### 如何写好链表
#### 理解指针和引用的意义
链表的结构不难，要想写好，需要理解指针的概念，指针就是存储所指对象的内存地址。

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向 了这个变量，通过指针就能找到这个变量。

在编写链表代码的时候，我们经常会有这样的代码：p->next=q。这⾏代码是说，p结点中的next指针存储了q结点的内存地址。

#### 警惕指针丢失和内存泄漏
们希望在结点a和相邻的结点b之间插⼊结点x，假设当前指针p指向结点a。如果我们将代码实现变成下⾯这个样 ⼦，就会发⽣指针丢失和内存泄露。
```
p->next = x; // 将p的next指针指向x结点； 
x->next = p->next; // 将x的结点的next指针指向b结点；
```
初学者经常会在这⼉犯错。p->next指针在完成第⼀步操作之后，已经不再指向结点b了，⽽是指向结点x。第2⾏代码相当于将 x赋值给x->next，⾃⼰指向⾃⼰。因此，整个链表也就断成了两半，从结点b往后的所有结点都⽆法访问到了。

对于有些语⾔来说，⽐如C语⾔，内存管理是由程序员负责的，如果没有⼿动释放结点对应的内存空间，就会产⽣内存泄露。 所以，我们插⼊结点时，⼀定要注意操作的顺序，要先将结点x的next指针指向结点b，再把结点a的next指针指向结点x，这样 才不会丢失指针，导致内存泄漏。所以，对于刚刚的插⼊代码，我们只需要把第1⾏和第2⾏代码的顺序颠倒⼀下就可以了。

同理，删除链表结点时，也⼀定要记得⼿动释放内存空间，否则，也会出现内存泄漏的问题。当然，对于像Java这种虚拟机 ⾃动管理内存的编程语⾔来说，就不需要考虑这么多了。

### 技巧三：利⽤哨兵简化实现难度
⾸先，我们先来回顾⼀下单链表的插⼊和删除操作。如果我们在结点p后⾯插⼊⼀个新的结点，只需要下⾯两⾏代码就可以搞 定。
```
new_node->next = p->next;
p->next = new_node;
```
但是，当我们要向⼀个空链表中插⼊第⼀个结点，刚刚的逻辑就不能⽤了。我们需要进⾏下⾯这样的特殊处理，其中head表 示链表的头结点。所以，从这段代码，我们可以发现，对于单链表的插⼊操作，第⼀个结点和其他结点的插⼊逻辑是不⼀样 的。
```
if (head == null) 
{ head = new_node;
}
```
我们再来看单链表结点删除操作。如果要删除结点p的后继结点，我们只需要⼀⾏代码就可以搞定。
```
p->next = p->next->next;
```
但是，如果我们要删除链表中的最后⼀个结点，前⾯的删除代码就不work了。跟插⼊类似，我们也需要对于这种情况特殊处 理。写成代码是这样⼦的：
```
if (head->next == null) {
head = null; 
}
```
从前⾯的⼀步⼀步分析，我们可以看出，针对链表的插⼊、删除操作，需要对插⼊第⼀个结点和删除最后⼀个结点的情况进⾏ 特殊处理。

技巧三中提到的哨兵就要登场了。哨兵，解决的是国家之间的边界问题。同理，这⾥说的哨兵也是解决“边界问题”的，不直接 参与业务逻辑。 还记得如何表示⼀个空链表吗？head=null表示链表中没有结点了。其中head表示头结点指针，指向链表中的第⼀个结点。

如果我们引⼊哨兵结点，在任何时候，**不管链表是不是空，head指针都会⼀直指向这个哨兵结点**。我们也把这种有哨兵结点 的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。

我画了⼀个带头链表，你可以发现，哨兵结点是不存储数据的。因为哨兵结点⼀直存在，所以插⼊第⼀个结点和插⼊其他结 点，删除最后⼀个结点和删除其他结点，都可以统⼀为相同的代码实现逻辑了。
![](asserts/Pasted%20image%2020250803102429.png)
实际上，这种利⽤哨兵简化编程难度的技巧，在很多代码实现中都有⽤到，⽐如插⼊排序、归并排序、动态规划等。这些内容 我们后⾯才会讲，现在为了让你感受更深，我再举⼀个⾮常简单的例⼦。代码我是⽤C语⾔实现的，不涉及语⾔⽅⾯的⾼级语 法，很容易看懂，你可以类⽐到你熟悉的语⾔。

代码⼀：
```
// 在数组 a 中查找字符 key，返回 key 所在的位置（索引）
// 参数：
//   a   - 字符数组指针
//   n   - 数组长度
//   key - 要查找的目标字符
// 返回值：
//   如果找到 key，返回其索引位置；否则返回 -1
int find(char* a, int n, char key) {
    // 边界条件检查：若数组为空或长度不合法，直接返回 -1
    if (a == NULL || n <= 0) {
        return -1;
    }

    // 遍历数组查找 key
    for (int i = 0; i < n; ++i) {
        if (a[i] == key) {
            return i; // 找到后立即返回索引
        }
    }

    // 未找到，返回 -1
    return -1;
}

```
代码二：
```
// 在数组 a 中查找 key，返回 key 所在的位置
// 其中，n 表示数组 a 的长度
int find(char* a, int n, char key) {
    // 边界条件处理，如果 a 为空，或者 n <= 0，说明数组中没有数据，就不用 while 循环比较了
    if (a == NULL || n <= 0) {
        return -1;
    }

    // 这里因为要将 a[n-1] 的值替换成 key，所以要特殊处理这个值
    if (a[n - 1] == key) {
        return n - 1;
    }

    // 把 a[n-1] 的值临时保存在变量 tmp 中，以便之后恢复。tmp = 6
    // 之所以这样做的目的是：希望 find() 代码不要改变 a 数组中的内容
    char tmp = a[n - 1];

    // 把 key 的值放到 a[n-1] 中，此时 a = {4, 2, 3, 5, 9, key}
    a[n - 1] = key;

    int i = 0;

    // while 循环比起代码一，少了 i<n 这个比较操作
    while (a[i] != key) {
        ++i;
    }

    // 恢复 a[n-1] 原来的值, 此时 a = {4, 2, 3, 5, 9, 6}
    a[n - 1] = tmp;

    if (i == n - 1) {
        // 如果 i == n-1 说明，在 0...n-2 之间都没有 key，所以返回 -1
        return -1;
    } else {
        // 否则，返回 i，就是等于 key 值的元素的下标
        return i;
    }
}
```

对⽐两段代码，在字符串a很⻓的时候，⽐如⼏万、⼏⼗万，你觉得哪段代码运⾏得更快点呢？答案是代码⼆，因为两段代码 中执⾏次数最多就是while循环那⼀部分。第⼆段代码中，我们通过⼀个哨兵a`[n-1]` = key，成功省掉了⼀个⽐较语句i<n，不要
⼩看这⼀条语句，当累积执⾏万次、⼏⼗万次时，累积的时间就很明显了。

当然，这只是为了举例说明哨兵的作⽤，你写代码的时候千万不要写第⼆段那样的代码，因为可读性太差了。⼤部分情况下， 我们并不需要如此追求极致的性能。

### 技巧四：重点留意边界条件处理
软件开发中，代码在⼀些边界或者异常情况下，最容易产⽣Bug。链表代码也不例外。要实现没有Bug的链表代码，⼀定要在 编写的过程中以及编写完成之后，检查边界条件是否考虑全⾯，以及代码在边界条件下是否能正确运⾏。

我经常⽤来检查链表代码是否正确的边界条件有这样⼏个： 如果链表为空时，代码是否能正常⼯作？ 如果链表只包含⼀个结点时，代码是否能正常⼯作？ 如果链表只包含两个结点时，代码是否能正常⼯作？ 代码逻辑在处理头结点和尾结点的时候，是否能正常⼯作？


当你写完链表代码之后，除了看下你写的代码在正常的情况下能否⼯作，还要看下在上⾯我列举的⼏个边界条件下，代码仍然 能否正确⼯作。如果这些边界条件下都没有问题，那基本上可以认为没有问题了。 当然，边界条件不⽌我列举的那些。针对不同的场景，可能还有特定的边界条件，这个需要你⾃⼰去思考，不过套路都是⼀样 的。 实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，⼀定要多想想，你的 代码在运⾏的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！

### 技巧五：举例画图，辅助思考
对于稍微复杂的链表操作，⽐如前⾯我们提到的单链表反转，指针⼀会⼉指这，⼀会⼉指那，⼀会⼉就被绕晕了。总感觉脑容 量不够，想不清楚。所以这个时候就要使⽤⼤招了，举例法和画图法。 你可以找⼀个具体的例⼦，把它画在纸上，释放⼀些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。⽐如往单 链表中插⼊⼀个数据这样⼀个操作，我⼀般都是把各种情况都举⼀个例⼦，画出插⼊前和插⼊后的链表变化，如图所示：
![](asserts/Pasted%20image%2020250803103444.png)
### 技巧六：多写多练，没有捷径
现在我写这些代码，简直就和“玩⼉”⼀样，其实也没有什么技巧，就是把常⻅的链表操作都⾃⼰多写⼏遍，出问题就⼀点⼀点 调试，熟能⽣巧

所以，我精选了5个常⻅的链表操作。你只要把这⼏个操作都能写熟练，不熟就多写⼏遍，我保证你之后再也不会害怕写链表 代码。 
单链表反转 
链表中环的检测 
两个有序的链表合并 
删除链表倒数第n个结点 
求链表的中间结点

