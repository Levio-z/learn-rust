### 实现顺序队列(java)
```java
// 用数组实现队列
public class ArrayQueue{
	//数组 items ，数组大小
	private String[] items;
	private int n =0;
	// head 表示队头下标，tail表示队尾下标
	private int head = 0;
	private int tail = 0;

	// 申请一个大小为capcity的数组
	public ArrayQueue(int capcity){
		items = new String[capcity];
		n = capcity;
	}

	// 入队
	public boolean enqueue(String item){
		 if (tail == n){
			 return false;
		 }
		 items[tail] = item;
		 ++tail;
		 return true;
	}

	// 出队
	public boolean dequeue(){
		// 队列为空
		if (tail == head){
			return false;
		}
		String ret = items[head];
		++head;
		return ret;
	}
}
```

队列需要两个指针：⼀个是head指针，指向队头；⼀个是tail指针，指向队尾。
![](asserts/Pasted%20image%2020250808084421.png)
当a、b、c、d依次⼊队之后，队列中的head指针指向下标为0的位置，tail指针指向下标为4的 位置。

![](asserts/Pasted%20image%2020250808084449.png)

当我们调⽤两次出队操作之后，队列中head指针指向下标为2的位置，tail指针仍然指向下标为4的位置。


随着不停地进⾏⼊队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空 闲空间，也⽆法继续往队列中添加数据了。这个问题该如何解决呢？


数组的删除操作会导致数组中的数据不连续,使用数据搬移解决，但是每次进行出队操作都相当于删除数组下标为0的数据，要搬移整个队列中的数据，出队的操作的时间复杂度由O(1)变为O(n)。如何优化？

如果没有空闲空间了，我们只需要在⼊队时，再集中触发⼀次数据的搬移操作
```java
public boolean enqueue(String item){
	// if tail == n 表示队列末尾没有空间了
	if(tail == n){
		// tail==n && head==0,整个队列都占满了
		if (head == 0) return false;
		// 数据搬移
		for (int i = head; i < tail;i++){
			items[i-head] = items[i];
		}
		// 搬完之后需要更新head和tail
		head =0;
		tail -= head;
	}
	items[tail] = item;
	tail ++;
	return true;
}
```

从代码中我们看到，当队列的tail指针移动到数组的最右边后，如果有新的数据⼊队，我们可以将head到tail之间的数据，整体 搬移到数组中0到tail-head的位置。

当队列的tail指针移动到数组的最右边后，如果有新的数据⼊队，我们可以将head到tail之间的数据，整体 搬移到数组中0到tail-head的位置。
![](asserts/Pasted%20image%2020250808085539.png)




