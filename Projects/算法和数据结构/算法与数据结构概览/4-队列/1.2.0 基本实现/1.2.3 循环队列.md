在`tail==n`时，会有数据搬移操作，这样⼊队操作性能就会受到影响。那有没有办法能够避 免数据搬移呢？我们来看看循环队列的解决思路。原本数组是有头有尾的，是⼀条直线。现在我们把⾸尾相连，扳成了⼀个环。
![](asserts/Pasted%20image%2020250808090454.png)
图中这个队列的⼤⼩为8，当前head=4，tail=7。当有⼀个新的元素a⼊队时，我们放⼊下标为7的位置。但这 个时候，我们并不把tail更新为8，⽽是将其在环中后移⼀位，到下标为0的位置。当再有⼀个元素b⼊队时，我们将b放⼊下标 为0的位置，然后tail加1更新为1。所以，在a，b依次⼊队之后，循环队列中的元素就变成了下⾯的样⼦：
![](asserts/Pasted%20image%2020250808090554.png)

通过这样的⽅法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要⽐前⾯讲的⾮循环队列难多了。要想写出没有bug的循环队列的实现代码，我个⼈觉得，最关键的是，确定好队空和队满的判定条件。

队列为空的判断条件仍然是head == tail。但队列满的判断条件就稍微有点复杂了。我画了⼀张队列满的图，你可以看⼀下， 试着总结⼀下规律。
![](asserts/Pasted%20image%2020250808090644.png)
就像我图中画的队满的情况，tail=3，head=4，n=8，所以总结⼀下规律就是：(3+1)%8=4。多画⼏张队满的图，你就会发 现，当队满时，**(tail+1)%n=head**。


你有没有发现，当队列满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费⼀个数组的存储空间。

```java
public class CircularQueue{
	// 数组items ，数组大小：n
	private String[] items;
	private int n;
	// head 表示队头下标，tail表示队尾下标
	private int head = 0;
	private int tail = 0;

	// 申请一个大小未capcity的数组
	public CircularQueue(int capcity){
		items = new String[capcity];
		n = capcity;
	}

	// 入队
	public boolean enqueue(String item){
		// 队列满了
		if((tail+1)%n == head ) return false;
		items[tail] = item;
		tail  = (tail+1)%n;
		return true;
	}

	// 出队
	public String dequeue(){
		// 如果head == tail表示队列为空
		if(head == tail) return null;
		String ret = items[head];
		head =(head+1)%n;
		return ret;
	}

}



```


