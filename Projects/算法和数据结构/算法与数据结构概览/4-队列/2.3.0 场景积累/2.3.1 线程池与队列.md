线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处 理？各种处理策略⼜是如何实现的呢？

第⼀种是⾮阻塞的处理⽅式，直接拒绝任务请求；另⼀种是阻塞的处理⽅式，将请求排队，等到有 空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？

我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前⾯说过，队列有 基于链表和基于数组这两种实现⽅式。这两种实现⽅式对于排队请求⼜有什么区别呢？


基于链表的实现⽅式，可以实现⼀个**⽀持⽆限排队的⽆界队列**（unbounded queue），但是可能会导致过多的请求排队等待， 请求处理的响应时间过⻓。所以，针对响应时间⽐较敏感的系统，基于链表实现的⽆限排队的线程池是不合适的。

⽽**基于数组实现的有界队列（bounded queue）**，队列的⼤⼩有限，所以线程池中排队的请求超过队列⼤⼩时，接下来的请求 就会被拒绝，这种⽅式对响应时间敏感的系统来说，就相对更加合理。不过，设置⼀个合理的队列⼤⼩，也是⾮常有讲究的。 队列太⼤导致等待的请求太多，队列太⼩会导致⽆法充分利⽤系统资源、发挥最⼤性能。 

除了前⾯讲到队列应⽤在线程池请求排队的场景之外，**队列可以应⽤在任何有限资源池中，⽤于排队请求**，⽐如数据库连接池等。实际上，对于⼤部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。
