冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进⾏⽐较，看是否满⾜⼤⼩关系要求。如果不满⾜就 让它俩互换。⼀次冒泡会让⾄少⼀个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序⼯作。

我⽤⼀个例⼦，带你看下冒泡排序的整个过程。我们要对⼀组数据4，5，6，3，2，1，从⼩到到⼤进⾏排序。第⼀次冒泡操 作的详细过程就是这样：

![](asserts/Pasted%20image%2020250808220953.png)
可以看出，经过⼀次冒泡操作之后，6这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进⾏6次这样 的冒泡操作就⾏了。

![](asserts/Pasted%20image%2020250808221044.png)

实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不⽤再继续执⾏后续的 冒泡操作。我这⾥还有另外⼀个例⼦，这⾥⾯给6个元素排序，只需要4次冒泡操作就可以了。


![](asserts/Pasted%20image%2020250808221108.png)
冒泡排序算法的原理⽐较容易理解，具体的代码我贴到下⾯，你可以结合着代码来看我前⾯讲的原理。

```java
public void bubbleSort(int[] a,int n){
	if(n<=1){
		return;
	}

	for (int i=0;i<n-1;i++){
		boolean flag = fasle;
		for (int j=0;j<n-1-i;j++){
			if(a[j]>a[j+1]){
				int temp = a[j];
				a[j] = a[j+1];
				a[j+1] =temp;
				flag =true;
			}
		}
		if(!flag) = break;
	}
}
```

每一次冒泡都是找一个最大值，每一次都能确定一个元素的位置，需要n-1次冒泡

第⼀，冒泡排序是原地排序算法吗？

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是⼀个原地排序算法。

第⼆，冒泡排序是稳定的排序算法吗？

在冒泡排序中，**只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素⼤⼩相等的时候，我们不做交换**，相同⼤⼩的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

第三，冒泡排序的时间复杂度是多少？

最好情况下，要排序的数据已经是有序的了，我们只需要进⾏⼀次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。⽽最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进⾏n次冒泡操作，所以最坏情况时间复杂度为O(n^2 )。

最好、最坏情况下的时间复杂度很容易分析，那平均情况下的时间复杂是多少呢？我们前⾯讲过，平均时间复杂度就是加权平 均期望时间复杂度，分析的时候要结合概率论的知识。

对于包含n个数据的数组，这n个数据就有n!种排列⽅式。不同的排列⽅式，冒泡排序执⾏的时间肯定是不同的。⽐如我们前⾯ 举的那两个例⼦，其中⼀个要进⾏6次冒泡，⽽另⼀个只需要4次。如果⽤概率论⽅法定量分析平均时间复杂度，涉及的数学 推理和计算就会很复杂。我这⾥还有⼀种思路，通过“有序度”和“逆序度”这两个概念来进⾏分析。

有序度是数组中具有有序关系的元素对的个数。有序元素对⽤数学表达式表示就是这样：


```
有序元素对：a[i] <= a[j], 如果i < j。
```

![](asserts/Pasted%20image%2020250808223100.png)


同理，对于⼀个倒序排列的数组，⽐如6，5，4，3，2，1，有序度是0；对于⼀个完全有序的数组，⽐如 1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是15。我们把这种完全有序的数组的有序度叫作满有序度。


逆序度的定义正好跟有序度相反（默认从⼩到⼤为有序），我想你应该已经想到了。关于逆序度，我就不举例⼦讲了。你可以 对照我讲的有序度的例⼦⾃⼰看下。

```
逆序元素对：a[i] > a[j], 如果i < j。
```

关于这三个概念，我们还可以得到⼀个公式：逆序度=满有序度-有序度。我们排序的过程就是⼀种增加有序度，减少逆序度的 过程，最后达到满有序度，就说明排序完成了。

我还是拿前⾯举的那个冒泡排序的例⼦来说明。要排序的数组的初始状态是4，5，6，3，2，1 ，其中，有序元素对有(4，5) (4，6)(5，6)，所以有序度是3。n=6，所以排序完成之后终态的满有序度为n*(n-1)/2=15。
![](asserts/Pasted%20image%2020250808223209.png)


冒泡排序包含两个操作原⼦，⽐较和交换。每交换⼀次，有序度就加1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。此例中就是15–3=12，要进⾏12次交换操作。

对于包含n个数据的数组进⾏冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是0，所以要进⾏n*(n-1)/2次 交换。最好情况下，初始状态的有序度是n*(n-1)/2，就不需要进⾏交换。我们可以取个中间值n*(n-1)/4，来表示初始有序度既 不是很⾼也不是很低的平均情况。

换句话说，平均情况下，需要n*(n-1)/4次交换操作，⽐较操作肯定要⽐交换操作多，⽽复杂度的上限是O(n^2)，所以平均情况 下的时间复杂度就是O(n^2)。 这个平均时间复杂度推导过程其实并不严格，但是很多时候很实⽤，毕竟概率论的定量分析太复杂，不太好⽤。等我们讲到快 排的时候，我还会再次⽤这种“不严格”的⽅法来分析平均时间复杂度。