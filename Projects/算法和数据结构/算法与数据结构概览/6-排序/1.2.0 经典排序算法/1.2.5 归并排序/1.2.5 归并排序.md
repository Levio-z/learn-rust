### 归并排序的原理

核心思想：
- 如果要排序⼀个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排 序，再将排好序的两部分合并在⼀起，这样整个数组就都有序了。
![](asserts/Pasted%20image%2020250810213901.png)

**分治思想**：
- 分治，顾名思义，就是分⽽治之，将⼀个⼤问题分解成⼩的⼦问题来解决。⼩的⼦问题解决 了，⼤问题也就解决了。

分治算法与递归：
- 分治算法⼀般都是⽤递归来实现的。分治是⼀种解决问题的处理思想，递归是⼀种编程技巧，这两者并不冲突。


### ⽤递归代码来实现归并排序
归并排序⽤的是分治思想，可以⽤递归来实现。我们现在就来看 看如何⽤递归代码来实现归并排序。
[2.1.0 如何编写递归代码](../../../5-递归/2.0%20使用/2.1.0%20如何编写递归代码.md)

1.先写出归并排序的递推公式
```
递推公式： merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) 
终⽌条件： p >= r 不⽤再继续分解
```

merge_sort(p…r)表示，给下标从p到r之间的数组排序。我们将这个排序问题转化为了两个⼦问题，merge_sort(p…q)和 merge_sort(q+1…r)，其中下标q等于p和r的中间位置，也就是(p+r)/2。当下标从p到q和从q+1到r这两个⼦数组都排好序之 后，我们再将两个有序的⼦数组合并在⼀起，这样下标从p到r之间的数据就也排好序了。

有了递推公式，转化成代码就简单多了。为了阅读⽅便，我这⾥只给出伪代码，你可以翻译成你熟悉的编程语⾔。
```java
// 归并排序算法，A是数组，n表示数组大小
merge_sort(A,n){
	merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
	// 递归终止条件
	if p >= r then return
	// 取p到r之间的q
	// 分治递归
	merge_sort_c(A, p, q)
	merge_sort_c(A, q+1, r)
	// 将A[p...q]和A[q+1...r]合并为A[p...r]
	merge(A[p...r], A[p...q], A[q+1...r])
}
```

```
你可能已经发现了，merge(A[p…r], A[p…q], A[q+1…r])这个函数的作⽤就是，将已经有序的A[p…q]和A[q+1…r]合并成⼀个有序的数组，并且放⼊A[p…r]。那这个过程具体该如何做呢？ 

如图所示，我们申请⼀个临时数组tmp，⼤⼩与A[p…r]相同。我们⽤两个游标i和j，分别指向A[p…q]和A[q+1…r]的第⼀个元素。⽐较这两个元素A[i]和A[j]，如果A[i]<=A[j]，我们就把A[i]放⼊到临时数组tmp，并且i后移⼀位，否则将A[j]放⼊到数组 tmp，j后移⼀位。

继续上述⽐较过程，直到其中⼀个⼦数组中的所有数据都放⼊临时数组中，再把另⼀个数组中的数据依次加⼊到临时数组的末尾，这个时候，临时数组中存储的就是两个⼦数组合并之后的结果了。最后再把临时数组tmp中的数据拷⻉到原数组A[p…r] 中。
```

![](asserts/Pasted%20image%2020250810215219.png)

我们把merge()函数写成伪代码，就是下⾯这样：
```
merge(A[p...r],A[p...q],A[q+1...r]){
	var i:=p,j :=q+1,k:=0 // 初始化变量i,j,k
	var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
	while i<=q AND j<=r do{
		if A[i]<= A[j]{
			tmp[k++] = A[i++] 
		}else{
			tmp[k++] = A[j++]
		}
	}

	// 判断哪个子数组中有剩余的数据
	var start:=i,end :=q
	if j<=r start := j,end :=r

	// 将剩余的数据拷贝到临时数组
	while start <= end do {
		tmp[k++] = A[start++]
	}

	// 将tmp中的数组拷贝回A[p...r]
	for i:0 to r-p do{
		A[p+i] = tmp[i]
	}
}
```

你还记得第7讲讲过的利⽤哨兵简化编程的处理技巧吗？merge()合并函数如果借助哨兵，代码就会简洁很多，这个问题留给你 思考。

### 归并排序的性能分析
第⼀，归并排序是稳定的排序算法吗？

```
结合我前⾯画的那张图和归并排序的伪代码，你应该能发现，归并排序稳不稳定关键要看merge()函数，也就是两个有序⼦数 组合并成⼀个有序数组的那部分代码。 在合并的过程中，如果A[p…q]和A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把A[p…q]中的元素放⼊tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是⼀个稳定的排序算法。
```

第⼆，归并排序的时间复杂度是多少？

归并排序涉及递归，时间复杂度的分析稍微有点复杂。我们正好借此机会来学习⼀下，如何分析递归代码的时间复杂度。

在递归那⼀节我们讲过，递归的适⽤场景是，⼀个问题a可以分解为多个⼦问题b、c，那求解问题a就可以分解为求解问题b、 c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。 

如果我们定义求解问题a的时间是T(a)，求解问题b、c的时间分别是T(b)和 T( c)，那我们就可以得到这样的递推关系式：

```
T(a) = T(b) + T(c) + K
```

其中K等于将两个⼦问题b、c的结果合并成问题a的结果所消耗的时间。

从刚刚的分析，我们可以得到⼀个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。 套⽤这个公式，我们来分析⼀下归并排序的时间复杂度。 我们假设对n个元素进⾏归并排序需要的时间是T(n)，那分解成两个⼦数组排序的时间都是T(n/2)。我们知道，merge()函数合 并两个有序⼦数组的时间复杂度是O(n)。所以，套⽤前⾯的公式，归并排序的时间复杂度的计算公式就是：

```
T(1) = C； n=1时，只需要常量级的执⾏时间，所以表示为C。 
T(n) = 2*T(n/2) + n； n>1
```
通过这个公式，如何来求解T(n)呢？还不够直观？那我们再进⼀步分解⼀下计算过程。
```
T(n) 
= 2*T(n/2) + n 
= 2*(2*T(n/4) + n/2) + n 
= 4*T(n/4) + 2*n 
= 4*(2*T(n/8) + n/4) + 2*n 
= 8*T(n/8) + 3*n 
= 8*(2*T(n/16) + n/8) + 3*n 
= 16*T(n/16) + 4*n ...... 
= 2^k * T(n/2^k) + k * n 
......
```
通过这样⼀步⼀步分解推导，我们可以得到T(n) = 2^kT(n/2^k)+kn。当T(n/2^k)=T(1)时，也就是n/2^k=1，我们得到k=log n 。 我们将k值代⼊上⾯的公式，得到T(n)=Cn+nlog n 。如果我们⽤⼤O标记法来表示的话，T(n)就等于O(nlogn)。所以归并排序 的时间复杂度是O(nlogn)。

从我们的原理分析和伪代码可以看出，归并排序的执⾏效率与要排序的原始数组的有序程度⽆关，所以其时间复杂度是⾮常稳 定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是O(nlogn)。

第三，归并排序的空间复杂度是多少？

归并排序的时间复杂度任何情况下都是O(nlogn)，看起来⾮常优秀。（待会⼉你会发现，即便是快速排序，最坏情况下，时间 复杂度也是O(n^2 )。）但是，归并排序并没有像快排那样，应⽤⼴泛，这是为什么呢？因为它有⼀个致命的“弱点”，那就是归并 排序不是原地排序算法。

这是因为归并排序的合并函数，在合并两个有序数组为⼀个有序数组时，需要借助额外的存储空间。这⼀点你应该很容易理 解。那我现在问你，归并排序的空间复杂度到底是多少呢？是O(n)，还是O(nlogn)，应该如何分析呢？

如果我们继续按照分析递归时间复杂度的⽅法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)。不 过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？

**实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的⼀点，那就是，尽管每次合并操作都 需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU只会有⼀个函数在执 ⾏，也就只会有⼀个临时的内存空间在使⽤。临时内存空间最⼤也不会超过n个数据的⼤⼩，所以空间复杂度是O(n)。**

