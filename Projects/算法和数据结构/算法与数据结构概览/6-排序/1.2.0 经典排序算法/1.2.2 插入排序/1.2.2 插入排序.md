我们先来看⼀个问题。⼀个有序的数组，我们往⾥⾯添加⼀个新的数据后，如何继续保持数据有序呢？**很简单，我们只要遍历数组，找到数据应该插⼊的位置将其插⼊即可。**

![](asserts/Pasted%20image%2020250808223756.png)

这是⼀个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种⽅法保持集合中的数据⼀直有序。⽽对于⼀组静态数据，我们也可以借鉴上⾯讲的插⼊⽅法，来进⾏排序，于是就有了插⼊排序算法。

那插⼊排序具体是如何借助上⾯的思想来实现排序的呢？

⾸先，**我们将数组中的数据分为两个区间，已排序区间和未排序区间。**初始已排序区间只有⼀个元素，就是数组的第⼀个元 素。插⼊算法的核⼼思想是取未排序区间中的元素，在已排序区间中找到合适的插⼊位置将其插⼊，并保证已排序区间数据⼀ 直有序。重复这个过程，直到未排序区间中元素为空，算法结束。 如图所示，要排序的数据是4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

![](asserts/Pasted%20image%2020250808223927.png)

插⼊排序也包含两种操作，**⼀种是元素的⽐较，⼀种是元素的移动**。当我们需要将⼀个数据a插⼊到已排序区间时，需要拿a 与已排序区间的元素依次⽐较⼤⼩，找到合适的插⼊位置。找到插⼊点之后，我们还需要将插⼊点之后的元素顺序往后移动⼀ 位，这样才能腾出位置给元素a插⼊。
对于不同的查找插⼊点⽅法（从头到尾、从尾到头），元素的⽐较次数是有区别的。但对于⼀个给定的初始序列，移动操作的 次数总是固定的，就等于逆序度。

为什么说移动次数就等于逆序度呢？我拿刚才的例⼦画了⼀个图表，你⼀看就明⽩了。满有序度是n*(n-1)/2=15，初始序列的 有序度是5，所以逆序度是10。插⼊排序中，数据移动的个数总和也等于10=3+3+4。
![](asserts/Pasted%20image%2020250808224151.png)
插⼊排序的原理也很简单吧？我也将代码实现贴在这⾥，你可以结合着代码再看下。

```java
// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a,n){
	if (n<=1) return;
	for (int i =1;i<n;++i){
		int value = a[i];
		int j = i-1
		for(;j>=0;j--){
			if (a[j]>value){
				a[j+1] = a[j];
			}else{	
				break;
			}
		}
		// 需要判断是不是所有元素都>=当前值
		a[j+1] = value;		
	}
}
```

第⼀，插⼊排序是原地排序算法吗？
从实现过程可以很明显地看出，插⼊排序算法的运⾏并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是⼀个 原地排序算法。

第⼆，插⼊排序是稳定的排序算法吗？ 在插⼊排序中，对于值相同的元素，我们可以选择将后⾯出现的元素，插⼊到前⾯出现元素的后⾯，这样就可以保持原有的前 后顺序不变，所以插⼊排序是稳定的排序算法。

第三，插⼊排序的时间复杂度是多少？ 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组⾥⾯查找插⼊位置，每次只需 要⽐较⼀个数据就能确定插⼊的位置。所以这种情况下，最好是时间复杂度为O(n)。**注意，这⾥是从尾到头遍历已经有序的数 据。**???如果不是会出现问题吗？复杂度会增大

如果数组是倒序的，每次插⼊都相当于在数组的第⼀个位置插⼊新的数据，所以需要移动⼤量的数据，所以最坏情况时间复杂 度为O(n^2 )。 还记得我们在数组中插⼊⼀个数据的平均时间复杂度是多少吗？没错，是O(n)。所以，对于插⼊排序来说，每次插⼊操作都相 当于在数组中插⼊⼀个数据，循环执⾏n次插⼊操作，所以平均时间复杂度为O(n^2)。

