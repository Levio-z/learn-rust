选择排序算法的实现思路有点类似插⼊排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最⼩的 元素，将其放到已排序区间的末尾。

![](asserts/Pasted%20image%2020250808225659.png)⾸先，选择排序空间复杂度为O(1)，是⼀种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度 都为O(n )。你可以⾃⼰来分析看看。

最好的就是有序的O(n^2)




那选择排序是稳定的排序算法吗？这个问题我着重来说⼀下。 

答案是否定的，选择排序是⼀种不稳定的排序算法。从我前⾯画的那张图中，你可以看出来，选择排序每次都要找剩余未排序 元素中的最⼩值，并和前⾯的元素交换位置，这样破坏了稳定性。 

**⽐如5，8，5，2，9这样⼀组数据，使⽤选择排序算法来排序的话，第⼀次找到最⼩元素2，与第⼀个5交换位置，那第⼀个5 和中间的5顺序就变了，所以就不稳定了**。正是因此，相对于冒泡排序和插⼊排序，选择排序就稍微逊⾊了

### 解答开篇'

基本的知识都讲完了，我们来看开篇的问题：冒泡排序和插⼊排序的时间复杂度都是O(n )，都是原地排序算法，为什么插⼊ 排序要⽐冒泡排序更受欢迎呢？ 我们前⾯分析冒泡排序和插⼊排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是⼀个固定值，是原始数据的逆序 度。插⼊排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。 但是，从代码实现上来看，冒泡排序的数据交换要⽐插⼊排序的数据移动要复杂，冒泡排序需要3个赋值操作，⽽插⼊排序只 需要1个。我们来看这段操作：


我们把执⾏⼀个赋值语句的时间粗略地计为单位时间（unit_time），然后分别⽤冒泡排序和插⼊排序对同⼀个逆序度是K的数 组进⾏排序。⽤冒泡排序，需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3*K单位时间。⽽插⼊排序中 数据移动操作只需要K个单位时间。

这个只是我们⾮常理论的分析，为了实验，针对上⾯的冒泡排序和插⼊排序的Java代码，我写了⼀个性能对⽐测试程序，随 机⽣成10000个数组，每个数组中包含200个数据，然后在我的机器上分别⽤冒泡和插⼊排序算法来排序，冒泡排序算法⼤约 700ms才能执⾏完成，⽽插⼊排序只需要100ms左右就能搞定！


所以，虽然冒泡排序和插⼊排序在时间复杂度上是⼀样的，都是O(n )，但是如果我们希望把性能优化做到极致，那肯定⾸选 插⼊排序。插⼊排序的算法思路也有很⼤的优化空间，我们只是讲了最基础的⼀种。如果你对插⼊排序的优化感兴趣，可以⾃ ⾏学习⼀下希尔排序。

![](asserts/Pasted%20image%2020250810211848.png)




