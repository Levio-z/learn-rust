### 排序算法的执行效率
#### 1. 最好情况、最坏情况、平均情况时间复杂度

我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最 好、最坏时间复杂度对应的要排序的原始数据是什么样的。

第⼀，有些排序算法会区分，为了好对⽐，所以我们最好都做⼀下区分。
第⼆，对于要排序的数据，有的接近有序，有的完全⽆序。有序度不同的数据，对于排序的执⾏时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

#### 2.时间复杂度的系数、常数 、低阶

我们知道，时间复杂度反应的是数据规模n很⼤的时候的⼀个增⻓趋势，所以它表示的时候会忽略系数、常数、低阶。但是实 际的软件开发中，我们排序的可能是10个、100个、1000个这样规模很⼩的数据，所以，在对同⼀阶时间复杂度的排序算法性 能对⽐的时候，我们就要把系数、常数、低阶也考虑进来。

#### 3.⽐较次数和交换（或移动）次数

这⼀节和下⼀节讲的都是基于⽐较的排序算法。基于⽐较的排序算法的执⾏过程，会涉及两种操作，⼀种是元素⽐较⼤⼩，另 ⼀种是元素交换或移动。所以，如果我们在分析排序算法的执⾏效率的时候，应该把⽐较次数和交换（或移动）次数也考虑进 去。

### 排序算法的内存消耗

我们前⾯讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还 引⼊了⼀个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是O(1)的排序算法。我们今天讲的 三种排序算法，都是原地排序算法。

### 排序算法的稳定性

仅仅⽤执⾏效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有⼀个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。


我通过⼀个例⼦来解释⼀下。⽐如我们有⼀组数据2，9，3，4，8，3，按照⼤⼩排序之后就是2，3，3，4，8，9。 这组数据⾥有两个3。**经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法**；如果前后顺序发⽣变化，那对应的排序算法就叫作不稳定的排序算法。

稳定与实际业务：希望按照⾦额从⼩到⼤对订单数据排序。对于⾦额相同的订单，我们希望按照下单时间从早到晚有序。

实现起来复杂：我们先按照⾦额对订单数据进⾏排序，然后，再遍历排序之后的订单数据，对于每个⾦额相同的⼩区间再 按照下单时间排序。

借助稳定排序算法：我们先按照下单时间给订单排序，注意是按照下单时 间，不是⾦额。排序完成之后，我们⽤稳定排序算法，按照订单⾦额重新排序。

**稳定排序算法可以保持⾦额相同的两个对象，在排序之后的前后顺序不变。**
![](asserts/Pasted%20image%2020250808104242.png)

