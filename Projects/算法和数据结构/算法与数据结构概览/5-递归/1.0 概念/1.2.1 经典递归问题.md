问题：假如这⾥有n个台阶，每次你可以跨1个台阶或者2个台阶，请问⾛这n个台阶有多少种⾛法？

**递推公式**：实际上，可以根据第⼀步的⾛法把所有⾛法分为两类，第⼀类是第⼀步⾛了1个台阶，另⼀类是第⼀步⾛了2 个台阶。所以n个台阶的⾛法就等于先⾛1阶后，n-1个台阶的⾛法 加上先⾛2阶后，n-2个台阶的⾛法。
```
f(n) = f(n-1)+f(n-2)
```
**终止条件**：有了递推公式，递归代码基本上就完成了⼀半。我们再来看下终⽌条件。当有⼀个台阶时，我们不需要再继续递归，就只有⼀ 种⾛法。所以f(1)=1。这个递归终⽌条件⾜够吗？我们可以⽤n=2，n=3这样⽐较⼩的数试验⼀下。

n=2时，f(2)=f(1)+f(0)。如果递归终⽌条件只有⼀个f(1)=1，那f(2)就⽆法求解了。所以除了f(1)=1这⼀个递归终⽌条件外，还要有f(0)=1，表示⾛0个台阶有⼀种⾛法，不过这样⼦看起来就不符合正常的逻辑思维了。所以，我们可以把f(2)=2作为⼀种终
⽌条件，表示⾛2个台阶，有两种⾛法，⼀步⾛完或者分两步来⾛。

所以除了f(1)=1这⼀个递归终⽌条件外，还要有f(0)=1，表示⾛0个台阶有⼀种⾛法，不过这样⼦看起来就不符合正常的逻辑思维了。所以，我们可以把f(2)=2作为⼀种终
⽌条件，表示⾛2个台阶，有两种⾛法，⼀步⾛完或者分两步来⾛。

我们把递归终⽌条件和刚刚得到的递推公式放到⼀起就是这样的：
```
f(1) = 1;
f(2) = 2; 
f(n) = f(n-1)+f(n-2)
```

有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：
```
int f(int n) { 
if (n == 1) return 1;
if (n == 2) return 2; 
return f(n-1) + f(n-2);
}
```

### 重复计算优化
[2.1.2 递归代码要警惕重复计算](../2.0%20使用/2.1.2%20递归代码要警惕重复计算.md)
### 改为非递归
[2.2.0 递归改为非递归](../2.0%20使用/2.2.0%20递归改为非递归.md)