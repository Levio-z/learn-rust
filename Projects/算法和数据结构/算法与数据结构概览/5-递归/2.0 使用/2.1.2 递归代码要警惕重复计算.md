![](asserts/Pasted%20image%2020250808100647.png)
对于[1.2.1 经典递归问题](../1.0%20概念/1.2.1%20经典递归问题.md)中，递归过程分解

从图中，我们可以直观地看到，想要计算f(5)，需要先计算f(4)和f(3)，⽽计算f(4)还需要计算f(3)，因此，f(3)就被计算了很多 次，这就是重复计算问题。

为了避免重复计算，我们可以**通过⼀个数据结构（⽐如散列表）来保存已经求解过的f(k)**。当递归调⽤到f(k)时，先看下是否已 经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

按照上⾯的思路，我们来改造⼀下刚才的代码：
```
public int f(int n) { 
if (n == 1) return 1;
if (n == 2) return 2; 

if(hasSolvedList.containsKey(n)){
	return hasSolvedList.get(n);
}
int ret = f(n-1) + f(n-2);
hasSolvedList.put(n,ret);
return ret;
}
```

在时间效率上，递归代码⾥多了很多函数调⽤，当这些函数调⽤的数量较⼤时，就会积聚成⼀个可观的时间成本。在空间复杂 度上，因为递归调⽤⼀次就会在内存栈中保存⼀次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开 销，⽐如我们前⾯讲到的电影院递归代码，空间复杂度并不是O(1)，⽽是O(n)。
