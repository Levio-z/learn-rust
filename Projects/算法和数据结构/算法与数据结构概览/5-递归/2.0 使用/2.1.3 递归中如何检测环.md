⽤户A推荐⽤户B来注册，⽤户B ⼜推荐了⽤户C来注册。我们可以说，⽤户C的“最终推荐⼈”为⽤户A，⽤户B的“最终推荐⼈”也为⽤户A，⽽⽤户A没有“最终推 荐⼈”。

在数据库表中，我们可以记录两⾏数据，其中actor_id表示⽤户 id，referrer_id表示推荐⼈id。
```
long findRootReferrerId(long actorId) {
Long referrerId = select referrer_id from [table] where actor_id = actorId; 
if (referrerId == null) return actorId;
return findRootReferrerId(referrerId); }
```
在实际项⽬中，上⾯的代码并不能⼯作
- 第⼀，如果递归很深，可能会有堆栈溢出的问题。
- 第⼆，如果数据库⾥存在脏数据，我们还需要处理由此产⽣的⽆限递归问题。⽐如demo环境下数据库中，测试⼯程师为了⽅ 便测试，会⼈为地插⼊⼀些数据，就会出现脏数据。如果A的推荐⼈是B，B的推荐⼈是C，C的推荐⼈是A，这样就会发⽣死 循环。
- 第⼀个问题，我前⾯已经解答过了，可以⽤限制递归深度来解决。第⼆个问题，也可以⽤限制递归深度来解决。不过，还有⼀ 个更⾼级的处理⽅法，就是⾃动检测A-B-C-A这种“环”的存在。