## 🧠 一、什么是引脚复用（Multiplexing）？

### ✅ 定义：

> **引脚复用**指的是：**同一个物理引脚可以根据软件配置，连接到不同的内部功能模块（GPIO、UART、SPI、PWM…）**，即一个引脚 → 多种用途，按需选择。

这就像一条街道，可以被分配为：

* 步行街（GPIO）
    
* 公交线路（UART TX）
    
* 快递通道（SPI MOSI）  
    取决于你希望它**承担什么角色**。
    

* * *

## 🧩 二、为什么需要复用？

现代芯片通常只有几十到几百个引脚，但内部模块却可能有：

* 5 个 UART
    
* 3 个 I2C
    
* 2 个 SPI
    
* 4 路 PWM
    
* 上百个 GPIO
    

**每个功能模块都需要用引脚对外通信，但芯片引脚不够怎么办？**

所以厂商设计了“**复用功能**”：

> 每个引脚可以连接多个内部模块，但一次只能启用其中之一。

这由芯片内部的一个逻辑电路单元 **IOMUX（Input Output Multiplexer）** 控制，类似这样：

```
       [UART_TX]   
           |
[SPI_MOSI]—|   ====> [引脚 PA2]
       [GPIO]
```

通过寄存器配置，选择你要启用的路径（MUX）

* * *

## 🔧 三、实际例子：STM32

假设要把 PA2 从普通 GPIO 输出切换到 USART2_TX：
```
// 1. 先配置为普通 GPIO 输出
GPIO_InitTypeDef GPIO_InitStruct = {0};
GPIO_InitStruct.Pin = GPIO_PIN_2;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;   // 推挽输出
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

// ... 运行一段时间，PA2作为普通GPIO输出

// 2. 切换到复用功能 UART2_TX
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;       // 复用推挽输出
GPIO_InitStruct.Alternate = GPIO_AF7_USART2; // 选择复用信号
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

```
![](asserts/Pasted%20image%2020250707164244.png)
芯片里面会罗列的，需要去设置。



* * *

## 🌐 四、Linux 设备树中的 IO MUX 示例（Rockchip RK3568）

```dts
&pinctrl {
    uart2_xfer: uart2-xfer {
        rockchip,pins = <2 RK_PA0 1 &pcfg_pull_up>;
        // 第一个参数 2 是 bank，PA0 是引脚编号，1 表示复用为 UART2_TX
    };
};
```
