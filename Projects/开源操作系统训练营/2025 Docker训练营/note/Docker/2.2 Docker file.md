Docker 生态之所以如此繁荣，是因为有许许多多的组织或者开发者贡献了大量的功能不同的镜像，这些镜像被用在各种场景中，比如软件分发，CI/CD，云原生应用部署，可观测性

## 从容器创建镜像
首先使用交互式运行一个 alpine 容器。
``` shell

docker run -it alpine

```
然后我们在容器中执行一些命令，比如安装一个软件，然后退出容器。
```shell

apk update

apk add figlet

figlet "hello docker"

exit

```
这样，我们就在 alpine 容器中安装了 figlet 工具，当然，之后我们会安装一些更加有用的软件，

比如 git，nginx 等等。然后我们需要将这个新的容器环境跟其他人分享，我们可以通过 commit 命令将容器保存为一个镜像。
```shell

docker ps -a #查看容器

docker commit <container_id>

```
这样，我们就创建了一个装有 figlet 的镜像，我们可以通过 docker image 命令查看。
``` shell

docker image ls

```
然后我们就可以使用这个新的镜像了。

```shell

docker run alpine-figlet figlet "hello docker"

```
最后我们也可以使用 `docker push` 命令将镜像推送到镜像仓库中，其他人便可以使用 `docker pull` 来使用这个镜像了。

构建过程不透明，无法追溯到镜像的更改，迭代效率低下。
难以进行版本控制和自动化。
重复构建资源消耗。
步骤多，人工失误出错高。
## Dockerfile 详解
![](asserts/Pasted%20image%2020250724165814.png)

![](asserts/Pasted%20image%2020250724165948.png)呃1
上述从容器创建镜像的方式虽然简单易懂，但是如果涉及版本迭代的时候，比如下次我需要再额外安装一个 git 命令，就需要重新 commit 一个容器，然后重新 tag 一个镜像，这样比较麻烦，而且容易出错。因此，我们需要一种更加灵活的镜像创建方式，这就是 Dockerfile。我们来使用 [Dockerfile](./Dockerfile) 来完成上述的同样的事情，最后使用 `docker build` 命令来构建镜像。
``` shell

docker build -t alpine-figlet-from-dockerfile .

```
[6-1 docker build](../ChatGpt/6-1%20docker%20build.md)

同样可以使用这个镜像

``` shell

docker run alpine-figlet-from-dockerfile figlet "hello docker"

```
这样当我们需要安装 git 的时候，只需要修改 Dockerfile 中的命令后重新构建镜像即可。
```shell

docker build -t alpine-figlet-from-dockerfile .
```
同样可以使用这个镜像
```
docker run alpine-figlet-from-dockerfile git

```

## 使用 Dockerfile 构建一个 jupyter notebook 镜像

接下来让我们使用 Docker 来构建一个真实可用的镜像，比如 jupyter notebook 镜像。[Dockerfile](./jupyter_sample/Dockerfile)
```shell

docker build -t jupyter-sample jupyter_sample/

```
该镜像使用 RUN 指令来安装 jupyter notebook，使用 WORKDIR 指令设置工作目录，使用 COPY 指令将代码复制到镜像中，使用 EXPOSE 指令来暴露端口，最后使用 CMD 指令来启动 jupyter notebook 服务。
使用上述镜像来启动 jupyter notebook 服务。

```shell

docker run -d -p 8888:8888  jupyter-sample

```

## 使用多阶段构建来打包一个 golang 应用

  ![](asserts/Pasted%20image%2020250724183547.png)

在实际开发中，我们经常需要构建 golang 应用。

如果使用传统的单阶段构建，最终的镜像会包含整个 Go 开发环境，导致镜像体积非常大。

通过多阶段构建，我们可以创建一个非常小的生产镜像。

  

创建一个 [main.go](./golang_sample/main.go) 文件，

一个普通构建的 [Dockerfile](./golang_sample/Dockerfile.single)

以及一个多阶段构建的 [Dockerfile](./golang_sample/Dockerfile.multi)

  

构建镜像：

  

```shell

docker build -t golang-demo-single -f golang_sample/Dockerfile.single golang_sample/

docker build -t golang-demo-multe -f golang_sample/Dockerfile.multi golang_sample/

```

  

运行容器：

  

```shell

docker run -d -p 8080:8080 golang-demo-single

docker run -d -p 8081:8081 golang-demo-multe

```

  

容器运行成功后可以通过如下命令行来访问，可以看到两个容器都是在运行我们写的 golang 服务。

  

```shell

curl http://localhost:8080

curl http://localhost:8081

```

  

让我们来对比一下单阶段构建和多阶段构建的区别：

  

```shell

# 查看镜像大小

docker images | grep golang-demo

```

  

你会发现最终的镜像只有几十 MB，而如果使用单阶段构建（直接使用 golang 镜像），镜像大小会超过 1GB。这就是多阶段构建的优势：

  

- 最终镜像只包含运行时必需的文件

- 不包含源代码和构建工具，提高了安全性

- 大大减小了镜像体积，节省存储空间和网络带宽

  

这种构建方式特别适合 Go 应用，因为 Go 可以编译成单一的静态二进制文件。在实际开发中，我们可以使用这种方式来构建和部署高效的容器化 Go 应用。