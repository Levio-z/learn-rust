## 一、Docker 的分层缓存策略（Layered Caching Strategy）

Docker 镜像是由**一层层的只读文件系统层（layer）构成**，每个构建命令（如 `RUN`、`COPY`、`ADD`）都会生成一个镜像层。构建时 Docker 会尽可能复用已有的层，从而加快构建速度。

### 1\. 缓存命中原则（按层顺序逐层命中）

Docker 缓存是**从上到下顺序匹配的**：

-   如果某层 **命中了缓存**，那么之后的层才有可能复用；
    
-   一旦某一层命中失败，**后续所有层的缓存都失效**，必须重新构建。
    

### 2\. 常见的缓存命中条件：

| 指令类型 | 缓存是否命中取决于 |
| --- | --- |
| `FROM` | 镜像是否已有且最新 |
| `COPY` | 文件内容是否变化（包括内容、时间戳） |
| `RUN` | 命令是否完全一致 |
| `ENV` | 环境变量是否相同 |

### 3\. 优化策略

为了更好利用缓存，可采用如下技巧：

-   **先固定依赖层**，再 COPY 本地代码：
    
    ```dockerfile
    COPY go.mod .         # 依赖变动少
    RUN go mod download   # 依赖层能缓存
    COPY . .              # 业务代码层变动频繁
    RUN go build ...
    ```
    
-   合并多个 `RUN` 命令，减少层数（但会牺牲可读性与缓存粒度）：
	- 减少镜像
    
    ```dockerfile
    RUN apt update && apt install -y curl && rm -rf /var/lib/apt/lists/*
    ```
    
-   避免频繁改动上层命令，确保底层缓存能复用。
    

---

## 二、Docker 镜像版本标签规范（Tagging Strategy）

Docker 镜像的标签（tag）是识别镜像的关键，良好的命名规范有助于：

-   部署控制（精确版本）
    
-   回滚容错（兼容旧版本）
    
-   持续集成（CI）流程清晰可控
    

### 1\. 常见标签策略：

| 标签 | 用法说明 |
| --- | --- |
| `latest` | 默认标签，**不代表最新版本**，只是默认值 |
| `v1.0.0` | 严格语义化版本（Semantic Versioning） |
| `v1.0.0-rc1` | 发布候选版本 |
| `dev`, `test` | 环境标识（开发环境 / 测试环境） |
| `commit-sha` | CI/CD 自动生成的唯一标识版本 |
| `build-20250724` | 日期版本 |

### 2\. 推荐组合策略

> **建议一镜多标签，语义 + 时间 + commit 结合**

构建完一个镜像时，给它多个 tag：

```bash
docker tag myapp:latest myapp:v1.2.3
docker tag myapp:latest myapp:20250724
docker tag myapp:latest myapp:4fa29d7   # commit hash
```

---

## 三、Docker 镜像与缓存清理机制

长期构建和运行 Docker 容器会积累：

-   悬空镜像（dangling images）
    
-   未使用的 volume / network
    
-   构建缓存（BuildKit 缓存）
    

### 1\. 常用清理命令

| 命令 | 功能 |
| --- | --- |
| `docker image prune` | 删除无标签镜像（dangling） |
| `docker image prune -a` | 删除所有未被容器使用的镜像 |
| `docker container prune` | 删除已停止的容器 |
| `docker volume prune` | 删除未挂载的 volume |
| `docker system prune` | 删除所有未使用的资源（镜像+容器+网络+缓存） |
| `docker builder prune` | 清理 BuildKit 构建缓存（新机制） |

⚠️：`-a` 和 `--force` 使用需谨慎，避免误删当前使用的内容。

---

### 2\. 自动化清理建议

-   使用 CI/CD 流水线中定期调用 prune 命令
    
-   利用 `cron` 或系统服务清理：
    

```bash
# 每周清理一次未使用镜像和缓存
0 3 * * 0 docker system prune -af --volumes
```

-   企业环境建议使用 Docker Registry + 生命周期策略管理镜像（如 Harbor/GitHub Packages）
    

---

## 四、BuildKit 的缓存机制（补充）

Docker 的新版构建引擎 BuildKit 提供：

-   并行构建
    
-   更好的缓存控制（如 mount cache、inline cache）
    
-   支持导入导出构建缓存
    

### 示例：启用 BuildKit 缓存导出

```dockerfile
# syntax=docker/dockerfile:1.4
FROM node:18
RUN --mount=type=cache,target=/root/.npm \
    npm install
```

构建时：

```bash
DOCKER_BUILDKIT=1 docker build .
```

你也可以指定：

```bash
docker build --build-arg BUILDKIT_INLINE_CACHE=1 \
             --cache-from=myapp:cache \
             --tag myapp:cache .
```

---

## 总结（清单形式）

| 项目 | 说明 | 推荐实践 |
| --- | --- | --- |
| 分层缓存 | Docker 按命令拆层构建，可缓存中间层 | 固定依赖层，延后业务代码 COPY |
| 版本标签 | 标签应语义清晰、可定位历史版本 | 语义 + 时间戳 + commit hash |
| 清理机制 | 多种 prune 命令清理镜像和缓存 | 定期执行清理计划 |
| BuildKit 缓存 | 支持高级挂载缓存、导入导出 | 构建性能显著提升，可用于 CI/CD |

---