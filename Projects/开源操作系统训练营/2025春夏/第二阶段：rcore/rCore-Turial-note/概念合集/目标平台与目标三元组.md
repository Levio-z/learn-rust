现代编译器工具集（以C或Rust编译器为例）的主要工作流程如下：

1. 源代码（source code） –> 预处理器（preprocessor） –> 宏展开的源代码
2. 宏展开的源代码 –> 编译器（compiler） –> 汇编程序
3. 汇编程序 –> 汇编器（assembler）–> 目标代码（object code）
4. 目标代码 –> 链接器（linker） –> 可执行文件（executables）

对于一份用某种编程语言实现的应用程序源代码而言，编译器在将其通过编译、链接得到可执行文件的时候需要知道程序要在哪个 **平台** (Platform) 上运行。这里平台主要是指 **CPU 类型、操作系统类型和标准运行时库**的组合。从上面给出的 [应用程序执行环境栈](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html#app-software-stack) 可以看出：

- 如果用户态基于的内核不同，会导致**系统调用接口不同**或者语义不一致；
- 如果底层硬件不同，对于硬件资源的访问方式会有差异。
    - 特别是如果 ISA 不同，则向软件提供的**指令集和寄存器**都不同。

它们都会导致最终生成的可执行文件有很大不同。需要指出的是，某些编译器支持同一份源代码无需修改就可编译到多个不同的目标平台并在上面运行。这种情况下，源代码是 **跨平台** 的。而另一些编译器则已经预设好了一个固定的目标平台。

Rust编译器通过 **目标三元组** (Target Triplet) 来描述一个软件运行的目标平台。它一般包括 CPU、操作系统和运行时库等信息，从而控制Rust编译器可执行代码生成。比如，我们可以尝试看一下之前的 `Hello, world!` 的目标平台是什么。这可以通过打印编译器 rustc 的默认配置信息
```
rustc --version --verbose
   rustc 1.57.0-nightly (e1e9319d9 2021-10-14)
   binary: rustc
   commit-hash: e1e9319d93aea755c444c8f8ff863b0936d7a4b6
   commit-date: 2021-10-14
   host: x86_64-unknown-linux-gnu
   release: 1.57.0-nightly
   LLVM version: 13.0.0
```
- `host: x86_64-unknown-linux-gnu` ：**其中 host 一项表明默认目标平台是 x86_64-unknown-linux-gnu，**
    - **CPU 架构是 x86_64**
    - **CPU 厂商是 unknown**
    - **操作系统是 linux**
    - **运行时库是 gnu libc。**
从其中的 host 一项可以看出默认的目标平台是 `x86_64-unknown-linux-gnu`，其中 CPU 架构是 x86_64，CPU 厂商是 unknown，操作系统是 linux，**运行时库是 GNU libc（封装了 Linux 系统调用，并提供 POSIX 接口为主的函数库）**。这种无论编译器还是其生成的可执行文件都在我们当前所处的平台运行是一种最简单也最普遍的情况。但是很快我们就将遇到另外一种情况。

讲了这么多，终于该介绍我们的主线任务了。我们希望能够在另一个硬件平台上运行 `Hello, world!`，而与之前的默认平台不同的地方在于，我们将 CPU 架构从 x86_64 换成 RISC-V。

可以看一下目前 Rust 编译器支持哪些基于 RISC-V 的目标平台：

```rust
rustc --print target-list | grep riscv
riscv32gc-unknown-linux-gnu
riscv32i-unknown-none-elf
riscv32imac-unknown-none-elf
riscv32imc-unknown-none-elf
riscv64gc-unknown-linux-gnu
riscv64gc-unknown-none-elf
riscv64imac-unknown-none-elf
```

这里我们选择 `riscv64gc-unknown-none-elf` 目标平台。这其中的 CPU 架构是 riscv64gc ，CPU厂商是 unknown ，操作系统是 none ， elf 表示没有标准的运行时库（表明没有任何系统调用的封装支持），但可以生成 ELF 格式的执行程序。这里我们之所以不选择有 linux-gnu 系统调用支持的目标平台 `riscv64gc-unknown-linux-gnu`，是因为我们只是想跑一个在裸机环境上运行的 `Hello, world!` 应用程序，没有必要使用Linux操作系统提供的那么高级的抽象和多余的操作系统服务。而且我们很清楚后续我们要开发的是一个操作系统内核，它必须直面底层物理硬件（bare-metal）来提供精简的操作系统服务功能，通用操作系统（如 Linux）提供的很多系统调用服务对这个内核而言是多余的。


