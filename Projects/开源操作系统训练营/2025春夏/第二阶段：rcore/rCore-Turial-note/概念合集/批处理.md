
批处理系统
- 问题1：
	- 用户通过监控程序**加载应用程序时（装载、启动、输出都需要），处理器保持空闲状态**，所有其他用户的程序都不能执行，
	- 解决方案：
		- 减少人工干预、连续执行多个作业
		- what：多个作业**一次性提交**自动按顺序加载，[批处理详细解释](#批处理详细解释)
		- 结果：**程序与程序之间的“切换等待时间”大幅减少**；
- 问题2： CPU 和外设耦合
	- [引入缓冲和部分 I/O 重叠机制](#引入缓冲和部分IO重叠机制)
	- 缓存：I/O 不再阻塞 CPU
	- 部分 I/O 重叠：实现“边算边读 / 边算边写”，CPU 与 I/O 并行

| 技术        | 作用                           | 意义               |
| --------- | ---------------------------- | ---------------- |
| 缓冲        | 减少 CPU 和外设耦合，批量处理 I/O 数据     | I/O 不再阻塞 CPU     |
| 部分 I/O 重叠 | 实现“边算边读 / 边算边写”，CPU 与 I/O 并行 | 提升整体执行效率，批处理真正高效 |

>但没有彻底解决“CPU 等 I/O”问题，还需要进一步引入“多道程序设计（Multiprogramming）”。

### 步骤
批处理是指把一批作业（英文： **Job** ，古老的术语，可理解为现在的应用程序）以[脱机方式（offline mode）](脱机方式（offline%20mode）.md)（offline mode）输入到磁带上，并使这批作业能一个接一个地连续处理，流程如下：

1. 将磁带上的一个作业装入内存；
2. 操作系统把运行控制权交给该作业；
3. 当该作业处理完成后，控制权被交还给操作系统；
4. 重复 1-3 的步骤处理下一个作业直到所有作业处理完毕。

# 附录
### 批处理详细解释

#### 🔸 1. 在“无操作系统”或“监控程序”阶段：

- 每运行一个程序，都需要人工干预（装载、启动、输出）；
- 程序执行完，CPU 就处于**空闲等待状态**；
- I/O 操作期间（如读取卡片或写磁带）CPU 也要**“傻等”**；
- 整体 CPU 利用率非常低（比如 10% 以下）。
    

#### 🔸 2. 引入“批处理系统”后：

- 多个作业打成“作业批（Job Batch）”后**一次性提交**；
- 系统自动按顺序加载并执行，不需要人工干预；
- 这样，**程序与程序之间的“切换等待时间”大幅减少**；
- CPU 不再因“等待下一个程序人工装载”而空转。

|阶段|每个作业处理流程|人工等待|CPU 利用率|
|---|---|---|---|
|手动阶段|人工装入 → 执行 → 人工取出|高|极低|
|批处理阶段|自动装入 → 执行 → 自动下一个|低|提升明显|
### 批处理是否彻底避免了 CPU 空转？
**没有完全避免。原因是：**

- 虽然程序之间无等待，但**每个程序内部如果有大量 I/O 操作（例如磁带读写），CPU 仍然要等待 I/O 完成**；
- 也就是说，CPU 与 I/O 不能“并行”，程序在 I/O 操作期间**阻塞整个系统**；
- 所以，“程序之间的空转”问题解决了，但“程序内部的 I/O 阻塞”问题仍然存在。

### 引入缓冲和部分IO重叠机制
#### 1. **输入缓冲区 / 输出缓冲区**

- 批处理操作系统会为输入（如卡片、磁带）与输出（如打印机）设置缓冲区；
    
- 程序可“**把数据扔进缓冲区就走**”，由 I/O 控制器慢慢读/写；
    
- 缓冲区满/空会触发中断或轮询通知。
    
#### 2. **双缓冲（Double Buffering）实现部分 I/O 重叠**

- 当程序在处理 **缓冲区 A 的数据时**，**I/O 控制器正从缓冲区 B 读入下一批数据**；
    
- 两个缓冲区轮流工作，CPU 与 I/O 可并行处理。

“部分”强调的是**受限于单作业单进程模型，没有调度器或多进程系统**，因此重叠能力是**有限度的**。
- 没有真正的任务切换，不能“让另一个进程运行”；
- 重叠仅限于 CPU 与 I/O 控制器的“错峰使用”；
- 不能处理复杂的 I/O 密集程序，只能减少 CPU 等待时间。

📌 **只有等到“多道程序系统”引入进程调度和内存保护后，才具备真正的“全 I/O 重叠”能力**。



