操作系统引入并发（Concurrency）的核心目标是：
- **提高 CPU 利用率**：通过分时执行，避免单个应用程序独占 CPU。
- **提高系统资源利用率**：在 I/O 等待时切换到其他任务，让 CPU 忙碌。
- **提升用户体验**：支持多任务操作，用户感觉多个程序“同时”执行。

实现方式：
- **分时执行**：OS 通过时间片轮转、优先级调度等方式，让多个应用程序交替运行。
- **任务切换**：OS 在应用执行期间保存和恢复上下文（寄存器、堆栈、程序计数器等），实现进程之间的快速切换。
### 并发性带来的问题
1. **共享资源的竞争**
    - 共享内存、文件、I/O 设备可能被多个进程同时访问。
    - 需要同步与互斥机制（锁、信号量、条件变量、自旋锁）来避免数据竞争。
2. **执行时间的不确定性**
    - 并发程序并非线性执行，而是“走走停停”，推进顺序受调度策略影响。
    - 结果是：
        - 程序的执行时间不可预测。
        - 执行路径可能不同，难以复现问题。
3. **死锁与活锁问题**
    - **死锁**：多个进程因相互等待资源而永远阻塞。
    - **活锁**：进程虽未阻塞，但因不断重试而无法前进。
        

### 并发性对操作系统的挑战

- **可预测性差**：调度策略、硬件中断、缓存一致性等都会改变执行时序。
- **可重现性弱**：并发错误常常难以稳定复现，调试困难。
- **正确性保证复杂**：需要在高性能与正确性（互斥、同步）之间找到平衡。

### 小结
- 并发性是操作系统高效利用资源的关键机制，但它带来了同步互斥、执行不可预测、死锁等问题。
- 操作系统必须通过 **调度算法 + 同步机制 + 死锁检测/避免策略** 来应对挑战。
- 程序员在编写并发应用时，也需要合理使用锁与并发模型，避免错误。

### 学习方法论
1. **理解基本模型**：掌握进程状态机、调度算法、上下文切换原理。
2. **掌握并发控制工具**：熟悉信号量、互斥锁、条件变量的实现和应用。
3. **通过实验学习**：写简单的并发程序（生产者-消费者、读者-写者问题），观察并发带来的问题。
4. **阅读案例**：学习 Linux 内核如何通过 CFS 调度器、RCU 机制处理并发问题。
### 习题思考

1. 为什么说并发程序的执行结果可能不确定？请结合调度机制解释。
2. 给出一个**死锁的必要条件**，并解释操作系统如何打破其中某一条件来避免死锁A
3. 设计一个“生产者-消费者问题”的解决方案，比较使用信号量 vs 条件变量的优劣。

### 重点关注的底层知识
- **进程上下文切换**（保存与恢复机制）
- **经典同步问题**（生产者-消费者、读者-写者、哲学家就餐问题）
- **死锁条件与银行家算法**
- **调度算法对并发性能的影响**

