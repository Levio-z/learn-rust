
|类型|定义|
|---|---|
|**运行库（runtime library）**|支持程序运行时与操作系统交互的 **底层库**，提供如内存管理、I/O、字符串处理、系统调用等功能。通常是 **平台相关的、与语言无关的**。例如：`libc`。|
|**语言运行库（language runtime）**|为支持某种语言的特性（如异常处理、协程、GC、多线程等）而提供的 **语言特定库或执行引擎**。这部分功能通常是 **语言层设计的一部分**。例如：Rust 的 `libstd`，Java 的 `JVM`，Go 的 `runtime`。|
### 一、什么叫“运行时库”？——按字面解释

> **运行时库（Runtime Library）**：指在程序**运行期间（runtime）**提供支持的**函数集合（库）**。

换句话说，它不是为了**编译时**（compile time），也不是为了**链接时**（link time），而是为了程序在 **运行起来之后** 能顺利执行各种操作，比如分配内存、读写文件、处理字符串、系统调用等。

###  二、为什么叫“运行时”？这和“编译时”、“链接时”有何区别？

|阶段|时间点|发生的事情|示例|
|---|---|---|---|
|编译时（Compile Time）|程序被翻译为机器代码时|检查语法、类型、生成中间代码|`gcc main.c -o main`|
|链接时（Link Time）|多个目标文件合并为可执行文件时|解析函数/变量引用，打包静态库|链接 libc.a|
|**运行时（Runtime）**|程序启动并执行时|实际执行代码、调用系统服务|`./main` 运行中调用 `malloc`, `read` 等|

📌 **运行时库之所以得名，是因为它的功能是在运行过程中才生效的。**

### 三、运行时库主要提供哪些“运行时才能完成的功能”？

这些功能都无法靠编译器提前静态生成，必须依赖运行时库在执行过程中动态处理：

|功能类别|示例函数|原因说明|
|---|---|---|
|内存管理|`malloc`, `free`|运行时才能知道你要多少内存|
|输入输出|`read`, `write`, `printf`|运行时才有文件描述符、用户输入|
|字符串操作|`strcpy`, `strlen`|字符串是动态内容，编译期不知道|
|系统调用封装|`fork`, `exec`, `open`|运行中由操作系统分配资源|
|动态库加载|`dlopen`, `dlsym`|动态库路径和加载顺序由运行时决定|
### 四、和“标准库（Standard Library）”的区别？

|类型|定义|是否运行时生效|
|---|---|---|
|**运行时库（Runtime Library）**|程序运行时必须依赖，封装低层功能|✅|
|**标准库（Standard Library）**|语言规范定义的库，包括算法、容器、数学等|❌（大部分是编译时链接好的代码）|

例如：

- Rust 的 `core`, `alloc`, `std` 中，`core` 和 `alloc` 可在 `no_std` 环境使用（不依赖 libc）；
    
- C++ 的 STL（如 `std::vector`, `std::map`）不是运行时库，而是编译期模板实例化生成代码。

### 五、总结：为什么叫“运行时库”？

> 因为这些库的主要功能是 **在程序运行期间被动态调用** 的，它们为程序运行时的行为（如内存管理、IO、系统服务调用）提供支撑。

运行时库 = 程序“活着时”赖以生存的基础设施