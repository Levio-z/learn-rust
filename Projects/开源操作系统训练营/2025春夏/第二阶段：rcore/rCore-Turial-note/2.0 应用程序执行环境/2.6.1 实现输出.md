```rust
// os/src/main.rs
#[macro_use]
mod console;

// os/src/console.rs
use crate::sbi::console_putchar;
use core::fmt::{self, Write};

struct Stdout;

impl Write for Stdout {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for c in s.chars() {
            console_putchar(c as usize);
        }
        Ok(())
    }
}

pub fn print(args: fmt::Arguments) {
    Stdout.write_fmt(args).unwrap();
}

#[macro_export]
macro_rules! print {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!($fmt $(, $($arg)+)?));
    }
}

#[macro_export]
macro_rules! println {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!(concat!($fmt, "\n") $(, $($arg)+)?));
    }
}
```

我们在 `console` 子模块中编写 `println!` 宏。结构体 `Stdout` 不包含任何字段，因此它被称为类单元结构体（Unit-like structs，请参考 [1](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/6print-and-shutdown-based-on-sbi.html#unit-like-structs) ）。 `core::fmt::Write` trait 包含一个用来实现 `println!` 宏很好用的 `write_fmt` 方法，为此我们准备为结构体 `Stdout` 实现 `Write` trait 。在 `Write` trait 中， `write_str` 方法必须实现，因此我们需要为 `Stdout` 实现这一方法，它并不难实现，只需遍历传入的 `&str` 中的每个字符并调用 `console_putchar` 就能将传入的整个字符串打印到屏幕上。

在此之后 `Stdout` 便可调用 `Write` trait 提供的 `write_fmt` 方法并进而实现 `print` 函数。在声明宏（Declarative macros，参考 [2](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/6print-and-shutdown-based-on-sbi.html#declarative-macros) ） `print!` 和 `println!` 中会调用 `print` 函数完成输出。

现在我们可以在 `rust_main` 中使用 `print!` 和 `println!` 宏进行格式化输出了，如有兴趣的话可以输出 `Hello, world!` 试一下。