>https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/4first-instruction-in-kernel2.html

# **本节导读**

承接上一节，本节我们将实践在 Qemu 上执行内核的第一条指令。首先我们编写内核第一条指令并嵌入到我们的内核项目中，接着指定内核的内存布局使得我们的内核可以正确对接到 Qemu 中。**由于 Qemu 的文件加载功能过于简单，它不支持完整的可执行文件，因此我们从内核可执行文件中剥离多余的元数据得到内核镜像并提供给 Qemu 。**最后，我们使用 GDB 来跟踪 Qemu 的整个启动流程并验证内核的第一条指令被正确执行。

提示：在进入本节之前请参考 [实验环境配置](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/5setup-devel-env.html) 安装配置 Rust 相关软件包、Qemu软件和 GDB 调试工具等。

# **编写内核第一条指令**

首先，我们需要编写进入内核后的第一条指令，这样更方便我们验证我们的内核镜像是否正确对接到 Qemu 上。

```jsx
 # os/src/entry.asm
     .section .text.entry
     .globl _start
 _start:
     li x1, 100
```

[rcore start 汇编指令详解](../../../../../../Areas/basic/编译原理/汇编指令/实践/rcore%20start%20汇编指令详解.md)
- 接着，我们在 `main.rs` 中嵌入这段汇编代码，这样 Rust 编译器才能够注意到它，不然编译器会认为它是一个与项目无关的文件：
    ```jsx
    // os/src/main.rs
    #![no_std]
    #![no_main]
    
    mod lang_items;
    
    use core::arch::global_asm;
    global_asm!(include_str!("entry.asm"));
    ```
    
- 第 8 行，我们通过 `include_str!` 宏**将同目录下的汇编代码 `entry.asm` 转化为字符串并通过 `global_asm!`** 宏嵌入到代码中。

###  **调整内核的内存布局**

们可以通过 **链接脚本** (Linker Script) 调整链接器的行为，**使得最终生成的可执行文件的内存布局符合Qemu的预期，即内核第一条指令的地址应该位于 0x80200000** 。我们修改 Cargo 的配置文件来使用我们自己的链接脚本 `os/src/linker.ld` 而非使用默认的内存布局：

```java
 // os/.cargo/config
 [build]
 target = "riscv64gc-unknown-none-elf"

 [target.riscv64gc-unknown-none-elf]
 rustflags = [
     "-Clink-arg=-Tsrc/linker.ld", "-Cforce-frame-pointers=yes"
 ]
```
[rcore自定义链接脚本配置](../../../../../../Areas/Rust/Area/1%20基本概念/2%20进阶/2.10%20编译器优化和性能优化/自定义链接脚本/rcore自定义链接脚本配置.md)

链接脚本 `os/src/linker.ld` 如下：
### linker.ld 链接脚本
[案例-rcore链接脚本详解](../../../../../../Areas/basic/编译原理/链接/自定义链接脚本/案例-rcore链接脚本详解.md)
- 此后我们便可以生成内核可执行文件，切换到 `os` 目录下并进行以下操作：
```java
cargo build --release
```
结果：target/riscv64gc-unknown-none-elf/release/os

我们以 `release` 模式生成了内核可执行文件，它的位置在 `os/target/riscv64gc.../release/os` 。接着我们通过 `file` 工具查看它的属性，可以看到它是一个运行在 64 位 RISC-V 架构计算机上的可执行文件，它是静态链接得到的。
[file-rcore-使用案例](../../../../../../Areas/basic/Linux/命令/file/案例/file-rcore-使用案例.md)
[rcore案例-绝对地址和相对地址基本概念](../../../../../../Areas/basic/编译原理/绝对地址和相对地址/rcore案例-绝对地址和相对地址基本概念.md)
[rcore-案例动态链接和静态链接基本概念](../../../../../../Areas/basic/编译原理/链接/动态链接和静态链接/rcore-案例动态链接和静态链接基本概念.md)

# **手动加载内核可执行文件**

关于命令的更详细信息查看：[2.3 rust-objcopy](../../../../../../Areas/Rust/Area/1%20基本概念/2%20进阶/2.10%20编译器优化和性能优化/分析程序/cargo-binutils/2.3%20rust-objcopy.md)

使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：

```java
rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin
```

- 这条命令是将编译生成的 **Rust 裸机操作系统内核 ELF 文件**，通过 `rust-objcopy` 转换为一个 **裸二进制镜像（binary image）** 的过程。它的作用是在裸机开发中**去掉冗余的元数据，只保留内核执行所需的纯机器码与数据**，以便 QEMU 这类简易加载器可以**直接写入内存启动**。

```java
stat target/riscv64gc-unknown-none-elf/release/os
File: target/riscv64gc-unknown-none-elf/release/os
Size: 1016              Blocks: 8          IO Block: 4096   regular file
...
stat target/riscv64gc-unknown-none-elf/release/os.bin
File: target/riscv64gc-unknown-none-elf/release/os.bin
Size: 4                 Blocks: 8          IO Block: 4096   regular file
...
```

- 可以看到，内核镜像的大小仅有 4 字节，这是因为它里面仅包含我们在 `entry.asm` 中编写的一条指令。一般情况下 RISC-V 架构的一条指令位宽即为 4 字节。而内核可执行文件由于包含了两部分元数据，其大小达到了 1016 字节。这些元数据能够帮助我们更加灵活地加载并使用可执行文件，比如在加载时完成一些重定位工作或者动态链接。**不过由于 Qemu 的加载功能过于简单，我们只能将这些元数据丢弃再交给 Qemu 。从某种意义上可以理解为我们手动帮助 Qemu 完成了可执行文件的加载**。

> 经过我们的实验，至少在 Qemu 7.0.0 版本后，我们可以直接将内核可执行文件 `os` 提交给 Qemu 而不必进行任何元数据的裁剪工作，这种情况下我们的内核也能正常运行。其具体做法为：将 Qemu 的参数替换为 `-device loader,file=path/to/os` 。但是，我们仍推荐大家了解并在代码框架和文档中保留这一流程，原因在于这种做法更加通用，对环境和工具的依赖程度更低。

# **基于 GDB 验证启动流程**

### Gdb的使用
[1.0 GDB-概念](../../../../../../Areas/basic/os/工具/GDB/1.0%20GDB-概念.md)
[2.0 GDB-如何使用](../../../../../../Areas/basic/os/工具/GDB/2.0%20GDB-如何使用.md)
[2.1 Rcore GDB使用案例-makefile详解](../../../../../../Areas/basic/os/工具/GDB/2.1%20Rcore%20GDB使用案例-makefile详解.md)
这里尝试一下
```

```
1、编译出二进制程序
```shell
cd os &&
cargo build --release &&
rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin 
```
2、使用Qemu监听TCP端口，受到GDB请求后再开始运行
```shell
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ../bootloader/rustsbi-qemu.bin \
    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \
    -s -S
```

- `-s` 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 `-S` 可以使 Qemu 在收到 GDB 的请求后再开始运行。因此，Qemu 暂时没有任何输出。注意，如果不想通过 GDB 对于 Qemu 进行调试而是直接运行 Qemu 的话，则要删掉最后一行的 `-s -S` 。 
3、打开另一个终端，启动一个 GDB 客户端连接到 Qemu ：
和原文不一样，直接使用qemu 7.0.0, 这里docker安装的是gdb-multiarch，具体查看.cnb.yml镜像中配置的
直接在项目顶级目录执行
```shell
gdb-multiarch \
    -ex 'file target/riscv64gc-unknown-none-elf/release/os1' \
    -ex 'set arch riscv:rv64' \
    -ex 'target remote localhost:1234'
[GDB output]
0x0000000000001000 in ?? ()
```
[2.2 Rcore-GDB-调试案例](../../../../../../Areas/basic/os/工具/GDB/2.2%20Rcore-GDB-调试案例.md)
### 参考资料
- 参考分支,fork之后直接点击云原生开发尝试：https://cnb.cool/docker.2025/rcore/-/tree/ch1
