>https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/2remove-std.html

[LibOS](../概念合集/操作系统设计/LibOS.md)
[Rust实现交叉编译实践](../概念合集/交叉编译/Rust实现交叉编译实践.md)
[交叉编译基本概念](../概念合集/交叉编译/交叉编译基本概念.md)
[1、禁用标准库](../../../../../../Areas/Rust/Area/1%20基本概念/2%20进阶/2.10%20编译器优化和性能优化/os/移除标准库/1、禁用标准库.md)

本章的目标是构建一个内核最小执行环境使得它能在 RV64GC （即实现了IMAFDC规范的 RISC-V 64位CPU）裸机上运行，在功能上它则像上一节最简单的 Rust 应用程序一样能够打印 `Hello, world!` ，这将会为我们的后续章节提供很多调试上的方便，我们将其称为“三叶虫”操作系统。本节我们来进行第一个步骤：即对上一节最简单的 Rust 应用程序进行改造使得它能够被编译到 RV64GC 裸机平台上，为此我们需要移除它对于 Rust std标准库的依赖，因为 Rust std标准库自己就需要操作系统内核的支持。这样我们需要添加能够支持应用的裸机级别的库操作系统（LibOS）。

# **移除 println! 宏**

`println!` 宏所在的 Rust 标准库 std 需要**通过系统调用获得操作系统的服务，而如果要构建运行在裸机上的操作系统，就不能再依赖标准库了**。**为你的 Rust 工具链添加对 RISC-V 架构（64位、无操作系统）的交叉编译支持**。
[rustup target add riscv64gc-unknown-none-elf 详解](../../../../../../Areas/Rust/Area/1%20基本概念/2%20进阶/2.10%20编译器优化和性能优化/交叉编译/实践/rustup%20target%20add%20riscv64gc-unknown-none-elf%20详解.md)

如果我们现在执行 `cargo build` ，还是会和上一小节一样出现找不到标准库 std 的错误。 `println!` 宏是由标准库 std 提供的，**且会使用到一个名为 write 的系统调用。**现在我们的代码功能还不足以自己实现一个 `println!` 宏。**由于程序使用了系统调用，但不能在核心库 core 中找到它，所以我们目前先通过将 `println!` 宏注释掉的简单粗暴方式，来暂时绕过这个问题。**

# **提供panic_handler功能应对致命错误**

我们重新编译简单的os程序，之前的 println 宏缺失的错误消失了，但又出现了如下新的编译错误：

> **错误**
> 
> `$ cargo build *Compiling os v0.1.0 (/home/shinbokuow/workspace/v3/rCore-Tutorial-v3/os)error:` #[panic_handler] `function required, but not found*`

[提供panic_handler功能应对致命错误实践](../../../../../../Areas/Rust/Area/1%20基本概念/2%20进阶/2.10%20编译器优化和性能优化/os/panic_handler/提供panic_handler功能应对致命错误实践.md)

# **移除 main 函数**
[添加自定义start语义实践](../../../../../../Areas/Rust/Area/1%20基本概念/2%20进阶/2.10%20编译器优化和性能优化/os/start/添加自定义start语义实践.md)

# **分析被移除标准库的程序**

[1.0 分析程序实践cargo-binutils](../../../../../../Areas/Rust/Area/1%20基本概念/2%20进阶/2.10%20编译器优化和性能优化/分析程序/cargo-binutils/1.0%20分析程序实践cargo-binutils.md)