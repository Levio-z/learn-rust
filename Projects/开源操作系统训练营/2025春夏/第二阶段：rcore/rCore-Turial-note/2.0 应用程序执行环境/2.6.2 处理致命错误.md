错误处理是编程的重要一环，它能够保证程序的可靠性和可用性，使得程序能够从容应对更多突发状况而不至于过早崩溃。不同于 C 的返回错误编号 `errno` 模型和 C++/Java 的 `try-catch` 异常捕获模型，Rust 将错误分为可恢复和不可恢复错误两大类。这里我们主要关心不可恢复错误。和 C++/Java 中一个异常被抛出后始终得不到处理一样，在 Rust 中遇到不可恢复错误，程序会直接报错退出。例如，使用 `panic!` 宏便会直接触发一个不可恢复错误并使程序退出。不过在我们的内核中，目前不可恢复错误的处理机制还不完善：
```rust
// os/src/lang_items.rs
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```
可以看到，在目前的实现中，当遇到不可恢复错误的时候，被标记为语义项 `#[panic_handler]` 的 `panic` 函数将会被调用，然而其中只是一个死循环，会使得计算机卡在这里。借助前面实现的 `println!` 宏和 `shutdown` 函数，我们可以在 `panic` 函数中打印错误信息并关机：

```rust
// os/src/main.rs
#![feature(panic_info_message)]

// os/src/lang_item.rs
use crate::sbi::shutdown;
use core::panic::PanicInfo;

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    if let Some(location) = info.location() {
        println!(
            "Panicked at {}:{} {}",
            location.file(),
            location.line(),
            info.message().unwrap()
        );
    } else {
        println!("Panicked: {}", info.message().unwrap());
    }
    shutdown(true)
}
```
我们尝试打印更加详细的信息，包括 panic 所在的源文件和代码行数。我们尝试从传入的 `PanicInfo` 中解析这些信息，如果解析成功的话，就和 panic 的报错信息一起打印出来。我们需要在 **`main.rs` 开头加上 `#![feature(panic_info_message)]` 才能通过 `PanicInfo::message` 获取报错信息**。
当打印完毕之后，**我们直接调用 `shutdown` 函数关机**，由于系统是异常 panic 关机的，参数 `failure` 应为 `true` 。

为了测试我们的实现是否正确，我们将 `rust_main` 改为：

```rust
// os/src/main.rs
#[no_mangle]
pub fn rust_main() -> ! {
    clear_bss();
    println!("Hello, world!");
    panic!("Shutdown machine!");
}
```
使用 Qemu 运行我们的内核，运行结果为：
```rust
[RustSBI output]
Hello, world!
Panicked at src/main.rs:26 Shutdown machine!
```
可以看到，panic 所在的源文件和代码行数被正确报告，这将为我们后续章节的开发和调试带来很大方便。到这里，我们就实现了一个可以在Qemu模拟的计算机上运行的裸机应用程序，其具体内容就是上述的 rust_main 函数，而其他部分，如 entry.asm 、 lang_items.rs 、console.rs 、 sbi.rs 则形成了支持裸机应用程序的寒武纪“三叶虫”操作系统 – LibOS 。





