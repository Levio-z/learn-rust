这题要学习的是编译期计算的问题。使用 C++/Rust 要分清编译期和运行期。编译期计算有 2 种情况：

1. 编译器利用常量传播把运行期的常量计算优化到编译期；
2. 直接指定计算可能或者必须发生在编译期；

第一个是编译器的能力问题，现代编译器几乎都会选择传播所有常量。
第二个则是语法现象，在 C++ 中，constexpr 关键字表示这种行为。
- 当 constexpr 修饰函数时，表示这个函数可以在编译期执行。
	- 这个函数的**函数体符合常量表达式规则**（例如：不能有 `malloc`，不能有 I/O，不能抛异常……）；
	- **如果实参是编译期常量**，则调用结果能在编译期直接求值。
	- 否则，它就像一个普通函数，运行时执行。
	- 换句话说，`constexpr` 是给函数加了一张 **“编译期资格证”**。
- 当 constexpr 修饰变量或者成员时，表示这个变量或者成员一定在编译期求值。所以在这一题中，需要同时在函数上和值上修饰 constexpr，才会导致所有计算发生在编译期。

同时也是因为计算发生在编译期，编译器执行代码的逻辑和运行时执行代码的逻辑不同，编译器会有一个最大递归深度限制。所以这个故意写成递归的斐波那契计算会算不了。所以这题的第一个解法是去掉 constexpr，这样解结果是对的但是会计算极慢。我们可以打印一下看看它在算啥：
```c++
#include "../exercise.h"

unsigned long long fibonacci(int i, int level = 0) {
    for (int j = 0; j < level; ++j) {
        std::cout << ": ";
    }
    std::cout << i << std::endl;
    switch (i) {
        case 0:
            return 0;
        case 1:
            return 1;
        default:
            return fibonacci(i - 1, level + 1) + fibonacci(i - 2, level + 1);
    }
}

int main(int argc, char **argv) {
    constexpr auto ANS_N = 5;
    auto ANS = fibonacci(ANS_N);
    std::cout << "fibonacci(" << ANS_N << ") = " << ANS << std::endl;
    return 0;
}
```
我这里改一改代码，我们看一个详细的过程。我给斐波那契函数加了一个参数 level，并且提供默认值 0，这样调用的时候就不用再传了，然后这个 level 每次递归就 +1，这就标记了递归的深度。然后搞一个小循环来打印一些缩进和标线出来好看。我们看一下这个结果：

```
5
: 4
: : 2
: : : 0
: : : 1
: : 3
: : : 1
: : : 2
: : : : 0
: : : : 1
: 3
: : 1
: : 2
: : : 0
: : : 1
fibonacci(5) = 5
```
可以看到为什么递归很慢。计算 5 需要计算 4 和 3，计算 4 又需要 3 和 2，所以相当于每多算一个数，计算量就大了接近 1 倍。

以及，我们再看这里计算的顺序。可以看到算 5 是先算 4 再算 3，但是算 4 的时候就是先算 2 再算 3 了。这说明什么 C++ 是不保证 `+` 两边求值的顺序的。实际上，C++ 只保证短路运算的顺序，其他的包括 `<<` 的顺序都是不保证的；函数调用的时候，函数的每个参数的求值顺序也是不保证的。所以**任何依赖参数求值顺序的操作都是未定义行为**。
- 所以<<多次出现c++也是未定义行为，求值顺序不一样

当然，虽然很慢，但是这个计算最终是可以完成的。所以我在这里写的是修改一处使代码编译运行，但这可不一定能运行出结果😂。要快速算出结果的话，最简单的改法当然还是直接减小这个 N。这题大家只要理解为什么原来不能编译运行就行了。我看到群里有同学也自己探索了用模板特化的手法实现编译时的缓存来加速，这个方法是最好的，但是比较比较超纲我们这里就不讲了。


