这题讲的是经典的形参和实参问题。但是需要关注参数传递的问题：值传递、左值引用传递、左值常引用传递、右值引用传递、完美转发，各有什么特点，如何选择？

---

## 1\. **值传递（by value）**

```cpp
void f(T x);
```
### 特点
-   **拷贝一份实参对象**传入函数（调用时会调用拷贝构造或移动构造）。
-   形参和实参互不影响（修改形参不会影响实参）。
-   需要对象可复制（或可移动）。
### 适用场景
-   **小对象**（`int`, `double`, `char` 等原生类型）或轻量级结构。
-   需要在函数内部修改，但不想影响外部对象。
-   参数可以安全地按值复制（有移动优化时，效率还不错）
### 注意
-   大对象（如 `std::string`, `std::vector`）值传递会产生额外开销。
-   C++17 以后很多 STL 容器支持移动构造，性能问题减轻。
---
## 2\. **左值引用传递（by lvalue reference）**

```cpp
void f(T& x);
```

### 特点
-   传入**必须是左值**。
-   形参是实参的别名，修改会影响实参。
-   无拷贝、无移动，**性能最好**。
### 适用场景
-   实参需要被函数修改（典型是输出参数）。
-   大对象，避免复制。

### 注意
-   不可接受右值（字面量、临时对象），除非配合 `const`。
    

---

## 3\. **左值常引用传递（by const lvalue reference）**

```cpp
void f(const T& x);
```

### 特点

-   可以绑定到**左值和右值**（包括临时对象）。
-   不能修改形参。
-   无拷贝/无移动（只建立别名），性能好。
-   适合大对象。
### 适用场景
-   只读参数，可能是大对象。
-   最常见的参数传递方式。
### 注意
-   对于小对象（`int`、`double`），按值更简单，可能还更高效。
---
## 4\. **右值引用传递（by rvalue reference）**

```cpp
void f(T&& x);
```
### 特点
-   只能绑定到右值（临时对象，字面量）。
-   常用于实现**移动语义**（可以“窃取”资源而不是复制）。
-   函数内部可以安全地修改或移动 `x`。
### 适用场景
-   构造函数/赋值函数的 **移动版本**：
    
    ```cpp
    class A {
        A(A&& other) noexcept { ... }   // 移动构造
        A& operator=(A&& other) noexcept { ... } // 移动赋值
    };
    ```
    
-   需要接收右值并优化性能（例如 `std::vector::push_back(T&&)`）。
    

---

## 5\. **完美转发（perfect forwarding）**

```cpp
template <typename T>
void f(T&& x); // 注意：这里的 T&& 是 *万能引用*
```
### 特点
-   `T&&` 在模板中是 **万能引用（forwarding reference）**。
-   既能接受左值，也能接受右值，具体取决于实参类型。
-   配合 `std::forward<T>(x)` 保留原始值类别：
    ```cpp
    template <typename T>
    void wrapper(T&& arg) {
        callee(std::forward<T>(arg));
    }
    ```
### 适用场景
-   通用封装、工厂函数、容器的 `emplace` 等场景。
-   STL 中广泛使用，比如 `std::make_shared`, `std::vector::emplace_back`。
### 注意
-   不要滥用。普通函数没必要模板化 + 转发。
-   仅在需要保持参数“值类别”时使用。

---

## 🔑 **如何选择？**

| 方式 | 可接受 | 是否拷贝 | 是否能修改 | 使用场景 |
| --- | --- | --- | --- | --- |
| 值传递 | 左值、右值 | 是（拷贝/移动） | 修改不影响实参 | 小对象，或需要副本 |
| 左值引用 | 左值 | 否 | 可以修改 | 输出参数，避免复制 |
| 左值常引用 | 左值、右值 | 否 | 不能修改 | 大对象只读，最常用 |
| 右值引用 | 右值 | 否 | 可以修改（通常是移动） | 移动语义，构造/赋值优化 |
| 完美转发 | 左值、右值 | 否 | 保留原始类别 | 泛型封装、容器构造 |

---

⚡一个**经验法则**：

-   **小对象 → 值传递**
    
-   **大对象只读 → const 引用**
    
-   **大对象需修改 → 引用**
    
-   **性能敏感且右值 → 右值引用**
    
-   **通用模板 → 完美转发**
    

---