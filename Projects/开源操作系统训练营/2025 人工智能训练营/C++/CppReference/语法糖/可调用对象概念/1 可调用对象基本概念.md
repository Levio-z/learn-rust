### 语法
```c++
struct Multiply {
    int operator()(int a, int b) const {
        return a * b;
    }
};
```
作用域：类内部
对象状态：可以访问类的成员变量
修饰符：
const → 表示调用该成员函数时不会修改对象的非 mutable 成员
volatile → 表示对象可能被异步修改
noexcept、inline、constexpr 等修饰符同样可用

---
## 1\. C++ 的“可调用对象”概念
在 C++ 里，**任何定义了 `operator()` 的对象都被视为可调用对象（callable object）**。
示例：
```c++
struct Multiply {
    int operator()(int a, int b) const {
        return a * b;
    }
};

Multiply mul;         // mul 是对象
int result = mul(3, 4); // 调用 mul.operator()(3,4)
```
-   写 `mul(3,4)` 时，**编译器会自动将 `mul(3,4)` 翻译成 `mul.operator()(3,4)`**。
-   所以我们 **不用显式写 `mul.operator()`**，直接用变量名加括号就能调用内部方法。

---
## 2\. 为什么可以直接调用？

1.  **语法糖设计**
    -   `()` 在 C++ 中不仅仅是函数调用运算符，它也可以作用于对象，前提是该对象定义了 `operator()`。
    -   这是语言设计者给对象“函数化”的语法糖，让对象像普通函数一样调用。
2.  **类型系统支持**
    -   编译器检查 `mul` 是否有 `operator()` 方法，并且参数匹配。
    -   如果有，生成调用代码；如果没有，报错。
3.  **函数对象 vs 普通函数**
    -   普通函数直接写名字就是调用函数，而函数对象需要 **对象 + operator()**，语法糖隐藏了这一层。
    -   所以你可以像调用函数一样写 `mul(3,4)`，而不必写成 `mul.operator()(3,4)`。
---
## 3\. 举个类比

-   普通函数：
    ```c++
    void foo(int x) {}
    foo(10); // 直接调用函数
    ```
-   函数对象：
    ```c++
    struct Foo { void operator()(int x) {} };
    Foo f;
    f(10); // 编译器自动调用 f.operator()(10)
    ```
-   Lambda 也是同样的规则（不理解）：
    ```c++
    auto l = [](int x){ return x*x; };
    l(5); // 编译器调用 l.operator()(5)
    ```
    

---

✅ **总结**：

-   **直接使用变量名加括号**调用内部方法是 C++ 的语法糖，由 `operator()` 提供。
    
-   本质上，`obj(args...)` == `obj.operator()(args...)`。
    
-   这种设计让函数对象和 Lambda 都能像普通函数一样使用，提高可读性和一致性。
    

---