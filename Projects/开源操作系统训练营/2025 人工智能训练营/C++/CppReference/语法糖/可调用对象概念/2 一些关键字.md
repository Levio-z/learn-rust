## 具体例子
```
struct Foo {
    // 修饰符组合使用示例
    inline constexpr int operator()(int x) const noexcept volatile {
        return x * 2;
    }
};
```

| 修饰符         | 作用                      | 在这个函数中的语义                                      |
| ----------- | ----------------------- | ---------------------------------------------- |
| `inline`    | 建议编译器在调用点展开函数           | 避免函数调用开销；允许在头文件多次定义                            |
| `constexpr` | 编译期可求值                  | 允许在编译期计算 `f(5)`，比如 `constexpr int val = f(5);` |
| `const`     | 调用时不修改对象的非 `mutable` 成员 | `operator()` 内不能写普通成员变量，只能修改 `mutable` 成员      |
| `volatile`  | 对象可能被异步修改，禁止优化          | 如果对象是 `volatile Foo`，调用依然合法，编译器不会优化访问对象成员      |
| `noexcept`  | 声明函数不会抛异常               | 调用该函数不会抛异常，如果抛异常会触发 `std::terminate()`         |
## 1\. `volatile`（不理解）
-   **用途**：告诉编译器这个对象的值可能在程序以外被改变（异步修改），禁止编译器对其进行优化。
-   **典型场景**：
    -   内存映射寄存器（硬件寄存器）
    -   多线程共享的非原子变量（不推荐，现代 C++ 用 `std::atomic`）
-   **示例**：
```c++
struct Foo {
    int x;
    void print() volatile { std::cout << x; }
};

volatile Foo f;
f.print();  // 编译器不会优化对 x 的访问
```

-   **说明**：`volatile` 和 `const` 可以结合使用，表示 **对象可能被异步修改，但函数不修改它自身的状态**。
    

---

## 2\. `noexcept`

-   **用途**：声明函数**不会抛出异常**
-   **好处**：
    1.  编译器可以进行更激进的优化
    2.  对模板或容器操作更安全（STL 在移动构造/移动赋值中依赖 `noexcept`）
-   **示例**：
```c++
void foo() noexcept {
    // 这里不能抛异常
}
```
-   **注意**：
    -   如果函数在 `noexcept` 声明下抛出异常，会调用 `std::terminate()`

>`std::terminate()` 是 C++ 标准库提供的一个全局函数，用来处理“程序异常终止”的情况。它通常在程序遇到**无法恢复的异常**时被调用，行为非常直接：**立即终止程序执行**。

---

## 3\. `inline`
-   **用途**：建议编译器**在调用点展开函数**
-   **作用**：
    1.  避免函数调用开销（小函数或 getter/setter 常用）
    2.  允许在头文件中定义函数而不会违反 ODR（One Definition Rule）
-   **示例**：
```c++
inline int add(int a, int b) { return a + b; }
```
-   **说明**：
    -   只是建议，编译器可以忽略
    -   C++17 起，`inline` 还用来修饰变量（inline variable）
---
## 4\. `constexpr`
-   **用途**：声明函数或变量在编译期可求值
-   **要求**：
    1.  函数体内必须能在编译期求值（不允许复杂运行时行为）
    2.  **函数必须有返回值**
-   **示例**：
```c++
constexpr int square(int x) {
    return x * x;
}

constexpr int val = square(5); // 在编译期求值
```

-   **函数对象的 `operator()`** 也可以 `constexpr`，允许在编译期求值：

```c++
struct Square {
    constexpr int operator()(int x) const { return x * x; }
};
constexpr Square sq;
constexpr int val2 = sq(6);
```
## 5. `const` 成员函数的语义
当你在成员函数后加 `const` 修饰符，例如：
```c++
struct Foo {
    int x;

    void f() const {
        // 这里不能修改 x
    }
};
```
- **含义**：  
    - 调用这个函数时，**成员函数承诺不会修改对象的状态**（也就是对象的非 `mutable` 成员）。
	- 编译器会给成员函数加上一个隐式参数 `this`，类型为：




---

## 5\. 总结对比

| 修饰符         | 作用                   | 可用场景                |
| ----------- | -------------------- | ------------------- |
| `volatile`  | 对象可能被异步修改，禁止优化       | 成员函数、对象访问           |
| `noexcept`  | 不会抛出异常               | 普通函数、成员函数           |
| `inline`    | 建议在调用点展开函数；允许头文件多次定义 | 普通函数、成员函数、变量(C++17) |
| `constexpr` | 编译期求值                | 普通函数、成员函数、构造函数、变量   |
| cosnt       |                      |                     |

---

✅ **一句话理解**：

-   `volatile` 和对象状态相关
    
-   `noexcept`、`inline`、`constexpr` 与函数行为或优化相关
    
-   可以组合使用，例如：
    

```c++
struct Foo {
    constexpr int operator()(int x) const noexcept { return x*2; }
};