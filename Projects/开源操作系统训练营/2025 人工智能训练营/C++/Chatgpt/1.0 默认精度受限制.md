
```cpp
#include <iostream>

int main(int argc, char **argv) {
    std::cout << "Hello, InfiniTensor!" << std::endl;
    std::cout << 123 << std::endl
              << 3.1415926535 << std::endl;
    return 0;
}
```

### 问题描述

你观察到：

```
3.1415926535
```

被**省略显示**成：

```
3.14159
```

或类似 **精度被截断** 的现象。

---

### 原因分析：默认浮点数显示精度受限

C++ 中 `std::cout` 默认使用 **`std::ios::defaultfloat` 格式**输出浮点数，其**精度默认为 6 位十进制有效数字（digits10）**，这会导致如下现象：

```cpp
std::cout << 3.1415926535 << std::endl;
// 实际输出: 3.14159
```

> ✅ 这个限制来自标准库对浮点数格式的默认设置，并不是你写的数值被修改，而是**输出格式控制器**进行了裁剪。

---

### 解决方案：手动设置输出精度

你可以使用 `std::setprecision` 来设置需要的精度，配合 `std::fixed` 或 `std::scientific` 格式：

```cpp
#include <iostream>
#include <iomanip>  // std::setprecision

int main() {
    std::cout << std::fixed << std::setprecision(10);
    std::cout << 3.1415926535 << std::endl;  // 输出完整：3.1415926535
    return 0;
}
```

-   `std::fixed`：表示以**小数点形式**输出（非科学计数法）
    
-   `std::setprecision(n)`：设置 **小数点后保留 `n` 位**（配合 `std::fixed` 时）
    

---

### 示例对比

| 配置 | 输出结果 |
| --- | --- |
| 默认输出 | `3.14159` |
| `std::setprecision(10)` | `3.141592654` |
| `std::fixed + setprecision` | `3.1415926535` |
| `std::scientific` | `3.141593e+00` |

---

### 总结

> 💡 **原因**：默认精度为 6 位有效数字  
> 🛠 **解决**：使用 `std::setprecision` 设置精度，配合 `std::fixed` 输出完整小数
