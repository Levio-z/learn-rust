# 左值（lvalue）详解

## 1\. 定义

**左值（lvalue）** 是指表示一个对象的**内存地址**且可以出现在赋值表达式左侧的表达式。简而言之，左值是具有持久存储位置的表达式，能够取地址。

-   在 C++ 标准中，左值是 **glvalue（generalized lvalue）** 的一种，是表达式值类别的一部分。
    
-   左值表达式指代一个**命名的内存位置**，可以对其进行读写（若非 const 限定）。
    

## 2\. 常见左值表达式举例

下列表达式均为左值表达式：

-   变量名（无论类型，如普通变量、函数、模板参数对象等），例如：
    
    ```cpp
    int x;
    x;             // 左值
    std::cin;      // 标准输入流对象名，左值
    ```
    
-   函数名（函数本身是左值）
    
-   返回左值引用的函数调用或重载运算符表达式，例如：
    
    ```cpp
    int& get_ref();
    get_ref() = 42;  // get_ref() 是左值表达式
    ```
- 函数 `get_ref()` 的返回类型是 `int&`，即**左值引用**。这意味着：
	- 调用 `get_ref()` 表达式的结果是一个左值（lvalue）。
	- 它表示某个可寻址的、可修改的内存位置。
- 通常，普通函数调用返回的是一个右值（prvalue），比如返回 `int`、`std::string` 这样的值类型。
	- 但若函数返回类型是 **左值引用**，则调用表达式本身是左值。
- `get_ref()` 代表的是一个具体的内存地址（函数内部返回的对象），你可以直接给它赋值。

-   内置赋值和复合赋值表达式左边：
    
    ```cpp
    a = b;   // a 是左值
    a += b;  // a 是左值
    ```
    
-   预递增、预递减操作符表达式：
    
    ```cpp
    ++a;  // a 是左值
    --a;  // a 是左值
    ```
    
-   解引用表达式：
    
    ```cpp
    *p;  // p 是指针，*p 是左值
    ```
    
-   数组下标表达式：
    
    ```cpp
    a[n];  // 若 a 是数组左值，则 a[n] 是左值
    ```
    
-   对象成员访问：
    
    ```cpp
    a.m;    // a 是对象左值，m 是非静态数据成员，则 a.m 是左值
    p->m;   // p 是指针，p->m 是左值
    ```
    
-   指针到成员访问：
    
    ```cpp
    a.*mp;  // a 是左值，mp 是数据成员指针，a.*mp 是左值
    p->*mp; // p 是指针，mp 是数据成员指针，p->*mp 是左值
    ```
    
-   逗号表达式：
    
    ```cpp
    (a, b);  // 其中 b 是左值，整个表达式为左值
    ```
    
-   三元条件表达式（在特定情况下返回左值）：
    
    ```cpp
    (cond ? b : c); // 当 b 和 c 都是相同类型的左值时，结果是左值
    ```
    
-   字符串字面量：
    
    ```cpp
    "Hello, world!";  // 字符串字面量是左值
    ```
    
-   转换为左值引用的表达式：
    
    ```cpp
    static_cast<int&>(x);  // 转换为左值引用，结果是左值
    ```
    
-   常量模板参数（左值引用类型）
    
    ```cpp
    template<int& v>
    void foo() {
        v = 5;  // v 是左值
    }
    ```
    

---

## 3\. 左值与右值的区别

-   **左值（lvalue）**：表示具名对象，内存地址明确，可以取地址，且常作为赋值左侧使用。
    
-   **右值（rvalue）**：通常是临时对象、字面值或表达式结果，不能取地址，不能作为赋值左侧。
    

例如：

```cpp
int x = 10;     // x 是左值，10 是右值
int& ref = x;   // ref 是左值引用，绑定 x
int&& rref = 10; // rref 是右值引用，绑定临时右值 10
```

值得注意的是，即使变量本身是 **右值引用类型**，该变量名字仍然是左值表达式：

```cpp
int&& r = 5;  // r 类型是 int&&，右值引用
r = 6;        // r 是左值，能赋值
```

---

## 4\. 左值的性能和语义特性

-   左值的地址可以通过内置地址符 `&` 获取。
    
-   可修改的左值能作为赋值语句左边操作数。
    
-   左值可用来初始化左值引用，从而为对象绑定一个新名字。
    

---

## 5\. 扩展知识点

### 5.1. 左值引用与右值引用

-   **左值引用（T&）**：只能绑定到左值。
    
-   **右值引用（T&&）**：只能绑定到右值。
    

但是变量名字永远是左值表达式，只有通过 `std::move` 等手段转换成右值。

---

### 5.2. 函数返回左值引用

例如：

```cpp
int& get_static_var() {
    static int x = 0;
    return x;   // 返回左值引用，调用处是左值表达式
}
```

调用：

```cpp
get_static_var() = 42;  // 合法，get_static_var() 是左值表达式
```

---

### 5.3. 非静态成员函数与成员枚举器不是左值

-   对象的非静态成员函数名表达式不是左值，不能取地址。
    

示例：

```cpp
struct Foo {
    void bar() {}
};

Foo f;
void (Foo::*p)() = &Foo::bar;  // 取成员函数指针，正确
void (*fp)() = &f.bar;         // 错误，不能取对象成员函数地址
```

---

### 5.4. 字符串字面量作为左值

字符串字面量在 C++ 中是类型为 `const char[N]` 的左值，具有固定内存位置。

---

## 6\. 代码示例

```cpp
#include <iostream>
#include <string>

int& global_var() {
    static int x = 10;
    return x;
}

int main() {
    int a = 5;
    int& ref = a;          // ref 是左值引用绑定 a
    ref = 10;              // 通过左值引用修改 a

    global_var() = 20;     // global_var() 是左值，可以赋值

    int&& rref = 30;       // rref 是右值引用，rref 本身是左值表达式
    rref = 40;             // 合法，rref 是左值

    std::cout << a << " " << global_var() << " " << rref << "\n";
}
```

---

# 总结

左值是 C++ 中表达式值类别的核心，代表可定位、可修改的内存实体。理解左值对于掌握引用、移动语义以及表达式求值规则至关重要。

如果你需要，我可以进一步详细说明左值与右值的历史演变（C++03 vs C++11），`glvalue`、`prvalue`、`xvalue`的区别，或者如何通过左值实现完美转发与移动语义。

---