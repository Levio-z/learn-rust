| 值类别     | 可绑定引用            | 备注                |
| ------- | ---------------- | ----------------- |
| lvalue  | `T&`、`const T&`  | `T&&` 不能绑定 lvalue |
| xvalue  | `T&&`、`const T&` | 两者都可绑定            |
| prvalue | `T&&`、`const T&` | 不能绑定 `T&`         |
```cpp
int a = 1;

int& lr = a;             // lvalue 引用，合法
const int& clr = a;      // 常量左值引用，合法
int&& rr = std::move(a); // 右值引用绑定 xvalue，合法
const int& crx = std::move(a); // 常量左值引用绑定 xvalue，合法

const int& cpr = 10;     // 常量左值引用绑定 prvalue，合法
int&& rpr = 10;          // 右值引用绑定 prvalue，合法

// int& lr2 = 10;        // 错误，不能将 prvalue 绑定到非常量左值引用
// int& lr3 = std::move(a); // 错误，不能将 xvalue 绑定到非常量左值引用
```
### 语义取分

| 绑定类型                   | 合法性   | 理由                 |
| ---------------------- | ----- | ------------------ |
| `T& ← lvalue`          | ✅ 合法  | 正常引用               |
| `T& ← xvalue`          | ❌ 不合法 | 可能误用将亡资源           |
| `T& ← prvalue`         | ❌ 不合法 | 临时对象无地址，悬空风险       |
| `const T& ← ANY`       | ✅ 合法  | 安全，编译器可生成临时并延长生命周期 |
| `T&& ← xvalue/prvalue` | ✅ 合法  | 明确表示：我就是来移动的       |
- 实际上你已经把 `a` 标记为“可移动,将亡资源
	- 但你又用“正常引用”的方式继续用它 → **可能出现野指针/悬空资源/逻辑错误**