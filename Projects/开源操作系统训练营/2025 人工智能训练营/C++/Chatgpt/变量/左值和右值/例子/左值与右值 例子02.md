
## 🔍 代码回顾

```cpp
#include <iostream>

struct S
{
    S() : m{42} {}
    S(int a) : m{a} {}
    int m;
};

int main()
{
    S s;
    // 1️⃣ S{} 是 prvalue，用于赋值
    s = S{};
    std::cout << s.m << '\n';

    // 2️⃣ S{} = S{7} 表达式也合法
    std::cout << (S{} = S{7}).m << '\n';
}
```

---

# ✳️ 第一步：基本语义分析

### ✅ `S s;`

-   创建对象 `s`，调用默认构造函数 → `s.m = 42`。
    

### ✅ `s = S{};`

-   表达式 `S{}` 是一个 **prvalue（纯右值）**，临时构造了一个 `S` 对象（默认构造，`m = 42`）
-   它作为赋值右边，是合法的。
-   `s = S{}` 调用 `S` 的 **赋值运算符**（隐式生成），将临时对象的值赋给 `s`
-   所以 `s.m == 42`

---

## ❓关键点：`(S{} = S{7}).m` 为何合法？

这是第二句代码的精华：

```cpp
std::cout << (S{} = S{7}).m << '\n';
```

---

### 🔧 表达式拆解

-   `S{}` 创建一个 **临时对象（prvalue）**
    
-   `S{7}` 创建另一个临时对象，`m == 7`
    
-   然后执行 `operator=`：将 `S{7}` 的值赋给 `S{}`
    

### ❗疑问：S{} 是一个临时值（prvalue），我们居然能对它赋值？

这在 **C++17** 之前是非法的！但在 **C++17 之后是合法的**，因为：

---

## 🚀 C++17 的重大改变：**prvalue 的具体化（temporary materialization）语义增强**

在 C++17 中，所有 **class 类型的 prvalue** 表达式会**自动具体化为一个临时对象**，从而：

-   拥有对象身份（地址）
-   可以作为赋值表达式的左值！

✅ 因此：

```cpp
(S{} = S{7}).m
```

是完全合法的表达式。

---

## ⚙️ 步骤解析（C++17+ 语义）

1.  `S{}` → prvalue → 自动\*\*物化（materialize）\*\*为临时对象（拥有地址）
    
2.  `S{7}` → prvalue → 初始化另一个临时对象，其 `m = 7`
    
3.  调用临时对象的赋值运算符：
    
    ```cpp
    temp1.operator=(temp2);
    ```
    
4.  返回 `temp1`（赋值结果），访问 `.m`，输出值 7
    

---

## 💡 为什么能“左值化”一个 prvalue？

因为 **class 类型的 prvalue**，在某些上下文下会自动 materialize 成对象。这些上下文包括：

-   成为赋值表达式的左值
-   绑定到引用
-   访问其成员（如 `.m`）
    

> 简言之：**只要你“想用 prvalue 像对象一样”，C++17 就会让它“临时变成对象”给你用！**

---

## 🔚 输出结果分析

```cpp
s = S{};
std::cout << s.m << '\n';          // 输出 42
std::cout << (S{} = S{7}).m << '\n'; // 输出 7
```

---

## 🧠 总结核心点

| 行为 | 在 C++17 之前 | 在 C++17 及之后 |
| --- | --- | --- |
| `prvalue = ...` 临时对象赋值 | ❌ 非法 | ✅ 合法 |
| prvalue 可访问成员、可取地址等 | ❌ 限制 | ✅ 自动 materialize |
| `S{} = S{7}` 是合法表达式 | ❌ 编译错误 | ✅ 合法临时对象赋值 |

---

## 📎 延伸阅读建议

如果你对这个变化感兴趣，可深入了解：

-   C++17 temporary materialization rules
    
-   C++17 标准草案中的 prvalue → xvalue 转换优化逻辑（P0135R1 proposal）
    

---