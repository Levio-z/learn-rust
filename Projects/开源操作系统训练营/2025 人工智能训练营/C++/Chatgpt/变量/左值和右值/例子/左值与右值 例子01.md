## 🔧 函数代码回顾

```cpp
void foo();
 
void baz()
{
    int a;         // Expression `a` is lvalue
    a = 4;         // ✅ OK: a is lvalue, can appear on left-hand side
    
    int &b{a};     // Expression `b` is lvalue
    b = 5;         // ✅ OK: b is lvalue reference, can be assigned to
    
    const int &c{a}; // Expression `c` is lvalue
    c = 6;           // ❌ ill-formed: c is a read-only reference
    
    void (*p)() = &foo; // ✅ foo is lvalue expression (function designator)
    
    foo = baz;      // ❌ ill-formed: cannot assign to function
}
```

---

# 📌 一、表达式值类别汇总

| 表达式         | 值类别（value category） | 类型           | 说明                      |
| ----------- | ------------------- | ------------ | ----------------------- |
| `a`         | lvalue              | `int`        | 有身份、可取地址、可被赋值           |
| `b`         | lvalue              | `int&`       | 引用变量，依然是 lvalue         |
| `c`         | lvalue              | `const int&` | 常量引用变量，lvalue 但不可赋值     |
| `foo`       | lvalue              | `void()`     | **函数名是 lvalue 表达式**     |
| `&foo`      | prvalue             | `void (*)()` | 地址常量，可赋给指针变量            |
| `foo = baz` | ❌ 非法                | 无            | 函数是 lvalue，但不可被赋值（不可修改） |
>函数在语法上是 **有身份的“实体”**，因此表达式是 lvalue：
>- 但这个 lvalue 是 **只读、常量性** 的 → **函数名是指代“只读代码段中某一段指令的起始地址”**。
>- 所以虽然它“有地址”，但它是 **只读的实体**，不能被赋值、覆盖或替换。
---

## 🔍 二、关键点逐条详解

### 1️⃣ `int a;`
-   `a` 是变量 → 表达式 `a` 是 **lvalue**
-   可以出现在赋值左边：`a = 4;`
---

### 2️⃣ `int& b{a};`

-   `b` 是左值引用 → 它本身是一个 **lvalue**
-   `b = 5;` 等价于 `a = 5;`
    

✅ 没问题，引用变量依然是左值，可读可写。

---

### 3️⃣ `const int& c{a};`

-   `c` 是常量左值引用 → 是 **lvalue**
    
-   但是是 **const** → 不能赋值
    

```cpp
c = 6; // ❌ 错误：不能给 const 引用赋值
```

编译错误类似：

> error: assignment of read-only reference ‘c’

---

### 4️⃣ `foo` 是函数名，为什么是 lvalue？

> 在表达式中，**函数名（未调用）是一个 lvalue，表示该函数实体的地址**。

```cpp
void (*p)() = &foo; // ✅ 正确
```

`&foo` 是取地址 → `foo` 表达式必须是 lvalue 才能取地址。

同样：

```cpp
foo == &foo; // 在大多数实现中是 true（但标准并不要求）
```

函数虽然不是对象（不能被修改），但表达式 `foo` 确实是 **函数的身份引用**，因此是 lvalue。

---

### 5️⃣ `foo = baz; // ❌ 错误！`

你试图给函数名赋值，这在 C++ 是不允许的：

-   函数是 **不可修改的 lvalue**
    
-   它有身份，但是“常量实体” → **不能被赋值**
    
-   语义上，函数定义是“只读”的，不能动态替换函数体
    

> ❌ `foo = baz;` 的意思是“把 baz 的地址赋给 foo”——但函数名不是函数指针变量，不能这样用。

---

## ✅ 总结一图理解：各种 lvalue 表达式

| 表达式 | 是 lvalue 吗？ | 是否可赋值？ | 原因备注 |
| --- | --- | --- | --- |
| `a` | ✅ | ✅ | 普通变量 |
| `b` | ✅ | ✅ | 左值引用，指向 a |
| `c` | ✅ | ❌ | 常量引用 |
| `foo` | ✅ | ❌ | 函数名是 lvalue，但不可修改 |
| `&foo` | ❌（prvalue） | ✅ | 生成函数地址，可赋给函数指针变量 |

---

## 💡 附加知识点

-   **函数名是 lvalue**：但用途受限（不能赋值）
    
-   **数组名也是 lvalue**：类似函数，但也不可赋值
    
    ```cpp
    int arr[10];
    arr = new int[10]; // ❌ 错误，数组名是 lvalue，但不可赋值
    ```
    

---

## 🧠 总结一句话

> **lvalue** 表示“有身份”的表达式，**是否可赋值**取决于其类型是否允许写入（如 `const`、函数、数组等）  
> 函数名 `foo` 虽是 lvalue，但语义上不可赋值，因此 `foo = baz;` 是非法的。

---



你提供的这个代码非常经典，用于说明 **prvalue 的初始化行为** 和 **临时对象赋值的语义（尤其是在 C++17 后）**。这个例子有点“超出直觉”，但背后的原理非常值得掌握。

我们逐句解释，并穿插语言标准支持的原理。

---
