### 历史
#### 1\. 传统理解的“右值”和 C++11 的值类别

在 C++98/03 里，值类别简单分为：
-   **左值（lvalue）**：有身份，可以取地址，可以出现在赋值左边。
-   **右值（rvalue）**：无身份，不可取地址，临时值或字面量。

比如：

```cpp
int a = 1;
int b = a;   // a 是左值，1 是右值
```

---

#### 2\. C++11 引入了更细粒度的值类别：

-   **glvalue（广义左值）** = lvalue + xvalue
-   **prvalue（纯右值）**
-   **xvalue（将亡值）**

其中：

-   **lvalue**：传统左值
-   **xvalue**：一种特殊的 glvalue，表示“即将死亡的对象”，资源可被“移动”
-   **prvalue**：纯右值，通常是临时无身份的纯值
	- 可以用来构造临时对象、移动、传值，但不可取地址
---
##### xvalue 详解

-   定义：xvalue 是一种 **glvalue**，也就是依然有对象身份，但表示这个对象即将“过期”，可以安全“搬走”其资源。
-   场景：这通常用于移动语义：表示可以将该对象的内部资源（比如堆内存、句柄等）“窃取”而不用复制。
-   底层：`std::move(a)` 并不真的移动任何东西，它只是转换 `a` 的类型为右值引用类型，从而告诉编译器可以移动资源。

- `std::move` 的定义实质是一个**类型转换**，它将表达式 `s` 强制转换为 `std::remove_reference_t<T>&&` 类型，即右值引用类型。
#### 3\. 所以，“右值”这个词在 C++11 以后要区分两种：
    
-   **prvalue 是纯值，没有身份，没有地址，是临时计算的纯数据**。
-   **所有 xvalue 和 prvalue 都是“右值”（rvalue）**
-   但 C++11 细分了右值为 prvalue 和 xvalue
-   **lvalue 不属于右值**

---
3\. 具体区别看表格：

| 属性          | prvalue (“纯右值”)          | xvalue (“将亡值”)                           | lvalue (“左值”)    |
| ----------- | ------------------------ | ---------------------------------------- | ---------------- |
| 是否有对象身份     | 否                        | 是                                        | 是                |
| 资源是否可被移动    | 通常是临时无身份值                | 资源可被移动                                   | 资源不可移动           |
| 是否是 glvalue | 否                        | 是                                        | 是                |
| 典型示例        | 字面量 `42`，返回值 `int foo()` | `std::move(a)`，`std::string().substr(0)` | 变量名 `a`，`int& r` |
| 是否可取地址      | 否                        | 是                                        | 是                |
| 用途          | 计算纯值、初始化临时对象             | 移动语义，资源窃取                                | 普通变量访问，取地址、赋值    |
| 定义          | “纯右值”，无身份（临时值、常量等）       | “将亡值”，有身份但即将销毁                           |                  |
> 1. 返回非引用的函数:**函数的返回类型不是引用类型（T& 或 T&&），而是普通值类型（T）**。
---
#### 4\. 举例对比

```cpp
int a = 1;

int&& rr = std::move(a);   // std::move(a) 是 xvalue
int b = a + 1;             // a+1 是 prvalue

int* p1 = &a;              // 合法，a 是 lvalue
// int* p2 = &(a+1);       // 错误，a+1 是 prvalue，没有地址

int* p3 = &std::move(a);   // 合法，std::move(a) 是 xvalue，有身份，可取地址
```

---

#### 5\. 额外补充：为何设计 xvalue？
设计 xvalue 是为了解决移动语义表达上的矛盾：
-   **lvalue** 表示表达式有明确对象身份，不能移动。
-   **xvalue** 也是有对象身份，但表达式允许“资源移动”，典型表现是右值引用类型。
-   `std::move` 是制造 xvalue 的标志性工具，不直接移动，但赋予对象“将亡值”身份。
-   移动的对象必须有身份（才能取地址，才能移动资源）
-   但又不能是普通左值（因为普通左值表示资源仍在正常使用）
-   因此诞生了 “将亡值”——表达对象即将过期，资源可以被安全转移。
    