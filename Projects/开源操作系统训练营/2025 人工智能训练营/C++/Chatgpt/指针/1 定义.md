# C++ 指针详解

## 1\. 指针定义

指针是**存储内存地址的变量**，用于间接访问其他变量或内存位置。

```cpp
int* p;  // p 是指向 int 类型的指针变量
```

-   `p` 存储的是一个内存地址，指向一个 `int` 类型的对象。
-   指针本身是变量，有自己的内存空间，存储目标对象的地址。
    

---

## 2\. 指针的作用

-   **间接访问**：通过指针可访问和修改指针指向的对象。
-   **动态内存管理**：指针配合 `new`/`delete` 实现动态分配和释放内存。
-   **实现数据结构**：链表、树等基于指针的结构实现。
-   **函数参数传递**：传递指针实现函数内修改外部变量。
-   **实现多态和虚函数表**（底层机制）。

---

## 3\. 指针基础语法

```cpp
int a = 10;
int* p = &a;    // &取地址操作符，p存储a的地址
int b = *p;     // *解引用，访问p指向的变量a的值
*p = 20;        // 通过指针修改a的值
```

-   `&`：取地址运算符，获取变量的内存地址。
-   `*`：解引用运算符，通过指针访问或修改指向的对象。
    

---

## 4\. 指针的内存模型

-   指针变量存储的内容是**内存地址**，通常是一个无符号整数（如 64 位机器上是 64 位地址）。
    
-   该地址指向一块内存，里面存储某种类型的数据（如 `int`、`char`、对象等）。
    
-   指针类型决定了编译器解引用时，访问内存的大小和解释方式。
    

---

## 5\. 指针类型与类型安全

```cpp
int* pi;
double* pd;
char* pc;
```

-   指针类型与所指对象类型对应。
-   不同类型指针的解引用结果大小不同，且指针算术运算以指针类型大小为步长。
-   类型安全：不应将指针强制转换成不匹配的类型，避免未定义行为。
    

---

## 6\. 指针算术运算

指针可以进行加减，运算时按指针类型大小自动调整地址。

```cpp
int arr[5] = {1,2,3,4,5};
int* p = arr;    // 指向 arr[0]
p = p + 2;       // 现在指向 arr[2]
```

注意：

-   指针只能在同一数组范围内做算术运算，超出范围访问是未定义行为。
    
-   不能对指针做乘法、除法等运算。
    

---

## 7\. 空指针（nullptr）

指针变量可以不指向任何有效地址，称为空指针。

```cpp
int* p = nullptr;  // C++11起推荐使用 nullptr
if(p == nullptr) {
    // 指针无效，不能解引用
}
```

`nullptr` 是类型安全的空指针常量，优于传统的 `NULL`（通常为 `0`）。

---

## 8\. 指针的使用场景

-   **函数参数传递**：实现对外部变量的修改。
    
    ```cpp
    void increment(int* p) {
        (*p)++;
    }
    
    int main() {
        int a = 5;
        increment(&a);
    }
    ```
    
-   **动态内存管理**
    
    ```cpp
    int* p = new int(10);  // 在堆上分配 int，初始化为10
    delete p;              // 释放内存，防止泄漏
    ```
    
-   **数组和字符串遍历**
    
    ```cpp
    char str[] = "hello";
    char* p = str;
    while(*p) {
        std::cout << *p;
        p++;
    }
    ```
    
-   **链表等数据结构**
    
    ```cpp
    struct Node {
        int data;
        Node* next;
    };
    ```
    

---

## 9\. 指针和引用的区别

| 特性 | 指针 | 引用 |
| --- | --- | --- |
| 定义 | 变量存储地址 | 另一个变量的别名 |
| 是否可为 null | 可以为 nullptr | 必须绑定到有效对象 |
| 语法 | 需解引用 `*p` | 使用时直接操作引用 |
| 赋值 | 可以重新指向别处 | 一旦绑定不可更改 |
| 复杂性 | 需要检查空指针，易错 | 语法更简洁，安全性更高 |

---

## 10\. 指针安全与陷阱

-   **野指针**：未初始化的指针，指向未知地址，访问会导致崩溃。
    
-   **悬空指针**：指向已释放内存，使用会导致未定义行为。
    
-   **内存泄漏**：忘记释放动态申请的内存。
    
-   **非法解引用**：解引用空指针或无效指针。
    

---

## 11\. 指针的扩展知识点

### 11.1. 指向指针的指针

```cpp
int a = 5;
int* p = &a;
int** pp = &p;
```

-   `pp` 是指针，指向指针 `p`。
    
-   可用于多级间接访问。
    

### 11.2. 函数指针

```cpp
int add(int a, int b) { return a + b; }
int (*func_ptr)(int, int) = &add;
int result = func_ptr(2, 3);
```

-   指针指向函数，可用于回调、事件驱动编程。
    

### 11.3. 智能指针（C++11 起）

-   `std::unique_ptr`：独占所有权指针，自动释放资源。
    
-   `std::shared_ptr`：共享所有权指针，引用计数管理。
    
-   `std::weak_ptr`：弱引用，解决循环引用问题。
    

智能指针极大提高了指针的安全性和易用性。

---

## 12\. 示例代码综合展示

```cpp
#include <iostream>
#include <memory>

void increment(int* p) {
    if (p) (*p)++;
}

int main() { 
    int a = 10;
    int* p = &a;

    std::cout << "a = " << a << std::endl;
    increment(p);
    std::cout << "after increment, a = " << a << std::endl;

    // 动态内存
    int* pd = new int(20);
    std::cout << "*pd = " << *pd << std::endl;
    delete pd;

    // 智能指针
    std::unique_ptr<int> up(new int(30));
    std::cout << "*up = " << *up << std::endl;

    return 0;
}
```

---

# 总结

-   指针是 C++ 的基础，灵活强大但易错。
    
-   需要注意初始化、释放、避免野指针和悬空指针。
    
-   现代 C++ 倾向使用智能指针代替裸指针，提升安全性。
    
-   理解指针是深入理解内存管理、性能优化和底层编程的关键。
    

---