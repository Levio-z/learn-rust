## 1\. 场景说明

假设我们有头文件 `something.h`：

```cpp
// something.h
#pragma once

int something(int); // 函数声明，返回值是 int
```

实现文件 `something.cpp`：

```cpp
#include "something.h"

void something(int)  // ❌ 实现时返回值是 void，不匹配
{
}
```

因为 `.cpp` 里 `#include` 了头文件，编译器会在**编译阶段**就看到：

-   声明：`int something(int)`
    
-   定义：`void something(int)`
    

返回类型不一致 → 编译器立刻报错（不用等链接阶段）。

---

## 2\. 如果不 `#include` 会怎样？

如果你去掉 `#include "something.h"`：

```cpp
// something.cpp
void something(int) // 编译器没法知道声明，认为是全新的定义
{
}
```

编译器不会报错（它以为这是一个返回 `void` 的新函数），但是：

-   如果其他 `.cpp` 文件用到了 `int something(int)`（从 `something.h` 得到的声明）
    
-   链接时就会发现两个符号签名不一致（一个 `int something(int)`，一个 `void something(int)`）→ 链接错误
    

这样错误要等到**链接阶段**才发现，浪费时间，而且错误信息也更晦涩。

---

## 3\. 为什么一定要 `#include` 自己的头文件？

这是 C++ 的一种**自检习惯**，叫做 *self-include check*：

-   每个 `.cpp` 文件的第一行就是 `#include "对应的头文件"`
    
-   确保声明和定义保持一致
    
-   提前发现签名不匹配等错误
    
-   避免接口和实现长期“偷偷”偏离
    

---

## 4\. 规律总结

| 是否包含头文件 | 错误发现阶段 | 优缺点 |
| --- | --- | --- |
| 包含头文件 | 编译期 | 立刻发现接口和实现不匹配 |
| 不包含头文件 | 链接期 | 错误发现晚、提示信息差 |

---

## 5\. 延伸

这种模式不仅适用于普通函数，也适用于：

-   类成员函数
    
-   模板函数
    
-   内联函数
    
-   外部变量声明（`extern`）
    
-   API 接口声明与实现
    

---