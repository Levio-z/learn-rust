函数声明可以出现在任何作用域中。类作用域的函数声明引入了类成员函数（除非使用友式说明符），有关详细信息，请参阅[成员函数](https://en.cppreference.com/w/cpp/language/member_functions.html "cpp/language/member functions")和[友式函数](https://en.cppreference.com/w/cpp/language/friend.html "cpp/language/friend") 。

---

## 🚩 一、函数声明可以出现在任何作用域中

```cpp
// 全局作用域
void global_func();

// 局部作用域
void outer() {
    void local_func(); // 局部作用域声明，只引入名字
}

// 命名空间作用域
namespace ns {
    void namespaced_func();
}

// 类作用域
struct A {
    void member_func();              // 成员函数
    friend void friend_func(A&);     // 友元函数（不是成员函数）
};
```

-   在**类作用域**中声明函数，**默认视为类的成员函数**。
    
-   如果加上 `friend` 说明符，则该函数 **不是成员函数**，但具有对类私有成员的访问权限。
    

---

## 📌 二、函数声明语法总览（Function Declarator Syntax）

函数声明形式如下：

```sql
noptr-declarator ( parameter-list ) cv ref except attr
                                   -> trailing-return-type (optional)
```

### 🔹 `noptr-declarator`

-   是最基本的声明器，可以是函数名、函数指针、成员函数指针等。
    
-   若以 `*`, `&`, `&&` 开头（如指针声明），**必须用括号括起**。
    
    ```cpp
    void (*fp)(int); // 函数指针
    ```
    

---

### 🔹 `(parameter-list)` 参数列表

-   一组以逗号分隔的形参定义：
    
    ```cpp
    int foo(int a, double b);
    ```
    

---

### 🔹 `cv`（cv-qualification）

-   仅适用于**非静态成员函数**：
    
    ```cpp
    struct X {
        int get() const;   // 成员函数不修改对象状态
    };
    ```
    
- const
	- 该函数**承诺不修改对象状态**
- 区分重载版本
	- （函数重载基于 cv）
- -当对象是 `const File`，只能调用 `const` 版本；
- 普通对象调用非 `const` 版本，允许修改返回值。
---

### 🔹 `ref`（ref-qualification）【C++11 起】

-   限制成员函数只能绑定到左值或右值对象：
    
    ```cpp
    struct X {
        void f() &;   // 只能通过左值对象调用
        void f() &&;  // 只能通过右值对象调用
    };
    ```
    

---

### 🔹 `except`（异常说明）

| 版本          | 说明              |
| ----------- | --------------- |
| C++11 前     | 动态异常说明（已废弃）     |
| C++11–C++17 | `noexcept` 可选说明 |
| C++17 起     | 仅允许 `noexcept`  |

```cpp
void f() noexcept;
void g() throw(int); // C++11 前合法，之后已废弃
```

---

### 🔹 `attr`（属性）【C++11 起】

-   属性出现在函数声明中，用于指示编译器优化或行为约束：
    
    ```cpp
    [[nodiscard]] int compute(); // 警告忽略返回值
    ```
    

---

### 🔹 `-> trailing-return-type`（尾随返回类型）【C++11 起】

-   当返回类型依赖于参数名、或很复杂时更清晰：
    

```cpp
// 普通形式
template <typename T, typename U>
decltype(t + u) add(T t, U u); // 错：t/u 在作用域外

// 尾随返回形式
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u); // ✅ 正确
```

> 尾随返回类型在函数体外部定义和 lambda 表达式中也非常常见。

---

## 🧠 三、几个典型例子解析

### 示例 1：成员函数 vs 非成员函数

```cpp
struct S {
    void f();                  // 成员函数
    friend void g(S&);         // 非成员函数，仅为友元
};
```

-   `S::f` 是成员函数，拥有 `this` 指针
    
-   `g` 虽然在类中声明，但不是成员函数，只是拥有访问权限
    

---

### 示例 2：复杂声明（函数指针 + 尾随返回）

```cpp
auto fpif(int) -> int(*)(int);
// 函数名：fpif
// 参数：int
// 返回值：int(*)(int) —— 一个函数指针，指向“接受 int 返回 int”的函数
```

---

## 📌 四、声明 vs 定义

-   声明（declaration）：引入函数名称 + 签名
    
-   定义（definition）：给出函数体
    

```cpp
void f(int);         // 声明
void f(int x) { }    // 定义
```

---

## ✅ 总结重点表格

| 语法组件 | 含义与限制 |
| --- | --- |
| `cv` | 仅用于成员函数，表示 const/volatile 限定 |
| `ref` | 仅用于成员函数，C++11 起，限制调用对象值类别 |
| `except` | `noexcept`（C++11 起）或 `throw()`（C++17 前） |
| `attr` | C++11 起支持，如 `[[nodiscard]]` |
| `->` | 尾随返回类型，仅 C++11 起，需 `auto` |

---