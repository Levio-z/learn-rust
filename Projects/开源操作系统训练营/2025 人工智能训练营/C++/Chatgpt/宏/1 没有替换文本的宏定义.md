这种 **没有替换文本** 的宏定义，其作用和普通的带值宏不一样——它主要用来做**条件编译的“标记宏”**（flag macro）。

---

## 1\. **定义但不替换的宏是什么**

-   它告诉预处理器：**这个标识符已经被定义**（`defined`）。
    
-   在代码中，宏名本身**不会被替换成任何东西**（因为没有替换文本）。
    
-   常见用途：配合 `#ifdef` / `#if defined()` 做条件编译控制。
    

---

## 2\. **作用**

### （1）**作为编译标志**

```c
#define DEBUG

#ifdef DEBUG
    printf("Debug info\n");
#endif
```

-   这里 `DEBUG` 就是一个“存在即为真”的宏。
    
-   只要宏定义存在，`#ifdef DEBUG` 块就会参与编译。
    
-   如果删除或注释掉 `#define DEBUG`，这段代码就会被编译器跳过。
    

---

### （2）**与编译器命令行结合**

这种“标记宏”经常不是在源码里写，而是在编译器命令行上加：

```bash
gcc -DDEBUG main.c
```

等价于在代码最开头写：

```c
#define DEBUG
```

这样可以在不修改源代码的情况下启用/禁用某些功能。

---

### （3）**作为 include guard（头文件保护）**

```c
#ifndef MY_HEADER_H
#define MY_HEADER_H

// 头文件内容

#endif
```

这里 `#define MY_HEADER_H` 并不需要替换文本，仅仅用来标记“我已经包含过这个文件了”，防止重复包含。

---

## 3\. **为什么不直接写变量？**

-   预处理发生在编译之前，宏标志可以影响编译流程（比如是否包含某段代码）。
    
-   变量则是在编译后的运行期存在，不影响编译流程。
    

---

## 4\. **总结**

没有替换文本的 `#define`：

-   **本质**：只是一个“是否已定义”的标记。
    
-   **典型用途**：
    
    1.  条件编译开关（`#ifdef` / `#if defined()`）。
        
    2.  编译器命令行参数（`-D`）。
        
    3.  头文件防重包含（include guard）。
        

---