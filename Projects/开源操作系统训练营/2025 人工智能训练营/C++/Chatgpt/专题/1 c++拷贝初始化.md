## 1\. **定义**

在 C++ 中，**拷贝初始化**（copy initialization）是一种对象初始化方式，语法形态一般是这样：

```cpp
T obj = expr;
```

它与**直接初始化**（direct initialization，如 `T obj(expr);`）的区别是：

-   **拷贝初始化**会先将右值 `expr` 转换成目标类型的临时对象（必要时通过转换构造函数或类型转换运算符），然后调用**拷贝构造函数**或**移动构造函数**构造最终对象。
    
-   **直接初始化**则会尽量直接调用匹配的构造函数，省去中间临时对象。
    

---

## 2\. **触发拷贝初始化的典型场景**

除了 `T obj = expr;` 这种显式写法，你提到的这三种情况**都属于隐式的拷贝初始化**：

1.  **按值将参数传递给函数**
    
    ```cpp
    void foo(T x); // 形参 x 按值接收
    foo(expr);     // expr 被用来拷贝初始化 x
    ```
    
2.  **按值从函数返回**
    
    ```cpp
    T bar() {
        T temp;
        return temp; // temp 拷贝初始化调用方的接收对象
    }
    ```
    
3.  **按值捕获异常**
    
    ```cpp
    try {
        throw expr;  // expr 被用来构造异常对象（拷贝初始化）
    } catch (T e) { // e 是按值接收的异常对象
    }
    ```
    

这三种都是**隐式调用拷贝初始化**的例子，虽然你没写 `=`，但编译器内部会走相同的规则。

---

## 3\. **源码层面的调用顺序**

拷贝初始化的底层过程（简化版）大致是这样：

1.  **类型转换**（如果 `expr` 不是目标类型）
    
    -   如果存在可行的**转换构造函数**（`T::T(const U&)`）或类型转换运算符（`U::operator T()`），编译器会先生成一个临时 `T` 对象。
        
2.  **调用构造函数**
    
    -   如果源是同类型对象：调用**拷贝构造函数** `T::T(const T&)`
        
    -   如果源是可移动的临时对象：调用**移动构造函数** `T::T(T&&)`（C++11 起）
        
3.  **优化（RVO / NRVO）**
    
    -   如果是函数返回值等场景，编译器可能会省掉拷贝或移动构造（Return Value Optimization）。
        

---

## 4\. **使用场景对比**

| 场景 | 示例 | 是否拷贝初始化 |
| --- | --- | --- |
| 显式 `=` 初始化 | `T obj = expr;` | ✅ |
| 按值传参 | `foo(expr);` where `void foo(T x)` | ✅ |
| 按值返回 | `return expr;` | ✅ |
| 按值捕获异常 | `catch (T e)` | ✅ |
| 直接初始化 | `T obj(expr);` | ❌（直接初始化） |
| 列表初始化 | `T obj{expr};` | ❌（直接初始化） |

---

## 5\. **额外知识点**

-   **`explicit` 构造函数**不能被拷贝初始化隐式调用，这就是为什么：
    
    ```cpp
    struct A {
        explicit A(int) {}
    };
    A a1(1);  // ✅ 直接初始化
    A a2 = 1; // ❌ 错误，explicit 禁止隐式转换
    ```
    
-   编译器会尽量用**移动构造**替代拷贝构造（如果存在且符合条件）。
    
-   对于 POD（Plain Old Data）类型，拷贝初始化通常就是简单的 `memcpy`。
    

---