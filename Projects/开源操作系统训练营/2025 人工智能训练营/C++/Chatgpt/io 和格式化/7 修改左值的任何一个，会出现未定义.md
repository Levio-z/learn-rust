这些宏可以扩展为可修改的左值。如果修改了这些 [std：：FILE](https://zh.cppreference.com/w/cpp/io/c/FILE.html)* 左值中的任何一个，则对相应流的后续作会导致未指定或未定义的行为。
```
#define stdout (*__stdoutp)  // 某些实现中
```
宏展开后，实际上是一个 **`FILE*` 类型的表达式**，**可以出现在左值（lvalue）位置**：
```
stdout = fopen("output.txt", "w");  // 这是合法的语法！

```

### 原因很直接：

- `stdout` 是标准库内部管理的 **全局变量或宏指针引用**
- 若你将它指向其他 `FILE*`，**库内部的行为将不可预测**
- 后续对 `stdout` 的调用如 `printf()` 等，都可能出错甚至 crash
- 标准库的内部数据结构和实现**假设**这些指针是固定的，且指向同一块受控内存。
	- 例如，glibc中 `stdout` 指向 `_IO_2_1_stdout_` 全局变量。
	- 如果你直接把 `stdout` 改成指向另一个 `FILE*`，标准库的其他部分就不能正确同步或保护这个流的状态。  
	- 这会导致缓冲区错乱、资源泄漏，甚至程序崩溃。
### C 标准术语：

> **"undefined behavior"（未定义行为）**：编译器没有义务保持程序逻辑正确，任何结果（甚至爆炸）都可能发生。