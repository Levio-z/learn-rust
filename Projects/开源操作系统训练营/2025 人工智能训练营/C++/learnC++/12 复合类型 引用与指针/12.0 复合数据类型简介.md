不理解以下内容会看这个例子[12.0.1 例子（辅助理解）：为什么需要复合数据类型](12.0.1%20例子（辅助理解）：为什么需要复合数据类型.md)
#### 为什么需要复合数据类型
- 表达更强的语义（Stronger Semantics）
	- 把一组逻辑相关的细节（分子、分母）打包成一个整体，隐藏实现细节，只暴露“这是一个分数”这个概念，把概念直接体现在代码里。
		- 现在 **类型名本身就是语义**：`Fraction`。
		- 使用时一看就知道：这是分数，不是随便两个 int。
		- 可以强制保证：每个分数对象一定是成对出现，而不是两个散落的 int。
	- 弱语义：用基本类型（如 `int`, `double`, `char*`）来表示复杂概念。
		- 含义靠 **注释** 或 **程序员脑子** 维持。
		- 影响 
			- 对编译器来说：只是两个整数。
			- 对程序员来说：必须记住 num 和 den 组合在一起才是“分数”。
			- 一旦忘记，就可能 `num/den` 搞错，或者 `den=0` 出问题。

- 可读性提高：自文档化（Self-documenting），`Fraction` 类型本身就是 **文档化的抽象**
	- **文档化**：类型名、字段名本身就承担了“说明文档”的作用。你不需要翻注释，就能从代码直观理解它的含义。
	- **抽象**：把一组逻辑相关的细节（分子、分母）打包成一个整体，隐藏实现细节，只暴露“这是一个分数”这个概念

- 扩展性：如果以后分数需要“约分”，逻辑就能放进 `Fraction` 类型里，外部调用无需修改。强语义类型为后续扩展留好空间。

- 降低了耦合性：外部调用者只依赖 `Fraction` 抽象，而不关心内部是否是 `(num, den)`、是否做过约分，甚至未来是否换成了 `double` 表示。内部实现变动不再牵连所有调用点，符合 **信息隐藏原则**（Encapsulation）。

### 复合数据类型
幸运的是，C++支持第二组数据类型，称为复合数据类型。**复合数据类型是可以从基本数据类型（或其他复合数据类型）构造的数据类型**。每个复合数据类型也有自己的唯一属性。

正如我们将在本章和以后的章节中所示，我们可以使用复合数据类型来优雅地解决我们上面提出的所有挑战。

C++支持以下复合类型：

1. 函数
2. 数组（Arrays）
3. 指针类型：
    - 对象指针
    - 函数指针
4. 指向成员类型的指针：
    - 指向成员数据的指针
    - 指向成员函数的指针
5. 引用类型：
    - 左值引用
    - 右值引用
6. 枚举类型：
    - 强作用域枚举
    - 若弱作用域枚举
7. 类类型：
    - struct
    - class
    - union

您已经经常使用一种复合类型：函数。例如，考虑此函数：
```C++
void doSomething(int x, double y)
{
}
```
此函数的类型为void(int, double)。请注意，此类型由基本类型组成，使其成为复合类型。当然，函数也有自己的特殊行为（例如，可调用）。

因为这里有许多材料要涵盖，我们将在多个章节中进行讨论。在本章中，我们将介绍一些更简单的复合类型，包括左值引用和指针。下一章，我们将介绍枚举类型以及struct。然后，在后面的章节中，我们将介绍class类型并深入研究一些更有用的数组类型。比如我们之前学习的std::string，它实际上是一种class类型！

我们走吧！
### 问题
1 为什么可以赋值两次
- 第一步：`std::cin >> num1` → 读取一个整数并存入 `num1`。
- 第二步：返回的还是 `std::cin` 流对象，所以接着执行 `>> ignore` → 读取一个字符（比如 `'/'`）。
- 第三步：继续 `>> den1` → 再读一个整数存入 `den1`。