### 总结
- 类型推导将删除const（和constexpr）限定符
- 通过在定义中添加const（或constexpr）限定符，可以（重新）应用const（或contexpr）
- 除了删除常量限定符外，类型演绎还将删除引用属性
- 就像删除的常量限定符一样，如果希望推导出的类型是引用，可以在定义点重新应用引用
- 类型推导：如果初始值设定项是对const（或constexpr）的引用，则首先删除引用（如果类型是auto&，则会重新加上引用），然后从结果中删除任何顶层const。
- 删除引用可能会把一个底层 const 转换成顶层 const
- 当我们说类型推导删除常量限定符时，它只删除顶层const。不会丢弃底层const
- 与引用不同，类型推导不会丢弃指针类型
### 前言
在前面，我们讨论了可以使用auto关键字，让编译器从初始值设定项推断变量的类型：
```C++
int getVal(); // 返回int的一个函数

int main()
{
    auto val { getVal() }; // val 类型推导为 int

    return 0;
}
```

同时，默认情况下，类型推导将删除const（和constexpr）限定符：
```C++
const double foo()
{
    return 5.6;
}

int main()
{
    const double cd{ 7.8 };

    auto x{ cd };    // double (const 被丢弃)
    auto y{ foo() }; // double (const 被丢弃)

    return 0;
}
```
通过在定义中添加const（或constexpr）限定符，可以（重新）应用const（或contexpr）：
```C++
const double foo()
{
    return 5.6;
}

int main()
{
    constexpr double cd{ 7.8 };

    const auto x{ foo() };  // const double
    constexpr auto y{ cd }; // constexpr double
    const auto z { cd };    // const double

    return 0;
}
```
### 类型推导会删除引用属性

除了删除常量限定符外，类型演绎还将删除引用属性：
```C++
#include <string>

std::string& getRef(); // 返回引用

int main()
{
    auto ref { getRef() }; // 类型推导为 std::string (而不是 std::string&)

    return 0;
}
```
在上面的示例中，尽管函数getRef()返回std::string&，但引用限定符被删除，因此ref的类型被推导为std::string。

就像删除的常量限定符一样，如果希望推导出的类型是引用，可以在定义点重新应用引用：

```C++
#include <string>

std::string& getRef(); // 返回引用

int main()
{
    auto ref1 { getRef() };  // std::string (引用限定符被丢弃)
    auto& ref2 { getRef() }; // std::string& (重新加上引用限定符)

    return 0;
}
```

### 顶层const和底层const
顶层（top-level）const 是应用于对象本身的常量限定符。例如：
```C++
const int x;    // const 作用于 x, 所以是顶层const
int* const ptr; // const 作用于 ptr, 所以是顶层const
```
相反，**底层（low-level）const 是应用于被引用或指向的对象的常量限定符**：
```C++
const int& ref; // const 作用于被引用的对象, 所以是底层const
const int* ptr; // const 作用于被指向的对象, 所以是底层const
```
对常量值的引用始终是底层const。指针可以具有顶层、底层或两种const：
```c++
const int* const ptr; // 左边的 const 是底层, 右边的 const 是顶层
```
当我们说类型推导删除常量限定符时，它只删除顶层const。不会丢弃底层const。稍后将看到这方面的示例。
### 类型推导和常量引用
如果初始值设定项是对const（或constexpr）的引用，则首先删除引用（如果类型是auto&，则会重新加上引用），然后从结果中删除任何顶层const。
```C++
#include <string>

const std::string& getConstRef(); // 返回const 引用

int main()
{
    auto ref1{ getConstRef() }; // std::string (先丢弃引用, 然后丢弃顶层const)

    return 0;
}
```
在上面的示例中，由于getConstRef()返回一个const std::string&，因此首先删除引用，留下一个const std::string。现在是顶层const，因此它也被删除，推导出的类型为std::string。

>删除引用可能会将底层const更改为顶层const： const std::string& 是底层const，但删除引用会产生const std::string，这是顶层const。

我们可以重新应用以下任一项或两项

```C++
#include <string>

const std::string& getConstRef(); // 返回const 引用

int main()
{
    auto ref1{ getConstRef() };        // std::string (引用 和 顶层 const 丢弃)
    const auto ref2{ getConstRef() };  // const std::string (引用丢弃, const 重新设置)

    auto& ref3{ getConstRef() };       // const std::string& (引用重新设置, 底层const 保留)
    const auto& ref4{ getConstRef() }; // const std::string& (引用 和 const 重新设置)

    return 0;
}
```

在前面的示例中，我们讨论了ref1的情况。对于ref2，这类似于ref1的情况，只是重新应用了const限定符，因此导出的类型是const std::string。

ref3让事情变得更有趣。通常，引用将首先被删除，但由于重新应用了引用，因此它被保留。这意味着类型仍然是const std::string&。由于它是底层const，不会删除const。因此，推导出的类型是const std::string&。

ref4类似于ref3，只是也重新应用了const限定符。由于类型已经被推导为对const的引用，因此在这里重新应用const是多余的。也就是说，在这里使用const可以明确地表明，结果将是const（而在ref3的情况下，推导结果是const是隐式的，不那么明显）。

**如果需要常量引用，请重新设置const限定符，即使这不是严格必要的。因为它使我们的意图清晰，并有助于防止错误。**
### constexpr引用
它的工作方式与const引用相同：

```C++
#include <string_view>

constexpr std::string_view hello { "Hello" };

constexpr const std::string_view& getConstRef()
{
    return hello;
}

int main()
{
    auto ref1{ getConstRef() };            // std::string_view (引用 和 顶层 const 丢弃)
    constexpr auto ref2{ getConstRef() };  // constexpr std::string_view (引用丢弃, const 重新设置)

    auto& ref3{ getConstRef() };           // const std::string_view& (引用重新设置, 底层const 保留)
    constexpr auto& ref4{ getConstRef() }; // constexpr const std::string_view& (引用 和 const 重新设置)

    return 0;
}
```

- constexpr
	- 指定函数 / 变量 “编译期可计算”
-  `const`：修饰引用指向的对象为 “常量”

### 类型推导和指针
与引用不同，类型推导不会丢弃指针类型：
```C++
#include <string>

std::string* getPtr(); // 返回指针

int main()
{
    auto ptr1{ getPtr() }; // std::string*

    return 0;
}
```

还可以将星号与指针类型推导结合使用：

```C++
#include <string>

std::string* getPtr(); // 返回指针

int main()
{
    auto ptr1{ getPtr() };  // std::string*
    auto* ptr2{ getPtr() }; // std::string*

    return 0;
}
```
