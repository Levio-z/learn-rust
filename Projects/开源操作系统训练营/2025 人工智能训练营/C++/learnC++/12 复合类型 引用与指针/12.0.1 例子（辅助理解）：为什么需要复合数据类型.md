### 基本类型并不能满足我们的全部需求
例如，假设您正在编写一个数学程序来将两个分数相乘。如何在你的程序中表示分数？或许可以使用一对整数（一个用于分子，一个用于分母），如下所示：
```C++
#include <iostream>

int main()
{
    // 第一个分数
    int num1 {};
    int den1 {};

    // 第二个分数
    int num2 {};
    int den2 {};

    // 用这个char来读取分子与分母之间的 '/'
    char ignore {};

    std::cout << "Enter a fraction: ";
    std::cin >> num1 >> ignore >> den1;

    std::cout << "Enter a fraction: ";
    std::cin >> num2 >> ignore >> den2;

    std::cout << "The two fractions multiplied: "
        << num1 * num2 << '/' << den1 * den2 << '\n';

    return 0;
}
```
以及该程序的运行情况：

```C++
Enter a fraction: 1/2
Enter a fraction: 3/4
The two fractions multiplied: 3/8
```

DRY：其次，遵循DRY（不要重复你自己）原则，我们应该创建一个函数来处理用户输入的分数（以及一些错误处理）。然而，函数只能返回单个值，那么我们如何将分子和分母返回给调用者呢？

现在想象另一种情况，您正在编写一个需要保存员工ID列表的程序。你会怎么做？您可以尝试这样的操作：
```C++
int main()
{
    int id1 { 42 };
    int id2 { 57 };
    int id3 { 162 };
    // 以及后续其它的id
}
```

但如果你有100名员工呢？首先，您需要输入100个变量名。如果你需要把它们都打印出来呢？或者将它们传递给函数？我们将会打很多很多的字。这根本无法扩展。

显然，基本类型只会让我们走到这一步。