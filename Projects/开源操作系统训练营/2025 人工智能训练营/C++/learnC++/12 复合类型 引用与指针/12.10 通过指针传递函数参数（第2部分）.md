### 总结
- 允许函数接收可选参数void greet(std::string* name=nullptr)
	- **函数重载是实现相同结果的更好的替代方法：**
- 正如所看到的，更改指针参数ptr2存储的地址不会影响原来指针ptr所保存的地址（ptr仍然指向x）。


### 传递地址的“可选”参数
传递地址的一个更常见的用法是允许函数接受“可选”参数：
```C++
#include <iostream>
#include <string>

void greet(std::string* name=nullptr)
{
    std::cout << "Hello ";
    std::cout << (name ? *name : "guest") << '\n';
}

int main()
{
    greet(); // 这里还不知道用户名

    std::string joe{ "Joe" };
    greet(&joe); // 现在知道用户是Joe

    return 0;
}
```
此示例打印：
```C++
Hello guest
Hello Joe
```
在这个程序中，greet()函数有一个由地址传递的参数，默认为nullptr。在main()中，调用该函数两次。第一次调用时，不知道用户是谁，因此在没有参数的情况下调用greet()。name参数默认为nullptr，greet函数打印“guest”。对于第二个调用，现在有一个有效的用户，因此调用greet(&joe)。name参数接收joe的地址，并可以使用它来打印名称“joe”。

然而，在许多情况下，函数重载是实现相同结果的更好的替代方法：
```C++
#include <iostream>
#include <string>
#include <string_view>

void greet(std::string_view name)
{
    std::cout << "Hello " << name << '\n';
}

void greet()
{
    greet("guest");
}

int main()
{
    greet(); // 这里还不知道用户名

    std::string joe{ "Joe" };
    greet(joe); // 现在知道用户是Joe

    return 0;
}
```

这有许多优点：不再需要担心解引用空指针，并且如果需要，可以传入字符串字面值。
### 更改指针参数指向的内容
**当向函数传递地址时，该地址将复制到指针参数中**（这很好，因为复制地址很快）。现在考虑以下程序：
```C++
#include <iostream>

// ptr被赋值但未被使用，[[maybe_unused]]让编译器不要告警
void nullify([[maybe_unused]] int* ptr2) 
{
    ptr2 = nullptr; // 将ptr指向空指针
}

int main()
{
    int x{ 5 };
    int* ptr{ &x }; // ptr 指向 x

    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");

    nullify(ptr);

    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
    return 0;
}
```
该程序打印：
```C++
ptr is non-null
ptr is non-null
```
正如所看到的，更改指针参数ptr2存储的地址不会影响原来指针ptr所保存的地址（ptr仍然指向x）。当调用函数nullify()时，ptr2接收传入地址的副本（在本例中，是ptr持有的地址，即x的地址）。当函数更改ptr2指向的内容时，这仅影响ptr2持有的副本。

那么，如果想允许函数改变原来的指针ptr所指向的地址，该怎么办？

### 通过引用传递指针？
就像可以通过引用传递普通变量一样，也可以通过引用来传递指针。下面是与上面类似的程序，ptr2更改为对指针的引用：
```C++
#include <iostream>

void nullify(int*& refptr) // refptr 现在是指针的引用
{
    refptr = nullptr; // 传入的指针，指向nullptr
}

int main()
{
    int x{ 5 };
    int* ptr{ &x }; // ptr 指向 x

    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");

    nullify(ptr);

    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
    return 0;
}
```

该程序打印：
```C++
ptr is non-null
ptr is null
```
因为refptr现在是指针的引用，所以当ptr传递给函数时，refptr绑定到ptr。这意味着对refptr的任何更改都是对ptr的更改。

**旁白**

由于对指针的引用相当少见，因此很容易混淆语法（它是int*&还是int&*？）。好消息是，后一种写法，编译器将报错，因为您不能有指向引用的指针（因为指针必须包含对象的地址，而引用不是对象）。

### 为什么不再推荐使用0或NULL表示空指针（可选）












