在前面章节中，我们引入了constexpr关键字，用于创建编译时（符号）常量。我们还引入了常量表达式，这些表达式可以在编译时计算，而不是在运行时计算。

考虑使用两个constexpr变量的以下程序：
```C++
#include <iostream>

int main()
{
    constexpr int x{ 5 };
    constexpr int y{ 6 };

    std::cout << (x > y ? x : y) << " is greater!\n";

    return 0;
}
```
这将产生以下结果：
```
6 is greater!
```

由于x和y是constexpr，编译器可以在编译时计算常量表达式 (x > y ? x : y)，得到结果 6。因为这个表达式不再需要在运行时求值，所以我们的程序将运行得更快。

然而，在print语句的中间有一个非平凡的表达式并不理想——如果表达式是命名函数，会更好。下面是使用函数的相同示例：

```C++
#include <iostream>

int greater(int x, int y)
{
    return (x > y ? x : y); // 比较操作在这里
}

int main()
{
    constexpr int x{ 5 };
    constexpr int y{ 6 };

    std::cout << greater(x, y) << " is greater!\n"; // 运行时才会计算

    return 0;
}
```

该程序产生与前一程序相同的输出。但将表达式放在函数中有一个缺点：对 greater(x, y) 的调用将在运行时执行。通过使用函数（这有利于模块化和文档），我们已经失去了在编译时运行代码的能力（这对性能有害）。

那么我们该如何解决这个问题呢？


### Constexpr函数可以在编译时计算

constexpr函数，其返回值可以在编译时计算。要使函数成为constexpr函数，只需在返回类型之前使用constexpr关键字。下面是一个与上面类似的程序，使用constexpr函数：

```C++
#include <iostream>

constexpr int greater(int x, int y) // 是一个 constexpr 函数
{
    return (x > y ? x : y);
}

int main()
{
    constexpr int x{ 5 };
    constexpr int y{ 6 };

    // 稍后解释这里为啥使用变量
    constexpr int g { greater(x, y) }; // 编译时计算

    std::cout << g << " is greater!\n";

    return 0;
}
```
**这将产生与前一示例相同的输出，但函数调用 greater(x, y) 将在编译时计算，而不是在运行时计算！**

当编译到对应的函数调用时，编译器将计算函数调用的返回值，然后用返回值替换函数调用。

因此在我们的示例中，对 greater(x, y) 的调用将被函数调用的结果替换，即整数值6。换句话说，编译器将编译以下内容：


```C++
#include <iostream>

int main()
{
    constexpr int x{ 5 };
    constexpr int y{ 6 };

    constexpr int g { 6 }; // greater(x, y) 被计算并被返回值 6 取代

    std::cout << g << " is greater!\n";

    return 0;
}
```

**为了有资格进行编译时计算，函数必须具有constexpr返回类型，并且在编译时计算时不能调用任何非constexpr函数。此外，对函数的调用必须传递constexpr参数（例如，constexpr变量或文本）。**

**上面示例中的greater() 函数定义和函数调用满足这些要求，因此它可以进行编译时求值。**

>在本文后面的部分中，我们将使用术语“有资格进行编译时求值”，因此请记住这个定义。

### Constexpr函数也可以在运行时求值

具有constexpr返回值的函数也可以在运行时求值，在这种情况下，它们将返回非 constexpr结果。例如：

```C++
#include <iostream>

constexpr int greater(int x, int y)
{
    return (x > y ? x : y);
}

int main()
{
    int x{ 5 }; // not constexpr
    int y{ 6 }; // not constexpr

    std::cout << greater(x, y) << " is greater!\n"; // 运行时才会计算

    return 0;
}
```




