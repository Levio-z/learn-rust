关系运算符是用于比较两个值的运算符。有6个关系运算符

|运算符|符号|使用形式|结果|
|---|---|---|---|
|大于|>|x > y|x大于y，返回true，否则false|
|小于|<|x < y|x小于y，返回true，否则false|
|大于等于|>=|x >= y|x大于等于y，返回true，否则false|
|小于等于|<=|x <= y|x小于等于y，返回true，否则false|
|等于|==|x == y|x等于y，返回true，否则false|
|不等于|!=|x != y|x不等于y，返回true，否则false|

它们非常直观。每个操作符的计算结果都是布尔值true（1）或false（0）。

下面是将这些运算符与整数一起使用的一些示例代码：

```C++
#include <iostream>

int main()
{
    std::cout << "Enter an integer: ";
    int x{};
    std::cin >> x;

    std::cout << "Enter another integer: ";
    int y{};
    std::cin >> y;

    if (x == y)
        std::cout << x << " equals " << y << '\n';
    if (x != y)
        std::cout << x << " does not equal " << y << '\n';
    if (x > y)
        std::cout << x << " is greater than " << y << '\n';
    if (x < y)
        std::cout << x << " is less than " << y << '\n';
    if (x >= y)
        std::cout << x << " is greater than or equal to " << y << '\n';
    if (x <= y)
        std::cout << x << " is less than or equal to " << y << '\n';

    return 0;
}
```

```C++
Enter an integer: 4
Enter another integer: 5
4 does not equal 5
4 is less than 5
4 is less than or equal to 5
```

在比较整数时，这些运算符非常容易使用。

### 比较浮点值可能会有问题
考虑以下程序：


```C++
#include <iostream>

int main()
{
    double d1{ 100.0 - 99.99 }; // 数学上应该等于 0.01 
    double d2{ 10.0 - 9.99 }; // 数据上应该等于 0.01

    if (d1 == d2)
        std::cout << "d1 == d2" << '\n';
    else if (d1 > d2)
        std::cout << "d1 > d2" << '\n';
    else if (d1 < d2)
        std::cout << "d1 < d2" << '\n';
    
    return 0;
}
```
量d1和d2的值都应为0.01。但此程序打印了意外的结果：

如果在调试器中检查d1和d2的值，您可能会看到d1=0.010000000000005116和d2=0.0099999999997868。这两个数字都接近0.01，但d1大于，d2小于。

使用任何关系运算符比较浮点值都可能是危险的。这是因为浮点值不精确，浮点操作数中的舍入错误可能会导致它们比预期的稍小或稍大。

当小于（<）、大于（>）、小于等于（<=）和大于等于（>=）运算符与浮点值一起使用时，它们在大多数情况下都会产生可靠的答案（当操作数的值不相似时）。然而，如果操作数几乎相同，则应认为这些运算符不可靠。例如，在上面的示例中，d1>d2碰巧产生true，但如果数值舍入方向相反，则也可能结果是false。

如果操作数相似时得到错误答案的结果是可以接受的，那么使用这些操作符也是可以的。这是一个特定于应用程序的判定。

例如，考虑一个游戏（如太空入侵者），您希望确定两个移动对象（如导弹和外星人）是否相交。如果对象仍然相距很远，则这些运算符将返回正确的答案。如果这两个对象非常接近，您可能会得到错误答案。在这种情况下，错误的答案可能根本不会被注意到（它只是看起来像是差点儿打中或差点儿击中），游戏将继续。

### 浮点等式和不等式
`等式运算符（== 和 !=）要麻烦得多。考虑运算符==，它仅在其操作数完全相等时返回true。因为即使最小的舍入误差也会导致两个浮点数不相等，所以当预期结果为true时，运算符==返回false的风险很高。运算符 != 也有同样的问题。`

因此，通常应避免将这两个运算符与浮点操作数一起使用。

上面有一个值得注意的例外情况：可以将低精度（只有几个有效数字）浮点数字面值与相同类型的相同字面值进行比较。

例如，如果函数返回这样的值（通常为0.0，有时为1.0），则可以安全地对相同类型的相同字面值进行直接比较：

```C++
if (someFcn() == 0.0) // 如果 someFcn() 返回的是 0.0，那么是ok的 
    // do something
```

或者，如果有一个可以保证是字面值常量初始化的const或constexpr浮点变量，也可以安全地进行直接比较：

```C++
constexpr double gravity { 9.8 }
if (gravity == 9.8) // gravity 使用字面值常量进行初始化，比较也是ok的
    // 我们在地球上
```

为什么这样做有效？考虑双精度字面值0.0。它在内存中有特定且唯一的表示。因此，0.0 == 0.0始终为true。0.0的副本也应该始终等于0.0。因此，我们可以安全地将返回0.0的函数（这是0.0的副本）或用0.0初始化的变量（这是0.0的副本）与字面值0.0进行比较。

### 比较浮点数（高级/可选阅读）
https://www.studycpp.cn/basic/chapter6/relation-op/





















