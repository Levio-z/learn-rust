
## 1\. 向量化倍数和寄存器的关系

-   **向量化倍数（vectorization factor）**：一次 SIMD 指令处理多少个元素
    
-   倍数越大：
    
    -   每条指令处理的数据更多
        
    -   **需要的寄存器数量也更多**（因为要同时保存更多的中间数据、循环变量、地址指针等）
        

**结果**：寄存器数量是有限的 → 超过上限就得用别的办法存放这些数据

---

## 2\. 寄存器溢出（Register Spilling）

-   当寄存器用完时，编译器会把部分寄存器内容**溢出到内存**（其实是 GPU 的 local memory / CPU 的栈内存）
    
-   在 CPU 上：
    
    -   Spilling 到栈（L1/L2/L3 → DRAM）
        
-   在 GPU 上：
    
    -   Spilling 到 local memory（其实是显存的一部分，不是寄存器速度的本地存储）
        

**问题**：

-   从寄存器（几纳秒） → 内存（几十~几百纳秒）
    
-   这会显著增加访存延迟和指令数量，抵消了向量化的收益
    

---

## 3\. 为什么增加向量化倍数会反而变慢？

-   倍数小 → 没用满 SIMD 宽度，计算带宽没拉满
    
-   倍数大 → 寄存器不够，频繁 spilling，访存开销大
    
-   这就是为什么 **最佳向量化倍数需要 profiling 才能找到**，而不是盲目追求最大宽度（比如 AVX-512 不一定总比 AVX256 快）
    

---

## 4\. 形象类比

-   工人（CPU 核心）手里有有限数量的口袋（寄存器）
    
-   向量化倍数小：口袋没塞满 → 浪费空间
    
-   向量化倍数大：口袋塞不下 → 只能放到背包（local memory），取出来慢得多
    

---

如果你愿意，我可以帮你画一个 **“向量化倍数 vs 性能”** 的典型曲线图：

-   左边：倍数太小 → 性能没拉满
    
-   中间：最佳点（寄存器刚好够用） → 性能峰值
    
-   右边：倍数太大 → spilling → 性能下降
    



























