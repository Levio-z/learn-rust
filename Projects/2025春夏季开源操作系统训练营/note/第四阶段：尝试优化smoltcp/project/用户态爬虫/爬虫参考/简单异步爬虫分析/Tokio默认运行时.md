#### 1. Tokio 默认运行时

- 你使用了 `#[tokio::main]` 宏，它默认启动 Tokio 的**多线程运行时（Multi-Threaded Runtime）**，也叫"work-stealing"运行时。
- 这个多线程运行时会在多核 CPU 上自动启动多个线程，并把你的异步任务分发到这些线程上执行。
- 你没有配置 `#[tokio::main]` 的 `flavor`，默认就是多线程（`flavor = "multi_thread"`）。

#### 2. 异步的部分

- 你所有的 IO 操作（TCP 连接、写请求、读响应）都是 `async` 的，属于**异步非阻塞**操作，不会阻塞线程。
- 你通过 `JoinSet` 并发执行多个 `scrape::get(i)` 任务，它们会被调度到运行时线程池的不同线程上，真正实现了并发/并行+异步。

#### 3. 总结

- 你的程序既是**异步**的（`async/await`），又是**多线程**的（Tokio 多线程运行时），具备高并发能力。
- 在多核机器上，Tokio 会自动利用多核，把任务分配到多个线程执行。

---

**补充：**  
只有当你显式写成 `#[tokio::main(flavor = "current_thread")]` 才是单线程异步。你现在的写法就是多线程异步，非常适合网络爬虫、高并发任务等场景。