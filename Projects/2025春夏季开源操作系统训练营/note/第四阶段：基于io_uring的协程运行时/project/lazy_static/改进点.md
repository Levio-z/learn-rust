```rust
compare_exchange_weak(false, true, Ordering::Acquire, Ordering::Relaxed)
```
推荐更严谨写法是：
```rust
compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)
// 或使用 call_once 时：Acquire-Release 对

```
当前 `compare_exchange_weak` 有可能失败并重试（特别在强争用下），但你没有 loop 包装，可能在某些架构下重试失败，导致初始化失败。建议替换为 `compare_exchange` 或显式循环包裹。
在多核 CPU 上，一些硬件指令（特别是 `cmpxchg`/`LL/SC` 类型）为性能考虑，允许在**竞争不激烈或根本没有变化的情况下也返回失败**。
也就是说：
```rust
let atomic = AtomicBool::new(false);
let result = atomic.compare_exchange_weak(false, true, Ordering::SeqCst, Ordering::SeqCst);
```
即便 `atomic == false`，也**有概率失败**。

**即使在没有线程竞争的情况下**，`compare_exchange_weak` 依然**可能出现伪失败（spurious failure）**。
- 这是由**底层硬件指令语义**决定的，与是否存在其他线程竞争**无关**。

即使没有线程竞争也会出现 `compare_exchange_weak` 的“伪失败”？
`compare_exchange_weak` 常用于映射到 LL/SC 原语：
- `LL`（Load-Linked）：加载一个地址的值，并标记该地址。
- `SC`（Store-Conditional）：尝试写入新值，**只有在“期间”没有其他内存操作**干扰这个地址时才成功。

即使只有一个线程运行，只要 CPU 发生了中断、cache 失效、上下文切换、TLB flush 或 prefetch，都可能导致 SC 失败。



[优化](https://github.com/arceos-org/lazyinit/pull/1)