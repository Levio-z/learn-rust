### 架构
![](Pasted%20image%2020250603195556.png)

### 实现目标
并发：贯彻始终的异步与无栈协程
- 系统调用的异步（poll & select）
- 线程管理中的无栈协程
- 文件系统的并发实现
- 设备驱动程序中的中断驱动异步
并行：SMP多核支持
- 异步执行器中的均衡负载
其他模块概览
开发中的问题与解决
比赛总结
### 异步 & 无栈协程
- 有栈协程将任务的调用栈和上下文分开保存，通过汇编代码手动切换函数调用栈来进行任务切换。
- 每个任务的**调用栈都会有一定的内存浪费（空闲），并都会有栈溢出风险。**
	- 递归就会有栈溢出的风险
![](Pasted%20image%2020250603195848.png)
无栈协程则将任务的信息同一保存成状态机，统一存放在堆上，由执行器通过更改指针来切换执行的任务。
调用栈仅每个执行器一个，一定程度上减少了内存浪费、降低栈溢出风险。
![](Pasted%20image%2020250603200256.png)
无栈协程你必须有一个堆。
传统的中断处理程序通常会以函数调用的形式，流程如下：
1. 保存用户上下文；
2. 通过标准的函数调用形式跳转到中断处理程序；
3. 恢复用户上下文并退出。
![](Pasted%20image%2020250603200515.png)
这里使用一种新的方式，思想与去年的一等奖作品FTL OS不谋而合，其伪代码分成两个部分，进入用户和进入内核，分别对应右上图和右下图。
![](Pasted%20image%2020250603200635.png)
![](Pasted%20image%2020250603200638.png)
两段过程是完全对偶的，本质上是一种有栈协程的上下文切换方式。这样，在内核态异步上下文中，就可以通过函数调用的方式切换特权级。
- 将线程生命周期抽象成异步循环，提高代码的直观性，方便调试。
- 分离了线程的信息和状态：
	- 为每个共享的可能可变的信息创建单独的细粒度锁；
	- 将私有的状态转移到异步循环中的局部变量。
- 既充分利用了Rust的所有权系统，又由于细粒度锁提高了线程信息访问的并发性
![](Pasted%20image%2020250603200749.png)

### 为了异步与并发：线程管理
-  将线程生命周期抽象成异步循环，提高代码的直观性，方便调试。
- 分离了线程的信息和状态：
	-  为每个共享的可能可变的信息创建单独的细粒度锁；
	- 将私有的状态转移到异步循环中的局部变量。
- 既充分利用了Rust的所有权系统，又由于细粒度锁提高了线程信息访问的并发性。
### ![](Pasted%20image%2020250603201002.png)   网络协议栈
我们基于`smoltcp`，参照`embassy-net`开发出了具有多设备统一的网络协议栈，在单独的背景任务里进行协议栈的异步轮询。
TCP插座的实现中，我们将ACCEPT队列的创建连接操作分离到背景任务中，分离了系统调用和实际的I/O操作，增加了该操作的吞吐量，提高了创建TCP连接的并发性。
![](Pasted%20image%2020250603202017.png)
### 文件系统
参考`rust-fatfs`实现的异步并发的FAT32文件系统。
通过将原本代码中的`RefCell`等结构换成了同步源语和引用计数指针，并且将文件锁和文件系统锁分离，实现了同时读写不同文件的功能，增强的了文件系统的并发性。
引入了批量操作文件分配表（FAT）的功能，一次可以读取、更新至多1024条（1024*4=4096刚好是一个页面）的条目，极大地加快了簇的分配以及依赖该功能的文件创建和写入功能。
### 为了并发：页帧管理
页帧（页缓存）管理参考Fuchsia实现了RAII的二叉树形结构内存管理模型。每一个结构体包含页帧哈希表、父节点（包含可能的I/O后端，比如文件或块设备）、刷新器（背景任务）、以及状态信息。
每个节点逻辑上是其父节点的一个切片，有标志指示是否拥有写时复制（CoW）特性。页帧通过引用计数和缓存状态的更新在树形结构中复制和流动。
每个节点可以实现同时读写页帧，在不浪费页帧的情况下提升页缓存的并发性
![](Pasted%20image%2020250603202146.png)页帧结构的关系图。其中上图为逻辑关系图；下图为实际存储关系图，箭头代表引用。同个颜色（内容）的页帧只存在一份副本。
### 为了并发：网络设备抽象
网络设备分成三部分抽象，独立成trait：设备信息、发送队列、接收队列。
通过令牌管理每个发送/接收包的缓冲区所有权。
借助Rust的所有权系统，可以最细粒度地分割网络设备和缓冲区的所有权和I/O操作的粒度，达到高并发的效果。
![](Pasted%20image%2020250603202336.png)
### 为了并发：SD卡设备

华山派cv1811h的SD卡设备是标准的MMIO SD Host Controller再加一点自定义的PINMUX控制寄存器。

我们通过阅读华山派官方镜像中的uboot和Linux代码了解了具体的实现细节，SD卡的官方文档了解了各个标准MMIO寄存器和SD卡命令的定义，最后编写了以ADMA2方式实现的中断驱动的SD卡块设备驱动。

ADMA2实现中，CPU通过内存中的描述符给设备提交I/O操作，设备则在I/O操作完成时通过中断通知CPU。
通过ADMA2的方式，使得提交I/O操作和完成I/O操作分离，细粒度化操作，可以增强其并发性。

### 为了多核：执行器
实现了软抢占和任务窃取两个功能。
每个调度核心的任务获取按照如下优先级顺序：
- 抢占槽
- 自身调度队列
- 其他调度队列（窃取）
两个功能分别考虑了I/O事件的时效性，和核心之间的均衡负载。
![](Pasted%20image%2020250603202517.png)
### 其他功能简介：地址空间管理
按需分配的原则
- 指定地址与大小：按地址分配
- 仅指定大小：随机化查找分配——地址空间随机化（ASLR）
建立映射：创建+提交
- 创建：仅对管理数据结构进行操作
- 提交：页错误再提交
- 优化空间：连续页预读取
用户指针：提交映射后读写
### 其他功能简介：时间管理
全局定时器队列
- Rust标准库的B树映射表
批处理注册机制
- 无锁队列存放注册请求
- 队列满则一次性加锁完成
- 减少锁定，增加并发度
### 其他功能 & 模块概览
`umio`抽象出一个读写相关的抽象trait `Io`，表示一切可读写的数据结构，以及从标准库扒来的`SeekFrom`、`IoSlice`等基础类型；
`umifs`实现了umi的虚拟文件系统，包括`FileSystem`、`Entry`、`Directory`、`DirectoryMut`等trait，实现了方便的路径解析，并兼容了Linux的文件类型 ；
VFS虚拟文件系统在各类文件系统之上构建了一个抽象层，从而使操作系统可以挂载各类文件系统；
`kalloc` : 内核和Rust语言自用的内核堆分配器；
`rv39-paging` : RISC-V 的 Sv39 页表机制；
`config` : 设备平台（开发板）相关的参数常量；
`hart-id` : 存储 hart-id；
`rand-riscv` : 随机数生成函数；
`sygnal` : 信号处理机制；
`ksync` : 提供了各种在异步上下文中同步源语。
### 开发问题与解决：丢包率
问题：在使用`smoltcp`时，`iperf`测试的UDP的丢包率一直居高不下（20%左右）。经过排查发现是`smoltcp`中的UDP收包逻辑较为简单，没有远程端口的参与，而`iperf`使用多个插座连接同一个服务器端口，于是经常出现收发不均衡的现象，造成某些插座缓冲区满而丢包。
解决：在`smoltcp`中加入了伪远程端口字段，使得在UDP收包时优先匹配远程端口。经过测试将丢包率降到了个位数。还在`smoltcp`中增加了检测收发缓冲区空闲大小的函数，以支持其poll事件功能。
### 开发问题与解决：用户缓冲区
问题：实际操作用户缓冲区的时机可能并不与提交映射的时机相同，有可能在使用时该缓冲区已经被另一个线程取消映射了。造成的页错误发生在内核空间，没有挽回的余地（二阶中断处理不能发生在异步上下文，因此异步的映射函数无法调用，错误的I/O操作无法中止）。

解决：在使用用户缓冲区的时候保持持有地址空间的读锁，使得其他线程无法改变地址空间，虽然在一定程度上拖慢了效率，但是增加了缓冲区安全性。
### 评价
- 创新特性
- 异步、多核怎么样和语言特性结合，怎么模块化
- 构建一个与众不多的东西，创新
- 进入研究小组，做了比较小的讲座，训练营之类的东西