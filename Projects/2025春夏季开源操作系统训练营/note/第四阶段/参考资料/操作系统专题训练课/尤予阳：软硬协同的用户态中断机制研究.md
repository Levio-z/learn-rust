### 课题背景
- 处理器通过划分特权级限制软件行 为，提供安全保护和隔离
- 中断提示处理器某个特殊事件的产 生，通常由较高特权的软件处理，如 操作系统内核 
- 内核可以通过软件方式为用户程序 模拟中断，但效率较低
- 硬件驱动需要使用中断来提高响应速度，降低处理器占用
- 跨特权级切换有额外开销，**用户态运行的驱动基本只能使用轮询**
- 更高效的驱动需要绕过内核直达用户的通知机制——用户态中断
### RISC-V 用户态中断扩展
- 也被称作“N 扩展”，v1.12 规范草案阶段提出，正式版本中被移除
- 中断控制寄存器和指令规范
- 未定义软件的跨核中断和外设的中断行为
- 已知有 shakti-c , StarFive 天枢,晶心科技 AX25MP 等处
![](Pasted%20image%2020250603205254.png)
- 在英特尔“即将”发布的Sapphire Rapids 处理器中支持
- 已在 Linux 内核中实现了软件接口
- 目前只能用于线程/进程间通信，性能相比软件方式大幅提升
- 尚未实现外设到软件的中断
![](Pasted%20image%2020250603205350.png)
### 系统设计
![](Pasted%20image%2020250603205432.png)• ustatus: 用户态中断全局使能

• utvec: 陷入处理函数入口

• uip & uie: 待处理中断和各类中断使能

• uepc: 陷入时的程序指针地址

ucause: 陷入原因

• utval: 陷入辅助值

• sideleg & sedeleg: 陷入委托

• uscratch: 自由使用

• uret 指令: 从用户态陷入上下文中返回
### 用户态陷入和处理
![](Pasted%20image%2020250603205601.png)
• 硬件处理陷入相关寄存器，跳转到 utvec
• 软件保存通用寄存器等上下文，处理陷入
• 软件处理完成，恢复上下文，调用 uret返回
• 硬件恢陷入相关寄存器，跳转回 uepc 继续执行

![](Pasted%20image%2020250603210104.png)
• RISC-V 系统中常见的外部中断控制器，在多个中断源和中断目标之间建立通路
• 硬件中断上下文是（硬件线程，特权级）的组合
• 加入用户态对应的中断上下文即可

![](Pasted%20image%2020250603210256.png)

需要内核将部分 PLIC 和外设对应的地址段映射到用户地址空间

• 读取 PLIC 的领取/完成寄存器，拿到对应的中断源编号

• 执行针对具体外设的处理逻辑

• 写入 PLIC 领取/完成寄存器，通知PLIC 中断处理完成
### 用户态中断控制器 (UINTC)
- 多个用户态实体之间发送（跨核）中断，这些实体不一定 运行在在特定的硬件线程上 
	- **用户态实体**：并非固定绑定硬件线程的实体，可能是调度实体（线程/协程）、VMM 客体、用户级网络栈处理器等；
	- **“不一定运行在特定硬件线程上”**：这些实体可能在多个核之间迁移、负载均衡调度、不稳定绑定。
- 现有的 (A)CLINT 架构无法满足需求，提出一种新的中断 控制器设计——UINTC 
- 设发送方数量为 S，接收方数量为 R，硬件上下文数量为 C 
- 每个发送方和接收方具有一个用户态中断 ID（UIID）
### UINTC 的寄存器
• enable(S, R): 第 s 个发送方是否可以给第 r 个接收方发送中 断 • pending(S, R): 是否有第 s 个发送方发给第 r 个接收方的待 处理的中断 
• listen(C): 第 c 个上下文监听的接收方编号（不是 UIID）
• sender_uiid(S): 第 s 个发送方对应的 UIID
• send/status(S): 写入接收方的 UIID 来发送中断，读出上一 次发送的结果
• receiver_uiid(R): 第 r 个接收方对应的 UIID
• claim(R): 领取一个待处理中断，读出对应发送方的 UIID
### UINTC 硬件处理流程
- 收到发送方软件 s 写入的接收方 UIID，查找是否存在接收 方 r 使得 receiver_uuid(r)=\=UIID 
• 若存在，且 enable(s,r)=\=1，则将 pending(s,r) 置为 1 
• 若存在硬件上下文 c 满足 listen(c)=\=r，则将对应上下文的 xip.XSIP 位置 1，触发软件中断 
• 接收方软件 r 读取 claim(r) 时，若存在 s 使得 pending(s,r)=\=1，则返回 sender_uuid(s)，否则返回 0
### 用户态中断上下文
• 记录每个进程的用户态中断 CSR、 中断缓冲区和中断记录数目 
• 中断缓冲区为一个内存页 
- 记录在内存中
• 一条中断记录包括原因和附加消 息 
	• 时钟中断和外部中断原因分别为 4 和 8，与 xcause 寄存器编码保持一 致 
	• 外部中断附加消息为中断外设号
	• 信号的中断原因为源进程 PID « 4
![](Pasted%20image%2020250603213521.png)
### 进程切换
• 进程切换时，保存当前 进程的中断 CSR，恢复 下一进程的中断 CSR， 以及外设中断使能配置 
• 从内核返回用户态时， 将缓存的中断数量写入 uscratch 寄存器  
• URET 返回正常执行流， 无需系统调用
![](Pasted%20image%2020250603214524.png)
### 外部中断
• 内核记录每个外设对应的 进程编号
• 如果外设对应的驱动进程 正在 CPU 上运行，PLIC 直 接产生 UEI，无需经过内核
• 否则产生 SEI，由内核转发
### 时钟中断
• 内核根据定时器到期 时间维护一个有序列 表 
• 产生中断时传递给到 期时间最早的申请者![](Pasted%20image%2020250603215148.png)
### 软件间中断
在没有 UINTC 的情况 下，需由内核转发，在 目标任务的中断缓冲区 中写入一条记录 

有 UINTC 的情况下，发 送过程不经过内核，中 断记录保存在 UINTC 中，内核只需在切换时 维护 listen 寄存器
### 系统调用
• init_user_trap(): 初始化用户程序中断上下文 
• send_msg(pid, msg): 向另一个进程发送软件中断 
• set_timer(time_us): 设置用户态时钟中断 
• claim_ext_int(device_id): 获取对外设地址空间访问权限 
• set_ext_int_enable(device, enable): 控制外设中断使能

• uipi_sender_ctl(flags, sender, buf): 控制用户态软件中断发 送方信息 
• uipi_receiver_ctl(flags, receiver, buf): 控制用户态软件中断 接收方信息 
• uipi_connection_ctl(sender, receiver, connected): 建立或取消 两个任务间的中断连接
### 用户中断处理
• 将中断处理函数 地址写入 utvec 寄存器 
• 系统提供缺省的 处理函数和跳板 代码 
• 用户程序可以覆 盖某一个或全部 的中断处理函数
### 后续工作
• 完成 UINTC 的 FPGA 实现（目前已有 QEMU 实现和 rCore 内核支持）
• 基于用户态软件驱动的任务间通信框架 
• 基于用户态外部中断的异步外设驱动 
• 更丰富可靠的性能评估