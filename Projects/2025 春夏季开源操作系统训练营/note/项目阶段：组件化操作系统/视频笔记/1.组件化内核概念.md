# 目标
- 研究和实践基于组件构造内核的方法，尝试构造应对不同场景的各种模式内核
- [多仓方式管理组件]( #1.多仓方式管理组件)，[组件间单向依赖](#2.组件间单向依赖)
## 内核组件化设计与传统设计思路的差异

## 面向场景和应用需求构建内核
- 针对特定场景和需求，选择和组合组件来构建目标内核，组件集合是满足需求的最小集合。
    组件化内核项目相当于“工厂”，组件相当于“零件”，生产过程主要是组装。
- 以统一视角看待各种模式、不同规模的内核
	- 规模较大、功能复杂的内核可以在规模较小、功能简单的内核基础上增量构造，增量的粒度是组件。而宏内核、Hypervisor等复杂模式与Unikernel模式没有绝对的界限，可以看作是特殊的Unikernel模式，可以通过扩展和增加专门模式的组件完成过渡。
## 组件化内核的意义
组件化内核相对传统构建方式的优势：
- 提高内核开发效率
	- 明确责任链：底层组件无需了解高层组件的实现细节，组件之间页一样的，降低了开发复杂性。
	- 可测试性：组件是良好封装的功能单元，直接通过接口调用。经过了良好测试和实际验证，相对成熟稳定，提升了质量。
	- 构建速度和质量两方面都能获得提升

- 降低内核维护难度
	- 内部功能之间的耦合度低
		- 缺陷的隔离
		- 快速的定位问题
- 开展基于组件的功能复用和开发协作
	- 内部/之间各自独立开发测试组件
	- 功能复用

## 组件化内核的概念
### 内核系统
运行在内核态的软件，向下管理硬件，向上为应用提供运行环境。可以独立运行。
在Rust中，相当于[bin].crate

### 内核组件
用于构建内核系统的最基本元素，最小可部署单元。
组件可以独立构建和分发，不能独立运行。
在Rust中，相当于[lib].crate
## 主流内核模式特点对比
### Unikernel OS

应用与内核：
(1) 处于同一特权级 - 内核态。
(2) 共享同一地址空间 - 相互可见。
(3) 编译形成一个Image，一体运行
(4) Unikernel既是应用又是内核
     是二者合体。
### Monolithic OS、Microkernel OS、Multikernel OS
应用与内核：
(1) 分别在独立的相互隔离特权级运行
(2) 分别在用户地址空间和内核地址空间 - 相互独立
(3) 分别是不同的Image，构造和运行相互独立
(4) 内核和应用之间的界限分明，以系统调用等ABI为界
## 组件化实验方式
在组件化内核领域：
所有内核实例都可以基于组合组件的方式，从简单到复杂逐级迭代的进行构建。
所有内核模式都可以看作以Unikernel模式为基础，朝向特定方向的组件化扩展









# 附录
## 概念
### 1.多仓方式管理组件
#### **定义**
- **多仓（Multi-Repo）**：将不同功能模块或组件拆分到独立的代码仓库（Repository）中管理。
- **每个组件一个仓库**：例如内核、内存管理、文件系统、驱动等各自独立仓库。
#### **优势**

- **解耦**：组件边界清晰，修改一个组件不会直接影响其他组件。
    
- **独立演进**：每个仓库可以独立开发、测试、发布版本。

#### **挑战**

- **依赖管理**：需要明确组件间的依赖关系（通过下文“单向依赖”解决）。
### 2.**组件间单向依赖**
#### **定义**

- **单向依赖（Unidirectional Dependency）**：依赖关系必须是单向的，形成有向无环图（DAG），禁止循环依赖。
    
- **层级化设计**：高层组件依赖底层组件，反之则不允许。
#### **优势**
- **避免循环依赖**：防止组件间相互纠缠，降低复杂度。
    
- **明确责任链**：底层组件无需了解高层组件的实现细节。
    
- **可测试性**：底层组件可独立测试（不依赖高层组件）。