# Rcore 第四章 地址空间

> 写作就是思考，因为对于Rcore第四章整个知识脉络有点过于庞大，使用写作的方式重新梳理

物理内存是操作系统需要管理的一个重要资源，无论是代码还是数据，程序的运行离不开内存。为了更好管理内存，提高内存的动态使用效率，通过隔离保证安全性，把有限内存变成无限内存，操作系统需要实现以下功能

- 通过**动态内存分配**，提高了应用程序对内存的动态使用效率

  - how：

    - 页表机制
    - 算法
    - 缓存：TLB

  - [why：]: 

    

    - 应用自己管理内存，应用执行完了还驻留在内存里，这部分空间无法利用
    - 应用自己分配不一定合理，比如应用80%代码可能不会执行，执行的就20%，这部分代码可以不用放在内存里
    - 内部内存碎片，外部内存碎片

- 通过页表的虚实内存映射机制

  - 简化：简化了编译器对应用的地址空间设置
    - how：使用抽象、透明易用的接口，应用开发者不需要考虑实际物理内存布局，地址可以统一使用内存布局
  - 安全：加强了应用之间，应用与内核之间的**内存隔离**，增强了系统安全
    - how：硬件和读写执行标志位和硬件机制，界限寄存器实现内存隔离，程序只能访问属于自己的内存
  - 通过页表的虚实内存映射机制，可以实现空分复用（提出，但没有实现）



问题：直接将程序放到物理内存，应用直接访问物理内存会产生什么问题？

- 不够透明，易用。（应用开发者视角）
  - 需要清楚计算机的物理内存布局以及自己被加载到哪个地址运行。
  - 为了避免冲突可能还需要应用的开发者们对此进行协商
- 没有任务保护和隔离
  - 可以读写其他应用的数据来窃取信息或者破坏其它应用的正常运行
  - 应用甚至可以直接来替换掉原本的 `trap_handler` 函数
- 内存使用空间在其运行前已经限定死了
  - 内核不能灵活地给应用程序提供的运行时动态可用内存空间。