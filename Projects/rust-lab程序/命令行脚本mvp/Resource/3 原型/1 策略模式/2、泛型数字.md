```rust
use std::error::Error;
use std::fmt;

// 1. 定义统一行为 trait
pub trait Handler {
    fn handle();
}

// 2. 定义参数到类型的映射（核心：通过数字生成对应类型名）
// 编译期将数字 N 映射为类型 HandlerN
pub struct HandlerSelector<const N: u8>;

impl<const N: u8> HandlerSelector<N> {
    // 调用对应数字的实现（若未实现则编译报错）
    pub fn handle() -> Result<(), AppError> {
        // 尝试调用 HandlerN 的 handle 方法
        HandlerN::<N>::handle();
        Ok(())
    }
}

// 3. 定义泛型类型 HandlerN，约束其必须实现 Handler
// 当 N=1 时，HandlerN<1> 即 Handler1，以此类推
pub struct HandlerN<const N: u8>;

impl<const N: u8> Handler for HandlerN<N> {
    // 若未为特定 N 实现，则调用此默认方法会编译报错
    fn handle() {
        // 编译期检查：若 N 无对应实现，此处会触发错误
        panic!("未实现数字 {} 的处理逻辑", N);
    }
}

// 4. 错误类型
#[derive(Debug)]
pub enum AppError {
    InvalidNumber(u8),
    HandlerNotFound(u8),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::InvalidNumber(n) => write!(f, "无效数字：{}（必须 1-100）", n),
            AppError::HandlerNotFound(n) => write!(f, "数字 {} 无对应实现", n),
        }
    }
}

impl Error for AppError {}
```

#### `src/main.rs`（命令行逻辑 + 具体实现）

rust

```rust
use clap::Parser;
use mycli::{Handler, HandlerSelector, AppError};

// 命令行参数
#[derive(Parser, Debug)]
struct Cli {
    #[arg(help = "输入 1-100 之间的数字")]
    num: u8,
}

// --------------------------
// 具体实现（遵循命名约定：为 N 实现 HandlerN）
// --------------------------

// 实现数字 1 的逻辑：定义 Handler1 并实现 Handler
pub struct Handler1;
impl Handler for Handler1 {
    fn handle() {
        println!("处理数字 1：初始化");
    }
}
// 关联到泛型 HandlerN<1>
impl mycli::Handler for mycli::HandlerN<1> {
    fn handle() {
        Handler1::handle();
    }
}

// 实现数字 2 的逻辑：定义 Handler2 并实现 Handler
pub struct Handler2;
impl Handler for Handler2 {
    fn handle() {
        println!("处理数字 2：备份");
    }
}
// 关联到泛型 HandlerN<2>
impl mycli::Handler for mycli::HandlerN<2> {
    fn handle() {
        Handler2::handle();
    }
}

// 实现数字 100 的逻辑：定义 Handler100 并实现 Handler
pub struct Handler100;
impl Handler for Handler100 {
    fn handle() {
        println!("处理数字 100：清理");
    }
}
// 关联到泛型 HandlerN<100>
impl mycli::Handler for mycli::HandlerN<100> {
    fn handle() {
        Handler100::handle();
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();
    let num = cli.num;

    // 校验数字范围
    if !(1..=100).contains(&num) {
        return Err(Box::new(AppError::InvalidNumber(num)));
    }

    // 根据数字调用对应实现（完全无注册逻辑，依赖类型映射）
    match num {
        1 => HandlerSelector::<1>::handle()?,
        2 => HandlerSelector::<2>::handle()?,
        100 => HandlerSelector::<100>::handle()?,
        // 补充 3-99 的匹配（此处是唯一需要手动添加的地方，但仅需一行）
        n => return Err(Box::new(AppError::HandlerNotFound(n))),
    }

    Ok(())
}
```
### 核心原理

1. **类型命名约定**：通过 `HandlerN` 泛型类型与具体类型 `Handler1`、`Handler2` 等的关联，强制编译器将数字 N 与类型 `HandlerN` 绑定。
2. **编译期映射**：`HandlerSelector::<N>::handle()` 会在编译期查找 `HandlerN` 的实现，若未实现则直接报错，无需运行时注册。
3. **零注册逻辑**：新增数字 N 的实现时，只需定义 `HandlerN` 结构体并实现 `Handler` trait，再为 `HandlerN<N>` 实现 `mycli::Handler` 即可，无需任何注册代码。

```rust
// 数字 3 的实现
pub struct Handler3;
impl Handler for Handler3 {
    fn handle() {
        println!("处理数字 3：日志记录");
    }
}
impl mycli::Handler for mycli::HandlerN<3> {
    fn handle() {
        Handler3::handle();
    }
}
```

然后在 `main` 函数的 `match` 中添加一行 `3 => HandlerSelector::<3>::handle()?,` 即可。

### 优势与局限

- **优势**：完全消除了注册逻辑，依赖类型系统和命名约定实现自动关联，编译期即可发现未实现的数字，类型安全极高。
- **局限**：`main` 函数中的 `match` 需要手动添加每个数字的分支（但仅需一行代码），适合 1-100 这种范围固定的场景。