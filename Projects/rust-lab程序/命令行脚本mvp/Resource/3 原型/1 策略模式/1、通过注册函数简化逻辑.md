```rust
use clap::Parser;
use std::collections::HashMap;
use std::error::Error;
use std::fmt;

// 1. 定义统一行为 trait
trait Handler: Send + Sync {
    fn handle(&self);
    fn number(&self) -> u8;
}

// 2. 全局管理器：存储数字到 Handler 的映射
struct HandlerRegistry {
    handlers: HashMap<u8, Box<dyn Handler>>,
}

impl HandlerRegistry {
    // 创建空管理器
    fn new() -> Self {
        Self {
            handlers: HashMap::new(),
        }
    }

    // 注册一个 Handler
    fn register(&mut self, handler: Box<dyn Handler>) {
        let num = handler.number();
        self.handlers.insert(num, handler);
    }

    // 根据数字获取 Handler
    fn get(&self, num: u8) -> Option<&Box<dyn Handler>> {
        self.handlers.get(&num)
    }
}

// 3. 实现自动注册机制（关键：通过静态变量和构造函数自动收集）
lazy_static! {
    static ref REGISTRY: HandlerRegistry = {
        let mut registry = HandlerRegistry::new();
        // 所有 Handler 在这里自动注册（新增实现时只需加一行）
        registry.register(Box::new(Handler1));
        registry.register(Box::new(Handler2));
        registry.register(Box::new(Handler100));
        // 未来加 Handler3 只需：registry.register(Box::new(Handler3));
        registry
    };
}

// 4. 具体实现（每个数字对应一个 struct）
struct Handler1;
impl Handler for Handler1 {
    fn handle(&self) {
        println!("处理数字 1：初始化");
    }
    fn number(&self) -> u8 { 1 }
}

struct Handler2;
impl Handler for Handler2 {
    fn handle(&self) {
        println!("处理数字 2：备份");
    }
    fn number(&self) -> u8 { 2 }
}

struct Handler100;
impl Handler for Handler100 {
    fn handle(&self) {
        println!("处理数字 100：清理");
    }
    fn number(&self) -> u8 { 100 }
}

// 错误类型
#[derive(Debug)]
enum AppError {
    InvalidNumber(u8),
    HandlerNotFound(u8),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::InvalidNumber(n) => write!(f, "无效数字：{}（必须 1-100）", n),
            AppError::HandlerNotFound(n) => write!(f, "数字 {} 无对应实现", n),
        }
    }
}

impl Error for AppError {}

// 命令行参数
#[derive(Parser, Debug)]
struct Cli {
    #[arg(help = "输入 1-100 之间的数字")]
    num: u8,
}

fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();
    let num = cli.num;

    // 校验数字范围
    if !(1..=100).contains(&num) {
        return Err(Box::new(AppError::InvalidNumber(num)));
    }

    // 从全局注册表中获取并执行（无 match 语句）
    match REGISTRY.get(num) {
        Some(handler) => {
            handler.handle();
            Ok(())
        }
        None => Err(Box::new(AppError::HandlerNotFound(num))),
    }
}
```



```rust
use clap::Parser;
use std::collections::HashMap;
use std::error::Error;
use std::fmt;

// 1. 定义统一行为 trait
trait Handler: Send + Sync {
    fn handle(&self);
    fn number(&self) -> &str;
}

// 2. 全局管理器：存储字符串到 Handler 的映射
struct HandlerRegistry {
    handlers: HashMap<String, Box<dyn Handler>>,
}

impl HandlerRegistry {
    // 创建空管理器
    fn new() -> Self {
        Self {
            handlers: HashMap::new(),
        }
    }

    // 注册一个 Handler
    fn register(&mut self, handler: Box<dyn Handler>) {
        let num = handler.number().to_string();
        self.handlers.insert(num, handler);
    }

    // 根据字符串获取 Handler
    fn get(&self, num: &str) -> Option<&Box<dyn Handler>> {
        self.handlers.get(num)
    }
}

// 3. 实现自动注册机制（关键：通过静态变量和构造函数自动收集）
lazy_static! {
    static ref REGISTRY: HandlerRegistry = {
        let mut registry = HandlerRegistry::new();
        // 所有 Handler 在这里自动注册（新增实现时只需加一行）
        registry.register(Box::new(Handler1));
        registry.register(Box::new(Handler2));
        registry.register(Box::new(Handler100));
        // 未来加 Handler3 只需：registry.register(Box::new(Handler3));
        registry
    };
}

// 4. 具体实现（每个字符串对应一个 struct）
struct Handler1;
impl Handler for Handler1 {
    fn handle(&self) {
        println!("处理字符串 '1'：初始化");
    }
    fn number(&self) -> &str {
        "1"
    }
}

struct Handler2;
impl Handler for Handler2 {
    fn handle(&self) {
        println!("处理字符串 '2'：备份");
    }
    fn number(&self) -> &str {
        "2"
    }
}

struct Handler100;
impl Handler for Handler100 {
    fn handle(&self) {
        println!("处理字符串 '100'：清理");
    }
    fn number(&self) -> &str {
        "100"
    }
}

// 错误类型
#[derive(Debug)]
enum AppError {
    InvalidString(String),
    HandlerNotFound(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::InvalidString(ref s) => write!(f, "无效字符串：{}", s),
            AppError::HandlerNotFound(ref s) => write!(f, "字符串 {} 无对应实现", s),
        }
    }
}

impl Error for AppError {}

// 命令行参数
#[derive(Parser, Debug)]
struct Cli {
    #[arg(help = "输入字符串（如 '1', '2', '100' 等）")]
    num: String,
}

fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();
    let num = &cli.num;

    // 从全局注册表中获取并执行（无 match 语句）
    match REGISTRY.get(num) {
        Some(handler) => {
            handler.handle();
            Ok(())
        }
        None => Err(Box::new(AppError::HandlerNotFound(num.to_string()))),
    }
}
```
