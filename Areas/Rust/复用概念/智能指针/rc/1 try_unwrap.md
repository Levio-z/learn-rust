```
if let Ok(mut node) = Rc::try_unwrap(node)
```
- 尝试从 `Rc<T>` 中**获取其所有权**
    
- 只有在**引用计数为 1** 的时候才成功
    
- 否则返回 `Err(Rc<T>)`
### **意图：**

- 如果这个 `Rc` 只有当前一个引用，那么说明我们可以**安全地移动出值 `Node<T>`**，不需要等 Rc 的析构；
    
- 可以继续遍历 `node.next.take()`，递归地清理下去。

这里有一个没见过的方法 `Rc::Try_unwrap` ，该方法会判断当前的 `Rc` 是否只有一个强引用，若是，则返回 `Rc` 持有的值，否则返回一个错误。

可以看出，我们会一直 drop 到第一个被其它链表所引用的节点：
```
list1 -> A ---+
              |
              v
list2 ------> B -> C -> D
              ^
              |
list3 -> X ---+

```

例如如果要 drop `List2`，那会从头节点开始一直 drop 到 `B` 节点时停止，剩余的 `B -> C -> D` 三个节点由于引用计数不为 1 (同时被多个链表引用) ，因此不会被 drop。

