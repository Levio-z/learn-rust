```rust
pub fn peek_front(&self) -> Option<Ref<T>> {
    self.head
        .as_ref()
        .map(|node| Ref::map(node.borrow(), |node| &node.elem))
}
```

- `node.borrow()` → 得到 `Ref<Node<T>>`，这里是对链表节点的只读借用守卫。
- `|node| &node.elem` → 从节点里取出元素的引用（`&T`）。
- `Ref::map → 把原本的 Ref<Node<T>> 投影成 Ref<T>，借用令牌 不丢失，只是视角从整个 Node<T>换成了 node.elem。`

### 假设我们直接返回裸的 `&T`，会有生命周期无法延续问题
```rust
pub fn peek_front(&self) -> Option<&T> {
    self.head.as_ref().map(|node| {
        let r = node.borrow();    // 借用计数 +1
        &r.elem                   // 试图返回裸引用
    })
} // ← 这里 r 被 drop，借用计数 -1
```
- `r` 在函数结束时被 drop，借用计数归零。
- 但是我们返回的 `&T` 还在外面活着！
- 外部代码以为可以安全用它，但实际上内部 `RefCell` 已经不认为有借用存在，可能马上被可变借用（`borrow_mut()`）篡改。
- 这就会产生 **悬垂引用 / 数据竞争**。
### 为什么 `Ref::map` 没有这个问题
```rust
Ref::map(node.borrow(), |node| &node.elem)
```
- `node.borrow()` 返回的 `Ref<Node<T>>` 里有令牌。
- `Ref::map` 消耗它，转交令牌，生成新的 `Ref<T>`。
- 返回的 `Ref<T>` 仍然持有令牌，所以只要你在外面还在用这个 `Ref<T>`，内部计数器就不会归零。
- 生命周期 `'b` 绑定的也是最初的借用范围，而不是函数作用域。
- 换句话说：**`Ref<T>` 把内部借用的生命周期安全地延长到外部**，而裸 `&T` 做不到。
