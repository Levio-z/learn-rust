**CAS 的“排他性”是由硬件 CPU 提供的原子性保障——**通常通过总线锁（bus lock）或缓存一致性协议（MESI 协议）确保**一条 CAS 指令在任意时刻只由一个 CPU 核心成功执行，其余全部失败。**
### 1. 什么是“排他性”？

排他性（mutual exclusion）在 CAS 中表现为：
- 多个线程并发尝试更新一个共享变量
- 只有**一个线程能成功更新**，其他线程的 CAS 操作会失败（`Err(expected)`）
- 整个比较-交换过程是 **不可中断的原子操作**

### CAS 背后的硬件原理
#### 核心机制一：**总线锁（x86 的 `LOCK` 前缀）**

在早期的 CPU 上，像 x86 架构中，CAS 是由如下指令完成：
```rust
LOCK CMPXCHG [mem], reg
```
- `LOCK` 前缀告诉 CPU **锁住内存总线**
- 确保此指令执行期间，**没有其他 CPU 能访问这段内存**
- 保证了比较和更新在硬件层面“独占执行”
> 这是真正的“原子” —— 在物理上阻止并发冲突。
#### 核心机制二：**缓存一致性协议（MESI 协议）**
现代 CPU 为了性能，通常不锁总线，而使用 **缓存一致性协议** 实现“排他”：
✨ MESI 协议（Modified, Exclusive, Shared, Invalid）
基本思路：
- 每个 CPU 核心有本地缓存（L1/L2）
- 当某个核心尝试 CAS 修改某个内存地址，必须获得该缓存行的 **独占（Exclusive）或修改（Modified）状态**
- 为此，会通过 **缓存一致性总线** 通知其他 CPU **“你们的这个地址缓存失效（Invalid）”**
- 成功获得独占权限后，CAS 才能继续
这样，即便多个核心同时尝试 CAS：
- 只有一个核心能成功将缓存行状态转换为 `Modified` 或 `Exclusive`
- 其余核心 CAS 会失败（数据不一致或状态不允许）
从逻辑上就表现为“只有一个成功”，实现了**排他性**

