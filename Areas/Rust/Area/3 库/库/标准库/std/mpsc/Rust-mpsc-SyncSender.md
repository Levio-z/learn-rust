---
tags:
  - fleeting
---
## 1. 核心观点  

“通信来共享内存”的机制，让多个线程可以安全地向同一个接收端发送数据。

这两个概念通常出现在 **Rust 语言**的并发编程中。`mpsc` 是 **Multi-producer, single-consumer**（多生产者，单消费者）的缩写。

简单来说，它提供了一种“通信来共享内存”的机制，让多个线程可以安全地向同一个接收端发送数据。

| **组件**              | **名称**    | **角色**  | **解释**                                            |
| ------------------- | --------- | ------- | ------------------------------------------------- |
| **`SyncSender<T>`** | **同步发送端** | **生产者** | 可以被 `clone()`（克隆）多份，让多个线程同时持有并发送消息。它是**同步（阻塞）**的。 |
| **`Receiver<T>`**   | **接收端**   | **消费者** | 只能由一个线程持有（不可克隆）。负责从通道中取出数据。                       |
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  



---

### 深入理解 `SyncSender` (同步通道)

Rust 的 `mpsc` 模块提供两种通道，`SyncSender` 对应的是**有界通道（Bounded Channel）**：

- **容量限制：** 创建时必须指定容量，例如 `mpsc::sync_channel(10)`。
    
- **阻塞特性：** 如果通道满了（缓冲区达到 10 个消息），`SyncSender::send()` 会**阻塞**当前线程，直到接收端取走消息腾出空间。
    
- **反压（Backpressure）：** 这在系统设计中很重要，它可以防止生产者发送速度过快导致内存耗尽。
    

---

### 3. 工作流程示例

想象一个场景：你有 3 个线程在爬取网页，1 个线程负责把结果写入数据库。

1. **创建通道：** 调用 `let (tx, rx) = mpsc::sync_channel(5);`。
    
2. **克隆发送端：** `tx` 可以被克隆多份，每个爬虫线程持有一个 `tx`。
    
3. **发送数据：** 爬虫线程调用 `tx.send(data)`。如果数据库线程处理太慢，导致 5 个位置全满，爬虫线程会原地等待。
    
4. **接收数据：** 数据库线程持有的 `rx` 通过 `rx.recv()` 不断取出任务。
    

---

### 4. 与普通 `Sender` 的区别

如果你使用的是 `mpsc::channel()`（没有 `sync_` 前缀），你会得到一个普通的 `Sender`：

- **无界：** 它是异步的，没有容量上限，直到耗尽内存。
    
- **非阻塞：** `send()` 永远不会阻塞线程。
    

---

### 总结

在 Rust 的任务执行器（Task Executor）架构中，`SyncSender` 是**任务的入口**（多个线程往里扔活），而 `Receiver` 是**任务的派发点**（执行器从这里拿活干）。

**你想看看如何在代码中结合 `SyncSender` 和线程池来构建一个健壮的后端任务处理系统吗？**

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
