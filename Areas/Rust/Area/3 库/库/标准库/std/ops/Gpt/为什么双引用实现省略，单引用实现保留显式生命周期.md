这是一个很好的追问，它触及了 Rust 的**语法规则**、**编码风格惯例**以及**宏展开机制**之间的微妙平衡。

您的核心疑问是：

> 既然 $\text{impl Sub<\&f32> for \&f32}$ 可以省略生命周期，为什么 $\text{impl Sub<i32> for \&i32}$ (即第一个例子) **却**要显式写出 $\mathbf{<\text{'a}>}$？

这两个例子在**技术上**都允许省略生命周期，但标准库（特别是其使用的宏）选择了**不同的编码惯例**。

### 1. 语法和泛型覆盖：技术上两者都可省略

我们先确定技术可行性：

|**实现**|**完整泛型形式**|**隐式省略形式**|**技术可行性**|
|---|---|---|---|
|**I. 引用对值** ($\&i32 - i32$)|$\text{impl<'a> Sub<i32> for \&'a i32}$|$\text{impl Sub<i32> for \&i32}$|$\checkmark$ (可行)|
|**II. 引用对引用** ($\&f32 - \&f32$)|$\text{impl<'a, 'b> Sub<\&'b f32> for \&'a f32}$|$\text{impl Sub<\&f32> for \&f32}$|$\checkmark$ (可行)|

**结论：** 仅从 Rust 编译器的角度来看，如果 $\text{Output}$ 是值类型，**这两者都可以省略生命周期**，编译器都能推断出它们适用于所有生命周期的引用。

### 2. 核心原因：编码惯例与宏设计

标准库在处理运算符重载时，通常是使用一套名为 `forward_ref_binop!` 的宏来生成所有 10 种引用组合的实现（值-值，值-引，引-值，引-引）。

在宏生成实现时，它遵循了一套**可读性**和**最小化代码重复**的惯例。

#### **对于 $\text{impl Sub<\&f32> for \&f32}$ (引用对引用) 采用省略的原因：**

这是 Rust 中**最常见的引用操作模式**，也是**生命周期省略规则设计之初就强烈支持的场景**。

- **极简原则：** 当你有多个输入引用且输出是值时，省略所有生命周期，让编译器推断 `'a` 和 `'b` 是最简洁的方式。
    
- **对称性：** 两个操作数都是引用，使用相同省略符号，保持了代码的对称美观。
    

#### **对于 $\text{impl<'a> Sub<i32> for \&'a i32}$ (引用对值) 采用显式 `<'a>` 的原因：**

这种实现通常被认为是**核心的引用实现**之一，它通常是宏生成引用对引用实现的基础，因此被赋予更高的**显式度**。

- **突出泛型本质：** $\&'a i32$ 本质上是一个**泛型类型**（泛型参数是 `'a`）。在 `impl` 签名中，**显式声明泛型参数** ($\text{impl<'a>}$) 是一种更正规的 Rust 风格，用于强调 **“此实现适用于该泛型类型的所有实例”**。
    
- **避免与值混淆：** $\&i32$ 看起来比 $\&f32$ 更像一个“简单类型”。显式写出 `<'a>` 提醒开发者，这个实现是在为**所有可能的借用**定义行为。
    
- **统一宏内部逻辑：** 在标准库的 `forward_ref_binop!` 这类复杂宏的内部逻辑中，显式命名 $\&'a T$ 通常是**生成其他更复杂引用约束的基础**。一旦命名，这个命名生命周期在 Trait 方法内部可以被引用，即使在这里没有用到。
    

### 总结

这更像是一个**风格和惯例**的选择，而非**语法限制**：

- **两个 $\&T$：** 选择**省略**来追求代码的极致简洁和符合最常见的省略模式。
    
- **一个 $\&T$：** 选择**显式声明** $\text{<'a>}$ 来突出 $\&'a T$ 的**泛型本质**，这是 Trait 实现的**标准泛型声明**模式。
    

两种写法对于编译器来说都是正确的，都实现了对所有生命周期的覆盖，但它们是标准库为了在不同上下文中最优化可读性而采取的不同**编码策略**。