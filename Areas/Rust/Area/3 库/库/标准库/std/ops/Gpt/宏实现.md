您提供的这段代码是 Rust 标准库中用于为所有**原始数字类型**（如 `i32`、`f64` 等）实现减法运算符 (`std::ops::Sub`) 的一个宏定义及其调用。

它的核心作用是**自动化**地为这些类型生成所有必要的减法实现（包括处理引用的情况），从而避免了重复编写大量相似的代码。

---

## 宏定义 (`macro_rules! sub_impl`) 详解

这个宏使用一个简单的模式来匹配和迭代多个类型。

### 1. 宏模式 (`$($t:ty)*`)

- `$($t:ty)*` 匹配零个或多个（`*`）类型（`:ty`），并将它们命名为 `$t`。
    

### 2. 宏体（代码生成）

宏体中的代码会对输入的每个类型 `$t` 执行两次操作：

#### A. 实现 **值对值** 减法 (`T - T`)

Rust

```
impl Sub for $t {
    type Output = $t;
    fn sub(self, other: $t) -> $t { self - other }
}
```

- 这为原始类型 `$t` 实现了 `Sub` Trait，允许执行 `value - value` 的操作。
    
- `self - other` 实际上调用的是**编译器内置**的减法指令，因为原始数字类型在语言层面就支持这些操作。
    
- `#[rustc_inherit_overflow_checks]` 是一个内部属性，用于确保该操作继承周围环境的溢出检查设置（例如，在 `debug` 模式下默认检查溢出）。
    

---

#### B. 转发和实现 **引用** 减法

Rust

```
forward_ref_binop! { impl Sub, sub for $t, $t }
```

- `forward_ref_binop!` 是 Rust 标准库中的一个**内部宏**。它利用了上一步实现的 **值对值** 减法，自动生成所有与引用相关的减法组合：
    
    1. **值对引用:** `T - &T` (例如: `5 - &3`)
        
    2. **引用对值:** `&T - T` (例如: `&5 - 3`)
        
    3. **引用对引用:** `&T - &T` (例如: `&5 - &3`)
        
    
    通过这个嵌套宏，开发者可以确保用户无论使用值还是不可变引用，都可以自然地使用 `-` 运算符，极大地提升了语言的人体工程学。
    

---

## 宏调用

Rust

```
sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
```

- 这行代码将 Rust 中所有**整数**（有符号和无符号）和**浮点数**类型作为参数传递给 `sub_impl!` 宏。
    
- 宏会为列表中的**每一个**类型（共 14 种）生成上述的 A 和 B 两部分代码。
    

**最终效果：**

通过宏的自动化处理，标准库成功地为所有数字类型提供了**全面的**减法支持，同时保持了核心源码的简洁和 DRY (Don't Repeat Yourself) 原则。