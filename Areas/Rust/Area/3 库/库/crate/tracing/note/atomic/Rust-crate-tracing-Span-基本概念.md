---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层



### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
在 `tracing` 这个 crate 中，`Span`（跨度）是一个非常核心的概念。如果说普通的 `log` 是一次性的**“快照”**，那么 `Span` 就是一个有始有终的**“过程”**。

简单来说，**Span 代表了一个随时间流逝的任务单元**。

---

### 1. Span 的核心作用

普通的日志（如 `info!`）只记录发生的一瞬间。而 `Span` 记录的是：

- **上下文（Context）**：在这个代码块里发生的所有日志，都会自动携带 `x = 5, y = 10` 这些属性。
    
- **层级关系**：如果你在 `Span A` 中调用了另一个带 `Span B` 的函数，系统会知道 B 是 A 的子任务。
    
- **耗时统计**：由于有进入（enter）和离开，你可以轻松测量出这个代码块执行了多久。
    

---

### 2. 代码解析

Rust

```
// 1. 定义：这里只是创建了一个“任务描述”，并没有开始执行。
// 此时关联了结构化数据 x 和 y。
let span = span!(Level::INFO, "计算操作", x = 5, y = 10);

// 2. 进入：通过 _enter 变量，当前线程被标记为“正在此 Span 中”。
// 只要 _enter 还没被 drop，之后产生的所有 info!() 都会带上 x=5, y=10。
let _enter = span.enter(); 

// 3. 退出：当函数结束或 _enter 离开作用域时，自动调用 Drop，退出 Span。
```

---

### 3. 更现代的写法：`#[instrument]`

在实际开发中，我们很少手动写 `span.enter()`，因为如果中间发生了 `panic` 可能会导致状态异常。更常用的做法是使用**过程宏**：

Rust

```
use tracing::{info, instrument};

#[instrument(fields(user_id = 123))] // 自动为整个函数创建一个 Span
fn my_function(data: &str) {
    info!("处理中..."); // 这条日志会自动带上 user_id=123 和 data 的值
}
```

---



| **特性**   | **普通 Log (info!)** | **Tracing Span** |
| -------- | ------------------ | ---------------- |
| **形态**   | 一个点（瞬间）            | 一段线（区间）          |
| **数据**   | 字符串或简单键值           | 结构化数据 + 继承关系     |
| **主要用途** | 告知发生了什么            | 追踪执行流程、性能分析      |

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 基本使用可以拆分原子笔记
  
