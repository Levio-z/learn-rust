---
tags:
  - fleeting
---
## 1. 核心观点  
### Ⅰ. 概念层
**`enum_dispatch` 的作用是消除“动态分发”（Dynamic Dispatch）带来的性能开销，同时保留类似 Trait 的多态特性。**


### Ⅱ. 应用层

自动去将trait实现和枚举关联


### Ⅲ. 实现层

### **IV**.原理层
- `enum_dispatch` 通过宏，自动为你生成那些枯燥的 `match` 结构，让你**以枚举的性能，享受 Trait 的开发体验**。
- [方案对比](#方案对比)

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 方案对比
#### 方案 A：Trait 对象 (`dyn Trait`)
使用 `Box<dyn MyTrait>`。
- **缺点**：存在 **动态分发** 开销。每次调用方法都要查虚表（vtable），且无法被编译器内联（Inline），性能较差。
#### 方案 B：手动枚举 (`enum`)
定义一个 `enum` 包含所有类型，然后在每个方法里写 `match`。
- **缺点**：代码极其冗余。每增加一个 Trait 方法，你都要手动写一遍 `match self { ... }` 逻辑。
### 2. `enum_dispatch` 的救场



#### 使用示例：
- 

#### 性能

- **零虚表开销**：直接跳转到函数地址。
- **支持内联**：编译器可以把编码逻辑直接塞进调用处，减少函数调用开销。
- **更多优化**：函数无副作用，可以直接删除

|**特性**|**手动 Enum + Match**|**enum_dispatch**|**Box<dyn Trait>**|
|---|---|---|---|
|**性能**|极高（静态）|极高（静态）|较低（动态）|
|**样板代码**|很多（需手动 match）|极少（自动生成）|少|
|**内存布局**|栈分配（大小固定）|栈分配（大小固定）|堆分配（Box）|
|**灵活性**|低|中|高（支持运行时扩展）|

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
