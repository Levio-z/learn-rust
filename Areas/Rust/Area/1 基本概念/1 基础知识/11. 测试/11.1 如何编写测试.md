**测试定义**

- 测试函数
    - 测试是一个用`test` 属性注释的函数，用于验证非测试代码是否按预期方式运行。
        - 设置任何需要的数据或状态。
        - 运行您想要测试的代码。
        - 断言结果正是您所期望的。
- `cargo test`
    - 当您使用该命令运行测试时`cargo test`，Rust 会构建一个测试运行器二进制文件，运行注释的函数并报告每个测试函数是通过还是失败。
        
  ```rust
        $ cargo test
           Compiling adder v0.1.0 (file:///projects/adder)
            Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
             Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)
        // 运行了多少测试
        running 1 test
        // 测试函数名称
        test tests::it_works ... ok
        // 可将某些测试忽略
        // 0 measured统计数据用于衡量性能的基准测试
        // 还可以过滤
        test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
        // 现实文档的测试结果
           Doc-tests adder
        
        running 0 tests
        
        test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
        ```
        

## 11.1.1 [**使用`assert!`宏检查结果**](https://rust-book.cs.brown.edu/ch11-01-writing-tests.html#checking-results-with-the-assert-macro)

- 【作用】
    - `assert!`宏一个计算结果为**布尔值的参数**。
        - `true` ，测试通过。
        - `false` ， `assert!`宏调用`panic!`导致测试失败。

## 11.1.2 [**使用`assert_eq!`和`assert_ne!`宏测试相等性**](https://rust-book.cs.brown.edu/ch11-01-writing-tests.html#testing-equality-with-the-assert_eq-and-assert_ne-macros)

【核心】
- 标准库提供了一对宏`assert_eq!`和`assert_ne!` ——以便更方便地执行此测试。
    - 这两个宏分别比较两个参数是否相等或不相等。
    - 如果断言失败，它们还会打印这两个值；
- **比较的值必须实现`PartialEq`和`Debug`特征**
    - 从表面上看， `assert_eq!`和`assert_ne!`宏使用运算符 `==`和`!=` 。当断言失败时，这些宏会使用调试格式打印它们的参数，这意味着被**比较的值必须实现`PartialEq`和`Debug`特征**
    - 所有**原始类型和大多数标准库类型**都实现了这些特征。对于您自己定义的结构和枚举，您需要实现`PartialEq`来断言这些类型的相等性。您还需要实现`Debug`来打印值，当 断言失败。
    - 因为这**两个特征都是可派生的特征**，正如 参见第 5 章中的清单 5-12，这通常很简单，只需添加 `#[derive(PartialEq, Debug)]`注释添加到结构或枚举定义中。

## 11.1.3 [**添加自定义失败消息**](https://rust-book.cs.brown.edu/ch11-01-writing-tests.html#adding-custom-failure-messages)

- 您还可以添加自定义消息，作为`assert!` 、 `assert_eq!`和`assert_ne!`宏的可选参数，与失败消息一起打印。任何 在必需参数之后指定的参数被传递给 `format!`宏。
    
- 案例
    
   ```rust
        #[test]
        fn greeting_contains_name() {
            let result = greeting("Carol");
            assert!(
                result.contains("Carol"),
                "Greeting did not contain name, value was `{result}`"
            );
        }
    ```
    

## 11.1.4 [**使用`should_panic`检查 Panics**](https://rust-book.cs.brown.edu/ch11-01-writing-tests.html#checking-for-panics-with-should_panic)

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

- 们将`#[should_panic]`属性放在`#[test]`属性之后、它所应用的测试函数之前。让我们看看这个测试通过时的结果：
- 【案例-**使用包含指定子字符串的`panic!`**】

```rust

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);

```

- 成功的时候会在打印测试函数后多显示should panic
    - test tests::greater_than_100 - should panic ... ok
- expected 期望特定的panic
    - #[should_panic(expected = "less than or equal to 100")]
    - 测试失败会多出以下信息
        - note: panic did not contain expected string
        - panic message: `"Guess value must be greater than or equal to 1, got 200."`, expected substring: `"less than or equal to 100"`

## 11.1.5 [**在测试中使用`Result<T, E>`**](https://rust-book.cs.brown.edu/ch11-01-writing-tests.html#using-resultt-e-in-tests)

```rust
    #[test]
    fn it_works() -> Result<(), String> {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }

```

函数`it_works`现在具有`Result<(), String>`返回类型。在函数主体中，`assert_eq!`我们不再调用宏， 而是`Ok(())`在测试通过时返回，在测试失败时返回`Err`一个内部的。`String`

您不能`#[should_panic]`在使用 的测试中使用注释`Result<T, E>`。要断言操作返回`Err`变体，_请不要_在值上使用问号运算符`Result<T, E>`。而是使用 `assert!(value.is_err())`。这个才会返回panic。