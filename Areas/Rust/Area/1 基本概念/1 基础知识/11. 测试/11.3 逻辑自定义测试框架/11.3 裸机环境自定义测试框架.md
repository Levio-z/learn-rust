### Rust 不稳定自定义测试框架（`custom_test_frameworks`）解析

#### 1\. 功能定义

Rust 提供了一个 **不稳定特性** `custom_test_frameworks`，允许用户 **替换默认的测试框架**。它的核心目的在于：
-   允许在 **`#[no_std]`** 环境下进行测试，而无需依赖 `std` 或 `libtest`。
-   提供对测试收集与执行过程的 **完全控制**。
-   允许自定义测试报告、执行顺序、日志收集等行为。
#### 2\. 工作原理

1.  **收集测试函数**  
    所有标注了 `#[test_case]`（而不是默认的 `#[test]`）的函数，会被编译器自动收集到一个测试函数列表中。
    
2.  **调用自定义 runner**  
    通过 `#![test_runner(my_runner)]` 指定一个自定义 runner 函数，例如：
    
    ```rust
    #![feature(custom_test_frameworks)]
    #![no_std]
    #![no_main]
    
    use core::panic::PanicInfo;
    
    #[panic_handler]
    fn panic(info: &PanicInfo) -> ! {
        loop {}
    }
    
    fn my_runner(tests: &[&dyn Fn()]) {
        for test in tests {
            test();
        }
    }
    
    #[test_case]
    fn test_example() {
        assert_eq!(1 + 1, 2);
    }
    ```
    
    在这个示例中：
    
    -   `my_runner` 接受一个 **函数切片**，每个元素是一个测试函数。
    -   runner 可以自由控制测试执行逻辑，例如顺序、并发、日志输出等。
        
3.  **对测试的控制**  
    因为 runner 是用户自定义的：
    
    -   可以在执行前后添加初始化或清理逻辑。
        
    -   可以收集测试结果并生成自定义报告。
        
    -   可以支持嵌入式或裸机环境，避免依赖操作系统资源。
        

#### 3\. 使用场景

-   **裸机开发**（如操作系统内核、嵌入式固件）：`#[no_std]` 环境下无法使用默认 `libtest`。
    
-   **自定义测试逻辑**：例如想控制测试执行顺序、统计执行时间或收集日志。
    
-   **最小化依赖**：在追求最轻量运行环境的场景下，只依赖语言本身，不依赖外部库。
    

#### 4\. 扩展知识点

-   `#[test_case]` 只在 `custom_test_frameworks` 下可用。
    
-   runner 的签名必须是 `fn(&[&dyn Fn()])` 或兼容类型。
    
-   结合 `#[no_main]` 和自定义 panic handler 可以在裸机上直接执行测试。
    
-   可以结合 `bootloader` 或 QEMU 模拟进行内核测试。
    

---