# 11.2 控制测试的运行方式

【测试的默认行为】

- 就像`cargo run`编译你的代码然后运行生成的二进制文件一样， `cargo test`在测试模式下编译您的代码并运行生成的测试二进制文件。Cargo `cargo test`生成的二进制文件的默认行为是并行运行所有测试并捕获测试运行期间生成的输出，从而防止显示输出并更轻松地读取与测试结果相关的输出。但是，您可以指定命令行选项来更改此默认行为。

## 11.2.1 [**并行或连续运行测试**](https://rust-book.cs.brown.edu/ch11-02-running-tests.html#running-tests-in-parallel-or-consecutively)

【并行运行】
- 【好处】
    - 当您运行多个测试时，**默认情况下它们会使用线程并行运行，这意味着它们可以更快地完成运行，并且您可以更快地获得反馈**。
- 【挑战】
    - 由于测试同时运行，因此**您必须确保您的测试不依赖于彼此或任何共享状态，包括共享环境，例如当前工作目录或环境变量**。

【并行语法】
- 【控制线程数】
    
    ```rust
    $ cargo test -- --test-threads=1

    ```
    

## 11.2.2 [**Showing Function Output  显示函数输出**](https://rust-book.cs.brown.edu/ch11-02-running-tests.html#showing-function-output)

```rust
$ cargo test -- --show-output
```

## 11.2.3 [**按名称运行测试子集**](https://rust-book.cs.brown.edu/ch11-02-running-tests.html#running-a-subset-of-tests-by-name)

[**运行单个测试**](https://rust-book.cs.brown.edu/ch11-02-running-tests.html#running-single-tests)

```rust
cargo test one_hundred
```

[**筛选以运行多个测试**](https://rust-book.cs.brown.edu/ch11-02-running-tests.html#filtering-to-run-multiple-tests)

我们可以指定测试名称的一部分，任何名称与该值匹配的测试都将运行。例如，由于我们的两个测试名称包含`add` ，我们可以通过运行`cargo test add`来运行这两个测试：

```rust
$ cargo test add
```

此命令运行名称中带有`add`的所有测试，并过滤掉名为`one_hundred`的测试。另请注意，测试所在的模块成为测试名称的一部分，因此我们可以通过过滤模块名称来运行模块中的所有测试。

[**忽略某些测试，除非特别要求**](https://rust-book.cs.brown.edu/ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested)

有时，一些特定的测试执行起来可能非常耗时，因此你可能希望在大多数`cargo test`运行过程中排除它们。 你不必将所有想要运行的测试列为参数，而是可以使用`ignore`属性注释耗时的测试以将其排除，如下所示：

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}
```

【只想运行被忽略的测试】`expensive_test`函数被列为`ignored` 。如果我们只想运行被忽略的测试，我们可以使用`cargo test -- --ignored` ：

## 11.3 [**Test Organization  测试组织**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#test-organization)

【分类】

- 单元测试和集成测试。_单元测试_规模较小，更专注，一次单独测试一个模块，并且可以测试私有接口。_集成测试_完全独立于库之外，并以与任何其他外部代码相同的方式使用您的代码，仅使用公共接口，并且可能每次测试执行多个模块。

## 11.3.1 [**Unit Tests  单元测试**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#unit-tests)

单元测试的目的是独立于其余代码测试每个代码单元，以快速找出代码是否按预期运行。您将在每个文件的_src_目录中放置单元测试，其中包含要测试的代码。惯例是创建一个名为`tests`模块 在每个文件中包含测试函数并使用注释模块 `cfg(test)` 。

## 11.3.2 [**测试模块和`#[cfg(test)]`**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#the-tests-module-and-cfgtest)

`tests`模块上的`#[cfg(test)]`注释告诉 Rust 仅在运行`cargo test`时编译并运行测试代码，而不是在运行`cargo build`时编译并运行。当您只想构建库时，这可以节省编译时间，并且由于不包含测试，因此可以节省生成的编译工件中的空间。您会发现，由于集成测试位于不同的目录中，因此它们不需要`#[cfg(test)]`注释。但是，由于单元测试与代码位于相同的文件中，因此您将使用`#[cfg(test)]`来指定它们不应包含在编译结果中。

```rust
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

在自动生成的`tests`模块中，属性`cfg`代表 _配置_并告诉 Rust 应该只包含以下项目 给定某个配置选项。在本例中，配置选项是 `test` ，这是 Rust 提供的，用于编译和运行测试。通过使用 `cfg`属性，只有当我们主动使用`cargo test`运行测试时，Cargo 才会编译我们的测试代码。除了用`#[test]`注释的函数外，这还包括此模块中可能存在的任何辅助函数。

## 11.3.3 [**测试私有函数**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#testing-private-functions)

```rust
pub fn add_two(a: usize) -> usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}
```

请注意， `internal_adder`函数未标记为`pub` 。测试只是 Rust 代码， `tests`模块只是另一个模块。正如我们在[“模块树中引用项目的路径”](https://rust-book.cs.brown.edu/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html)中讨论的那样 部分中，子模块中的项目可以使用其祖先模块中的项目。在 这个测试，我们把所有`tests`模块的父项都纳入范围 `use super::*` ，然后测试可以调用`internal_adder` 。如果你认为私有函数不应该被测试，Rust 中没有任何内容可以强迫你这样做。

## 11.3.4 [**Integration Tests  集成测试**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#integration-tests)

在 Rust 中，集成测试完全独立于库之外。它们使用库的方式与任何其他代码相同，这意味着它们只能调用属于库公共 API 的函数。它们的目的是测试库的许多部分是否能够正常工作。单独工作正常的代码单元在集成时可能会出现问题，因此集成代码的测试覆盖率也很重要。要创建集成测试，首先需要一个_测试_目录。

【[**_tests_目录**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#the-tests-directory)】

- **我们在项目目录的顶层，即_src_旁边创建一个_tests_目录。Cargo 知道在这个目录中查找集成测试文件。然后我们可以根据需要创建任意数量的测试文件，Cargo 会将每个文件编译为单独的 crate。**
    
- 让我们创建一个集成测试。示例 11-12 中的代码仍然位于 _src/lib.rs_文件，创建一个_tests_目录，并创建一个名为 _tests/integration_test.rs_ 。你的目录结构应该如下所示：

    ```rust
    adder
    ├── Cargo.lock
    ├── Cargo.toml
    ├── src
    │   └── lib.rs
    └── tests
        └── integration_test.rs
    adder
    ├── Cargo.lock
    ├── Cargo.toml
    ├── src
    │   └── lib.rs
    └── tests
        └── integration_test.rs
    
    ```
    

【案例】

```rust
use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}
```

_测试_目录中的每个文件都是一个单独的包，因此我们需要将我们的库纳入每个测试包的范围。因此，我们在代码顶部添加了`use adder::add_two;`但在单元测试中我们并不需要它。

我们不需要在_tests/integration_test.rs_中使用以下代码进行注释 `#[cfg(test)]` 。Cargo 对_tests_目录进行了特殊处理，只有运行`cargo test`时才会编译此目录中的文件。现在运行`cargo test` ：

- 输出的三个部分包括单元测试、集成测试和文档测试。请注意，如果某一部分中的任何测试失败，则不会运行以下部分。例如，如果单元测试失败，则不会有任何集成测试和文档测试的输出，因为只有在所有单元测试都通过的情况下才会运行这些测试。
- 我们仍然可以通过将测试函数的名称指定为`cargo test`参数来运行特定的集成测试函数。要运行特定集成测试文件中的所有测试，请使用`cargo test`的`--test`参数 后跟文件的名称：
`cargo test --test integration_test`

## 11.3.5 [**集成测试中的子模块**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#submodules-in-integration-tests)

当您有一组辅助函数用于多个集成测试文件，并尝试按照第 7 章[“将模块分离到不同的文件中”](https://rust-book.cs.brown.edu/ch07-05-separating-modules-into-different-files.html)部分中的步骤将它们提取到一个公共模块中时，_测试_目录文件的不同行为最为明显。例如，如果我们创建_tests/common.rs_ 并在其中放置一个名为`setup`的函数，我们可以向`setup`添加一些我们想要从多个测试文件中的多个测试函数中调用的代码：

我们并不想让`common`出现在测试结果中，并且只显示`running 0 tests` 。我们只想与其他集成测试文件共享一些代码。为了避免`common`出现在测试输出中，我们将创建_tests_ _/common/mod.rs 而不是 tests/common.rs_ 。项目目录现在如下所示：

```rust
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs

```

这是我们在第 7 章[“备用文件路径”](https://rust-book.cs.brown.edu/ch07-05-separating-modules-into-different-files.html#alternate-file-paths)部分中提到的 Rust 也能理解的旧命名约定。以这种方式命名文件告诉 Rust 不要将`common`模块视为集成测试文件。当我们将`setup`函数代码移到 _tests/common/mod.rs_并删除_tests/common.rs_文件，测试输出中的部分将不再出现。 _tests_子目录中的文件 目录不会被编译为单独的包或在测试中有部分 输出。

```rust
use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}
```

请注意， `mod common;`声明与模块声明相同 我们在示例 7-21 中演示了这一点。然后，在测试函数中，我们可以调用 `common::setup()`函数。

## 11.3.6 [**二进制包的集成测试**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#integration-tests-for-binary-crates)

- 如果我们的项目是一个二进制包，只包含_src/main.rs_文件，而没有_src/lib.rs_文件，我们就无法在 _tests_目录并使用`use`语句将_src/main.rs_文件中定义的函数引入范围。只有库包才会公开其他包可以使用的函数；二进制包应该单独运行。
- 这就是 Rust 项目提供二进制文件的原因之一，它有一个简单的_src/main.rs_文件，该文件调用位于 _src/lib.rs_文件。使用该结构，集成测试_可以_`use`测试库包，以使重要功能可用。如果重要功能有效，则_src/main.rs_中的少量代码 文件也能正常工作，而且那一小部分代码不需要测试。

## 11.3.7 [**Summary  概括**](https://rust-book.cs.brown.edu/ch11-03-test-organization.html#summary)