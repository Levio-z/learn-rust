正如我们在[第 16 章](http://localhost:3000/ch16-00-concurrency.html)中看到的，线程提供了一种并发方法。在本章中，我们已经看到了另一种方法：将 async 与 futures 和 streams 一起使用。如果您想知道何时选择方法而不是其他方法，答案是：这要看情况！
### 线程 vs 异步（async/futures/streams）

| 方面    | 线程（Threads）        | 异步（Async/Futures/Streams）        |
| ----- | ------------------ | -------------------------------- |
| 并发模型  | 多个操作系统线程，操作系统调度    | 单线程事件循环（或有限线程池）中的任务调度            |
| 资源消耗  | 线程栈和切换开销较大         | 轻量级任务，状态机驱动，开销小                  |
| 适合场景  | CPU 密集型计算，真正的并行    | I/O 密集型任务，高并发场景                  |
| 编程复杂度 | 需要处理锁、死锁、竞态等复杂同步问题 | 需要理解 Future 状态机和生命周期，但避免了许多锁竞争问题 |
| 调度方式  | 操作系统调度，抢占式         | 用户态调度，协作式                        |
| 可扩展性  | 随线程数增长资源消耗显著       | 大量并发任务下资源使用更低                    |
几十年来，许多作系统都提供了基于线程的并发模型，因此许多编程语言都支持它们。然而，这些模型并非没有权衡取舍。在许多作系统上，它们为每个线程使用相当多的内存，并且它们会带来一些启动和关闭的开销。线程也仅在您的作系统和硬件支持时才是一个选项。与**主流台式机和移动计算机不同，一些嵌入式系统根本没有操作系统，因此它们也没有线程。**

异步模型提供了一组不同的（最终是互补的）权衡。在异步模型中，并发操作不需要自己的线程。相反，它们可以在任务上运行，就像我们在 streams 部分使用 `trpl：：spawn_task` 从同步函数启动工作时一样。任务类似于线程，但它不是由操作系统管理，而是由库级代码（运行时）管理。

在上一节中，我们看到可以使用 async 构建流 channel 并生成一个我们可以从同步代码中调用的异步任务。我们可以 对线程执行完全相同的操作。在示例 17-40 中，我们使用了 `trpl：：spawn_task` 和 `trpl：：sleep`。在示例 17-41 中，我们将它们替换为标准库中的 `thread：：spawn` 和 `thread：：sleep` API。 `get_intervals` 函数。
```rust
fn get_intervals() -> impl Stream<Item = u32> {
    let (tx, rx) = trpl::channel();

    // This is *not* `trpl::spawn` but `std::thread::spawn`!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // Likewise, this is *not* `trpl::sleep` but `std::thread::sleep`!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}
```
如果你运行这段代码，输出与示例 17-40 相同。请注意，从调用代码的角度来看，这里的变化是多么小。更重要的是，即使我们的一个函数在运行时生成了一个异步任务，另一个函数生成了一个 OS 线程，结果流也不受差异的影响。
尽管它们相似，但这两种方法的行为非常不同，尽管我们可能很难在这个非常简单的示例中对其进行测量。我们可以在任何现代个人计算机上生成数百万个异步任务。如果我们尝试对线程执行此作，我们实际上会耗尽内存！
但是，这些 API 如此相似是有原因的。线程充当同步集的边界;线程_之间_可以并发。任务充当_异步_作集的边界;并发在 Task _之间_和_任务内部_都是可能的，因为 Task 可以在其主体中的 future 之间切换。最后，futures 是 Rust 最精细的并发单位，每个 future 可能代表其他 future 的树。运行时（具体来说，是其执行程序）管理任务，而任务管理 futures。在这方面，任务类似于轻量级的运行时管理的线程，具有来自运行时而不是系统管理的附加功能。


这并不意味着异步任务总是比线程好（反之亦然）。从某些方面来说，线程并发是一种`比异步并发`更简单的编程模型。这可能是优点，也可能是缺点。线程在某种程度上是 “即发即弃”;它们没有 future 的原生等价物，因此它们只是运行到完成，除了操作系统本身之外，不会被中断。也就是说，它们没有像 futures 那样内置对_任务内并发_的支持。Rust 中的线程也没有取消机制——我们在本章中没有明确讨论这个主题，但每当我们结束一个 future 时，它的状态都会被正确地清理。

这些限制也使线程比 future 更难组合。很多 例如，使用线程来构建帮助程序（如 `timeout` 和 `throttle` 方法。正如我们所看到的，futures 是更丰富的数据结构，这意味着它们可以更自然地组合在一起。

然后，任务为我们提供了对 future _的额外_控制权，允许我们选择在哪里以及如何对它们进行分组。事实证明，线程和任务通常可以很好地协同工作，因为任务可以（至少在某些运行时中）在线程之间移动。事实上，在后台，我们一直在使用的运行时（包括 `spawn_blocking` 和 `spawn_task` 函数）默认是多线程的！许多运行时使用一种称为_工作窃取_的方法，根据线程当前的使用方式，在线程之间透明地移动任务，以提高系统的整体性能。这种方法实际上需要线程_和_任务，因此需要 futures。

在考虑何时使用哪种方法时，请考虑以下经验法则：
- 如果工作_非常可并行化_ ，例如处理一堆数据，其中每个部分都可以单独处理，则线程是更好的选择。
- 如果工作_非常并发_ ，例如处理来自一堆不同来源的消息，这些消息可能以不同的时间间隔或不同的速率传入，则 async 是更好的选择。

如果您同时需要并行性和并发性，则不必在线程和异步之间进行选择。您可以自由地将它们一起使用，让每个角色发挥它最擅长的作用。例如，示例 17-42 展示了真实 Rust 代码中这种混合的一个相当常见的例子。
```rust
use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}
```
我们首先创建一个异步通道，然后生成一个线程，该线程获取通道的发送方的所有权。在线程中，我们发送数字 1 到 10，每个数字之间休眠一秒钟。最后，我们运行一个使用传递给 `trpl：：run` 的异步块创建的 future，就像我们在整个章节中所做的那样。在那个将来，我们等待这些消息，就像我们看到的其他消息传递示例一样。


回到我们本章开头的场景，想象一下使用专用线程运行一组视频编码任务（因为视频编码是计算绑定的），但通知 UI 这些作是通过异步通道完成的。在实际用例中，有无数此类组合的例子。
### [Summary  总结](https://rust-book.cs.brown.edu/ch17-06-futures-tasks-threads.html#summary)

无论您选择哪种方法，Rust 都会为您提供编写安全、快速、并发代码所需的工具——无论是用于高吞吐量 Web 服务器还是嵌入式作系统。


