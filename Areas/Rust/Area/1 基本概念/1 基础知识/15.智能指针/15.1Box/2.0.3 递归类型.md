==递归类型==
- _递归类型_的值可以将另一个相同类型的值作为其自身的一部分。
- **递归类型会带来问题，因为在编译时 Rust 需要知道类型占用了多少空间。但是，递归类型的值的嵌套理论上可以无限继续，因此 Rust 无法知道该值需要多少空间**。由于框的大小已知，我们可以通过在递归类型定义中插入框来启用递归类型。
### 递归类型示例：cons 列表
[Lisp-cons函数](../../../../../../basic/编译原理/Lisp%20语言中核心构造机制——cons%20函数/Lisp-cons函数.md)


#### 如何获取具有已知大小的递归类型
- 改变数据结构，通过存储指向该值的指针来间接存储值。
- 因为`Box<T>`是一个指针，所以 Rust 总是知道`Box<T>`有多少空间 需求：**指针的大小不会根据其数据量而改变指向**
- 这意味着我们可以将Box<\T>放入Cons变量中，而不是直接放入另一个List值。Box Box<\T>将指向下一个List 值将位于堆上，而不是Cons变量内。从概念上讲，我们仍然有一个列表，它由包含其他列表的列表创建，但此实现现在更像是将项目彼此相邻放置，而不是彼此嵌套。
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```
- `Cons`变量需要`i32`的大小加上存储框指针数据的空间。Nil `Nil`不存储任何值，因此它所需的空间比`Cons`变量要小。我们现在知道，任何`List`值都将占用`i32`的大小加上框指针数据的大小。通过使用框，我们打破了无限递归链，因此编译器可以计算出存储`List`值所需的大小。图 15-2 显示了`Cons`变量现在的样子。
![](asserts/Pasted%20image%2020250604202804.png)




### 参考链接
- [使用 Boxes 启用递归类型](https://rust-book.cs.brown.edu/ch15-01-box.html#enabling-recursive-types-with-boxes)
- [1.链表刷题中的Option相关设计](../../../2%20进阶/2.9%20算法和设计模式/1.链表刷题中的Option相关设计.md)