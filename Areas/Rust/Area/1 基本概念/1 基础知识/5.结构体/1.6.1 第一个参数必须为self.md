### 第一个参数为self
- 在`area`的签名中，我们使用`&self`而不是`rectangle: &Rectangle` 。
	- 实际：`&self`实际上是`self: &Self`缩写。在`impl`块中，**类型`Self`是`impl`块所针对类型的别名**。
	- 语法：方法的第一个参数必须有一个名为`self`且类型为`Self`参数，因此 Rust 允许您在第一个参数位置仅使用名称`self`来缩写它。
		- 可以借用
		- 可以获取所有权
- 我们在这里**选择`&self`原因**与在函数版本中使用`&Rectangle`原因相同：我们不想取得所有权，我们**只想读取结构中的数据，而不是写入数据**。如果我们想在方法执行的过程中更改我们调用该方法的实例，我们将使用`&mut self`作为第一个参数。使**用`self`作为第一个参数来取得实例所有权的方法很少见；这种技术通常用于当方法将`self`转换为其他内容并且您想阻止调用者在转换后使用原始实例时。**

### 什么是方法（Method）？

在 Rust 中，方法其实是 `impl` 块中定义的函数，其本质是函数（`fn`），但带有一个特殊的隐式参数 `self`。与普通函数不同，**`self` 没有显式类型，而是用于与某个实例进行绑定。**
```rust
fn foo(self, arg2: Type2) -> ReturnType {
    // ...
}
```

Rust 的方法定义中，`self` 参数可以有以下三种主要形式：

| self 形式     | 所有权语义       | 中文解释     | 场景                     |
| ----------- | ----------- | -------- | ---------------------- |
| `self`      | 所有值的所有权     | **值**    | 消耗型方法，如 `into_xxx`     |
| `&mut self` | 可变借用（独占访问）  | **可变引用** | 修改 `self` 的方法          |
| `&self`     | 不可变借用（共享访问） | **共享引用** | 只读访问方法，如 `peek`, `len` |
- self：拥有值（Ownership）
	- 表示方法获取了 `self` 的**所有权**，意味着调用者失去对原值的访问。
	- 用途：通常用于构造器或“消费型方法”（如 `into_iter`），但 **日常方法中极少使用*
	- 原因：如果每次调用方法都“消耗”整个值，那该值就没法再使用了 —— **这显然不合理**。
- &mut self：可变引用（独占借用）
	- 表示对 `self` 的**独占可变访问权限**，但不拥有它的所有权。
	- 你可以：修改、覆盖、重排其内容。
	- 要求：调用方必须持有该值的 `&mut` 引用，不能有其他借用同时存在。
	- ✅ 非常适合“修改自身状态”的方法，例如链表的 push、pop、clear。
	- ❗ 唯一不能做的是把值**无替代地 move 掉**（即“掏空”自己）。
- &self：共享引用（只读访问）
	- 表示对 `self` 的**共享访问权限**。
	- 不可变，不可被修改 —— 只能“看”，不能“动”。
	- 使用场景：统计、读取值、不需要修改的场合。