除了方法之外，Rust 还有相关函数。**这些函数是在结构本身上定义的，它们不以结构（实例）的任何引用作为参数，也不拥有结构的[所有权](https://www.rustfinity.com/learn/rust/ownership) ，因此无需结构实例即可调用它们。**

与**方法**不同， **关联函数**是使用结构体本身的 `::` 语法来调用的，而不是结构体的实例。它们类似于其他语言中的**静态方法** 。

【定义】
- `impl`块中定义的所有函数称为关联函数因为它们与`impl`命名的类型相关联。
	- 所以，**"method 是一种特殊的关联函数"** —— 带 `self` 的关联函数称为“方法（methods）”，不带 `self` 的就只是“关联函数（但不是方法）”。
- 我们可以将关联函数定义为**不以`self`作为其第一个参数的函数（因此不是方法），因为它们不需要该类型的实例即可使用**。我们已经使用过一个这样的函数：在`String`类型上定义的`String::from`函数。

【应用】

- 关联函数不是方法，通常用于返回结构体新实例的构造函数。这些函数通常被称为`new` ，但 `new`不是一个特殊名称，也不是语言内置的。例如，我们可以选择提供一个名为`square`的关联函数，该函数有一个维度参数，并将其用作宽度和高度，从而更容易创建一个方形`Rectangle` ，而不必两次指定相同的值：
```rust
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
```
### 关联函数调用
- ：：用于关联函数
### 【[多个](https://rust-book.cs.brown.edu/ch05-03-method-syntax.html#multiple-impl-blocks)[impl](https://rust-book.cs.brown.edu/ch05-03-method-syntax.html#multiple-impl-blocks)[块](https://rust-book.cs.brown.edu/ch05-03-method-syntax.html#multiple-impl-blocks)】
每个结构体允许多个impl块
```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```
方法调用是函数调用的语法糖
```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn set_width(&mut self, width: u32) {
        self.width = width;
    }
}
```

```rust
   let mut r = Rectangle { 
        width: 1,
        height: 2
    };
    let area1 = r.area();
    let area2 = Rectangle::area(&r);
    assert_eq!(area1, area2);

    r.set_width(2);
    Rectangle::set_width(&mut r, 2);
```
方法调用r.area()变成Rectangle::area(&r) 。函数名称是关联函数Rectangle::area 。函数参数是&self参数。Rust 自动插入借位运算符& 。

方法调用r.set_width(2)类似地变为 Rectangle::set_width(&mut r, 2) 。此方法需要&mut self ，因此第一个参数是可变借用&mut r 。第二个参数完全相同，即数字 2。