- 是**静态分配变量**，有固定的内存地址。
- 默认不可变，如果需要修改必须用 `static mut`，且访问必须 `unsafe`。
- 可以存放复杂的类型，也可以被引用。
- 初始化表达式必须是常量表达式，但初始化在程序运行时完成。
- 生命周期为 `'static`，程序整个运行期间都存在。



### Rust 中 `const` 与 `static` 的区别

| 方面         | `const`         | `static`                       |
| ---------- | --------------- | ------------------------------ |
| **定义**     | 编译时常量，类似于宏替换    | 静态变量，存储于固定内存地址                 |
| **内存位置**   | 不固定，通常内联替换（无地址） | 有固定内存地址（符号）                    |
| **是否可变**   | 只读，不可变          | 默认不可变，可用 `static mut` 定义可变静态变量 |
| **初始化时机**  | 编译时求值           | 程序启动时初始化                       |
| **引用生命周期** | 与使用位置相关，不固定     | `'static`，整个程序生命周期             |
| **适用场景**   | 编译时常量表达式        | 需要全局持久化的值，如全局变量、缓存等            |
### 修改
是的，**你只能在 `unsafe` 块中修改 `static mut` 变量**。这是 Rust 的**语言级安全设计**，因为对 `static mut` 的访问本质上是**共享可变引用**（违反 Rust 正常的 aliasing 规则），可能导致 **数据竞争（data race）**，编译器无法静态检查其安全性。
#### 1. 多线程并发下的风险
Rust 的核心内存安全原则之一是：**可变引用不能与其他引用并存**（"no aliasing with mut"）。
但 `static mut` 不受这个规则约束，下面这种写法在多线程场景下会发生未定义行为（UB）：
```
static mut CONFIG: u32 = 0;

fn update() {
    unsafe {
        CONFIG += 1; // ❌ 多线程同时调用可能竞争
    }
}

```
### 2. 原始指针没有自动安全保护

你用的是 `*const Config`（原始指针），Rust 不会为你保证它不是空指针、悬垂指针或重复借用。写这类代码，等价于 C 的指针操作，必须你来保证安全。

### Rust中static和sync联系
#### 1. `static` 的定义和特点
- `static` 变量是全局静态分配的变量，存储在程序的静态内存区，生命周期是 `'static`，即整个程序运行期间都存在。
- 它是**唯一且共享**的全局变量，多个线程都能访问。
#### 2. 线程安全限制

由于 `static` 是全局共享变量，多线程同时访问时可能产生数据竞争。Rust 编译器为此强制要求：
- **`static` 变量必须包含实现了 `Sync` trait 的类型**。  
    `Sync` 是 Rust 的自动 trait，表示类型的引用可以安全地在多个线程间共享。
- 如果你声明一个非 `Sync` 类型的 `static` 变量，编译器会拒绝，提示类型不满足 `Sync`。
#### 3. 为什么 `Sync` 很重要？

- 假设你声明了一个非线程安全的全局变量，多个线程同时写入，没有同步机制，会引发未定义行为和数据竞争。
- Rust 的类型系统通过 `Sync` trait 防止这种情况，强制你只能声明线程安全的全局变量。