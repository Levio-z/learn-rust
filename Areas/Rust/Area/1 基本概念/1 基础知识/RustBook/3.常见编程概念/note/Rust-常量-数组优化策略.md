---
tags:
  - note
---
## 1. 核心观点  
**内存表 + 计算偏移读取**（通用、简单）
**展开成分支/条件移动（register-only）**（小数组常见）

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 运行时访问流程（高层到低层）

1. **编译期**：把 `[(0,1),(1,0),(0,-1),(-1,0)]` 放在某个地方（内联进指令、或放到 `.rodata`）。
    
2. **代码生成**：对 `DIRS[di]` 生成运行时代码：

    - 计算 `offset = di * sizeof(Element)`（`Element` 为 `(i32,i32)`，通常 8 bytes）。
        
    - 生成 `load`：从 `base_address + offset` 读取元素到寄存器。
        
    - 如果 Rust 未消除边界检查，还会先生成 bounds-check（`di < 4`），否则省去。
        
3. **可能的优化**：编译器可把常量展开成 `match di {0 => (0,1), 1 => (1,0), ...}`，用 CMOV（条件移动）或 jump-table 来避免内存访问，尤其在数组很小时。
    

---

### 两种典型实现策略（编译器会择优）

- **内存表 + 计算偏移读取**（通用、简单）
    
    - 生成 `.rodata`（或直接内嵌常量），运行时：`addr = base + di * 8; load addr`。
        
    - 如有边界检查：先 `if di >= 4 { panic!() }`。
        
- **展开成分支/条件移动（register-only）**（小数组常见）
    
    - 生成等价 `match`：编译器将每个分支的常量放入寄存器，通过比较和条件移动（`cmov`/predicated move）选择结果，避免内存访问。
        
    - 优点：减少 memory traffic、可能更快；缺点：生成更多指令。
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
