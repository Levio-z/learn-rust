---
tags:
  - fleeting
---
## 1. 核心观点  
### Ⅰ. 概念层
1. **按分派时间理解多态**：静态（特设 + 参数化） vs 动态（子类型）；
2. **按行为依赖类型分析**：类型特定（特设） vs 类型无关（参数化） vs 运行时类型决定（子类型）；


### Ⅱ. 实现层



### Ⅲ. 原理层

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 三类多态对比：特设多态、参数化多态与子类型多态

为了完整理解多态体系，我们将三类多态放在一起分析。

---

### 1. 特设多态（Ad-hoc Polymorphism）

#### 定义

同名函数或操作符根据**具体类型**表现不同的行为，编译器在编译期选择匹配实现。

#### 特点

- **静态分派**，无运行时开销；
    
- 每种类型可以拥有独立实现；
    
- 接口统一，行为类型依赖。
    

#### Rust 示例

```rust
trait Add<RHS=Self> {
    type Output;
    fn add(self, rhs: RHS) -> Self::Output;
}

impl Add for i32 {
    type Output = i32;
    fn add(self, rhs: i32) -> i32 { self + rhs }
}

impl Add for f64 {
    type Output = f64;
    fn add(self, rhs: f64) -> f64 { self + rhs }
}
```

- `i32` 与 `f64` 的行为不同；
    
- 调用时编译器选择对应实现。
    

---

### 2. 参数化多态（Parametric Polymorphism）

#### 定义

函数或类型**对所有类型行为一致**，通过类型参数泛化实现。

#### 特点

- **行为与类型无关**；
    
- 可以用泛型写出统一算法或数据结构；
    
- Rust 中通常通过 **monomorphization** 静态生成实例。
    

#### Rust 示例

```rust
fn identity<T>(x: T) -> T {
    x
}

let a = identity(5);   
let b = identity("hi"); 
```

- 对不同类型行为完全一样；
    
- 编译器生成对应类型实例，无行为差异。
    

---

### 3. 子类型多态（Subtype Polymorphism / Inclusion Polymorphism）

#### 定义

基于**继承或接口实现的类型层次**，子类对象可以赋值给父类类型变量，运行时调用实际对象的方法。

#### 特点

- **动态分派**（通常使用 vtable）；
    
- 行为依赖运行时对象类型；
    
- 典型面向对象多态。
    

#### Rust 示例（trait 对象）

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
impl Draw for Circle {
    fn draw(&self) { println!("Circle"); }
}

struct Square;
impl Draw for Square {
    fn draw(&self) { println!("Square"); }
}

fn render(shape: &dyn Draw) {
    shape.draw();  // 动态分派，运行时确定调用
}

let c = Circle;
let s = Square;
render(&c);
render(&s);
```

- `&dyn Draw` 是 trait 对象（类似父类引用）；
    
- 调用 `draw` 时，实际类型决定行为；
    
- 有一定运行时开销，但可以实现高度抽象和动态行为。
    

---

### 4. 对比总结

|特性|特设多态 (Ad-hoc)|参数化多态 (Parametric)|子类型多态 (Subtype)|
|---|---|---|---|
|行为差异|每种类型可不同|对所有类型一致|运行时根据对象类型|
|实现方式|函数重载 / trait impl / type class|泛型 / template|继承 / trait 对象 / vtable|
|分派时间|编译期静态分派|编译期静态分派（monomorphization）|运行期动态分派|
|性能|高性能，无开销|高性能，零成本抽象|有少量运行时开销|
|适用场景|类型特定操作|泛型算法/数据结构|OOP 抽象、插件系统、动态接口|

---

### 5. Rust 的实践特点

- **特设 + 参数化混合**：泛型函数中通过 trait 提供类型特定实现；
- **子类型多态**：通过 trait 对象实现动态分派；
- Rust 中 trait 对象提供类似 OOP 的子类型多态，同时保证 trait 方法安全调用；
- 静态分派和动态分派可以灵活组合，实现零成本抽象或动态接口。
    
### 6. 学习方法论



    

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
