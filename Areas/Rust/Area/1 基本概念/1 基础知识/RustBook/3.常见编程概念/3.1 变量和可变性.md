### **声明变量关键字`let`**
#### 未初始化
- 声明变量，不初始化，不使用
- `let` **可以声明变量而不初始化，添加类型注解，让编译器可以推断类型，编译器会警告**
```rust
fn main() {
     let LOCAL_STATIC: i32;
     print!("1");
}
```
- 错误：warning: unused variable: `local`
- **故意声明了变量但没有使用解决方案**
	- 故意不使用某个变量，但不想看到这个警告
		-  1. **加“\_”** ：变量前加上可以让编译器不警告注明这是有意预留的变量
		- 2.`#[allow(unused_variables)]`：`#[allow(unused_variables)]` 是 **Rust 的属性（attribute）**，用于告诉编译器**不要对未使用的变量发出警告**。
			```rust
			#[allow(unused_variables)]
			fn main() {
			    let x = 1;
			}
			```
		- 范围：函数、模块、代码块

- **未初始化但使用会无法编译**

#### 变量绑定
- **let变量绑定**
	- 简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，**绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人**
    - 解构（Note: 解构式赋值只能在 Rust 1.59 或者更高版本中使用）
        - 在 [Rust 1.59](https://course.rs/appendix/rust-versions/1.59.html) 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了
#### 不可变
-  Rust 的变量在默认情况下是**不可变的**。
	- **再次分配不可变变量新值就会提示**：
		- consider making this binding mutable
			- 不能对不可变变量二次分配
			- **“绑定可变绑定”**（mutable binding）是指在某些编程语言中，**变量的绑定**（即变量与值的关联）是**可变的**，也就是说，可以在赋值后再次修改该变量的值。
- 注意点：**变量不能分配给与其原始类型不同类型的值**。
- 为什么这么设计：**不必自己追踪，降低心智负担，增加可读性**
	- 如果我们的代码的一部分在假设值永远不会改变的情况下运行，而代码的另一部分更改了该值，则代码的第一部分可能不会执行其设计目的。事后很难追查这种错误的原因，尤其是当第二段代码有时只更改值时。 **Rust 编译器保证，当你声明一个值不会改变时，它确实不会改变，所以你不必自己跟踪它。因此，您的代码更容易推理。**
	- 这种规则让我们的代码变得非常清晰，**只有你想让你的变量改变时，它才能改变，这样就不会造成心智上的负担**，也给别人阅读代码带来便利。
#### 可变
- 加mut