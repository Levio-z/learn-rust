---
tags:
  - permanent
---
## 1. 核心观点  

**array**
- **固定长度**
- 线性排列的同类型元素

我们将数组中的值写为方**括号内的逗号分隔列表**：
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

- **存储位置**：当您希望将数据分配在栈而不是堆上，或当您想确保始终具有**固定数量的元素**时
- **声明数组 `[T; N]` 时必须初始化所有元素。**  
	- 原因是：**数组长度是固定的，所有元素都必须在编译期具有确定的值**，Rust 不允许未初始化的内存存在于安全代码中。
	- [使用`[类型;数量]`声明数组](#使用`[类型;数量]`声明数组)
	- [使用`[初始值;长度]`初始化数组](#使用`[初始值;长度]`初始化数组)
- [Accessing Array Elements  访问数组元素](#Accessing Array Elements  访问数组元素)
- [Invalid Array Element Access无效的数组元素访问](#Invalid Array Element Access无效的数组元素访问)
	- 当您尝试使用索引访问元素时，Rust 将检查您指定的索引是否小于数组长度。如果索引大于或等于长度，Rust 就会panic。此检查必须在运行时进行，尤其是在这种情况下，因为编译器不可能知道用户稍后运行代码时将输入什么值。
- 
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 应用场景-月份
但是，当您知道元素数量不需要更改时，数组会更有用。例如，如果您在程序中使用月份的名称，您可能会使用数组而不是向量，因为您知道它始终包含 12 个元素：
```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];

```
### 使用`[类型;数量]`声明数组
您可以使用方括号、每个元素的类型、分号以及数组中元素的数量来编写数组的类型，如下所示：
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
`i32` 是每个元素的类型。分号后，数字 `5` 表示数组包含五个元素。
### 使用`[初始值;长度]`初始化数组
您还可以通过指定初始值、后跟分号、然后在方括号中指定数组的长度来初始化数组，使其每个元素包含相同的值，如下所示：

```rust
let a = [3; 5];
```

这与编写`let a = [3, 3, 3, 3, 3];`但以更简洁的方式。

### Accessing Array Elements  访问数组元素

数组是可以在堆栈上分配的已知固定大小的单个内存块。您可以使用索引访问数组的元素

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

### Invalid Array Element Access无效的数组元素访问

https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=b1f26f1ed78c05a9e32ee3e4396de35e
- 当您尝试使用索引访问元素时，Rust 将检查您指定的索引是否小于数组长度。如果索引大于或等于长度，**Rust 就会出现恐慌**。

### 数组元素为非基础类型的复制初始化

- ❌ 不能直接用 `["rust is good!"; 8]`
    
- **基本类型在 Rust 中赋值是以 Copy 的形式**，这时候你就懂了吧，`let array=[3;5]`底层就是不断的Copy出来的，但很可惜复杂类型都没有深拷贝，只能一个个创建。
    
- **正确的写法**，应该调用`std::array::from_fn`
    
    ```rust
    let array: [String; 8] = std::array::from_fn(|_i| String::from("rust is good!"));
    
    println!("{:#?}", array);
    ```
    

### 数组切片

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice: &[i32] = &a[1..3];

assert_eq!(slice, &[2, 3]);

```

上面的数组切片 `slice` 的类型是`&[i32]`，与之对比，数组的类型是`[i32;5]`

- 切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置
- 创建切片的代价非常小，因为切片只是针对底层数组的一个引用
- **数组类型容易跟数组切片混淆**，[T;n] 描述了一个数组的类型，而 [T] 描述了切片的类型， 因为**切片是运行期的数据结构，它的长度无法在编译期得知**，因此不能用 [T;n] 的形式去描述
- 切片类型 [T] 拥有不固定的大小，而切片引用类型 &[T] 则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此 &[T] 更有用，`&str` 字符串切片也同理

### 循环迭代数组

- **如果只是遍历元素**，用 `for n in a.iter()`，**安全且高效**。
- **如果需要索引**，用 `for (i, n) in a.iter().enumerate()`，**比索引方式更安全**。
- **如果数组是 `Vec<T>` 且要消耗它**，用 `for n in a.into_iter()`。
- **如果编译器优化掉边界检查，`for i in 0..a.len()` 可能更快**，但通常不推荐，需要索引才需要用。
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- 
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  

