---
tags:
  - note
---

## 1. 核心观点  
- **无固定内存地址，不占全局数据段**  
    `const` 本质是“编译期内联”，类似 C++ 的 `constexpr`。  
    编译器会在用到 `DIRS` 的地方直接复制这个数组字面量。
	- **不能取地址**  
	    因为没有统一的全局内存，`&DIRS` 不是一个固定指针，实际上每一处用法都可能是独立副本。
- **固定不可变**：**内容绝对不可变、不可写**  
    `const` 永远是编译期常量表达式。
- **更适合纯编译期计算**  
    如数组长度、泛型参数等 compile-time expressions。
- **每次内联更高效**
	- 常量仅仅是“替换文本”，不需要参与运行时逻辑。
- **常量和静态不可变变量一般大写**
- `const` 声明的常量 **必须在编译时确定类型**
	- Rust 的类型推导对 `const` 比对 `let` 更严格：**它不能依赖上下文推导类型**，必须明确常量类型
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
- 定义
	- 常数不仅仅是 **默认情况下是不可变的——它们始终是不可变的**。
- 使用：
	- **不允许将`mut`与常量一起使用**。
	- 您可以使用以下方式声明常量 `const`关键字而不是`let`关键字，并且值的类型必须被注释。
	- 常量**只能设置为常量表达式，而不是只能在运行时计算的值的结果**
	- 常量表达式：可以在编译时计算出结果。`const TWO: u32 = 1 + 1;`
- 范围：
	- 常量可以在任何范围内声明，包括全局范围，这使得它们对于代码的许多部分需要了解的值非常有用。    
## 示例：

`const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`

## 命名约定：

- Rust 的常量命名约定是全部大写，单词之间使用下划线。
- 可以选择以更容易理解和验证的方式写出该值
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
