---
tags:
  - permanent
---
## 1. 核心观点  

常量模式允许在模式匹配中使用常量值。例如：
```rust
const ZERO: i32 = 0;

match x {
    ZERO => println!("zero"),
    _ => println!("non-zero"),
}
```
在使用常量 `C` 作为模式时，Rust 首先要求其类型 `T` 实现 `PartialEq`，以保证模式匹配时能比较值相等性。
## 2. 背景/出处  
- 来源：https://doc.rust-lang.org/reference/patterns.html#constant-patterns
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
常量模式不仅要求 `PartialEq`，还要求“结构相等性”，即值在递归层面上可以逐字段比较是否相等。

1. **原始类型**
    
    - `i32`、`str`、`bool`、`char` 等总是具有结构相等。
        
2. **聚合类型**
    
    - 元组、数组、切片：所有元素必须具备结构相等。
        
    - 空元组 `()` 和空数组 `[]` 总是相等。
        
3. **引用类型**
    
    - 引用的目标值具有结构相等，则引用也相等。
        
4. **结构体和枚举**
    
    - 必须通过 `#[derive(PartialEq)]` 派生 PartialEq，且所有字段（枚举只看活动变体）具有结构相等。
        
5. **原始指针**
    
    - 仅在由常量整数定义后 cast/transmute 的情况具有结构相等。
        
6. **浮点数**
    
    - 非 NaN 的浮点值具有结构相等。
        
7. **其他情况**
    
    - 其他值均不具有结构相等性。

### 常量值必须在模式构建时就已知（pre-monomorphization）。
    
- 涉及泛型参数的关联常量不能用作模式。
### 不可变性要求
常量值不能包含对可变静态（`static mut` 或内部可变静态）或外部静态 (`extern`) 的引用。

### 转换
- 当所有条件满足后，常量会被直接翻译为对应模式。
    
- 其行为完全等价于手写该模式，并参与穷尽性检查。
```rust
const X: i32 = 5;

match n {
    X => println!("five"),
    _ => println!("other"),
}
// 在内部，编译器处理时等价于
match n {
    5 => println!("five"),
    _ => println!("other"),
}

```
- 对于原始指针，常量是唯一能写模式的方式，`_` 是唯一被视为穷尽的模式。
- 你不能直接写 `*const T` 的字面值作为模式，唯一可用的方式是用**常量指针**：
```rust
// 先定义一个 **常量指针**
// 除了这种常量，无法写其他形式的原始指针模式。
const PTR: *const i32 = &10 as *const i32;

match some_ptr {
    PTR => println!("matched"),
    _ => println!("not matched"),
}

```
`_` 是原始指针类型模式的唯一“穷尽”写法。

- 因为指针值理论上可以指向任意地址，没有办法列出所有可能值，编译器认为只有 `_` 才是“覆盖所有可能指针值”的穷尽模式。
## 4. 与其他卡片的关联  
- 前置卡片：
	- [Rust-模式-基本概念](Rust-模式-基本概念.md)
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 分类的原子笔记
- [ ] 实现的原子笔记
