---
tags:
  - permanent
---
## 1. 核心观点  

**绑定模式只有在默认绑定模式为“移动（move）”时，才可以显式指定 `ref` 或 `ref mut` 绑定mod**，或者用 `mut` 指定可变性。例如，以下情况是不被接受的：
```rust
let [mut x] = &[()]; //~ ERROR
let [ref x] = &[()]; //~ ERROR
let [ref mut x] = &mut [()]; //~ ERROR
```
>在 2024 版本之前，即使默认绑定模式不是“移动”，绑定也可以显式指定 `ref` 或 `ref mut` 绑定模式，并且它们可以使用 `mut` 指定此类绑定的可变性。在这些版本中，在绑定上指定 `mut` 会将绑定模式设置为“移动”，而不管当前默认绑定模式如何。

同样，仅当默认绑定模式为“移动”时，引用模式才会出现。例如，这是不接受的：
```rust
let [&x] = &[&()]; //~ ERROR
```

>在 2024 年版之前，即使默认绑定模式不是“移动”，引用模式也可能出现，并且既具有与被审查者匹配的效果，又具有导致默认绑定模式重置为“移动”的效果。

移动绑定和引用绑定可以在同一模式中混合在一起。这样做将导致绑定到的对象部分移动，并且之后无法使用该对象。仅当无法复制类型时，这才适用。

在下面的示例中，`name` 已移出 `person`。尝试将`人`作为一个整体或 `person.name` 使用会导致部分_移动_的错误。

```rust
// `name` is moved from person and `age` referenced
let Person { name, ref age } = person;
```

## 2. 背景/出处  
- 来源：https://rust-book.cs.brown.edu/ch06-02-match.html
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 简单示例
```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {state:?}!");
            25
        }
    }
}


```
- **此时，`state` 的绑定将是值 `UsState：：Alaska`**。
	- 然后，我们可以在 `println！` 表达式中使用该绑定，从而从 `Quarter` 的 `Coin` 枚举变体中获取内部状态值。

### 简单示例2：Option
```rust
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

```
将变量绑定到里面的数据，然后基于它执行代码


### 语法
接下来是`match`臂。臂有两部分：模式和一些代码。
- 模式：这里的第一个臂有一个模式，即值 `Coin：:P enny`，=
- 分隔符：然后是 `=>` 运算符，用于分隔模式和要运行的代码。
- 代码：本例中的代码 只是值 `1`。每个臂都用逗号与下一个臂分隔。
	- 与每个臂关联的代码是一个表达式，匹配臂中表达式的结果值是为整个`匹配`表达式返回的值。
	- 如果要在匹配臂中运行多行代码，则必须使用大括号，并且臂后面的逗号是可选的。

语法逻辑
- 当`匹配`表达式执行时，它会按顺序将结果值与每个臂的模式进行比较。**如果模式与值匹配，则执行与该模式关联的代码。如果该模式与值不匹配，则执行将继续到下一臂**，就像在硬币分类机中一样。我们可以根据需要拥有任意数量的手臂：在示例 6-3 中，我们的`匹配`有四个手臂。



## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [Rust-模式-模式分类-Non-reference patterns非引用模式](Rust-模式-模式分类-Non-reference%20patterns非引用模式.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  

