---
tags:
  - permanent
---
## 1. 核心观点  

- **用安全的方式显式处理null值，而不是用有值的方式处理非空值**：**用类型系统来表达这个概念意味着编译器可以检查您是否已经处理了应该处理的所有情况（null值的情况）**。[编译原理-null值的设计](../../../../../../basic/编译原理/null值的设计/编译原理-null值的设计.md)
- **避免我们有值的逻辑处理非空值**，从而使前面讨论的数十亿美元的错误变得不可能。
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 消除什么错误：**消除错误假设非空值的风险有助于你对代码更有信心**
- 您必须先将 `Option<T>` 转换为 `T`，然后才能对其执行 `T` 作。通常，避免**用非null的逻辑处理null值代码导致运行时错误**。
### 表现
由于 `Option<T>` 和 `T`（ `其中 T` 可以是任何类型）是不同的类型，因此编译器不允许我们使用 `Option<T>` 值，就好像它绝对是有效值一样。
	- 当我们在 Rust 中拥有像`i8`这样的类型的值时，编译器将确保我们始终拥有一个有效值。我们可以放心地继续，而不必在使用该值之前检查是否为 null。
	- 只有当我们拥有`Option<i8>` （或我们正在使用的任何类型的值）时，我们才需要担心可能没有值，并且编译器将确保我们在使用该值之前处理这种情况。

- 两个是不同的类型，无法一起计算
    
    ```
    let x: i8 = 5;
    let y: Option<i8> = Some(5);
    
    let sum = x + y;
    
    ```
    
- 太厉害了！实际上，这个错误信息意味着 Rust 无法理解如何添加`i8`和`Option<i8>` ，因为它们是不同的类型。
### 何时使用
**消除错误假设非空值的风险有助于你对代码更有信心**。为了具有可能为 null 的值，您必须通过将该值的类型设置为 `Option<T>` 来显式选择加入。 然后，当您使用该值时，您需要显式处理该案例 当值为 null 时。值具有非空() `Option<T>`， _可以_放心地假设该值不是空。这是 Rust 经过深思熟虑的设计决策，旨在限制 null 的普遍性并提高 Rust 代码的安全性。
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  

