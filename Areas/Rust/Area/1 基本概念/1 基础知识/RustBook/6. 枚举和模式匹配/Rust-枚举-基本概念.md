---
tags:
  - permanent
---
## 1. 核心观点  
- 基本定义：表达一个 value 是一组可能的值之一，**Rust允许将这些可能性编码为枚举**，枚举变体就是同一类型对的不同可能的值。
- 优点
	- 我们**将数据直接附加到枚举的每个变体，因此不需要额外的结构**。
	 - **每个变体可以具有不同类型和数量的关联数据**，**轻松地定义一个函数来接收任何这些类型的消息**。
 - 语法
	 - **可以将任何类型的数据放入枚举变体中**：例如，字符串、数字类型或结构。您甚至可以包含另一个枚举！此外，标准库类型通常不会比您可能想到的复杂多少。
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
- **变体（Variants）是什么？**
    **变体是枚举类型中定义的每一个具体的值或状态。它们是枚举类型的核心组成部分，用于表示枚举可以取到的所有可能值。变体可以是简单的标识符（无数据），也可以携带不同类型的数据。**
- 创建变体的实例/可以直接将数据放入枚举变体
	```
	let four = IpAddrKind::V4; 
	let six = IpAddrKind::V6;
	
	enum IpAddr { 
	V4(String), 
	V6(String), 
	} 
	let home = IpAddr::V4(String::from("127.0.0.1"));
	let loopback = IpAddr::V6(String::from("::1"));
	```
	- 每个枚举变体的名称也成为构造枚举实例的函数。也就是说， `IpAddr::V4()`是一个函数调用，它接受一个`String`参数并返回一个`IpAddr`类型的实例。我们自动获得这个构造函数的定义，这是定义枚举的结果。
- vs结构体：使用枚举而不是结构还有另一个优势：每个变体可以具有不同类型和数量的关联数据。
	```
	enum IpAddr {
	    V4(u8, u8, u8, u8),
	    V6(String),
	}
	
	let home = IpAddr::V4(127, 0, 0, 1);
	
	let loopback = IpAddr::V6(String::from("::1"));
	}
	```
- 嵌入多种数据类型
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
- 使用枚举而不是结构体的好处
但是如果我们使用不同的结构体，每个结构体都有自己的类型，我们就无法像示例 6-2 中定义的`Message`枚举那样轻松地定义一个函数来接收任何这些类型的消息，因为它只有一种类型。
- 枚举也可以定义方法
```rust
 impl Message {
        fn call(&self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
```

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [Rust-枚举-递归类型中大小如何计算](Rust-枚举-递归类型中大小如何计算.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  

