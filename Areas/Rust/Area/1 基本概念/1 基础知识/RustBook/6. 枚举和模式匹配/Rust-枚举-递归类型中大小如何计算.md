---
tags:
  - permanent
---
## 1. 核心观点  

Rust 会检查每个变体，看看哪个变体需要最多的空间。

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### Rust怎么确定空间大小
- 为了确定为`Message`值分配多少空间，Rust 会检查每个变体，看看哪个变体需要最多的空间。Rust 发现`Message::Quit`不需要任何空间， `Message::Move`需要足够的空间来存储两个`i32`值，等等。**因为只使用一个变体，所以`Message`值所需的最大空间是存储其最大变体所需的空间。**
- 这与 Rust 尝试确定递归类型（如示例 15-2 中的`List`枚举）需要多少空间时发生的情况形成对比。编译器首先查看`Cons`变量，它保存一个`i32`类型的值和一个`List`类型的值。因此， `Cons`需要的空间量等于`i32`的大小加上`List`的大小。要确定`List`需要多少内存 类型需要时，编译器会查看变体，从`Cons`开始 变体。Cons `Cons`体保存`i32`类型的值和 `List` ，这个过程无限地继续，如图15-1所示。
- ![](../15.智能指针/15.1Box/asserts/Pasted%20image%2020250604202437.png)
由于 Rust 无法计算出为递归定义的类型分配多少空间，因此编译器给出了以下有用建议的错误：
```
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +


```

在这个建议中， _间接_意味着我们应该**通过存储指向值的指针来更改数据结构以间接存储值**，而不是直接存储值。

因为 `Box<T>` 是一个指针，所以 Rust 总是知道 `Box<T>` 有多少空间 needs：指针的大小不会根据其数据量而变化 指向。这意味着我们可以将 `Box<T>` 放入 `Cons` 变体中，而不是直接将另一个 `List` 值放入其中。`Box<T>` 将指向下一个`列表` 值，该值将位于堆上而不是 `Cons` 变体中。从概念上讲，我**们仍然有一个列表，使用包含其他列表的列表创建，但这种实现现在更像是将项目彼此相邻放置，而不是彼此内部**。

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}

```

`Cons` 变体需要 `i32` 的大小加上存储盒子指针数据的空间。`Nil` 变体不存储任何值，因此它比 `Cons` 变体需要更少的空间。我们现在知道，任何 `List` 值都将占用 `i32` 的大小加上框的指针数据的大小。通过使用一个盒子，我们打破了无限的递归链，因此编译器可以计算出存储 `List` 值所需的大小。图 15-2 显示了 `Cons` 变体现在的样子。
![A finite Cons list](https://rust-book.cs.brown.edu/img/trpl15-02.svg)

图 15-2：一个不是无限大小的`列表` ，因为 `Cons` 包含一个 `Box`
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  

