---
tags:
  - permanent
---


## 1. 核心观点  

`Deref` 是 Rust 为“自定义解引用行为”提供的核心特征，用于让你的类型在**使用 `*` 运算符或隐式解引用（比如方法调用、字段访问）时，表现为“某种引用”**。
- [字段访背后的原理](#背后的原理)，实现自定义类型像引用一样使用**：允许智能指针（如 `Box<T>`、`Rc<T>`、`Arc<T>`）像普通引用一样访问内部数据
- [[# 隐式解引用规则生效（Deref coercion）]]


### `*`背后的原理
- `*`背后的原理：[1.0 Deref Trait 源码和原理（星号背后如果有deref会做什么事情？）](1.0%20Deref%20Trait%20源码和原理（星号背后如果有deref会做什么事情？）.md)
	- *String =>*String.deref =>*(&str)=>**str**

### 引用归一化

如果是一个智能指针或者 `&&&&v` 类型的呢？ 该如何对这两个进行解引用？

答案是：Rust 会在解引用时自动把智能指针和 `&&&&v` 做引用归一化操作，转换成 `&v` 形式，最终再对 `&v` 进行解引用：
- 把智能指针（比如在库中定义的，Box、Rc、Arc、Cow 等）从结构体脱壳为内部的引用类型，也就是转成结构体内部的 `&v`
- 把多重`&`，例如 `&&&&&&&v`，归一成 `&v`
在这段源码中，`&T` 被自动解引用为 `T`，也就是 `&T: Deref<Target=T>` 。 按照这个代码，`&&&&T` 会被自动解引用为 `&&&T`，然后再自动解引用为 `&&T`，以此类推， 直到最终变成 `&T`。



###  隐式解引用规则生效（Deref coercion）
在函数参数、方法调用、字符串转换等上下文中自动插入 `deref()`。
#### 支持连续的隐式转换
- Rust 会分析该类型并且连续使用 `Deref` 直到最终获得一个引用来匹配函数或者方法的参数类型，这种行为完全不会造成任何的性能损耗，因为完全是在编译期完成。
- 隐式deref转换：[Rust-自动解引用-方法调用&&方法接收器](../../../../2%20进阶/2.1%20所有权、生命周期和内存系统/2.1.3%20生命周期和引用/引用机制/Rust-自动解引用/Rust-自动解引用-方法调用&&方法接收器.md)
#### 缺点
- 但是 `Deref` 并不是没有缺点，缺点就是：如果你不知道某个类型是否实现了 `Deref` 特征，那么在看到某段代码时，并不能在第一时间反应过来该代码发生了隐式的 `Deref` 转换。事实上，不仅仅是 `Deref`，在 Rust 中还有各种 `From/Into` 等等会给阅读代码带来一定负担的特征。还是那句话，一切选择都是权衡，有得必有失，得了代码的简洁性，往往就失去了可读性，Go 语言就是一个刚好相反的例子。
#### self类型的参数什么时候可以使用
- [Deref Trait 原理 - 方法调用隐式自动解引用 - self move](Deref%20Trait%20原理%20-%20方法调用隐式自动解引用%20-%20self%20move.md)
### 三种Deref转换
[Deref Trait - Deref 转换](Deref%20Trait%20-%20Deref%20转换.md)
## 2. 背景/出处  

- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 定义
```
fn deref(&self) -> &Self::Target;
```
其中 `Target` 表示“解引用后得到的实际类型”。




## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [1.0.2 Rust-智能指针的Deref设计](../15.1Box/1.0.2%20Rust-智能指针的Deref设计.md)
	- [2.0 如何使用Deref](2.0%20如何使用Deref.md)
	- [Rust-自动解引用-Deref语义继承](../../../../2%20进阶/2.1%20所有权、生命周期和内存系统/2.1.3%20生命周期和引用/引用机制/Rust-自动解引用/Rust-自动解引用-Deref语义继承.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
