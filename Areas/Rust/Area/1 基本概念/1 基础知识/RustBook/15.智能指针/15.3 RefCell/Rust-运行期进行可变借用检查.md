---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层
- 在运行时检查借用规则的优势在于，**它允许某些内存安全的场景，而这些场景在编译时检查中会被禁止**
- **由于某些分析无法实现，如果 Rust 编译器无法确定代码是否符合所有权规则，它可能会拒绝一个正确的程序**
### Ⅱ. 实现层

### Ⅲ. 原理层

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 编译时检查vs运行时检查
在编译时检查借用规则的优势在于，可以在开发过程中**更早地发现错误，并且由于所有分析都已预先完成，因此不会影响运行时性能**。基于这些原因，在大多数情况下，编译时检查借用规则是最佳选择，这也是 Rust 的默认设置。

在运行时检查借用规则的优势在于，**它允许某些内存安全的场景，而这些场景在编译时检查中会被禁止**。静态分析（如同 Rust 编译器一样）本质上是保守的。代码的某些属性无法通过代码分析来检测：最著名的例子是停机问题，这超出了本书的讨论范围，但是一个值得深入研究的有趣课题。

### 解决编译期间静态检查的瓶颈
**由于某些分析无法实现，如果 Rust 编译器无法确定代码是否符合所有权规则，它可能会拒绝一个正确的程序**；从这个意义上讲，Rust 是一种保守的做法。如果 Rust 接受了错误的程序，用户就无法信任 Rust 所做的保证。然而，如果 Rust 拒绝了一个正确的程序，程序员会感到不便，但不会发生灾难性的事情。当**您确信自己的代码遵循借用规则，但编译器无法理解和保证这一点时， `RefCell<T>` 类型就非常有用**。
### 报错play ground案例

https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=9eb9ee4bf73eb6f7891cbf83ff5b0f7e

- 请注意，代码出现了 panic，并返回了消息 `already borrowed: BorrowMutError` 。这是 `RefCell<T>` 在运行时处理借用规则违规的方式。
### 设计核心，运行时借用检查
- `RefCell<T>` 并不能完全绕过借阅规则：借阅检查器 编译器允许这种内部可变性，并且会检查借用规则。 而是在运行时进行。如**果违反规则，将会抛出 `panic!` 而不是编译器错误**。
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
