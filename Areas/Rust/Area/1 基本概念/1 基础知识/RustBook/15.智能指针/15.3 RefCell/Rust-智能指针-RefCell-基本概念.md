---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层

`RefCell` 主要用于在 Rust 中实现**结构体内部字段的可变性**。

### Ⅱ. 应用层
- **应用场景：跟踪在只允许使用不可变值的上下文中使用它**。
    - 在一个不可变借用，内部可变借用的修改一个字段，外部仍是不可变的借用
- 使用注意事项：
	- 不适合多线程
	- 借用规则运行期强制执行
	- **开发后期发现错误以及运行时性能略微下降**
- 案例：[Rust-智能指针-内部可变性-案例](Rust-智能指针-内部可变性-案例.md)

### Ⅲ. 实现层

- **unsafe封装不安全**：内部可变性的实现是因为 Rust 使用了 `unsafe` 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些**不安全代码都被封装到了安全的 API** 中
	- 内部可变性：使用`unsafe` ，允许你拥有不可变引用同时改变数据，即某些情况下需要一个值在其方法内部能够修改自身，但对其他代码而言却保持不可变状态。
-  **在运行时检查**：
	- **借用规则在运行时强制执行**：对于引用和 `Box<T>` ，借用规则的不变式在编译时强制执行。对于 `RefCell<T>` ，这些不变式_在运行时_强制执行。 使用引用时，如果违反这些规则，就会出现编译器错误。 `RefCell<T>` ，如果您违反这些规则，您的程序将崩溃并退出。
	- **开发后期发现错误以及运行时性能略微下降**：选择在运行时而非编译时捕获借用错误（就像我们这里所做的那样）意味着你可能会在开发过程的后期才发现代码中的错误：甚至可能要等到代码部署到生产环境后才会发现
### **IV**.原理层

- [Rust-设计模式-内部可变性-基本概念](../../../../4%20设计模式/Rust-设计模式-内部可变性-基本概念.md)
- [Rust-智能指针-内部可变性-案例](Rust-智能指针-内部可变性-案例.md)
- [Rust-运行期进行可变借用检查](Rust-运行期进行可变借用检查.md)
- [Rust-智能指针-RefCell-与多所有者Rc结合](Rust-智能指针-RefCell-与多所有者Rc结合.md)

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  



### 多线程

与 `Rc<T>` 类似， `RefCell<T>` 仅适用于单线程场景，如果在多线程环境中使用，将会产生编译时错误。我们将在第 16 章讨论如何在多线程程序中使用 `RefCell<T>` 的功能。

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
