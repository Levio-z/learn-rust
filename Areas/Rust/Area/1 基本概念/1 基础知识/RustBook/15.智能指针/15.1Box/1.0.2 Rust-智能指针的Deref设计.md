

## 1. 核心观点  

语法：最直接的[智能指针](../15.0%20智能指针基本概念/Rust-智能指针-基本概念.md)是一个Box，其类型写为 Box<\T> 。

功能：只提供**间接寻址和堆分配；
- Box 允许您将数据存储在堆上而不是堆栈上。
- 堆栈上剩余的是指向堆数据的指针。

[2.0 Rust-如何使用Box](2.0%20Rust-如何使用Box.md)
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

- 常规引用是一种指针类型，包含了目标数据存储的内存地址。对常规引用使用 `*`操作符，就可以通过解引用的方式获取到内存地址对应的数据值：

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
     // 下面一行代码将报错
    // let b = a + 1; // cannot add `{integer}` to `Box<{integer}>`
}
```
- 智能指针往往都实现了 `Deref` 和 `Drop` 特征，因此：
    - `println!` 可以正常打印出 `a` 的值，是因为它隐式地调用了 `Deref` 对智能指针 `a` 进行了解引用
	    - 机制：Rust 为函数参数做了 Deref 自动解引用（Deref coercion）
	    - **自动解引用（auto-deref）**  通常发生在：
		    - 函数/方法参数传递
		    - `.` 运算访问字段或方法
    - 最后一行代码 `let b = a + 1` 报错，是因为在表达式中，我们无法自动隐式地执行 `Deref` 解引用操作，你需要使用  操作符 `let b = *a + 1`，来显式的进行解引用
    - `a` 持有的智能指针将在作用域结束（`main` 函数结束）时，被释放掉，这是因为 `Box<T>` 实现了 `Drop` 特征
总结：`Box<T>`类型是一个智能指针，因为它实现了`Deref`特性，允许将`Box<T>`值视为引用。当`Box<T>` 值超出范围，box 指向的堆数据将被清除 由于`Drop`特征的实现，这两个特征也同样重要。

## 4. 与其他卡片的关联  
- 前置卡片：
	- [Rust-智能指针-基本概念](../15.0%20智能指针基本概念/Rust-智能指针-基本概念.md)
- 后续卡片：
	- [1.0 Deref Trait 基本概念](../15.2%20Deref%20Trait/1.0%20Deref%20Trait%20基本概念.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
