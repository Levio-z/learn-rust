---
tags:
  - permanent
---
## 1. 核心观点  

消费掉 Box 并且强制目标值从内存中泄漏


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

Box::leak
- Box::leak，它可以消费掉 Box 并且强制目标值从内存中泄漏
你可以把一个 String 类型，变成一个 'static 生命周期的 &str 类型：
```rust
fn main() {
   let s = gen_static_str();
   println!("{}", s);
}

fn gen_static_str() -> &'static str{
    let mut s = String::new();
    s.push_str("hello, world");

    Box::leak(s.into_boxed_str())
}
```

- **'static 生命周期的往往都是编译期就创建的值，Box::leak 就可以将一个运行期的值转为 'static**
	- 在之前的代码中，如果 `String` 创建于函数中，那么返回它的唯一方法就是转移所有权给调用者 `fn move_str() -> String`，而通过 `Box::leak` 我们不仅返回了一个 `&str` 字符串切片，它还是 `'static` 生命周期的！
	- 要知道真正具有 `'static` 生命周期的往往都是编译期就创建的值，例如 `let v = "hello, world"`，这里 `v` 是直接打包到二进制可执行文件中的，因此该字符串具有 `'static` 生命周期，再比如 `const` 常量。
	- 又有读者要问了，我还可以手动为变量标注 `'static` 啊。其实你标注的 `'static` 只是用来忽悠编译器的，但是超出作用域，一样被释放回收。而使用 `Box::leak` 就可以将一个运行期的值转为 `'static`。


### 使用场景

**你需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久，那么就可以使用 Box::leak，例如有一个存储配置的结构体实例，它是在运行期动态插入内容，那么就可以将其转为全局有效**，虽然 Rc/Arc 也可以实现此功能，但是 Box::leak 是性能最高的。
#### 跨线程共享的静态资源（无 Arc）
当资源只写一次且只读，使用 `Box::leak` 可节省 Arc 开销：
```
static GLOBAL: OnceLock<&'static Data> = OnceLock::new();

GLOBAL.set(Box::leak(Box::new(init_data()))).unwrap();
```
应用：
- 高性能服务器中全局路由表
- 机器学习模型加载至常驻内存
- 数据库连接池配置
#### 创建全局可变静态对象（无锁单例）
适合数据结构：初始化一次，之后只读或少量修改。

示例：
```rust
static mut CONFIG: Option<&'static Config> = None;

fn init() {
    let cfg = Config { port: 8080 };
    unsafe {
        CONFIG = Some(Box::leak(Box::new(cfg)));
    }
}

```

应用：
- 嵌入式系统无 `lazy_static!`、`OnceLock` 时的全局配置
- 无 std 场景（OS 内核、bootloader）做静态表
- 构建无锁全局常量表（如字符分类表、解析器状态表）

#### 存储大型查找表避免拷贝（编译期构建 → 运行期静态）
```rust
let table = compute_big_table();
let TABLE: &'static BigTable = Box::leak(Box::new(table));
```
常用于：

- parser 状态机表
    
- DFA/Regex 状态表
    
- 关键字 hash table
    
- 游戏开发中的 prefab、tile map 数据

#### 在运行时构建必须是 `'static` 的回调 / trait 对象
```rust
let handler: &'static mut dyn Handler = Box::leak(Box::new(MyHandler {}));
register(handler);

```
适用点：

- FFI 回调必须提供 `'static` 指针
    
- 异步 executor 注册 `'static` future
    
- WebAssembly host function 注册 `'static` 函数表
#### OS / Runtime 内核开发：手动管理全局堆对象

你经常写 OS，以下特别常见：

- 内核 MMU/页表需要一个 `'static` PageTable
    
- scheduler 需要固定地址的 Task struct
    
- SBI/中断向量表需要 `'static` 函数表
    

例如内核任务控制块（TCB）：

```rust
let tcb = Box::new(TaskControlBlock::new());
let tcb_ref: &'static mut TCB = Box::leak(tcb);
// 后续调度器长期持有
```
`Box::leak` 最大的优势：**不会被 Rust 借用检查器限制生命周期**。

### 典型误用场景（必须避免）

1. **伪造全局可变数据导致数据竞争**  
    `'static mut` 本质就是全局可变变量，需要同步。
    
2. **频繁调用导致真正的内存泄漏**  
    每调用一次，就泄漏一个对象。适用于“只初始化一次”的对象。
    
3. **使用 `Box::leak` 创建循环引用 → 永不释放**  
    会导致程序常驻内存急剧上升。
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  


