https://docs.rs/volatile/latest/volatile/

为原始指针提供易失性包装器类型。

此 crate 中的易失性包装器类型包装指向任何[`可复制`](https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html "trait core::marker::Copy")类型的指针，并提供对包装值的易失性内存访问。编译器永远不会优化易失性内存访问，并且在许多低级系统编程和并发上下文中很有用。
>在易失性内存访问中，编译器无法优化对这些值的访问，因此每次读取和写入都必须直接操作内存。如果是非 `Copy` 类型，且其中的资源（如指针、堆内存等）未正确管理，可能会在异步或并发访问时引发未定义行为。
>Rust 中的非 `Copy` 类型（如 `Box`、`Vec` 等）是通过所有权机制来管理内存的。将这些类型包装为易失性类型可能会导致多个地方同时拥有对同一资源的所有权，从而导致内存错误（如双重释放、野指针等）。例如，如果你在多个地方访问一个 `Vec`，而它在一个地方被销毁或重新分配内存，那么在另一个地方访问它时就会遇到未定义的行为。

该 crate 提供两种不同的包装器类型：[`VolatilePtr`](https://docs.rs/volatile/latest/volatile/struct.VolatilePtr.html "struct volatile::VolatilePtr") 和 [`VolatileRef`](https://docs.rs/volatile/latest/volatile/struct.VolatileRef.html "struct volatile::VolatileRef")。这两种类型之间的区别在于，前者的行为类似于原始指针，而后者的行为类似于 Rust 引用类型。
- 由于 `VolatilePtr` 的行为类似于原始指针，它可以像普通指针一样被复制。但是，**不能跨线程传递**这个指针。这是因为传递原始指针可能会导致“可变别名”（mutable aliasing），即多个地方对同一内存位置进行修改，导致数据竞争和不安全的行为。
	- 例如，`VolatilePtr` 可能会在多个线程中访问同一内存位置，这就可能引发并发安全问题，因此它不能被发送到其他线程。
	- 例如，`VolatilePtr` 可以自由复制，但不能跨线程发送，因为这可能会引入可变的别名。`VolatileRef` 另一方面，类型需要对突变进行独占访问，以便跨 线程边界是安全的。
- VolatileRef
	- `VolatileRef` 与 `VolatilePtr` 类似，但是它的行为更接近 Rust 的引用类型（`&T`）。它要求对包装的值进行**独占访问**，这意味着只有一个线程或一部分代码可以在某一时刻访问或修改该值。
	- 由于 `VolatileRef` 必须具有独占的访问权限，它可以安全地跨线程传递，因为它确保对值的突变（mutability）是独占的，因此避免了并发访问中的可变别名问题。
	- `VolatileRef` 适用于需要确保只有一个线程能够修改数据的场景，可以通过它实现线程安全的易失性内存访问。


这两种包装器类型_都不_强制执行任何原子性保证;要获得原子性，请考虑查看 `libcore` 或 `libstd` 中的`原子`包装器类型。


