```rust
    // 测试 VolatileRef 借用操作

    #[test]

    fn test_volatile_ref_borrow_mut() {

        let mut data = 42u32;

        let mut volatile_ref = VolatileRef::from_ref(&mut data);

  

        // 可变借用并修改数据

        let mut borrowed_mut = volatile_ref.borrow_mut();

  

        // 下面这行代码如果取消注释会导致编译错误，因为 data 已经被借用为可变引用

        // data = 18;

        //   ^^^^^^^^^ `data` is assigned to here but it was already borrowed

  

        borrowed_mut.as_mut_ptr().write(100); // 通过 VolatilePtr 写入数据

  

        // 确认修改后的数据

        assert_eq!(data, 100);

    }
```
报错：
```rust
error[E0271]: type mismatch resolving `<ReadOnly as RestrictAccess<WriteOnly>>::Restricted == WriteOnly`
   --> volatile-lab/src/volatile_ref.rs:18:35
    |
 18 |         borrowed_mut.as_mut_ptr().write(100); // 通过 VolatilePtr 写入数据
    |                                   ^^^^^ expected `WriteOnly`, found `NoAccess`
    |
    = note: required for `ReadOnly` to implement `Writable`
note: required by a bound in `volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'a, T, A>>::write`
   --> /home/l/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/volatile-0.6.1/src/volatile_ptr/operations.rs:114:12
```
- 这表示在尝试使用 `VolatilePtr` 执行写入作时，存在与访问级别相关的类型不匹配。让我详细解释一下这个错误。
- 线索
	- `ReadOnly` 和 `WriteOnly` 可能是 `RestrictAccess` 特征中定义的类型或访问模式。
	- 该错误表示 `ReadOnly` 应被视为 `WriteOnly` 类型，但它解析为 `NoAccess`，这表示没有读取或写入的访问权限。
	- Rust 编译器需要 `WriteOnly` 访问以允许写入指针，但在检查 `RestrictAccess` 特征的 `Restricted` 类型时，它会找到 `NoAccess`。`NoAccess`**：这可能意味着您借用的 `VolatileRef` 不允许任何类型的访问（读取或写入）。
### 查看构造相关方法
VolatilePtr结构体定义
```rust
pub struct VolatilePtr<'a, T, A = ReadWrite>
```
from_ref
- 从引用构造会调用底层方法
```rust
pub fn from_ref(reference: &'a T) -> VolatileRef<'a, T, ReadOnly>

    where

        T: 'a,

    {

        unsafe { VolatileRef::new_restricted(ReadOnly, reference.into()) }

    }
```
底层方法
- 该函数是类型 `A` （`<A>`） 的泛型函数，其中 `A` 是通常受某些特征绑定约束的类型参数，它表示 `VolatileRef` 的**访问类型** 。
```rust
    pub const unsafe fn new_restricted<A>(access: A, pointer: NonNull<T>) -> VolatileRef<'a, T, A>
    where
        A: Access,
    {
        let _ = access;
        unsafe { Self::new_generic(pointer) }
    }
```
- `access` 参数被传递到函数中，但它不直接用于函数体（它只是 `_ = access;`，这实际上丢弃了它）。让我们逐步分解一下，以了解`为什么存在 access` 参数以及为什么不在此特定函数中使用它。
- `Access`).`access` 是类型 `A` 的参数，其中 `A` 被约束为实现 `Access` 特征（`A：Access`）。
- 下划线 `_` 用于显式丢弃值。在这种情况下，它表明 `access` 参数实际上并未在函数体中使用。这样做的目的可能是：
	- **指示意图** ：对于类型检查或文档目的， `访问`值在签名中可能很重要，但在运行时实际上并不需要它。
	- **供将来使用的占位符** ： `访问`参数可能旨在供将来在实现中使用，但目前没有必要。这可能发生在正在开发的代码中，其中功能可能已规划但尚未实现。
new_generic
```rust
    const unsafe fn new_generic<A>(pointer: NonNull<T>) -> VolatileRef<'a, T, A> {

        VolatileRef {

            pointer,

            reference: PhantomData,

            access: PhantomData,

        }

    }
```

```rust
pub struct VolatileRef<'a, T, A = ReadWrite>

where

    T: ?Sized,

{

    pointer: NonNull<T>,

    reference: PhantomData<&'a T>,

    access: PhantomData<A>,

}
```
- 这意味着类型 `A`（可能是调用此方法的对象的类型）必须实现`可写特征` 。 `可写特征`可能表示`允许 A` 对其底层内存或资源执行写入作。此特征用于强制只有支持写入的类型才能调用此方法。


- 得出一个结论，调用from_ref会给VolatileRef添加ReadOnly标记
### 查看访问的方法
```rust
 pub fn write(self, value: T)

    where

        T: Copy,

        A: Writable,

    {

        unsafe { ptr::write_volatile(self.pointer.as_ptr(), value) };

    }
```
写入的时候是要求Writable的

Writable是什么
```rust
pub trait Writable: Access {}
impl<A: RestrictAccess<WriteOnly, Restricted = WriteOnly>> Writable for A {}
```
此实现意味着： **任何可以限制为 `WriteOnly` 而不更改其行为的类型 `A`（即，受限制的类型仍然是 `WriteOnly`）都被视为`可写。`**

```rust
pub trait RestrictAccess<To>: Access {

    /// The resulting [`Access`] type of `Self` restricted to `To`.

    type Restricted: Access;

}
```

#### 限制特征
```rust
pub trait RestrictAccess<To>: Access {

    /// The resulting [`Access`] type of `Self` restricted to `To`.

    type Restricted: Access;

}
```
该特征用于将一个 [`Access`] 类型限制为另一个 [`Access`] 类型。

限制 `Self` 到 `To` 会产生 [`Self::Restricted`] 类型。

限制是一个对称操作，用 ∩ 来表示，表示权限的交集。以下表格展示了不同类型之间的限制关系：

| `Self`        | `To`          | `Self` ∩ `To` |
| ------------- | ------------- | ------------- |
| `T`           | `T`           | `T`           |
| [`ReadWrite`] | `T`           | `T`           |
| [`NoAccess`]  | `T`           | [`NoAccess`]  |
| [`ReadOnly`]  | [`WriteOnly`] | [`NoAccess`]  |
```rust
impl<To: Access> RestrictAccess<To> for ReadWrite {

    type Restricted = To;

}
```
- 对于ReadWrite，实现了RestrictAccess这个泛型，对于TO这个泛Access泛型
- 它的关联类型是To
#### 例子
```rust
`RestrictAccess<WriteOnly>` 是一种特征约束，它要求类型 `Self`（例如 `ReadOnly`）能够限制为 `WriteOnly`。换句话说，我们需要检查 `ReadOnly` 类型与 `WriteOnly` 类型的交集。
```
交集和限制：
- `RestrictAccess` 会返回一个 `Restricted` 类型，表示限制后的结果。
- 在这里，编译器尝试解析 `<ReadOnly as RestrictAccess<WriteOnly>>::Restricted`，它表示 `ReadOnly` 类型限制到 `WriteOnly` 后的结果。
**`ReadOnly` 与 `WriteOnly` 的交集**：
- `ReadOnly` 只能进行读取操作，而 `WriteOnly` 只能进行写入操作。它们没有交集，因此限制后的结果应该是 `NoAccess`，即两者权限的交集是“无权限”。
    
- 如果你的代码期望 `Restricted` 是 `WriteOnly`，那么这就产生了类型不匹配，因为限制后的类型实际是 `NoAccess`，而不是 `WriteOnly`。


#### 分析
A: Writable,
也就是对于A，也就是传入的accesss需要实现Writable

```rust
impl<A: RestrictAccess<WriteOnly, Restricted = WriteOnly>> Writable for A {}
```

具体元组
- 对于to也就是限制  **WriteOnly** 我的关联类型也就是最终的访问权是WriteOnly

而Readonly带入，当限制是WriteOnly，Restricted是NoAccess

`ReadOnly` to implement `Writable`

#### 编译器
```rust
error[E0271]: type mismatch resolving `<ReadOnly as RestrictAccess<WriteOnly>>::Restricted == WriteOnly`
```
- 编译器尝试解决 `RestrictAccess<WriteOnly>` 对于 `ReadOnly` 类型的 `Restricted` 类型，但是它得到了与 `WriteOnly` 不匹配的结果。对于你提供的错误，编译器在检查 `ReadOnly` 类型是否可以被限制为 `WriteOnly` 类型时发生了问题。

### 全局接口
