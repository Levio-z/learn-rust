>https://keats.github.io/tera/docs/


### 加载模板
#### 编译
编译模板是一个只发生一次的步骤：使用类似 [lazy_static](https://crates.io/crates/lazy_static) 以定义常量实例。
```rust
use std::sync::LazyLock;

use std::collections::HashMap;

use tera::{Tera, Context, Result as TeraResult, Value};

  

// Custom filter example: does nothing

fn do_nothing_filter(value: &Value, _: &HashMap<String, Value>) -> TeraResult<Value> {

    Ok(value.clone())

}

  

// Global template singleton

pub static TEMPLATES: LazyLock<Tera> = LazyLock::new(|| {

    let mut tera = match Tera::new("templates/**/*") {

        Ok(t) => t,

        Err(e) => {

            eprintln!("Parsing error(s): {}", e);

            std::process::exit(1);

        }

    };

  

    tera.autoescape_on(vec![".html", ".sql"]);

    tera.register_filter("do_nothing", do_nothing_filter);

  

    tera

});

  

fn main() {

    // Build template context

    let mut context = Context::new();

    context.insert("name", "World");

  

    // Render template

    match TEMPLATES.render("hello.html", &context) {

        Ok(output) => println!("{}", output),

        Err(err) => eprintln!("Template error: {}", err),

    }

}
```
#### globs
```
Tera::new("templates/**/*")
```

>如果您使用的是 globs，Tera 将自动从模板名称中删除 glob 前缀

- `"templates/**/*"` 是 **glob 模式**，表示递归加载 `templates` 目录下所有模板文件
- Tera 会 **去掉 glob 前缀**，把每个文件的路径转换为模板名称


上下文可以是实现 `serde_json` `Serialize` 特征的数据结构，也可以是 `tera：：Context` 的实例：
```rust
use tera::Context;
// Using the tera Context struct
let mut context = Context::new();
context.insert("product", &product);
context.insert("vat_rate", &0.20);
tera.render("products/product.html", &context)?;

#[derive(Serialize)]
struct Product {
    name: String
}
// or a struct
tera.render("products/product.html", &Context::from_serialize(&product)?)?;
```

### 自动转义

默认情况下，Tera 将自动转义以 `“.html”、“``.htm”` 和 `“.xml”` 结尾的文件中的所有内容。转义遵循 [OWASP](https://www.owasp.org/index.php/XSS_\(Cross_Site_Scripting\)_Prevention_Cheat_Sheet) 的建议。