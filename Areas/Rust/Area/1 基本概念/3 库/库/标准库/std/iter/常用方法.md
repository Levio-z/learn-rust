#### 常用方法
#### zip


`zip(bfn.iter())`**：将两个迭代器 "压缩" 成一个新的迭代器，每次产生一个元组 `(x, y)`，其中 `x` 来自 `afn` 的迭代器，`y` 来自 `bfn` 的迭代器。
```rust
let prefix_cmp = afn                 
.iter()                 
.zip(bfn.iter())                 
.find_map(|(x, y)| if x != y { Some(x.cmp(y)) } else { None });
```
- 比较两个字节切片的相同部分
#### find_map
**作用**：遍历迭代器，对每个元素应用一个返回 `Option` 的函数，**找到第一个使函数返回 `Some(value)` 的元素**，并返回这个 `Some(value)`；如果所有元素都返回 `None`，则返回 `None`。
**特点**：
- 是 `find` 和 `map` 的结合：既 “查找”（提前终止），又 “转换”（返回 `Option` 中的值）。
- 遍历到第一个满足条件（函数返回 `Some`）的元素后会**立即停止遍历**，不会处理后续元素。
- 最终返回的是 `Option<T>`（`T` 是 `Some` 中包裹的类型），而不是迭代器。

```rust
let numbers = [1, 3, 4, 5, 6];
let result = numbers.iter().find_map(|&x| {
    if x % 2 == 0 {
        Some(x * x)  // 找到第一个偶数，返回其平方（终止遍历）
    } else {
        None  // 不是偶数，继续遍历
    }
});
// result 结果：Some(16)（只处理到元素 4 就停止了）
```
### filter_map

```rust
let vec = vec.into_iter()
    .filter_map(|x| x) // 直接解包 Some，None 自动丢弃
    .collect::<Vec<_>>();
```