---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层

内部可变性是 Rust 中的**一种设计模式**，它**允许你修改内部结构。**
- **即使存在对该数据的不可变引用**，数据仍然会被保存；通常情况下，这 借用规则不允许此操作。要修改数据，该模式使用 在数据结构内部编写 `unsafe` 代码，是为了规避 Rust 通常关于数据修改和借用规则的规定。不安全代码会告诉编译器，我们正在手动检查这些规则，而不是依赖编译器自动检查；我们将在第 20 章详细讨论不安全代码。

- 此时，相关的 `unsafe` 代码会被封装在一个安全的 API 中，而外部类型仍然是不可变的。
### Ⅱ. 实现层

- 所以，实现 **内部可变性** 的 `Cell` 和 `RefCell` 正是为了解决诸如这类问题存在的，通过它们可以实现 `struct` 部分字段可变，而不用将整个 `struct` 设置为 `mutable`。
### 借用规则为何不允许该行为

- 在 Rust 中，**可变性是作用于整个绑定或引用的**，而不是单独字段。由于 `Rust` 的 `mutable` 特性，一个结构体中的字段，要么全都是 `immutable`，要么全部是 `mutable`，**不支持针对部分字段进行设置**。
	- 当你声明一个结构体实例为 `let mut s = MyStruct { ... };` 时，`s` 的所有字段都是可变的；
	- 如果 `s` 是不可变的（`let s = MyStruct { ... };`），那么所有字段都是不可变的。
	- 比如，在一个 `struct` 中，**可能只有个别的字段需要修改，而其他字段并不需要修改**，如果为了修改一个字段就将整个结构体标记为 `mut`，会**放宽了原本不应被修改的字段可变性**，增加潜在错误风险。

Rust 的核心借用规则：
- 任意时刻，要么存在**一个可变引用**，要么存在**多个不可变引用**；
- 不可变引用保证观察到的数据不会变化。
内部可变性**显式违背第二条的直觉语义**：即使只有 `&T`，内部数据也可能发生变化。因此，这种能力**不能由编译期借用检查自动保证**。

 

### Ⅲ. 原理层

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
详细阐述这个观点，包括逻辑、例子、类比。  
- 要点1  
- 要点2  

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
