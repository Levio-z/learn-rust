对于上面这个被移除标准库的应用程序，通过了Rust编译器的检查和编译，形成了二进制代码。但这个二进制代码的内容是什么，它能否在RISC-V 64计算机上正常执行呢？为了分析这个二进制可执行程序，首先需要安装 cargo-binutils 工具集：

```java
cargo install cargo-binutils
rustup component add llvm-tools-preview
```
[cargo-binutils](../../../2.7%20模块组织、工具和文档/cargo-binutils/cargo-binutils.md)

```java
文件格式
file target/riscv64gc-unknown-none-elf/debug/os
// ELF 64 位 ：文件采用 ELF（可执行和可链接格式）并且是 64 位，这意味着它以 64 位系统为目标。
// 这表示系统的字节序。在这种情况下，系统使用 little-endian 字节顺序。
// UCB RISC-V：这是目标系统的架构，具体来说，就是加州大学伯克利分校开发的 RISC-V。
target/riscv64gc-unknown-none-elf/debug/os: ELF 64-bit LSB executable, UCB RISC-V, ......

文件头信息
rust-readobj -h target/riscv64gc-unknown-none-elf/debug/os
   File: target/riscv64gc-unknown-none-elf/debug/os
   Format: elf64-littleriscv
   Arch: riscv64
   AddressSize: 64bit
   ......
   Type: Executable (0x2)
   Machine: EM_RISCV (0xF3)
   Version: 1
   Entry: 0x0
   ......
   }

反汇编导出汇编程序
rust-objdump -S target/riscv64gc-unknown-none-elf/debug/os
   target/riscv64gc-unknown-none-elf/debug/os:       file format elf64-littleriscv
```

```
file target/riscv64gc-unknown-none-elf/debug/os
```

```java
target/riscv64gc-unknown-none-elf/debug/os1: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, with debug_info, not stripped
```

- **文件格式**: ELF 64-bit
    - 这是一个 64 位的 ELF（可执行与可链接格式）文件，适用于 64 位系统。
- **字节顺序**: LSB (Least Significant Byte)**字节顺序** ： LSB （Least Significant Byte）
    - 该文件使用小端（Little Endian）字节序。
- **架构**: UCB RISC-V**架构** ： UCB RISC-V
    - 该文件为 RISC-V 架构，UCB 表示这是来自加州大学伯克利分校开发的 RISC-V 标准。
- **指令集扩展**: RVC (RISC-V Compressed Instructions)**指令集扩展** ： RVC （RISC-V Compressed Instructions）
    - 使用 RISC-V 压缩指令集（RVC），这可以帮助减少指令长度，提高代码密度。
- **浮点 ABI**: Double-float ABI**浮点 ABI**： 双浮点型 ABI
    - 使用双精度浮点数 ABI，这意味着浮点数运算遵循双精度（64 位）浮点标准。
- **ABI 版本**: Version 1 (SYSV)**ABI 版本** : Version 1 (SYSV)
    - 使用版本 1 的 SYSV 应用程序二进制接口（ABI），SYSV 是 UNIX 系统的 ABI 标准。
- **链接方式**: Statically Linked**链接方式** : Statically Linked
    - 该文件是静态链接的，所有依赖的库都已经编译到可执行文件中，因此它不依赖于系统上的共享库。
- **调试信息**: With debug_info
    - 可执行文件包含调试信息，这有助于开发和调试，但会增加文件大小。
- **符号信息**: Not Stripped
    - 可执行文件没有经过符号剥离，因此保留了函数名和调试符号等信息，这对于调试非常有帮助。

`rust-readobj -h target/riscv64gc-unknown-none-elf/debug/os1`

```java
Format: elf64-littleriscv       # 文件格式为 ELF 64 位，使用小端字节序，目标架构是 RISC-V。

Arch: riscv64                   # 目标架构为 RISC-V 64 位。

AddressSize: 64bit              # 地址大小为 64 位，意味着指针和地址将使用 64 位表示。

LoadName: <Not found>           # 没有找到加载名称，通常指的是动态加载的库文件名（如果有）。

ElfHeader {                     # ELF 文件头，包含基本的文件格式信息。
  Ident {                       # 标识符部分，包含 ELF 文件的魔数和其他基本属性。
    Magic: (7F 45 4C 46)        # 魔数（Magic number），ELF 文件的标识符。7F 45 4C 46 对应 ASCII 字符“ELF”。
    Class: 64-bit (0x2)         # 文件是 64 位格式（值为 0x2 表示 64 位）。
    DataEncoding: LittleEndian (0x1)  # 字节顺序为小端（Little Endian，值为 0x1）。
    FileVersion: 1              # ELF 文件的版本为 1。
    OS/ABI: SystemV (0x0)       # 操作系统和 ABI（应用程序二进制接口）为 SystemV（值为 0x0）。
    ABIVersion: 0               # ABI 版本为 0，表示没有特定的版本。
    Unused: (00 00 00 00 00 00 00)  # 未使用的字节，通常填充为零。
  }
  Type: Executable (0x2)        # 文件类型为可执行文件（值为 0x2）。
  Machine: EM_RISCV (0xF3)      # 目标机器架构为 RISC-V（值为 0xF3）。
  Version: 1                    # ELF 文件的版本为 1。
  Entry: 0x0                    # 入口点地址为 0x0。通常这是程序的起始执行位置。
  ProgramHeaderOffset: 0x40     # 程序头部的偏移量为 0x40，指向程序头部表的开始位置。
  SectionHeaderOffset: 0x1918  # 节头部的偏移量为 0x1918，指向节头部表的开始位置。
  Flags [ (0x5)                 # 文件标志（值为 0x5）说明了文件的一些特性。
    EF_RISCV_FLOAT_ABI_DOUBLE (0x4)  # 表示使用双精度浮点 ABI（值为 0x4）。
    EF_RISCV_RVC (0x1)          # 表示使用 RISC-V 压缩指令集（RVC，值为 0x1）。
  ]
  HeaderSize: 64                # ELF 文件头的大小为 64 字节。
  ProgramHeaderEntrySize: 56    # 程序头部条目的大小为 56 字节。
  ProgramHeaderCount: 4         # 程序头部表有 4 个条目。
  SectionHeaderEntrySize: 64   # 节头部条目的大小为 64 字节。
  SectionHeaderCount: 12       # 节头部表有 12 个条目。
  StringTableSectionIndex: 10  # 字符串表节的索引为 10，这通常包含文件中的符号名称。
}

```

通过 `file` 工具对二进制程序 `os` 的分析可以看到它好像是一个合法的 RISC-V 64 可执行程序，但通过 `rust-readobj` 工具进一步分析，发现它的入口地址 Entry 是 `0` ，从 C/C++ 等语言中得来的经验告诉我们， `0` 一般表示 **NULL 或空指针**，因此等于 `0` 的入口地址看上去无法对应到任何指令。

再通过 `rust-objdump` 工具把它反汇编，可以看到没有生成汇编代码。

所以，我们可以断定，这个二进制程序虽然合法，但它是一个空程序。

产生该现象的原因是：目前我们的程序（参考上面的源代码）没有进行任何有意义的工作，由于我们移除了 `main` 函数并将项目设置为 `#![no_main]` ，它甚至没有一个传统意义上的入口点（即程序首条被执行的指令所在的位置），因此 Rust 编译器会生成一个空程序。

在下面几节，我们将建立有支持显示字符串的最小执行环境。