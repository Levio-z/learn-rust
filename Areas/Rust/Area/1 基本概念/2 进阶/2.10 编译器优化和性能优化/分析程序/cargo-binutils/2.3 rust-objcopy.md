当前的ELF执行程序有许多与执行无直接关系的信息（如调试信息等），可以通过 `rust-objcopy` 工具来清除。
```rust
rust-objcopy --strip-all target/debug/os target/debug/os.bin
ls -l target/debug/os*

./target/debug/os.bin
   Hello, world!
```
可以看到，经过处理的ELF文件 `os.bin` 在文件长度上大大减少了，但也能正常执行。

另外，当将程序加载到内存的时候，**对于每个 program header 所指向的区域，我们需要将对应的数据从文件复制到内存中。这就需要解析 ELF 的元数据 才能知道数据在文件中的位置以及即将被加载到内存中的位置。但如果我们不需要从 ELF 中解析元数据就知道程序的内存布局 （这个内存布局是我们按照需求自己指定的），我们可以手动完成加载任务。**

具体的做法是利用 `rust-objcopy` 工具删除掉 ELF 文件中的 所有 header 只保留各个段的实际数据得到一个没有任何符号的纯二进制镜像文件：
```rust
rust-objcopy --strip-all target/debug/os -O binary target/debug/os.bin
```
这样就生成了一个没有任何符号的纯二进制镜像文件。由于缺少了必要的元数据，我们的 `file` 工具也没有办法 对它完成解析了。而后，我们可直接将这个二进制镜像文件手动载入到内存中合适位置即可。


上面得到的内核可执行文件完全符合我们对于内存布局的要求，但是我们不能将其直接提交给 Qemu ，因为它除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。如下图所示：
![](../../../../../../../../Projects/on%20hold/开源操作系统训练营/2025春夏/第二阶段：rcore/rCore-Turial-note/2.0%20应用程序执行环境/asserts/Pasted%20image%2020250909132657.png)


丢弃元数据前后的内核可执行文件被加载到 Qemu 上的情形

图中，红色的区域表示内核可执行文件中的元数据，深蓝色的区域表示各个段（包括代码段和数据段），而浅蓝色区域则表示内核被执行的第一条指令，它位于深蓝色区域的开头。图示的上半部分中，我们直接将内核可执行文件 `os` 提交给 Qemu ，而 Qemu 会将整个可执行文件不加处理的加载到 Qemu 内存的 `0x80200000` 处，由于内核可执行文件的开头是一段元数据，这会导致 Qemu 内存 `0x80200000` 处无法找到内核第一条指令，也就意味着 RustSBI 无法正常将计算机控制权转交给内核。相反，图示的下半部分中，将元数据丢弃得到的内核镜像 `os.bin` 被加载到 Qemu 之后，则可以在 `0x80200000` 处正确找到内核第一条指令。如果想要深入了解这些元数据的内容，可以参考 [附录 B：常见工具的使用方法](https://rcore-os.cn/rCore-Tutorial-Book-v3/appendix-b/index.html) 。