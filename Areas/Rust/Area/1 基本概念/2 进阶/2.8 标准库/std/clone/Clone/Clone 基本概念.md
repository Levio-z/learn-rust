### 1. `Clone` Trait

#### 定义与功能

`Clone` trait 用于 **显式地** 创建一个值的 **深拷贝**。换句话说，`Clone` 允许你创建一个新的对象，它和原始对象相同，但它们各自拥有独立的内存空间。`Clone` 适用于需要深度复制的类型。

- **`Clone` 的核心方法：**
```rust
pub trait Clone {
    fn clone(&self) -> Self;
}
```

`clone` 方法创建一个与当前对象相同的新实例。需要注意的是，`clone` 方法是一个 **显式的** 操作，它需要类型实现 `Clone` trait，并且通常会产生额外的内存开销，因为它涉及到对所有数据的复制。

#### 示例
```rust
#[derive(Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1.clone();  // 使用 clone 创建 p1 的深拷贝

    println!("p1: ({}, {}), p2: ({}, {})", p1.x, p1.y, p2.x, p2.y);
}

```

#### 使用场景

- `Clone` 适用于那些**在其生命周期内可能需要被多次使用的类型，特别是当你需要在不同地方保存相同数据的副本时**。
    
- 对于堆分配的数据（如 `String`、`Vec` 等）通常需要使用 `clone` 来确保创建一个新的副本，而不是简单的浅拷贝。


#### 性能考虑

- `Clone` 通常会涉及 **深拷贝**，这意味着它可能会有 **性能开销**。例如，当你克隆一个包含大量数据的集合（如 `Vec<T>`）时，所有数据都会被复制。
    
- 如果你不希望创建新副本，而是希望共享相同的数据，`Rc` 或 `Arc`（引用计数类型）等智能指针可以用来避免复制。