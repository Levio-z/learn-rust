### 核心
**锁的粒度**：**整个循环或操作一次性加锁**，
**配合组合缓冲区**：主要目的就是 **减少系统调用次数，提高性能**。
## 1. `print!` / `println!`
`println!("Hello, world!"); 
print!("Hello, "); 
print!("world!\n");`

- **特点**：
    - 内部自动调用 `stdout()` 并加锁（线程安全）
    - 自动处理换行 (`println!`)
    - 简单易用，适合小量输出
- **优点**：
    - 代码简洁
    - 多线程安全
- **缺点**：
    - 每次调用都会加锁一次，**循环或大数据输出时性能可能低**

**适用场景**：
- 小量输出
- 调试信息
- 少量日志
- 简单脚本或 CLI 工具

---

## 2. `stdout().lock()`

`use std::io::{self, Write}; 
let stdout = io::stdout(); 
let mut handle = stdout.lock(); 
for i in 0..1000 {    
writeln!(handle, "Line {}", i).unwrap();
}`
- **特点**：
    - 手动获取 stdout 锁一次
    - 可以在锁定期间多次写入
    - 配合 `BufWriter` 可进一步提高性能
- **优点**：
    - 避免循环中多次锁定，提高性能
    - 可以精细控制写入（缓冲、格式化等）
- **缺点**：
    - 代码稍复杂，需要手动 flush

**适用场景**：
- 循环输出大量数据（如文件生成、日志）
- 性能敏感的程序
- 需要组合缓冲器、哈希计算或其他操作
- 多线程环境下确保输出原子性

