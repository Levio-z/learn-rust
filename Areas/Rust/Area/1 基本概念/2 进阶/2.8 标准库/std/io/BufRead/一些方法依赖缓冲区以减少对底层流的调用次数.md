### 1\. `read_until(delim, buf)` 和 `read_line(&mut String)`
-   **作用**：按指定分隔符（`delim` 或换行 `\n`）读取数据到缓冲区
-   返回时，缓冲区 `buf` 会包含 **从当前位置到分隔符（含分隔符）的所有字节**
示例：
```rust
let mut buf = Vec::new();
buf_reader.read_until(0, &mut buf)?; // 按 null 字节读取
```
---
### 2\. 为什么需要缓冲区
假设底层流是一个文件或压缩器流（如 `ZlibDecoder`）：
-   **底层流只提供 `read(&mut buf)`**
    -   每次 `read()` 都可能触发系统调用或解压操作
    -   只能按“块”读取，无法直接按分隔符读取
	- 文件或套接字
		- 每次 `read(&mut tmp)` 会触发 **一次系统调用**（`read()`）
		- 系统调用有开销：切换用户态 ↔ 内核态，复制数据
		- 如果你按单字节读，每个字节都系统调用，效率极低
-   **缓冲区的作用**
    -   `BufReader` 内部维护一个内存缓冲区（通常 8KB）
    -   每次从底层读取一大块数据到缓冲区
    -   高层调用 `read_until` 或 `read_line` 时：
        1.  优先从缓冲区取数据
        2.  只在缓冲区不够时再访问底层流
> 这样做的好处是 **减少系统调用/解压操作次数**，提高效率，同时保证按分隔符正确切分数据。
---

### 3\. 为什么不直接用 `ZlibDecoder` 可以吗？
-   `ZlibDecoder` 实现了 `Read`，但没有 `BufRead`
-   直接用 `read()` 只能按字节或固定块读
-   如果你想“按 null 字节或换行分割”，必须手动管理缓冲区
-   用 `BufReader` 就省事了：它已经帮你做了缓冲和分隔符查找
---

### 4\. 可视化理解
```
底层文件 f (压缩数据)
   ↓ read()
ZlibDecoder (解压成原始数据)
   ↓ read()
BufReader (缓冲区，按需提供数据给上层)
   ↓ read_until / read_line
```
-   `read_until` 只从缓冲区取数据，如果缓冲区不足，再去底层填充
-   避免每次按分隔符都去底层流读取，提高性能
用户缓冲区
---

✅ **总结**

-   `read_until` / `read_line` 依赖缓冲区，因为：
    1.  可以减少访问底层流次数（系统调用或解压操作）
    2.  能保证“按分隔符读取完整数据”
-   没有缓冲区，这些方法就无法高效实现，必须手动管理内存和查找分隔符
    

---
