`RefCell` 是 Rust 中一个提供 **内部可变性** 的智能指针类型，允许通过借用规则在运行时进行可变借用检查。它是通过 **动态借用检查** 来允许在编译时不可变的情况下对数据进行修改。
#### 特性：
- **内部可变性**：`RefCell` 允许在不可变引用的情况下通过 **可变借用** 来修改数据。
- **运行时检查**：它的借用规则是在运行时进行检查的，而不是编译时。具体来说，`RefCell` 允许多次可变借用或者不可变借用，但它会确保在任何时刻只有 **一个可变借用** 或者 **任意数量的不可变借用**。
- **借用规则**：`RefCell` 在内部使用 `Ref` 和 `RefMut` 来分别表示不可变借用和可变借用。当试图违反借用规则时，`RefCell` 会在运行时 panic。
#### 使用场景：
- 当你需要在不可变引用下修改数据，但又不想使用 `unsafe` 时，可以使用 `RefCell`。
- 用于实现像单例模式、对象的可变状态等功能。
#### 示例：
```rust
use std::cell::RefCell;

fn main() {
    let x = RefCell::new(5);

    {
        let mut y = x.borrow_mut();  // 可变借用
        *y += 1;
    }

    {
        let z = x.borrow();  // 不可变借用
        println!("{}", *z);  // 打印 6
    }
}

```

```rust
use std::cell::RefCell;

fn f1() -> bool {
    true
}

fn f2() -> bool {
    !f1()
}

fn main() {
    let v1 = RefCell::new(42);

    let v2 = RefCell::new(666);

    let p1 = if f1() { &v1 } else { &v2 }.try_borrow().unwrap();

    if f2() {
        let mut p2 = v1.try_borrow_mut().unwrap();

        *p2 = 37;

        println!("p2: {}", *p2);
    }

    println!("p1: {}", *p1);
}

```