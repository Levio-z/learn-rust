#### 定义与功能

`Copy` trait 是一种 **零开销的复制机制**，它表示一个类型的值可以通过 **简单地复制** 内存来实现类似的效果。`Copy` 类型的变量可以通过赋值或传递给函数时自动进行按位复制，而不需要显式的深拷贝操作。

- **`Copy` 的核心语义：**
    
    - 对于 **简单类型**（如整数、浮点数、字符等），Rust 会进行按位复制。
        
    - 复制是**隐式的**，即你不需要显式调用 `clone()` 方法，赋值或传递给函数时会自动复制。
        

#### 示例

```rust
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1;  // 这里 `p1` 会被按位复制，p2 和 p1 是独立的
    
    println!("p1: ({}, {}), p2: ({}, {})", p1.x, p1.y, p2.x, p2.y);
}
```

在这个例子中，`Point` 实现了 `Copy` trait，因此 `p2 = p1` 赋值时会自动进行按位复制，而不是移动数据（`p1` 依然有效）。

#### 使用场景

- `Copy` 适用于那些不需要进行深度复制的类型，尤其是大小固定、无需额外内存分配的类型（如原始数值类型 `i32`、`f64`、`char`）。
    
- `Copy` 常用于那些 **简单、不可变** 的类型，因为它们的复制操作非常高效且不涉及堆分配。
    

#### 性能考虑

- `Copy` 是 **零开销** 的操作，直接通过 **按位复制** 内存来实现。它不涉及任何堆分配或复杂的复制操作，因此性能上非常高效。
    
- 仅适用于类型的大小已知且固定的情况，例如基本数据类型（整数、字符、浮点数等），这些类型的复制不会引起额外的内存开销。
### 依赖Clone
`Copy` 依赖于 `Clone`，但 `Clone` 不依赖于 `Copy`。
**`Copy`** trait 是 **`Clone`** 的 **子集**。也就是说，当一个类型实现了 `Copy` 时，Rust 会自动为该类型实现 `Clone`。但是，反之并不成立，**实现 `Clone` 并不意味着自动实现 `Copy`**。
### Vs Clone

| 特性         | `Clone`                        | `Copy`                         |
| ---------- | ------------------------------ | ------------------------------ |
| **操作类型**   | 深拷贝                            | 按位复制                           |
| **性能开销**   | 可能会有额外的内存和时间开销，尤其是对于包含堆分配数据的类型 | 零开销，不涉及额外的内存分配                 |
| **语义**     | 创建新对象的副本，独立于原始对象               | 简单地复制数据，原始数据和副本共享相同的内存区域       |
| **应用类型**   | 适用于堆分配的类型和需要深度复制的类型            | 适用于简单类型，如原始数值类型（`i32`、`f64` 等） |
| **是否自动执行** | 需要显式调用 `clone()`               | 赋值时自动复制，无需显式调用                 |