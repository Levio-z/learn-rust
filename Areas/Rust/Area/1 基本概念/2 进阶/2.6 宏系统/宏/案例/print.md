```rust
#[macro_export]
macro_rules! println {
    () => (print!("\n"));
    ($($arg:tt)*) => (print!("{}\n", format_args!($($arg)*)));
}
```
#### 1. `#[macro_export]`：
- **作用**：这是一个宏的属性，用于将这个宏导出，使得它可以在模块外部使用。如果没有这个属性，这个宏将只能在定义它的模块内使用。
- **解释**：将 `println!` 宏公开，以便在其他模块或文件中可以调用。
#### 2. `macro_rules! println { ... }`：2. `macro_rules！ println { ... }`：
- **作用**：定义一个名为 `println!` 的宏。宏通过 `macro_rules!` 关键字来定义。
- **解释**：宏是一种代码生成工具，它允许我们在代码中定义模式匹配规则，然后根据输入生成相应的代码。
#### 3. `()` 匹配：
`() => (print!("\n"));`
- **作用**：这是宏的第一种匹配模式。它匹配没有任何参数的调用，表示我们希望打印一个单独的换行符。
- **解释**：
    - 当我们调用 `println!()` 时，这个宏的第一种模式会被匹配，执行 `print!("\n")`，也就是输出一个换行符。
    - `print!` 宏用于输出不带换行符的字符串，`"\n"` 就是一个换行符，打印后光标会移到下一行。
#### 4. `($($arg:tt)*)` 匹配：

`($($arg:tt)*) => (print!("{}\n", format_args!($($arg)*)));`

- **作用**：这是宏的第二种匹配模式。它匹配带有一个或多个参数的 `println!` 调用，并格式化它们后输出。
- **解释**：
    - `($($arg:tt)*)`：这里的 `$($arg:tt)*` 是一个模式，它匹配零个或多个 token trees（`tt`）。token tree 是 Rust 语法中的一个最小的语法单位，可以是一个标识符、一个字面量、一个表达式，甚至是其他宏调用。
        - 举例来说，如果我们传入 `"Hello, {}!"` 和 `"world"`，那么 `$($arg:tt)*` 就会匹配到 `"Hello, {}!"` 和 `"world"`。
    - `format_args!($($arg)*)`：将传入的参数使用 `format_args!` 进行格式化，`format_args!` 返回一个格式化的值，但并不生成一个新的字符串（因此它更高效），而是直接交给 `print!` 打印。`format_args!` 内部会解析和格式化传入的参数。
        - `format_args!` 类似于 `format!`，但是它不会分配内存，而是生成一个可以直接用于输出的结构，特别适合打印和日志记录等高效输出的场景。
            
    - `print!("{}\n", ...)`：将格式化后的结果输出，`{}` 代表格式化输出的位置，`\n` 是强制换行符。
        

### 核心流程：

- 当你调用 `println!()` 时，它会触发第一种匹配规则，打印一个换行符。
    
- 当你调用 `println!(...)` 并传入一些参数时，宏会触发第二种匹配规则，格式化这些参数并打印它们，最后加上换行符。