>https://doc.rust-lang.org/nomicon/other-reprs.html#reprtransparent

`#[repr（transparent）]` 只能用于具有单个非零大小字段的结构或单变量枚举（可能还有其他零大小字段）。效果是保证整个结构/枚举的布局和 ABI 与该字段相同。

`#[repr(transparent)]` 是 Rust 的一种 **数据布局属性**，它告诉编译器：
- “这个结构体或元组结构只包含一个字段，它的内存布局和该字段完全相同，二者可以视作等价的底层表示。也就是说，这个类型**在内存中和它唯一字段的类型完全一致**，没有额外的填充（padding）或改变。


此外，通过 FFI 传递结构/枚举，其中内部字段类型是预期的 另一边保证工作。特别是，这对于 `struct Foo（f32）` 或`枚举 Foo { Bar（f32） }` 始终具有与 `f32` 相同的 ABI。


仅当单个字段是 `pub` 或其布局以散文形式记录时，此 repr 才被视为某类公共 ABI 的一部分。否则，其他板条箱不应依赖该布局。

 **单个字段是 `pub` 的情况**
当你为一个结构体添加 `#[repr(transparent)]` 属性时，Rust 会保证该结构体的内存布局与它唯一的字段相同。这个字段如果是 **`pub`**（公共的），那么它的布局会被视作类型的 **公共 ABI** 的一部分。公共 ABI 意味着这个结构体在内存中的布局会被暴露给外部代码（例如，C 语言程序或其他库），并且可以安全地与外部系统进行交互。

**“散文形式记录”**：
- 这里的 **“散文形式记录”** 指的是，尽管该结构体的字段是私有的，Rust 不会强制要求它的内存布局是公开的，但你可以通过 **文档** 或其他方式（如外部工具）显式地记录类型的内存布局，说明该类型的布局不会改变，并且可以安全地与外部系统交互。
    
- **文档** 或其他工具中的记录意味着，你作为开发者承诺该类型的内存布局在未来会保持不变，确保其他系统（如外部 C 语言库）可以正确地与其交互。


- **封装单一字段的包装类型**：确保包装类型在内存中的布局与底层类型一致。
- **FFI 交互**：与外部 C 语言或其他语言的类型兼容。
- **性能敏感的场景**：减少包装类型带来的内存开销，避免多余的性能损失。
- **C++ 等语言的类型映射**：确保 Rust 类型与其他语言的类型在内存中的一致性。
- **简化类型转换**：通过直接的内存布局一致性简化类型转换。
