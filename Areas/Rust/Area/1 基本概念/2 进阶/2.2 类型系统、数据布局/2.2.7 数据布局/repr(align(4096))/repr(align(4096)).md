### `#[repr(align(4096))]` 定义与作用
在 Rust 中，`#[repr(align(N))]` 是一个 **表示（representation）属性**，用于指定某个结构体或枚举的 **对齐方式**。
- **N 必须是 2 的幂次**（例如 1, 2, 4, 8, …, 4096）。
- `#[repr(align(4096))]` 表示该类型的 **起始地址** 必须是 4096 的整数倍。

这意味着编译器在为该类型分配内存时，会保证地址满足 4 KiB 对齐。


`#[repr(align(4096))]` 指定了数据结构的内存对齐要求，使其起始地址总是 4KiB 对齐。这样能保证页表正好落在单个页中，方便 CPU/MMU 在做地址映射时使用，同时也让编译器能利用对齐信息进行更高效的内存访问。

### 内存对齐原理
- **自然对齐（默认）**
    - Rust 默认会根据字段的类型选择合适的对齐，例如 `u32` 对齐到 4 字节，`u64` 对齐到 8 字节。
    - 结构体的整体对齐一般取决于最大字段的对齐需求。
- **强制对齐（repr(align))**
    - 使用 `#[repr(align(N))]` 可以人为提高对齐要求，即使结构体字段本身不需要。
    - 编译器会在类型大小上进行 **padding**（填充），确保内存对齐满足要求。
### 使用场景
**页表、内存页对齐**
- 页大小通常为 **4 KiB (4096 字节)**。
- 在实现操作系统时，页表、页帧分配等需要严格的页对齐。
```rust
#[repr(align(4096))]
struct Page([u8; 4096]);  // 一个对齐到 4KiB 的页
```
- **DMA / 硬件交互**
    - 某些硬件控制器要求数据缓冲区必须对齐到特定大小（如 64B、4KiB）。
    - 否则可能会触发异常或性能大幅下降。
- **SIMD/向量化优化**
    - 在使用 AVX/AVX-512 等指令时，通常要求 16B、32B、64B 对齐。
### 为什么？
#### **硬件与 MMU 的对齐要求**
- **MMU（内存管理单元）** 只识别按页对齐的内存块。
- 页帧（Page Frame）必须从物理内存的页边界开始，否则会破坏地址翻译逻辑。
- 某些 CPU 指令（如 TLB 填充、分页异常处理）直接假设页对齐。
