---
tags:
  - permanent
---
## 1. 核心观点  

类型强制（**coercion**）是 Rust 中的一种**隐式类型转换机制**，即在特定场景下，编译器会自动将一个值的类型转换为另一个类型，而无需开发者显式调用转换函数或方法。它与显式类型转换（`as` 操作符）不同，**无需手动书写**。

**特点**：

- 自动发生，仅在特定上下文中触发。
- 适用类型严格受限，并非任意类型都可以强制。
- 主要目的是为了简化类型适配，比如借用、引用层级调整等
### 类型强制
- 自动解引用

## 2. 背景/出处  
- 来源：https://doc.rust-lang.org/reference/type-coercions.html
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

####  常见触发场景

Rust 中类型强制通常出现在以下场景：

1. **函数参数匹配**  
    当函数参数期望一个类型，而传入的值是兼容类型时：
    
```rust
fn foo(s: &str) {}
let string = String::from("hello");
foo(&string); // &String 自动强制为 &str
```
    
    这里发生了 **`&String → &str`** 的强制。

    
2. **借用调整（借用层级）**  
    可变借用和不可变借用之间，或者引用层级之间的自动调整：
    
    `let x: &i32 = &5; 
	 let y: &&i32 = &x; // &i32 自动强制为 &i32 的引用`
    
3. **函数返回值**  
    如果函数返回值类型与调用期望类型不完全一致，但存在合法强制：
    
    `fn get_ref() -> &String { ... } 
    let s: &str = get_ref(); 
    // &String → &str`
#### 3. 显式类型转换 (`as`)

Rust 的 `as` 操作符可以显式执行任何允许的强制类型转换。例如：

`let s: &String = &String::from("hello"); 
let t: &str = s as &str; // 显式强制`

这与隐式类型强制效果等价，只是开发者明确指定了转换。

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [Rust-类型强制-强制点](Rust-类型强制-强制点.md)
	- [Rust-类型强制-强制类型转换分类](Rust-类型强制-强制类型转换分类.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 原子笔记整理
	- [x] 整理基本概念的笔记
	- [x] String中的自动解引用，String的本质
	- [x] 自动解引用规则
	 
