---
tags:
  - permanent
---
## 1. 核心观点  

类型强制（**coercion**）是 Rust 中的一种**隐式类型转换机制**，即在特定场景下，编译器会自动将一个值的类型转换为另一个类型，而无需开发者显式调用转换函数或方法。它与显式类型转换（`as` 操作符）不同，**无需手动书写**。

**特点**：

- 自动发生，仅在特定上下文中触发。
- 适用类型严格受限，并非任意类型都可以强制。
- 主要目的是为了简化类型适配，比如借用、引用层级调整等
### 主要类型
- [4. 引用 → 指针（&T → const T）](#4.%20引用%20→%20指针（&T%20→%20const%20T）)
- [2. &mut 强制为 &（Mut reborrow）](#2.%20&mut%20强制为%20&（Mut%20reborrow）)
- [2. &mut 强制为 &（Mut reborrow）](#2.%20&mut%20强制为%20&（Mut%20reborrow）)
- [5. Deref 强制（&T → &U）](#5.%20Deref%20强制（&T%20→%20&U）)
- [9. Never 类型（! → T）](#9.%20Never%20类型（!%20→%20T）)


## 2. 背景/出处  
- 来源：https://doc.rust-lang.org/reference/type-coercions.html
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### Rust 类型强制：允许的强制种类（定义 | 原理 | 源码走向 | 使用场景 | 扩展）

### 1. 反身与传递强制（Reflexive / Transitive）

#### 定义

- **反身（Reflexive）**：若 _T 是 U 的子类型_，则允许 `T → U` 的隐式强制。
- **传递（Transitive）**：若 `T1 → T2`，且 `T2 → T3`，则可推得 `T1 → T3`。

#### 原理

Rust 子类型关系极少，**仅对引用有子类型存在**，例如 `&'static T` 是 `&'short T` 的子类型，生命周期可以收缩。  
传递性目前未完全支持，是 Rust Coercion 引擎长期要补完的方向。

#### 使用场景

- 生命周期收缩：`&'static str → &'a str`
    
- 多级 Deref 强制链的推导
    

#### 扩展

可查看 compiler 子模块 `rustc_typeck` 中的 `coerce.rs`，实现了强制序列构建。

---

### 2. &mut 强制为 &（Mut reborrow）

#### 定义

`&mut T → &T`（可变借用自动“再借用”为不可变借用）

#### 原理

保证**可变引用唯一**、**共享引用任意**的借用规则。  
`&mut` 再借用 `&` 后，后续仅允许只读操作。

Rust 的借用规则规定：

- **不可变借用（`&T`）可以有多个别名，共享读取**
- **可变借用（`&mut T`）必须唯一，排他写入**
    

在这些规则下，编译器允许：

> **从一个可变引用自动生成一个不可变引用**  
> 因为这不会破坏“可变借用唯一性”这一核心不变量。

因为 **共享只读访问不会破坏排他借用的语义**。

生成一个 `&T`（共享只读引用）意味着：

- 仍然只有 **一个** 可变借用存在
- 新得到的 `&T` **无法进行写入**
- 所以不会造成数据竞争

因此这是安全的。



#### 场景

- 在函数中只需要读：
    
    ```rust
    fn f(_: &i32) {}
    let x = &mut 3;
    f(x); // &mut → &
    ```
    

---

###  3. `*mut → *const`（Mut pointer）

#### 定义

`*mut T → *const T`，对应 C 的 const 性弱化。

#### 原理

非借用指针不受借用检查限制，但为了内存安全，改变“只读性”方向只能从强到弱。

#### 场景

- 与 C 交互，函数参数常是 `*const T`。
    

---

### 4. 引用 → 指针（&T → *const T）

#### 定义

`&T → *const T`  
`&mut T → *mut T`

#### 原理

引用具有借用语义（安全），原生指针无安全保证，因此可以降级。
#### ● 引用（`&T`, `&mut T`）是带有 **借用规则保证** 的安全指针

- 保证不悬空
    
- 保证符合别名规则（unique/mutable aliasing）
    
- 生命周期受编译器检查
    
- 不允许越界指针运算
    
- 永远是有效内存的一部分

#### ● 原生指针（`*const T`, `*mut T`）是 **不安全的弱指针**

- 无有效性保证
    
- 不遵循 Rust borrow checker
    
- 需要 unsafe 才能解引用
    
- 可以为空，加减运算
    
- 不能保证对齐
#### 因此：

> **从强约束 → 弱约束“降级”是安全的，反过来不允许。**  
> 由编译器可验证的引用转换成编译器不给你保证的裸指针，不会破坏安全性，因为**风险从安全区转移到了调用方显式 `unsafe` 的地方。**

#### 场景

- FFI 调用
    
- NumPy、GPU 等外部内存交互
    

---

### 5. Deref 强制（&T → &U）

#### 定义

若 `T: Deref<Target = U>`，则  
`&T → &U`  
若 `T: DerefMut<Target = U>`，则  
`&mut T → &mut U`

#### 核心源码

`op::Deref`、`op::DerefMut` trait，编译器自动寻找 `deref()` 返回类型。

#### 场景

- String 强制为 &str
    
    ```rust
    fn foo(_: &str) {}
    let s = String::from("hi");
    foo(&s);  // String → str
    ```
    
- Rc、Box 都依赖 Deref 链实现智能指针透明访问
    

---

###  6. Unsized Coercion（T → U，其中 U 是动态大小类型）

#### 定义

支持如下结构的对称转换：  
`&T → &U`  
`&mut T → &mut U`  
`*const T → *const U`  
`Box<T → Box<U>` 等  

条件：`T: Unsize<U>`

#### 原理

DST (动态大小类型) 如 `dyn Trait`、`[T]` 必须通过胖指针表示。  
Unsize 则是编译器内置 trait，用于构建胖指针。

#### 场景

- `Box<[T]>`
    
- `&dyn Trait`
    
- `Rc<dyn Trait>`
    

---

###  7. 函数项类型 → fn 指针（function item → fn pointer）

#### 定义

函数项类型（具体函数）可强制为 fn 指针。

```rust
fn foo(x: i32) {}
let p: fn(i32) = foo;   // item → fn pointer
```

#### 原理

函数项类型包含零大小实体，编译器可直接取其函数地址。

---

###  8. 无捕获闭包 → fn 指针

#### 定义

无环境捕获的闭包自动强制为 fn 指针。

```rust
let f = |x: i32| x + 1;
let p: fn(i32) -> i32 = f;
```

#### 原理

闭包结构中无捕获时，其结构体可自动转为真实函数符号。

---

### 9. Never 类型（! → T）

#### 定义

`!`（永不返回类型）可强制为任意类型 T。

#### 原理

`!` 表示“永不会产生值”，因此可赋值给任何类型。  
典型于：`panic!()`、`loop {}`、`return expr`

#### 场景

```rust
let x: i32 = panic!();  // ! → i32
```

---

### 总结（完整梳理）

Rust 类型强制系统通过**子类型、可变性、降级（引用→指针）、Deref 链、DST 扩展**实现了从安全到灵活的转换体系。其核心依赖编译器内部 `Coerce` 引擎控制强制链和可行性判断。

---

### ### 学习方法论

1. **按“三层结构”学习**：
    
    - _语义层_：哪些地方允许发生？（coercion sites）
    - _类型层_：哪些强制受支持？（本页内容）
    - _运行时层_：哪些强制是零成本？哪些是胖指针转换？
        
2. **以“Deref 链条”为主线**阅读智能指针：  
    Box、Rc、Arc、String 分别如何触发强制？
    
3. **通过阅读 rustc 源码强化理解**：  
    `rustc_typeck/src/coerce.rs` 是最重要的模块。

---

### ### 练习题

1. 解释 `String → &str` 的强制链条完整路径。
    
2. 写出一个自定义智能指针，实现 Deref 后能自动参与函数参数强制。
    
3. 给出一个涉及 `dyn Trait` 与 unsize coercion 的示例代码，并说明胖指针如何构造。
    
4. 为什么 `&mut T` 不能强制为 `&mut U`（除非满足 DerefMut），但可以强制为 `&T`？
    
5. 是否允许多级强制：`Box<String> → &str`？若允许，列出完整步骤。
    

---

### ### 高价值底层知识（优先掌握）

- **Deref / DerefMut 强制链核心机制**
    
- **Unsize coercion 与胖指针内部布局**
    
- **Borrow Checker 的可变性规则（mut reborrow）**
    
- **从引用转原生指针的安全边界**
    
- **Never 类型在控制流中的作用**
    

需要我再为你分别整理这些强制种类对应的**Coercion Site（强制发生的具体位置）**吗？
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [Rust-类型强制-unsize && CoerceUnsized](Rust-类型强制-unsize%20&&%20CoerceUnsized.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 原子笔记整理
	- [x] 整理基本概念的笔记
	- [x] String中的自动解引用，String的本质
	- [x] 自动解引用规则

