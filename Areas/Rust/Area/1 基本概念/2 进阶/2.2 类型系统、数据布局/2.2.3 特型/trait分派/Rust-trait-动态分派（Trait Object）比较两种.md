---
tags:
  - permanent
---
## 1. 核心观点  
### Ⅰ. 概念层
- `&dyn Trait`：引用，栈上，无堆分配，临时借用，vtable 调用
- `Box<dyn Trait>`：拥有对象，堆上，长期存储，可替换，vtable 调用
### &dyn
#### 1️⃣ 内存与生命周期
- 不拥有对象本身，只是引用
- 对象的生命周期必须在引用作用域内有效
- 没有堆分配，引用指向栈上或已有对象
#### 2️⃣ 用途
- 批量调用已有对象的方法（批量日志、绘图、回调等）
- 适合**临时借用，不转移所有权**
#### 3️⃣ 限制
- 必须确保对象活得比引用长
- 无法跨作用域持有（不能存到 struct 内部，需要生命周期标注）
- 无法直接动态替换整个对象，只能调用方法
#### 4️⃣ 性能
- vtable + 间接调用
- 无堆分配开销
- CPU 分支预测可能稍差，但引用操作快速
### BOX
#### 1️⃣ 内存与所有权
- `Box` 拥有对象，把对象放在堆上
- 可在函数/struct 内跨作用域持有
- 可动态替换对象（如 `manager.switch_logger(Box::new(...))`）
#### 2️⃣ 用途
- **需要拥有对象并长期存储**
- 动态替换策略 / 插件系统 / 配置驱动对象
- trait 对象大小未知（DST），放在堆上才能直接拥有
#### 3️⃣ 限制
- 额外堆分配开销
- vtable + 间接调用
- 小对象堆分配可能不如引用高效
#### 4️⃣ 性能
- 间接调用 + 堆访问
- 可移动、可传递给线程（如 `Box<dyn Send + Trait>`）



### Ⅱ. 应用层
1. **判断是否需要所有权**
    - 临时调用 → 引用
    - 动态存储 / 替换 → Box
2. **注意生命周期**
    - `&dyn` 依赖外部对象
    - `Box<dyn>` 自包含，生命周期独立
3. **分析性能开销**
    - vtable 固定成本
    - 堆分配仅在 Box / Arc / Rc 时发生
        
#### 场景案例

1. **场景 1：批量调用**
```rust
batch_log(&mut loggers, "应用启动成功");
```
- 只需要 **借用已有 logger**
- 不需要持久存储，也不需要跨函数移动
- `&mut dyn` 最轻量

2. **场景 2：策略模式 / 可替换对象**
```rust
manager.switch_logger(Box::new(FileLogger::new("app.log")?));
```

- 需要 **拥有对象并存储在 manager 内部**
- 需要动态替换 logger
- `Box<dyn>` 提供对象所有权和 DST 封装
    



### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  



|特性|`&dyn Trait`|`Box<dyn Trait>`|
|---|---|---|
|所有权|不拥有，只是借用|拥有对象本身|
|生命周期|必须依附于已有对象|自身拥有，可跨作用域|
|堆分配|❌ 栈上 / 静态|✅ 堆上|
|可替换对象|❌ 只能调用方法|✅ 可替换整个对象|
|适合场景|临时调用 / 批量操作|持久策略 / 动态切换 / 存储在 struct|

---





## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
