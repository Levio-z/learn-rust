### 一、什么是未定义行为
[未定义行为常见来源](../../../../../../../../basic/编译原理/未定义行为/未定义行为常见来源.md)
### 二、安全是没有未定义的行为
- 运行时检查变量是否有定义是有代价的：当这样的程序由解释器执行时，在定义之前读取 `x` 会引发异常，例如 Python 的 [`NameError`](https://docs.python.org/3/library/exceptions.html#NameError) 或 Javascript 的 [`ReferenceError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)。但例外是有代价的。每次解释程序读取变量时，解释器都必须检查该变量是否已定义。
- Rust目标是确保运行时高效=》所以在编译器检查：Rust 的目标是将程序编译成高效的二进制文件，这些二进制文件需要尽可能少的运行时检查。因此，Rust 不会在_运行时_检查变量在使用之前是否已定义。相反，Rust 在编译时进行检查。如果您尝试编译不安全的程序，您将收到此错误：

### 三、Rust的基本目标
**Rust 的一个基本目标是确保您的程序永远不会有未定义的行为。** 
- 这就是“安全”的含义。对于直接访问内存的低级程序来说，未定义的行为尤其危险。低级系统中[报告的安全漏洞中约有 70%](https://msrc.microsoft.com/blog/2019/07/a-proactive-approach-to-more-secure-code/) 是由内存损坏引起的，**内存损坏是未定义行为的一种形式**。
**Rust 的第二个目标是防止在编译时而不是运行时出现未定义的行为。**
- 在编译时捕获错误意味着避免生产中的这些错误，从而提高软件的**可靠性**。
- 在编译时捕获错误意味着对这些错误的运行时检查更少，从而提高软件的**性能**。

### 四、机制：所有权通过阻止未定义行为保证安全
安全是没有未定义的行为，并且由于所有权是关于安全的，那么我们需要从它所阻止的未定义行为的角度来理解所有权。Rust 参考维护着一个大列表[的“被视为未定义的行为”](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)。现在，我们将重点关注一类：内存操作。
- 【所有权的目标】
    - 怎么保证安全→防止未定义的行为→使用所有权
- `[管理内存]`
    - 通过所有权系统和编译器检查的一组规则来管理内存和保证安全和减少运行期开销。

### 五、内存结构
[Rust-堆栈内存模型](../../2.1.1%20内存安全与防止数据竞争/Rust内存模型/Rust-堆栈内存模型.md)
### 六、所有权内容
[手动管理内存产生的未定义问题](../../../../../../../../basic/编译原理/未定义行为/手动管理内存产生的未定义问题.md)
- 使用自动释放内存，杜绝手动释放带来潜在未定义的行为的可能性
##### 自动释放内存
**盒子释放原则（几乎正确）：** 如果一个变量绑定到一个盒子，当 Rust 释放变量的帧时，那么 Rust 会释放盒子的堆内存。
原因：手动释放可能会带来未定义的行为，所以Rust不允许程序手动释放内存
- 因为手动内存管理容易出现问题
- 释放指针后再使用指针会导致未定义的行为
##### 所有者自动释放内存
**Box释放原则（完全正确）：** 如果一个变量拥有一个盒子，当 Rust 释放变量的帧时，Rust 会释放盒子的堆内存。
- 所有者概念：Rust中每一个值都被和只能被一个变量所拥有，该变量被称为值的所有者
- 2、**当所有者（变量）离开作用域范围，值被丢弃**
	- 解决什么问题：杜绝自动释放导致的两次释放，分配会将所有权转

- 
##### 移动语义转移所有权

- [Rust-move-内存模型-三种语义-move](../../2.1.1%20内存安全与防止数据竞争/Rust内存模型/move/Rust-move-内存模型-三种语义-move.md)
