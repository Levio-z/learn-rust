### ### [修复不安全的程序：返回对堆栈的引用](https://rust-book.cs.brown.edu/ch04-03-fixing-ownership-errors.html#fixing-an-unsafe-program-returning-a-reference-to-the-stack)
我们的第一个案例研究是关于返回对堆栈的引用，就像我们在 [“数据必须比其所有引用更持久”](https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html#data-must-outlive-all-of-its-references) 中的最后一节讨论的那样。这是我们查看的函数：
```rust
fn return_a_string() -> &String { 
let s = String::from("Hello world"); 
&s 
}
```
在考虑如何修复此功能时，我们需要问： **为什么这个程序不安全？** 在这里，问题在于引用数据的生存期。如果要传递对字符串的引用，则必须确保底层字符串的寿命足够长。

#### 延长生命周期的四种方法
- 一种是将字符串的所有权移出函数
	- 每次调用可能需要堆分配
	- 返回较短字符串或偶尔调用,可以修改
- 返回一个字符串文字，它永远存在（由 `'static` 表示）。存储在 **程序二进制的只读数据段（RODATA）**,生命周期为 `'static`，整个程序运行期间都存在。
	- 零分配、零开销、高性能
	- 仅适用于常量或固定内容，不能修改
- 使用垃圾回收将借用检查推迟到运行时。。例如，您可以使用[引用计数指针](https://doc.rust-lang.org/std/rc/index.html)
```rust
use std::rc::Rc;
fn return_a_string() -> Rc<String> {
    let s = Rc::new(String::from("Hello world"));
    Rc::clone(&s)
}

```
- 另一种可能性是让调用者提供一个“插槽”来使用可变引用放置字符串：
	- 调用方控制内存生命周期，可以提高内存效率。
```rust
fn return_a_string(output: &mut String) { output.replace_range(.., "Hello world"); 
}
```


### [修复不安全的程序：权限不足](https://rust-book.cs.brown.edu/ch04-03-fixing-ownership-errors.html#fixing-an-unsafe-program-not-enough-permissions)

另一个常见问题是尝试更改只读数据，或尝试将数据丢弃在引用后面。
![](../2.%20引用、借用和切片类型/asserts/Pasted%20image%2020250904104444.png)


- `name` 是一个不可变的引用，但 `name.push（..）` 需要 W 权限。此程序不安全，因为 `push` 可能会使 `stringify_name_with_title` 之外的其他 `name` 引用无效


```rust
fn stringify_name_with_title(name: &mut Vec<String>) -> String {
    name.push(String::from("Esq."));
    let full = name.join(" ");
    full
}
```
- 但这不是一个好的解决方案！ **如果调用方不期望函数更改其输入，则不应更改其输入。**

另一种选择是通过将 `&Vec<String>` 更改为 `Vec<String>` 来获取名称的所有权：
```
fn stringify_name_with_title(mut name: Vec<String>) -> String {
    name.push(String::from("Esq."));
    let full = name.join(" ");
    full
}
```
**Rust 函数很少拥有拥有堆的数据结构（如 `Vec` 和 `String`）的所有权。** 这个版本的 `stringify_name_with_title` 会使输入`名称`无法使用，这对调用者来说非常烦人，正如我们在 [“引用和借用”](https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html) 开头所讨论的那样。


所以 `&Vec` 的选择实际上是一个不错的选择，我们_不想_改变。相反，我们可以更改函数的主体。有许多可能的修复方法，它们使用的内存量各不相同。一种可能性是克隆输入`名称` ：
```rust
fn stringify_name_with_title(name: &Vec<String>) -> String {
    let mut name_clone = name.clone();
    name_clone.push(String::from("Esq."));
    let full = name_clone.join(" ");
    full
}
```
通过克隆`名称` ，我们可以改变载体的本地副本。但是，克隆会复制输入中的每个字符串。我们可以通过稍后添加后缀来避免不必要的副本：
```rust
fn stringify_name_with_title(name: &Vec<String>) -> String {
    let mut full = name.join(" ");
    full.push_str(" Esq.");
    full
}
```
此解决方案之所以有效，是因为 [`slice：：join`](https://doc.rust-lang.org/std/primitive.slice.html#method.join) 已经将 `name` 中的数据复制到字符串 `full` 中。

### 修复安全程序：改变不同的元组字段
上述示例是程序不安全的情况。Rust 也可能拒绝安全程序。一个常见的问题是 Rust 试图在细粒度级别跟踪权限。然而，Rust 可能会将两个不同的地方混淆为同一个地方。
![](../2.%20引用、借用和切片类型/asserts/Pasted%20image%2020250904105532.png)
语句 `let first = &name.0` 借用 `name.0`。此借用从 `name.0` 中删除 WO 权限。它还从`name`中删除了 WO 权限。（例如，不能将 `name` 传递给将 `（String， String）` 类型的值作为输入的函数。但是 `name.1` 仍然保留 W 权限，因此执行 `name.1.push_str（...）` 是一个有效的操作。

然而，Rust 可能会忘记到底借用了哪些地方。例如，假设我们将表达式 `&name.0` 重构为函数 `get_first`。请注意，在调用 `get_first（&name）` 后，Rust 现在如何删除对 `name.1` 的 W 权限：
![](../2.%20引用、借用和切片类型/asserts/Pasted%20image%2020250904105627.png)

现在我们不能做 `name.1.push_str（..）`！Rust 将返回此错误：
```rust
error[E0502]: cannot borrow `name.1` as mutable because it is also borrowed as immutable
  --> test.rs:11:5
   |
10 |     let first = get_first(&name);
   |                           ----- immutable borrow occurs here
11 |     name.1.push_str(", Esq.");
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
12 |     println!("{first} {}", name.1);
   |                ----- immutable borrow later used here

```

这很奇怪，因为在我们编辑之前，该程序是安全的。我们所做的编辑不会有意义地改变运行时行为。那么为什么我们将 `&name.0` 放入函数中很重要呢？



问题在于 Rust 在决定 `get_first（&name）` 应该借用什么时没有考虑 `get_first` 的实现。**Rust 只查看类型签名，它只是说“输入中的一些 `String` 被借用”。Rust 保守地决定借用 `name.0` 和 `name.1`，并消除对两者的写入和拥有权限。**

请记住，关键思想是**上面的程序是安全的。** 它没有未定义的行为！Rust 的未来版本可能足够聪明，可以让它编译，但今天，它被拒绝了。那么今天我们应该如何解决借款检查器呢？一种可能性是内联表达式 `&name.0`，就像在原始程序中一样。另一种可能性是将借用检查推迟到[单元格](https://doc.rust-lang.org/std/cell/index.html)的运行时，我们将在以后的章节中讨论。



### 修复安全程序：改变不同的数组元素

当我们借用数组的元素时，也会出现类似的问题。例如，观察当我们对数组进行可变引用时，借用了哪些位置：
![](../2.%20引用、借用和切片类型/asserts/Pasted%20image%2020250904105854.png)

Rust 的借用检查器不包含 `a[0]`、`a[1]` 等的不同位置。它使用一个位置 `a[_]` _来表示_ `a` 的所有索引。Rust 这样做是因为它不能总是确定索引的值。例如，想象一个更复杂的场景，如下所示：

```rust
let idx = a_complex_function(); 
let x = &mut a[idx];
```
`idx` 的价值是多少？Rust 不会猜测，所以它假设 `idx` 可以是任何东西。例如，假设我们尝试从一个数组索引读取，同时写入另一个数组索引：

![](../2.%20引用、借用和切片类型/asserts/Pasted%20image%2020250904105939.png)

  
但是，Rust 将拒绝此程序，因为 `a` 将其读取权限授予`了 x`。编译器的错误消息说了同样的事情：
```rust
error[E0502]: cannot borrow `a[_]` as immutable because it is also borrowed as mutable
 --> test.rs:4:9
  |
3 | let x = &mut a[1];
  |         --------- mutable borrow occurs here
4 | let y = &a[2];
  |         ^^^^^ immutable borrow occurs here
5 | *x += *y;
  | -------- mutable borrow later used here

```

同样， **这个程序是安全的。** 对于此类情况，Rust 通常会在标准库中提供一个可以绕过借用检查器的函数。例如，我们可以使用 [`slice：：split_at_mut`](https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut)：

您可能想知道，但 `split_at_mut` 是如何实现的？在一些 Rust 库中，尤其是`像 Vec` 或 `slice` 这样的核心类型，你经常会发现**`不安全的`块** 。 `不安全的`块允许使用“原始”指针，借用检查器不会检查这些指针的安全性。例如，我们可以使用一个不安全的块来完成我们的任务：

```rust
let mut a = [0, 1, 2, 3];
let x = &mut a[1] as *mut i32;
let y = &a[2] as *const i32;
unsafe { *x += *y; } // DO NOT DO THIS unless you know what you're doing!
```

**有时需要不安全的代码来解决借用检查器的限制**。作为一般策略，假设借款检查器拒绝了您认为实际上安全的程序。然后，**您应该寻找包含`不安全`块的标准库函数（如 `split_at_mut`）来解决您的问题。我们将在[第 20 章](https://rust-book.cs.brown.edu/ch19-01-unsafe-rust.html)中进一步讨论不安全的代码**。现在，请注意，不安全的代码是 Rust 实现某些原本不可能的模式的方式。






