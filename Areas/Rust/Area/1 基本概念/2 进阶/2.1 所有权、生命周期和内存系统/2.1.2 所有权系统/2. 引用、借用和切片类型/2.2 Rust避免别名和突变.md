### 1️. 指针与别名（Aliasing）
指针是一个强大而危险的功能，因为它们启用了**别名** 。别名是通过不同的变量访问相同的数据。就其本身而言，**别名**是无害的。但结合**突变** ，我们就有了灾难的秘诀。一个变量可以通过多种方式“夺走”另一个变量的权力，例如：

| 风险类型                | 描述                      |
| ------------------- | ----------------------- |
| Use-after-free      | 一个变量释放了数据，其他别名仍然指向这块内存。 |
| Invalid assumptions | 通过别名修改数据，使其他变量期望的属性失效。  |
| Data race           | 并发修改别名数据，导致非确定性行为。      |

### 2. Rust 的指针安全原则
>但是，由于**引用是非拥有指针**，因此它们需要与Box不同的规则来确保指针安全原则 。根据设计，引用旨在临时创建别名。

**Pointer Safety Principle**：

> 数据不能同时被别名访问和修改。
-   **允许别名**：数据可以被多个只读引用访问
-   **允许修改**：数据可以被单一所有者修改
-   **不允许两者同时存在**：禁止可变数据存在别名


Rust 实现方式：

| 类型           | 安全策略            |
| ------------ | --------------- |
| Box<T>（拥有指针） | 移动所有权，保证唯一访问    |
| &T（不可变引用）    | 允许短期别名，禁止同时可变访问 |
| &mut T（可变引用） | 独占访问，不允许别名      |


### 3. Vec 示例：堆分配与扩容

```rust
let mut v: Vec<i32> = vec![1, 2, 3];
v.push(4);
```

-   Vec 内部在堆上存储数据，长度 `len` 可变，容量 `cap` 可能大于等于 `len`。
-   当容量不足时，`push` 会触发**重新分配（reallocation）**：
    1.  分配更大的堆空间
    2.  拷贝已有元素
    3.  释放原有堆空间

> 注意：新分配的数组可能在不同的内存位置。

---

### 4. 引用与 Vec 的可变性冲突示例

```rust
let mut v: Vec<i32> = vec![1, 2, 3];
let num: &i32 = &v[2];  // 别名引用
v.push(4);              // 可变操作
println!("Third element is {}", *num); // ❌ 未定义行为
```

-   问题原因：
    -   `num` 是对 `v[2]` 的引用（别名）
    -   `v.push(4)` 可能触发堆重分配
    -   原数组被释放，`num` 变为悬垂指针
    -   解引用 `*num` 访问无效内存 → 未定义行为
        

---



