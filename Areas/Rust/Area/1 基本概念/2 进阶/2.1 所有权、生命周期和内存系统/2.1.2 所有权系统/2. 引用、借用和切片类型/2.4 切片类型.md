_切片_允许您引用[集合](https://rust-book.cs.brown.edu/ch08-00-common-collections.html)中连续的元素序列 而不是整个系列。切片是一种引用，因此**它是一个非拥有指针**。

将文章中的单词和文章概念同步起来

### 字符串切片
_字符串切片_是对 `String` 的一部分的引用，它看起来像这样：
![](asserts/Pasted%20image%2020250904111204.png)

`hello` 不是对整个 `String`（如 `s2`）的引用，而是对 `String` 的一部分的引用，在额外的 `[0..5]` 位中指定。我们通过指定 `[starting_index..ending_index]` ，使用括号内的范围创建切片，其中 `starting_index` 是切片中的第一个位置，`ending_index` 比切片中的最后一个位置多一个。

切片是特殊类型的引用，因为它们是“胖”指针或具有元数据的指针。在这里，元数据是切片的长度。我们可以通过更改可视化来查看 Rust 数据结构的内部结构来查看此元数据：


![](asserts/Pasted%20image%2020250904111305.png)

请注意，变量 `hello` 和 `world` 同时具有 `ptr` 和 `len` 字段，它们共同定义了堆上字符串的下划线区域。您还可以在这里看到 `String` 的实际外观：字符串是字节向量 （`Vec<u8>`），其中包含长度 `len` 和具有指针 `ptr` 和容量`cap`的缓冲区 `buf`。

由于切片是引用，因此它们还会更改对引用数据的权限。例如，在下面观察 `hello` 被创建为 `s` 的切片，然后 `s` 失去写入和自己的权限：
![](asserts/Pasted%20image%2020250904111340.png)




### range语法

- Rust 的 `..` 范围语法，如果你想从索引零开始，你可以删除两个句点之前的值
- 如果您的切片包含 `String` 的最后一个字节，您可以删除尾随数字
- 您还可以删除这两个值以获取整个字符串的切片

### 使用字符串切片重写 `first_word`

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

### 字符串文字是切片
回想一下，我们谈到了存储在二进制文件中的字符串文字。现在我们了解了切片，我们可以正确理解字符串文字：
```rust
let s = "Hello, world!";
```
这里 `s` 的类型是 `&str`：它是指向二进制文件特定点的切片。这也是字符串文字不可变的原因;`&str` 是一个不可变的引用。

### 字符串切片作为参数
知道您可以获取文字和 `String` 值的切片，这使我们在 `first_word` 上又进行了一项改进，这就是它的签名：
```rust
fn first_word(s: &String) -> &str {}
```
更有经验的 Rustacean 会编写示例 4-9 中所示的签名，因为它允许我们在 `&String` 值和 `&str` 值上使用相同的函数。
```rust
fn first_word(s: &str) -> &str {
```
示例 4-9：通过对 `s` 参数的类型使用字符串切片来改进 `first_word` 函数

如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个 `String`，我们可以传递 `String` 的切片或对 `String` 的引用。这种灵活性利用了 _deref 强制_ ，我们将在 第 15 章的 [“具有函数和方法的隐式 Deref 强制”](https://rust-book.cs.brown.edu/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods) 部分。


**定义一个函数以获取字符串切片而不是对 `String` 的引用 使我们的 API 更加通用和有用**，而不会丢失任何功能：
```rust
fn main() {
    let my_string = String::from("hello world"); // 创建一个 String 类型的字符串 "hello world"

    // `first_word` 可以对 String 的切片进行操作，无论是部分切片还是整个字符串。
    let word = first_word(&my_string[0..6]); // 获取前 6 个字符的切片作为参数
    let word = first_word(&my_string[..]);   // 获取整个字符串的切片作为参数
    // `first_word` 也可以作用于对 String 的引用，这与整个字符串的切片是等价的。
    let word = first_word(&my_string);       // 直接传入 String 的引用

    let my_string_literal = "hello world";   // 定义一个字符串字面量

    // `first_word` 可以对字符串字面量的切片进行操作，无论是部分切片还是整个字面量。
    let word = first_word(&my_string_literal[0..6]); // 对字面量的前 6 个字符切片
    let word = first_word(&my_string_literal[..]);   // 对整个字面量切片

    // 由于字符串字面量本身已经是字符串切片，
    // 所以直接传入也可以，不需要切片语法！
    let word = first_word(my_string_literal); 
}

```
`String` 实现了 `Deref<Target=str>` trait：
- `Deref` 允许 **自动把 `&String` 当作 `&str` 使用**

