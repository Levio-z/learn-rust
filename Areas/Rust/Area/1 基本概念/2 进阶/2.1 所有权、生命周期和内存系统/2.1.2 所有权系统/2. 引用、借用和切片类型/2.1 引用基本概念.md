### 引用是为了解决什么问题
多次读取相同场景，移动语义虽安全，却不太方便。
- `m1`、`m2` 在调用时发生 **所有权转移**，进入 `greet`，然后 `greet` 的作用域结束后释放，`main` 里就没法再用。
- 这种行为虽然安全（避免 use-after-free），但**太不方便**：实际程序里，我们常常需要多次读取相同数据。

### 引用的概念
>通过指针访问数据，避免数据的拷贝
- 引用**是非拥有指针**，因为它们不拥有它们指向的数据。**允许您引用某些值而不获取它的所有权。**
    - **默认**情况下**不允许修改我们所引用的内容**。
    - 它们指向栈上的引用，栈上的引用指向堆上的数据。我们采用`&String`而不是 `String` 。这些 & 符号代表引用，它们

### 取消引用访问底层数据
- 底层机制是**取消引用**运算符，用星号 ( `*` ) 表示。
    - `*` 的作用是取消引用
    - **补充&**
### 方法调用隐式自动解引用和引用机制
- **隐式插入取消引用和引用**
	- Rust 的方法调用语法会触发 **自动解引用（deref coercion）**：
		- 此隐式转换适用于多层指针。例如，对指向 box r 的引用调用`abs` `r: &Box<i32>`将插入两个取消引用。
	- Rust 的方法调用语法会触发 **自动引用（deref coercion）**：这种转换也可以**反向进行**。函数`str::len`需要一个引用`&str` 。如果你对一个拥有的`String`调用`len` ，那么 Rust 将插入一个借用运算符。（事实上，还有从`String`到`str`的进一步转换！）
    - 这种隐式转换适用于多层指针。例如，在对框 r 的引用上调用 `abs``： &Box<i32>` 将插入两个取消引用。
    
