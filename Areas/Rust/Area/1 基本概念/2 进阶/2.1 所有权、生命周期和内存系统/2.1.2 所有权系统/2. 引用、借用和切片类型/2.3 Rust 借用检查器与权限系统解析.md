### 1. 权限模型（Permissions on Places）

**变量对其数据的三种权限**
- **读取**（ **R** ）：数据可以被复制到另一个位置。
- **写入**（ **W** ）：数据可以改变。
- **自身**（ **O** ）：数据可以被移动或删除。

这些权限在运行时不存在，只存在于编译器中。

#### 1.1 **权限规则**
- 权限存在于 **编译期**，用于 Rust 对代码进行安全分析，并不在运行时存在。
- 所有变量都可以读取、拥有和（可选）写入其数据。
	-  默认情况下，变量拥有 **RO** 权限。
	- `let mut` 变量额外获得 **W** 权限。
- **引用（& 或 &mut）** 会暂时改变这些权限，使得借用期间的数据不能被非法修改或移动，会将权限从借用地点转移到引用。临时把访问权限交给引用。原变量的权限被“冻结”或限制，直到引用生命周期结束。
- 引用的生存期结束后，将返回权限。
- 数据必须比指向它的所有引用更有效。



#### 1.2案例-不可变引用
![](asserts/Pasted%20image%2020250904100152.png)
1. `let mut v = ...` → `v` 获得 `+R +W +O`
2. `let num = &v[2]` → 
	1. **v 无法被写入或拥有，但仍可读取**:`v` 丢失 `W` 和 `O`，只能读取，。
	2. 变量 `num` 已获得 **RO （通过声明获得）权限**。`num` 不可写，因为它没有标记为 `let mut`。
	3. `*num` 已获得 R 权限。
3. `println!(...)` → num不再使用，因此v不再被借用。因此：
	1. `v` 重新获得其 WO 权限。
	2. `num` 和 `*num` 已丢失其所有权限。
4. `v.push(4)` → v不再使用，并且它失去了所有权限。
##### `let mut num`?
```
fn main() {
let x = 0;
let mut x_ref = &x;
 println!("{x_ref} {x}");
}
```
请注意，`x_ref` 具有 W 权限，而 `*x_ref` 没有。这意味着我们可以为 `x_ref` 变量分配不同的引用（例如 `x_ref = &y`），但我们不能改变它指向的数据（例如 `*x_ref += 1`）。

##### 1.2.1所有权典型问题

 - 典型场景：vector扩容导致悬空指针
	- 初始状态：长度=容量=3
	- push操作需要重新分配内存
	- **旧指针指向已释放内存区域**
- 问题特征：
	- 表面无害但实际危险
	- 问题可能延迟显现
	- 难以通过代码审查发现
- Rust解决方案：编译器阻止同时存在活跃引用和修改操作
### 2.Rust 权限针对 Place 的通用性与互斥性

1. **Place** 是权限检查的基本单位，而不仅是变量
2. **权限互斥**确保借用期间数据不被非法修改或移动
3. **权限恢复**发生在引用生命周期结束后

#### **权限作用于所谓的Place（位置）**
在 Rust 中，**权限不仅仅作用于变量**，而是作用于所谓的 **Place（位置）**。Place 指的是代码中可以出现在赋值左侧的任意位置，其范围包括：

1. **变量**：如 `a`
2. **解引用**：如 `*a`
3. **数组访问**：如 `a[0]`
4. **结构体/元组字段**：如 `a.0` 或 `a.field`
5. **组合形式**：如 `*((*a)[0].1)`

#### 权限失效的原因是互斥权限
**当一个位置被借用时，它无法被修改，直到借用不再使用**。一旦借用的生命周期结束，该位置的权限也随之失效，从而允许其他操作（如修改）重新获得权限。


### 3. 借用检查器发现权限冲突

#### 3.1 借用会导致该数据暂时处于只读状态
>临时提供对数据的访问而不移动数据也很有用

回想一下指针安全原则：数据不应被别名化和变异。这些权限的目标是确保数据在被别名化后不能被变异。**创建对数据的引用（“借用”）会导致该数据暂时处于只读状态，直到不再使用该引用。**
![](asserts/Pasted%20image%2020250904100728.png)
- 每当使用某个地方时，Rust 都希望该地方根据作拥有某些权限。例如，借用 `&v[2]` 要求 `v` 是可读的。因此，R 权限显示在作 `&` 和位置 `v` 之间。该字母被填写，因为 `v` 在该行具有读取权限。
- 相比之下，变更作 `v.push（4）` 要求 `v` 是可读和可写的。显示了 R 和 W。但是，`v` 没有写入权限（它是由 `num` 借用的）。所以字母 W 是空心的，表示写入权限是预期的，但 `v` 没有。
- 如果您尝试编译此程序，则 Rust 编译器将返回以下错误：
```rust
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> test.rs:4:1
  |
3 | let num: &i32 = &v[2];
  |                  - immutable borrow occurs here
4 | v.push(4);
  | ^^^^^^^^^ mutable borrow occurs here
5 | println!("Third element is {}", *num);
  |                                 ---- immutable borrow later used here
```
错误消息解释说，在引用 `num` 使用时不能改变 `v`。这是表面原因——根本问题是 `num` 可能会被`push`无效。Rust 捕获了潜在的内存安全违规行为。

#### 3.2 可变引用提供对数据的唯一且非所有权的访问
>临时提供对数据的可变访问而不移动数据也很有用

其机制是**可变引用** （也称为**唯一引用** ）。下面是一个带有随附权限更改的可变引用的简单示例：
![](asserts/Pasted%20image%2020250904101216.png)

使用 `&mut` 运算符创建可变引用。`num` 的类型写为 `&mut i32`。与不可变引用相比，您可以看到权限的两个重要差异：

1. 当 `num` 是不可变引用时，`v` 仍然具有 R 权限。现在 `num` 是一个可变引用，当 `num` 使用时，`v` 已经失去_了所有_权限。
2. 当 `num` 是不可变引用时，地方 `*num` 只有 R 权限。现在 `num` 是一个可变引用，`*num` 也获得了 W 权限。

第一个观察结果是使可变引用_安全_的原因。**可变引用允许突变，但防止别名。借用的 place `v` 暂时无法使用，因此实际上不是别名**。

第二个观察是使**可变引用有用的原因**。**`v[2]` 可以通过 `*num` 进行变异**。例如，`*num += 1` 会改变 `v[2]。` 请注意，`*num` 具有 W 权限，但 `num` 没有。`num` 引用可变引用本身，例如 `num` 不能重新分配给不同的可变引用。

#### 3.3 可变引用也可以暂时“降级”为只读引用
![](asserts/Pasted%20image%2020250904101547.png)


在此程序中，借用 `&*num` 删除了 `*num` 中的 W 权限， 但不会删除 R 权限，因此 `println！（..）` 可以同时读取 `*num` 和 `*num2`。

### 4. 权限和生存期
#### 4.1 权限在引用的生存期结束时返回
我们上面说过，引用在“使用中”时会更改权限。短语“使用中”描述的是引用的生命周期，或者从其**诞生（创建引用的地方）到其消亡（最后一次使用引用的时间）的代码范围**。

例如，在此程序中，`y` 的生命周期以 `let y = &x` 开始，以 `let z = *y` 结束：
![](asserts/Pasted%20image%2020250904102322.png)


在 `y` 的生命周期结束后，`x` 上的 W 权限将返回给 `x`。

![](asserts/Pasted%20image%2020250904102452.png)
- 变量 `c` 在 if 语句的每个分支中具有不同的生存期。在 then-block 中，表达式 `c.to_ascii_uppercase（）` 中使用`了 c`。因此，`*v` 直到该行之后才会重新获得 W 权限。
- 但是，在 else-block 中，不使用 `c`。`*v` 在进入 else-block 时立即重新获得 W 权限。

#### 4.2 数据必须比其所有引用更长
指针安全原则的一部分，借用检查器强制要求**数据必须比对它的任何引用更有效**。

Rust 以两种方式强制执行此属性。
第一种方法处理在单个函数范围内创建和删除的引用。例如，假设我们试图在保留对它的引用时删除一个字符串：

![](asserts/Pasted%20image%2020250904102732.png)

为了捕获此类错误，Rust 使用我们已经讨论过的权限。借用 `&s` 从 `s` 中删除 O 权限。但是，`drop` 需要 O 权限，从而导致权限不匹配。引用存在，原数据不能删除。


关键思想是，在这个例子中，**Rust 知道 `s_ref` 寿命有多长。
对于函数输出引用来说，rust需要知道输出和哪个输入引用关联来计算引用的寿命。
但是，当 Rust 不知道引用的寿命有多长时，它需要一种不同的强制机制。具体来说，当引用是函数的输入或函数的输出时。例如，下面是一个安全函数，它返回对向量中第一个元素的引用**。

![](asserts/Pasted%20image%2020250904102905.png)
此代码段引入了一种新的权限，即流权限 F。每当表达式使用输入引用（如 `&strings[0]`）或返回输出引用（如`返回 s_ref`）时，都需要 F 权限。

与 RWO 权限不同，F 不会在函数的整个主体中更改。如果允许在特定表达式中使用（即_流动_ ），则引用具有 F 权限。例如，假设我们`首先`更改为包含`默认`参数的新函数 `first_or`：

![](asserts/Pasted%20image%2020250904102945.png)

此函数不再编译，因为表达式 `&strings[0]` 和 `default` 缺少返回所需的 F 权限。但是为什么？Rust 给出了以下错误：

```
error[E0106]: missing lifetime specifier
 --> test.rs:1:57
  |
1 | fn first_or(strings: &Vec<String>, default: &String) -> &String {
  |                      ------------           -------     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `strings` or `default`

```
消息“缺少生命周期说明符”有点神秘，但帮助消息提供了一些有用的上下文。如果 Rust _只_查看函数签名，它不知道输出 `&String` 是对`字符串`的引用还是`对默认值`的引用。为了理解为什么这很重要，假设我们使用了这样的 `first_or`：


```rust
fn main() {
    let strings = vec![];
    let default = String::from("default");
    let s = first_or(&strings, &default);
    drop(default);
    println!("{}", s);
}
```
**如果允许`默认`流入返回值 `first_or` 则此程序是不安全的**。与前面的示例一样，`drop` 可能会使 `s` 无效。Rust 只有在_确定_ `default` 不能流入返回值时才允许该程序编译。

为了指定是否可以返回 `default，Rust` 提供了一种称为_生命周期参数_的机制。我们将在后面的第 10.3 章 “ [验证具有生命周期的引用”](https://rust-book.cs.brown.edu/ch10-03-lifetime-syntax.html) 中解释该功能。现在，只要知道：（**1） 输入/输出引用的处理方式与函数体中的引用不同，以及 （2） Rust 使用不同的机制， 即 F 权限，来检查这些引用的安全性。**



要在另一个上下文中查看 F 权限，假设您尝试返回对堆栈上变量的引用，如下所示：

![](asserts/Pasted%20image%2020250904103151.png)

此程序不安全，因为当引用 `&s` 返回时 `return_a_string` 将失效。Rust 将拒绝这个程序，并出现类似的`缺少生命周期说明符`错误。现在，您可以理解错误意味着 `s_ref` 缺少适当的流权限。

- **局部变量生命周期限制**：
    - `s` 是函数 `return_a_string` 内部创建的局部 `String`。
    - 函数结束后，`s` 会被销毁，内存释放。
- **返回引用问题**：
    - `s_ref` 是对 `s` 的引用。
    - 返回 `&s` 相当于返回了一个 **悬空指针**（dangling reference）。
    - Rust 借用检查器发现此引用可能在 `s` 已释放后使用，因此拒绝编译。
- **权限模型视角**：
    - `s_ref` 对 `s` 拥有 **R（只读）权限**。
    - 当尝试返回 `s_ref` 时，函数外部需要延长 `s` 的权限，但 `s` 已经超出作用域 → 权限无法延续。
    - 因此 **缺少适当的流权限（lifetime）**，Rust 编译器会报：

```

error[E0515]: cannot return reference to local variable `s`
```




















