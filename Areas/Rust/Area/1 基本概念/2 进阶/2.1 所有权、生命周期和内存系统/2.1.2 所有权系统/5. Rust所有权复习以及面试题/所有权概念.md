### 所有权概念
#### 1所有权核心
核心在于
- 所有权是 Rust 一种编译期静态内存管理模型，是Rust内存管理的核心：通过一套编译器规则来保证 **内存安全** 、 **无数据竞争**。
基本规则
- 可以分为三点：基本规则是每个值有唯一的所有者，离开作用域时自动释放，从而避免未定义行为。
举个例子
- [内存管理模型分类分析](../../../../../../../basic/编译原理/内存管理/内存管理的机制/内存管理模型分类分析.md)
他的价值是
- 编译期静态分析生命周期：**内存安全** 、 **无数据竞争**
##### 1.1 解释一下什么叫编译器静态内存管理？为什么这么设计？
编译器在 **编译阶段** 就确定程序的内存分配和释放策略，而不是依赖运行时垃圾回收或手动释放。换句话说，**内存的生命周期和使用规则在编译期就已经明确，运行时不需要额外的垃圾收集开销**。

Rust 的所有权系统就是典型实现：通过所有权（ownership）、借用（borrowing）和生命周期（lifetime）规则，编译器可以 **静态分析** 每个值的生命周期，确保[1所有权核心](#1 所有权核心)-价值
##### 1.2 相比于其他语言解决了什么问题？
在 **系统编程（System Programming）** 领域解决 C/C++ 长期存在的痛点，同时在一定程度上借鉴现代语言（如 Java、Go）的优点。
内存安全（Memory Safety）：静态检查模型，编译期保证内存安全
数据竞争（Data Race）：编译器禁止数据竞争Send Trait，封装并发原语，静态类型检查
零成本抽象：借鉴高抽象语言，同时保持高表达性（用简洁、自然的方式表达复杂逻辑和抽象概念的能力，代码可读可维护，语法糖/内置模板（宏），类型系统（自动推断）/模式匹配（直观））和抽象能力（隐藏实现细节，只保留核心本质特征，以便简化理解和使用），不牺牲性能

ELSE：
- 跨领域统一（Systems + Application）
- 延迟敏感和安全的场景（高频交易）
- 现代生态与工具链
	- Cargo：官方包管理器 + 构建工具，远强于 `make` / `cmake`。
	- Crates.io：统一依赖仓库，生态完善。
	- Rustfmt / Clippy：代码风格和 lint 工具，提升一致性。
	- 强大的编译器错误提示，被称为“世界上最友好的编译器”。
##### 1.3 解释一下基本规则，为什么这么设计？
基本规则
- 每个值（资源）都有一个唯一的所有者（owner）
- 当所有者离开作用域时，该值会被自动释放（drop）
- 所有权可以转移（Move），也可以通过引用借用（Borrow）
具体规则
- 移动（Move）规则：对大多数非标量类型，赋值 = 移动所有权。
- 借用（Borrowing）规则
	- **不可变借用**：允许多个同时存在。
	- **可变借用**：同一作用域只允许 **一个**，避免数据竞争。
	- **不可变借用和可变借用不能共存**。
- 生命周期（Lifetime）规则
	- 所有引用必须在它们所指向的值的生命周期内有效。
	- 编译器通过 **生命周期推断** 和 **显式生命周期标注** 来检查引用的合法性。
- 切片
	- 切片（`&[T]`, `&str`）也是引用，受借用规则约束。
- 函数
	- 参数
		- 值传递 = Move（除非实现 `Copy`）。
		- 引用传递 = Borrow。
	- 返回值
		- **返回值转移所有权**：
##### 1.4 如何实现内存安全与无数据竞争的？
Rust 的核心目标是 **在编译期（不依赖 GC）实现内存安全（memory safety）和无数据竞争（data race free）**。这主要依靠 **所有权（Ownership）+ 借用（Borrowing）+ 生命周期（Lifetime）+ 类型系统**（独特的类型，并发安全类型系统 (`Send` 和 `Sync`)） 组合实现。
- 借用规则 + 生命周期检查保证引用永远指向有效内存
######  1. 所有权系统
- 每个值在同一时刻只能有一个所有者。
- 超出作用域时自动释放（RAII，类似 C++ 智能指针但更严格）。
- 避免了 **悬垂指针（Dangling pointer）** 和 **内存泄漏（Memory leak）**。
###### 2. 借用检查器（Borrow Checker）
- 引用分为 `&T`（不可变借用）和 `&mut T`（可变借用）。
- 编译器检查：
    - **同一时刻**要么有任意多个不可变引用，要么有唯一的可变引用。
    - 保证在编译期 **不存在数据竞争。
###### 3. 生命周期（Lifetimes）
- 编译器跟踪每个引用的生命周期，确保引用在其指向的数据有效期内使用。
- 避免 **悬垂引用**（dangling reference）。


无数据竞争的保证机制
- 编译期借用规则
	- 多个线程同时访问同一内存地址，至少有一个写操作，且没有同步机制。
- 并发安全类型系统 (`Send` 和 `Sync`)
	- 禁止非线程安全类型跨线程传递

### 引用、借用和切片类型
### Rust中的借用检查器的主要内容，是为了解决什么问题
- 引用，读取数据避免数据拷贝，提供一种不依赖转移或复制来读取数据的方式，引用是一种别名
- 核心：避免别名和突变
- 实现：定义别名（只读引用）和可变引用（突变）来实现，底层是编译期权限分析系统和借用检查器
#### 权限系统和编译器的借用检查器协同工作
- R W O？
- 一开始有什么权限
- 借用和可变引用（唯一的独占访问）会改变原来变量的访问权限，读就会与W互斥，W会与RW互斥
- 基于位置而不是变量
	- 和函数声明有关，传入一个结构体可读引用，所有位置都会被禁用
	- 数组，借用一个位置，整个数组权限也会禁用，对于 `[T; N]` 或 `Vec<T>`，可以使用 **split_at_mut** 或 **索引安全分割**：借用一个元素 → 整个数组被冻结，不追踪数组索引的具体值（x可能是任何值），**最保守**，保证唯一可变访问原则不被破坏
- 数据比引用更长
	- 方法内，引用的时候，不能删除原数据、
	- 函数和方法规则不一样，输出和输入的引用关联，编译器才能静态分析
