---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层
- 目标：**避免不必要的深拷贝，提高性能，并安全地表达所有权转移。**
- 移动本质：当值从一个作用域移动到另一个作用域时，**新作用域获得所有权，原作用域失去访问权**，让新对象接管原对象的数据指针，原对象进入一种“空壳（valid but unspecified）”状态。
- 示例说明：let data = vec![10, 42, 9, 8];传递给函数时，data会被移动到函数内部，main作用域将无法再使用
![](asserts/Pasted%20image%2020260101103333.png)
- find_pos会获取栈上的副本，原来的变量失去堆上变量的所有权
##### 包含堆内存的数据结构/只有持有所有权的以及数据在在堆上变量才能移动所有权**
- 如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。
- 基本类型、元组、不可变引用
### Ⅱ. 实现层



### Ⅲ. 原理层

**移动堆数据原理**：如果一个变量 `x` 将堆数据的所有权转移到另一个变量 `y` 上，则移动后不能使用 x`。
- 为什么
    - 第一个，后面释放了使用前面的就会出现未定义异常
    - 第二个, **二次释放（double free）**

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  



C++11：支持移动 → 只转移指针，避免多次堆分配与拷贝。移动语义保证“独占所有权”安全转移，避免重复释放或泄漏。




### 位置

讨论数据固定及相关主题时，一个有用的概念是“ _位置_ ”（place）。**位置是一块内存区域（带有地址），值可以存放在这里**。

**引用指向的是位置**：引用实际上并不指向值本身，而是指向一个位置。这就是为什么 `*ref = ...` 有意义：解引用返回的是位置，而不是值的副本。位置对于语言实现者来说是众所周知的，但在编程语言中通常是隐式的（例如 Rust 就是隐式的）。程序员通常对位置有很好的直觉，但可能不会特意去思考它们。

**变量和字段访问也被求值为位置**：除了引用之外，变量和字段访问也会被求值为位置。事实上，赋值语句左侧的任何内容在运行时都必须是一个位置（这就是为什么在编译器术语中位置被称为“左值”的原因）。

在 Rust 中，可变性是位置的属性，就像由于借用而被“冻结”一样（我们可能会说位置被借用了）。

**赋值操作改变对象的地址**：Rust 中的赋值操作会移动数据（大多数情况下是这样，一些简单的数据具有复制语义，但这并不重要）。当我们写 `let b = a;` 时，内存中位于 `a` 地址的数据会被移动到 `b` 地址。这意味着赋值之后，数据存在于 `b` ，但不再存在于 `a` 。换句话说， [赋值](https://rust-lang.github.io/async-book/part-reference/pinning.html#footnote-compiler)操作改变了对象的地址。

**引用阻止移动**：如果指向被移动对象所在位置的指针仍然存在，那么这些指针将失效，因为它们不再指向该对象。这就是为什么借用的引用会阻止移动： `let r = &a; let b = a;` 是非法的，因为 `r` 的存在阻止了 `a` 移动

### 对象内部的引用对于编译器来说是不可见的

```rust
struct Bad {
    field: u64,
    r: &'self u64,
}
```

我们可以有一个 `Bad` 的实例 `b` ，其中 `br` 指向 `b.field` 。在 `let a = b;` 中，内部引用 `br` 指向 `b.field` 对编译器是不可见的，因此看起来好像没有对 `b` 引用，所以将 b 移动到 `a` 操作似乎是可以的。然而，如果这种情况发生，那么在移动之后， `ar` 指向的将不是我们期望的 `a.field` ，而是 `b.field` 原位置的无效内存，这违反了 Rust 的安全保证。

移动数据不仅限于值。数据也可以从唯一引用中移出。 `Box` 进行解引用会将数据从堆移动到栈。`take`、 `replace` 和 `swap` （均在 [`std::mem`](https://doc.rust-lang.org/std/mem/index.html) 中）会将数据从可变引用（ `&mut T` ）中移出。[Rust-移动语义-对于可变引用中移动出数据](Rust-移动语义-对于可变引用中移动出数据.md)
- 从 `Box` 中移出数据会使指向的位置失效。从可变引用中移出数据会使该位置仍然有效，但其中包含不同的数据。
```rust
fn main() {
    let b = Box::new(42);
    let x = *b; // 解引用移动
    println!("z 的地址: {}", x);
}
```

从抽象意义上讲，数据移动的实现方式是将源位置的位复制到目标位置，然后擦除源位置的位。然而，编译器可以通过多种方式优化这一过程。

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
