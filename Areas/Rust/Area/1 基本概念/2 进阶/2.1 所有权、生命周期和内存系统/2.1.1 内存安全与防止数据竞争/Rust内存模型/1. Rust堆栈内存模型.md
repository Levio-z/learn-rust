
### 一、基本内存模型概念

Rust 的内存管理分 **栈（Stack）** 与 **堆（Heap）**：
### 二、【[**Variables Live in the Stack**](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#variables-live-in-the-stack)】
#### 基本概念
- 存放局部变量和函数帧（frame）。
- 先进后出，生命周期清晰。 
	- 变量存在于栈中，由于栈的分配机制，栈中所有数据都必须占用**已知且固定大小的内存空间**
- 函数返回时，栈帧自动释放。
#### 1. 栈分配的机制
**核心机制**
- **栈在编译时就确定了每个函数需要多少栈空间（局部变量 + 栈帧开销）**，分配和释放都是通过简单的指针加减操作完成的，**不需要动态计算大小或查找空闲块**
**具体过程：**
- 当函数被调用时，CPU 只需将栈指针（Stack Pointer, SP）**向下移动固定偏移量**，就完成所有局部变量的分配
- 函数返回时，栈指针再恢复到调用前的位置，一次性释放所有栈帧
---
#### 2. 为什么必须固定大小
栈分配的机制：栈帧在编译期大小已确定，运行期通过指针移动快速分配
#### 特点
栈的优势在于**快速分配和释放**，编译期确定栈和局部变量大小，保证栈操作一次性分配所有空间

### 三、【[**Boxes Live in the Heap**](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#boxes-live-in-the-heap)】
#### 3.1为什么需要堆
- 存放**动态分配**的数据（例如 `Box`, `Vec`, `String`）。不要求必须提前知道大小，数据量过大。
- 生命周期**不依赖栈帧，而是依赖所有者**。
- 所有者离开作用域时，堆内存自动回收。
##### 3.1.1 存储大小未知或变化的数据
- 栈内存分配要求 **编译时必须知道数据大小**，并且生命周期跟随函数调用帧。
- 如果数据量 **过大**（如百万级数组），栈无法容纳；或者数据大小 **在运行时才能确定**，就需要堆。
栈为什么设计不大

- **节约每个线程内存**，多线程难以创建大量内存。
- **保证快速分配和释放**，越小越快
- **减少栈溢出风险**，没创建一个线程就有很大的栈，内存空间容易被耗尽。如果每层栈帧大 → 递归深度减少。
##### 3.1.2 为了在不复制数据的情况下传输对数据的访问
- 在栈上传递大对象意味着 **复制整个对象**，性能和内存消耗都很大。
- 堆允许我们存一次，再通过 **指针** 引用，而不是复制数据本身。
#### 3.2 指针与堆的关系
Rust 中的堆内存分配流程：
1. **在堆上分配内存**
    - 向操作系统请求空间，OS 在堆区域找到一块合适内存，标记为已用。
    - 返回这块内存的起始地址（即指针）。
2. **在栈上保存指针**
    - 该指针本身存储在栈上。
    - 通过栈上的指针，可以访问堆上真实的数据。
3. **通过指针共享访问**
    - 多个变量可以持有相同的指针（受 Rust 所有权规则管理），避免复制大块数据。
#### 3.3 Rust 中的堆分配工具
##### **`Box<T>`：最基础的堆分配工具**
- 把一个值放到堆上，并返回指针。
- 常用于：大数据结构、递归类型（如链表）、或需要在堆上保留生命周期的对象。
```rust
let boxed_array = Box::new([0u8; 1_000_000]); // 在堆上存储百万数组
```
##### **`Vec<T>`**
- 动态数组，内部管理堆分配的内存块。
- 典型场景：存储大小在运行时才能确定的数据。
```rust
let mut v = Vec::new();
v.push(1);
v.push(2);
```
##### **`Rc<T>` / `Arc<T>`**
- 引用计数堆分配，用于在多个地方共享同一份数据（单线程/多线程）。



### 四、性能区别

在**栈上分配内存比在堆上分配内存要快**，因为入栈时操作系统**无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。**相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

### 五、静态与动态内存分配
#### 静态分配
- 基本定义：在程序编译时就确定并分配内存空间的方式
	- 程序员视角：在代码中声明变量类型
	- 编译器视角：编译程序时已经知道这些变量所占的字节大小，于是给它们分配一块固定的内存将它们存储其中，这样变量在栈帧/数据段中的位置就被固定了下来
	- 内存视角：其分配的内存大小和位置在程序运行期间是固定的
#### 动态分配
- 随着应用运行动态增减的内存空间
- 实现机制：应用所依赖的基础系统库（如 Linux 中的 glibc 库等）会直接通过系统调用（如类 Unix 内核提供的 sbrk 系统调用）来向内核请求增加/缩减应用地址空间内堆的大小
#### 动态分配的本质
动态分配是一项非常基础的功能，很多高级语言的系统标准库中都实现了它。以 C 语言为例，C 标准库中提供了如下两个动态分配 的接口函数：
```rust
void* malloc (size_t size); void free (void* ptr);
```
- `malloc`
    - 其中，`malloc` 的作用是从堆中分配一块大小为 `size` 字节的空间，并返回一个指向它的指针。而后续不用的时候，将这个指针传给 `free` 即可在堆中回收这块空间。
- 指针是在栈上的，通过指针间接访问堆空间上的数据。
    - 我们通过返回的指针变量来 **间接** 访问堆空间上的数据。
    - 事实上，我们在程序中能够 **直接** 看到的变量都是被静态分配在栈或者全局数据段上的，它们大小在编译期已知。
    - 比如我们可以把**固定大小的指针放到栈（局部变量）或数据段（全局变量）上，然后通过指针来指向运行时才确定的堆空间上的数据**，并进行访问。这样就可以**通过确定大小的指针来实现对编译时大小不确定的堆数据**的访问。
- 灵活调整变量的生命周期
    - 局部变量生命周期随着函数的结束而结束
    - 静态分配在数据段中的全局变量在整个运行期都存在
    - **动态分配允许构造一种不一定绑定在函数调用的变量生命周期，参数或返回值提供夸函数使用**
- 缺点
    - 运行着**复杂的连续内存分配算法，相比静态分配会带来一些额外的开销**
    - **分配过于频繁，会带来内存碎片**
### 其他
#### 栈帧
**存放函数帧（Function Frame / Stack Frame）
- 每次函数调用，栈会为该函数分配一块内存空间，称为**栈帧**
- 栈帧包含：
    - 函数参数
    - 局部变量
    - 返回地址（函数调用完返回到调用者的位置）
    - 有时保存寄存器临时值