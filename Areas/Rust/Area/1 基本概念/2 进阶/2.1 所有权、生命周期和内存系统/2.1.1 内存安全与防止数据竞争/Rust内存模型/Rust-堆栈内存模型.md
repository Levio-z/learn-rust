---
tags:
  - permanent
---

## 1. 核心观点  
### Ⅰ. 概念层

    
Rust 的内存管理分 **栈（Stack）** 与 **堆（Heap）**：
- 栈内存的特点与生命周期
    - 动态变化：随函数调用增减而动态变化
    - 规律性强：生命周期有明确规律可循
    - 自动管理：由编译器自动分配和回收
    - 大小确定：函数栈帧大小在编译期就已确定
- 堆内存的特点与管理方式﻿05:00﻿
    - 管理方式多样：
        - C/C++：手工管理
        - Java/Go：GC自动管理
        - Swift：ARC引用计数
    - 动态扩展：适合存储需要动态扩展的大数据
    - 生命周期不确定：不受栈帧限制

### Ⅱ. 应用层





### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
	- [**Variables Live in the Stack**](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#variables-live-in-the-stack)
	- [**Boxes Live in the Heap**](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#boxes-live-in-the-heap)
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 3.1 基本内存模型概念

### 3.2 栈
- [操作系统-栈-基本概念](../../../../../../../basic/操作系统/os-note/note/atomic/操作系统-栈-基本概念.md)
### 3.3堆
- 生命周期**不依赖栈帧，而是依赖所有者**。
- 所有者离开作用域时，堆内存自动回收。
- [操作系统-堆-基本概念](../../../../../../../basic/操作系统/os-note/note/atomic/操作系统-堆-基本概念.md)
- [Rust-堆内存管理-生命周期核心规则和机制](Rust-堆内存管理-生命周期核心规则和机制.md)
### 3.4 指针和堆栈
- [操作系统-堆-指针与堆和栈的关系](../../../../../../../basic/操作系统/os-note/note/atomic/操作系统-堆-指针与堆和栈的关系.md)
### 3.5 Rust 中的堆分配工具
##### **`Box<T>`：最基础的堆分配工具**
- 把一个值放到堆上，并返回指针。
- 常用于：大数据结构、递归类型（如链表）、或需要在堆上保留生命周期的对象。
```rust
let boxed_array = Box::new([0u8; 1_000_000]); // 在堆上存储百万数组
```
##### **`Vec<T>`**
- 动态数组，内部管理堆分配的内存块。
- 典型场景：存储大小在运行时才能确定的数据。
```rust
let mut v = Vec::new();
v.push(1);
v.push(2);
```
##### **`Rc<T>` / `Arc<T>`**
- 引用计数堆分配，用于在多个地方共享同一份数据（单线程/多线程）。



### 四、性能区别

在**栈上分配内存比在堆上分配内存要快**，因为入栈时操作系统**无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。**相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

### 五、静态与动态内存分配
#### 静态分配
- 基本定义：在程序编译时就确定并分配内存空间的方式
	- 程序员视角：在代码中声明变量类型
	- 编译器视角：编译程序时已经知道这些变量所占的字节大小，于是给它们分配一块固定的内存将它们存储其中，这样变量在栈帧/数据段中的位置就被固定了下来
	- 内存视角：其分配的内存大小和位置在程序运行期间是固定的
#### 动态分配
- 随着应用运行动态增减的内存空间
- 实现机制：应用所依赖的基础系统库（如 Linux 中的 glibc 库等）会直接通过系统调用（如类 Unix 内核提供的 sbrk 系统调用）来向内核请求增加/缩减应用地址空间内堆的大小
#### 动态分配的本质
动态分配是一项非常基础的功能，很多高级语言的系统标准库中都实现了它。以 C 语言为例，C 标准库中提供了如下两个动态分配 的接口函数：
```rust
void* malloc (size_t size); void free (void* ptr);
```
- `malloc`
    - 其中，`malloc` 的作用是从堆中分配一块大小为 `size` 字节的空间，并返回一个指向它的指针。而后续不用的时候，将这个指针传给 `free` 即可在堆中回收这块空间。
- 指针是在栈上的，通过指针间接访问堆空间上的数据。
    - 我们通过返回的指针变量来 **间接** 访问堆空间上的数据。
    - 事实上，我们在程序中能够 **直接** 看到的变量都是被静态分配在栈或者全局数据段上的，它们大小在编译期已知。
    - 比如我们可以把**固定大小的指针放到栈（局部变量）或数据段（全局变量）上，然后通过指针来指向运行时才确定的堆空间上的数据**，并进行访问。这样就可以**通过确定大小的指针来实现对编译时大小不确定的堆数据**的访问。
- 灵活调整变量的生命周期
    - 局部变量生命周期随着函数的结束而结束
    - 静态分配在数据段中的全局变量在整个运行期都存在
    - **动态分配允许构造一种不一定绑定在函数调用的变量生命周期，参数或返回值提供夸函数使用**
- 缺点
    - 运行着**复杂的连续内存分配算法，相比静态分配会带来一些额外的开销**
    - **分配过于频繁，会带来内存碎片**
### 其他
#### 栈帧
**存放函数帧（Function Frame / Stack Frame）
- 每次函数调用，栈会为该函数分配一块内存空间，称为**栈帧**
- 栈帧包含：
    - 函数参数
    - 局部变量
    - 返回地址（函数调用完返回到调用者的位置）
    - 有时保存寄存器临时值

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：
	- [操作系统-栈-为什么设计不大](../../../../../../../basic/操作系统/os-note/note/atomic/操作系统-栈-为什么设计不大.md)

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
