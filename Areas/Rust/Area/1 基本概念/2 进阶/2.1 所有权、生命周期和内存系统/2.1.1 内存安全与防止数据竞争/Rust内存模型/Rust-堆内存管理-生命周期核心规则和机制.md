---
tags:
  - permanent
---

## 1. 核心观点  
### Ⅰ. 概念层

- 核心规则：
	- 唯一所有权：值被唯一的scope（所有者Owner）拥有
	- 共存亡：当所有者离开作用域时，其值会被自动释放（drop）。
	-  如果要共享或转移值，必须通过 **借用（&T / &mut T）** 或 **所有权转移（Move）**。
		- 移动语义：值可移动到新scope，所有权随之转移
		- 引用规则：
			- 允许多个只读引用 或 单个可变引用
			- 引用间存在互斥关系（类似RwLock）
			-  活跃性检查：**只有当引用被实际使用时才会触发互斥检查**
	- 生命周期约束：引用不能超过值的存活期
- 堆栈绑定：
    - 堆内存生命周期与栈内存绑定
    - 通过栈指针管理堆内存，实现自动释放

- 辅助理解：类比系统：类似UNIX权限系统，所有权决定访问权限
- [相比其他语言](Rust-堆内存管理-生命周期核心规则和机制.md#相比其他语言)
### Ⅱ. 应用层





### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
	- [**Variables Live in the Stack**](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#variables-live-in-the-stack)
	- [**Boxes Live in the Heap**](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#boxes-live-in-the-heap)
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 相比其他语言

- 优势体现：
    - 避免内存泄漏和use-after-free
    - 内存使用效率高于GC语言
    - 无运行时GC开销
- C/C++方式：由程序员完全手动控制堆内存生命周期，灵活性高但容易出错
- JAVA/Golang方式：由系统通过GC自动管理，剥夺了程序员控制权，只能解决内存问题
- Rust折中方案：通过编译器强制约束规则，既保证安全又不完全剥夺控制权
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：
	- [操作系统-内存结构以及生命周期管理](../../../../../../../basic/操作系统/os-note/操作系统-内存结构以及生命周期管理.md)

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
