---
tags:
  - permanent
---

## 1. 核心观点  
### Ⅰ. 概念层

- 核心规则：
	- 唯一所有权：值被唯一的scope（所有者Owner）拥有
		- 有权核心规则: 两个scope不能同时拥有同一块内存，必须通过Mutex、RwLock或Arc等机制进行保护。
	- 共存亡：当所有者离开作用域时，其值会被自动释放（drop）。
	-  如果要共享或转移值，必须通过 **借用（&T / &mut T）** 或 **所有权转移（Move）**。
		- 移动语义：值可移动到新scope，所有权随之转移
		- 引用规则：
			- 允许多个只读引用 或 单个可变引用
			- 引用间存在互斥关系（类似RwLock）
			-  活跃性检查：**只有当引用被实际使用时才会触发互斥检查**
	- 生命周期约束：引用不能超过值的存活期
		- 标注作用：帮助编译器理解参数间生命周期关系
	- 安全保证：通过编译即无内存安全问题（但不保证无并发问题）
### 核心机制：堆栈绑定来解决内存安全问题
- [Rust-堆内存管理-如何解决内存安全问题](Rust-堆内存管理-如何解决内存安全问题.md)
### 如何解决线程安全问题
- [Rust-堆内存管理-如何解决线程安全问题](Rust-堆内存管理-如何解决线程安全问题.md)
### 共享内存
- 共享内存方案:
    - 方案1：使用Arc等智能指针进行共享
    - 方案2：将值移动到另一个scope（原scope会失去控制权）
    - 方案3：拷贝内存创建新实例
### 辅助理解
- 辅助理解：类比系统：类似UNIX权限系统，所有权决定访问权限
### VS其他语言
- [相比其他语言](Rust-堆内存管理-所有权和生命周期核心规则和核心机制.md#相比其他语言)
### Ⅱ. 应用层





### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
	- [**Variables Live in the Stack**](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#variables-live-in-the-stack)
	- [**Boxes Live in the Heap**](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#boxes-live-in-the-heap)
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 所有权解决内存安全问题



### 相比其他语言

- 优势体现：
    - 避免内存泄漏和use-after-free
    - 内存使用效率高于GC语言
    - 无运行时GC开销
- C/C++方式：由程序员完全手动控制堆内存生命周期，灵活性高但容易出错
- JAVA/Golang方式：由系统通过GC自动管理，剥夺了程序员控制权，只能解决内存问题
- Rust折中方案：通过编译器强制约束规则，既保证安全又不完全剥夺控制权
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：
	- [操作系统-内存结构以及生命周期管理](../../../../../../../basic/操作系统/os-note/操作系统-内存结构以及生命周期管理.md)

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
