### Rust堆中的堆数据机构
#### 基本概念
- 指针
	- 是包含内存地址的变量的一般概念。此地址引用或“指向”其他数据。
 - 引用
	 - 最常见的指针类型是引用：用&符号表示，并**借用它们指向的值**。除了引用数据之外，它们没有任何特殊功能，并且没有开销。严格的 **借用检查** (Borrow Check) ，来确保在编译期就解决掉很多内存不安全问题。
- 裸指针 `*const T/*mut T` 
	- 基本等价于 C/C++ 里面的普通指针 `T*` ，它自身的内容仅仅是一个地址。它最为灵活，但是也最不安全。编译器只能对它进行最基本的可变性检查（只读的数据不能写）。
- 智能指针
	- 额外功能：**相比较于普通指针（裸指针），除了位置信息，还携带额外信息，以提供管理和控制**。拥有它们指向的数据。
    - 额外大小：因此智能指针的大小通常大于裸指针，这被称作 **胖指针** (Fat Pointer)。
        - 如果智能指针仅**用堆维护元信息**（如针对 `Sided` 类型的 `Arc` 与 `Rc`），那么它们“胖”在堆上，指针本身仍然是 8 字节的；
        - 反之，如果**指针本身维护元信息**（如 `Mutex` 和 `Vec`），指针本身就会大于 8 字节。
#### 特点
- 虽重但强，可以提供比引用更多的功能特性。
![](../../../../1%20基础知识/RustBook/15.智能指针/asserts/Pasted%20image%2020250604193144.png)
#### 分类
- `Box<T>` 在创建时会在堆上分配一个类型为 `T` 的变量，它自身也只保存在堆上的那个变量的位置。而和裸指针或引用不同的是，**当 `Box<T>` 被回收的时候，它指向的那个变量（位于堆上）也会被回收**。`Box<T>` 可以对标 C++ 的 `std::unique_ptr` 。
- `Rc<T>` 
	- 多所有权支持：是一个**单线程上使用的引用计数类型，它提供了多所有权支持**，即可同时存在多个智能指针指向同一个堆上变量的 `Rc<T>` ，它们都可以拿到指向变量的不可变引用来访问这同一个变量。
	- 引用计数：而它同时也是一个引用计数，事实上在堆上的另一个位置维护了这个变量目前被引用的次数 N ，即存在 N 个 `Rc<T>` 智能指针。这个计数会随着 `Rc<T>` 智能指针的创建或复制而增加，并在 `Rc<T>` 智能指针生命周期结束时减少。当这个**计数变为零之后，这个智能指针变量本身以及被引用的变量都会被回收**。 
	- **`Arc<T>` 与 `Rc<T>` 功能相同，只是 `Arc<T>` 可以在多线程上使用**。 `Arc<T>` 类似于 C++ 的 `std::shared_ptr` 。
- `RefCell<T>` 与 `Box<T>` 等智能指针不同，其 **借用检查** **在运行时进行**。对于 `RefCell<T>` ，如果违反借用规则，程序会编译通过，但会在运行时 panic 并退出。使用 `RefCell<T>` 的好处是，可在**其自身是不可变的情况下修改其内部的值**。在Rust语言中，在不可变值内部改变值是一种内部可变性的设计模式。
- `Mutex<T>` 是一个**互斥锁，在多线程中使用**。它可以保护里层的堆上的变量同一时间只有一个线程能对它进行操作，从而避免数据竞争，这是并发安全的问题，会在后面详细说明。同时，它也能够提供内部可变性 。**`Mutex<T>` 时常和 `Arc<T>` 配套使用**，因为它是用来保护多线程（线程概念在后面会讲，这里可简单理解为运行程序）可同时访问的数据，其前提就是多个线程都拿到指向同一块堆上数据的 `Mutex<T>` 。于是，要么这个 **`Mutex<T>` 作为全局变量被分配到数据段上**，要么将 `Mutex<T>` 包裹上一层多所有权 `Arc` ，变成 **`Arc<Mutex<T>>`** 这种经典组合结构，让最里层基于泛型 `T` 数据结构的变量可以在线程间安全传递。
- 在讲解 **同步互斥** 之前我们通过 `RefCell<T>` 来获得内部可变性。可以将 `Mutex<T>` 看成 `RefCell<T>` 的多线程版本， 因为 `RefCell<T>` 是只能在单线程上使用的。而且 `RefCell<T>` 并不会在堆上分配内存，它仅用于基于数据段的静态内存分配。
- `String`和`Vec<T>` 这些类型算作智能指针，因为它们拥有一些内存，并允许你 来操纵它。它们还**具有元数据和额外的功能或保证。**
    - `String`将其容量存储为元数据，并具有额外的能力来确保其数据始终是有效的 UTF-8。
#### 实现
- 智能指针通常使用结构体实现，实现了`Deref`和`Drop`特征
    - `Deref` 特征允许智能指针结构体的实例**表现得像一个引用** 因此您可以写出同时支持智能指针和引用的代码，例如 `*T`
    - `Drop`特征允许您**自定义**智能指针**实例超出范围时运行的代码**。在本章中，我们将讨论这两个特征并说明它们对智能指针的重要性。
### 参考链接
- https://learningos.cn/rCore-Tutorial-Book-v3/chapter4/1rust-dynamic-allocation.html
- https://rust-book.cs.brown.edu/
