---
tags:
  - reference
---
## 1. 核心观点  

对于if和else分支后的代码，编译器也要识别所有可能发生的借用延长情况：
- **外面的变量延长了里面的借用**。
	- **Rust 所谓的“借用活跃期”不仅限于 if/else 代码块，而是扩展到最后使用引用的地方**。
- 每个分支都会被同样计算借用状态
	- 即使 `else` 分支在运行时不执行，编译器为了安全会认为 `y` **可能借用了 `b` 到它最后被使用的地方**

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 错误原因分析

你的代码报错是 **E0499：cannot borrow `b` as mutable more than once at a time**。核心原因在于 **Rust 的可变借用规则**：
1. **可变借用规则**：在同一作用域内，一个变量同时只能有 **一个可变引用**。
2. **作用域延长**：
    - Rust 编译器的借用检查器（MIR borrowck）会 **延长可变借用的作用域到最后使用的地方**，不仅仅是语法块结束。
    - 在你的代码中：

```rust
fn main() {
    let mut a = 10;
    let mut b = 20;
    let mut x = & mut 10;
    let mut y = & mut 10;
    if true {
        x = &mut a; // if 分支借用 a
    } else {
        y = &mut b; // else 分支借用 b
    }

    // 这里 a 和 b 的借用已经结束
    let z = &mut b;
    // print!("{z}");
    println!("after if/else: a = {}, b = {}", x, y);
}

```

- `y = &mut b;` 是在 `else` 分支。
- 分支被计算状态了，作用域延长：
	- 即使 `else` 分支在运行时不执行，编译器为了安全会认为 `y` **可能借用了 `b` 到它最后被使用的地方**（即 `println!("after if/else: a = {}, b = {}", x, y);`）。

- 因此，`z = &mut b;` 是 **第二次可变借用**，在借用结束前，Rust 不允许重复可变借用。

3. **打印语句的影响**：

```rust
println!("after if/else: a = {}, b = {}", x, y);
```

- `x` 和 `y` 的生命周期还活跃，因此它们持有的借用还在作用中。


## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  


