---
tags:
  - fleeting
---
## 1. 核心观点  

当你从一个可变引用上再次产生一个可变引用时，Rust 会遵循极其严格的**层级权力委托机制**。
### 基本定义
当你把一个可变引用 `r1` 传递给一个函数，或者赋值给另一个变量 `r2` 时，Rust 不会自动“移动”这个引用，而是进行一次隐式的重借用。

**关键规则：** 在 `r2`（新的可变引用）存在期间，`r1`（原始的可变引用）会被**暂时锁定**，无法使用。
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 1. 什么是重借用 (Reborrowing)？

```
fn main() {
    let mut data = 100;
    let r1 = &mut data;     // 第一次可变借用

    {
        let r2 = &mut *r1;  // 在 r1 的基础上产生可变借用（重借用）
        *r2 += 1;           // 允许：使用最新的借用
        // println!("{}", r1); // 错误！此时 r1 被锁定，不能使用
    } 

    // r2 生命周期结束，r1 被“解锁”
    *r1 += 1;               // 现在允许了
    println!("{}", r1);      // 输出 102
}
```

### 2. 为什么要这么设计？（权力链条）

你可以把这想象成一个**令牌委托系统**：

1. **所有者**（变量）把“修改权”交给了 **A**。
2. **A** 决定把“修改权”暂时转租给 **B**。
3. **在 B 还回权力之前，A 绝对不能擅自动手**，否则就会出现多个入口同时修改内存的情况。

这种“链式锁定”保证了在任何给定的时间点，虽然可能存在一串借用链，但**只有链条最末端的那个引用是真正活跃的**。

### 3. 一个常见的坑：函数调用

重借用在 Rust 中非常频繁，甚至你每天都在用却没意识到。当你调用一个接收 `&mut self` 的方法时，其实就发生了重借用。

Rust

```
let mut v = vec![1, 2, 3];
let r = &mut v;

r.push(4); // 实际上是 push(&mut *r, 4) 的简写
r.push(5); // 再次重借用并使用

// 这里 r 依然有效，因为之前的重借用（在 push 调用里）已经结束了
```

### 4. 什么时候会报错？

如果你尝试让两个从同一源头产生的可变借用**同时处于活跃状态**，编译器就会介入：

Rust

```
let mut val = 1;
let r1 = &mut val;

let r2: &mut i32 = r1; // 这里发生了重借用，r1 被锁定
let r3: &mut i32 = r1; // 错误！你不能从已被锁定的 r1 再次重借用

// 必须等 r2 用完，r1 恢复自由后，才能再次借出
```

---

### 总结

- **可以**在可变借用的基础上继续产生可变借用。
- 这种行为叫 **Reborrow（重借用）**。
- **代价**是：父级引用会被“冻结”，直到子级引用彻底消失。
- 这依然维持了 Rust 的核心承诺：**在任何时刻，只有一个指针具有写入权限。**
    

**你是不是在写代码时遇到了具体的编译器报错（比如 `borrow of moved value` 或 `cannot borrow as mutable more than once`）？如果有代码片段，我可以帮你分析具体的“权力链条”是在哪里断掉的。**

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [Rust-借用检查器-if 和else中借用不会互相影响](Rust-借用检查器-if%20和else中借用不会互相影响.md)
	- [Rust-自己赋值一个自己产生借用的绑定-会导致绑定生命周期被延长到结束](Rust-自己赋值一个自己产生借用的绑定-会导致绑定生命周期被延长到结束.md)
	- [Rust-借用检查器-if 和else中的借用被外部的变量延长](Rust-借用检查器-if%20和else中的借用被外部的变量延长.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
