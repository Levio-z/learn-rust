---
tags:
  - fleeting
---
## 1. 核心观点  

简单来说：**可变性具有“排他性”，而不可变性具有“共享性”。**

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

我们可以把这种关系看作是“写权限”与“读权限”的分配。

### 1. 不可变借用：可以无限“套娃”

不可变借用（`&T`）代表的是**只读权限**。因为只读操作不会改变数据，所以它是安全的，无论多少人同时读都不会出问题。

- 你可以从一个**不可变引用**产生无数个新的**不可变引用**。
- 这些引用可以同时存在，互不干扰。

Rust

```
let x = 5;
let r1 = &x;
let r2 = &*r1; // 从 r1 产生 r2
let r3 = r1;    // 再次产生
// r1, r2, r3 现在都可以同时用来读取数据
```

---

### 2. 可变借用：只能“单线传递”

可变借用（`&mut T`）代表的是**独占写权限**。为了保证安全，Rust 必须确保在任何时候，修改权的“源头”只有一个。

- **可以**从可变借用产生新的借用（包括可变和不可变）。
- **但是**，一旦产生新的借用，**原有的借用就会进入“冻结”状态**，直到新的借用生命周期结束。
    

#### 场景 A：从 `&mut` 产生 `&mut`（重借用）

这是权力的**暂时移交**。



```
let mut x = 5;
let r1 = &mut x;
{
    let r2 = &mut *r1; // 从 r1 产生 r2 (Reborrow)
    *r2 += 1;          // 此时只有 r2 可用
    // r1 在这里被冻结，不能使用
} 
// r2 消失，r1 恢复活力
*r1 += 1; 
```

#### 场景 B：从 `&mut` 产生 `&`（降级借用）

这是权力的**临时削减**。当你从一个可变引用产生一个不可变引用时，原有的可变引用也会被冻结，因为它现在必须保证数据在“只读期”不会被修改。

Rust

```
let mut x = 5;
let r1 = &mut x;
{
    let r2 = &*r1;     // 从可变引用产生不可变引用
    println!("{}", r2); // 此时数据是只读的
    // *r1 += 1;       // 错误！r1 被冻结，因为 r2 还在预期数据不被改变
}
*r1 += 1;              // 允许，r2 已失效
```

---

### 3. 核心差异总结表

|**特性**|**不可变借用 (&T)**|**可变借用 (&mut T)**|
|---|---|---|
|**再产生 `&T`**|允许（产生多个共享引用）|允许（但会冻结原有的 `&mut`）|
|**再产生 `&mut T`**|**禁止**（不能从只读变可写）|允许（但会冻结原有的 `&mut`）|
|**并发性**|允许多个引用同时活跃|任何时刻只能有一个引用活跃|

---

### 为什么不能从 `&T` 产生 `&mut T`？

这是为了防止“后门修改”。如果一个人只有读权限（`&T`），却能偷偷生出一个写权限（`&mut T`），那么其他持有读权限的人就会发现数据在他们毫不知情的情况下变了，这会引发崩溃或逻辑错误。

> **例外情况：** 如果你确实需要“看似只读，实则能改”的功能，Rust 提供了 **`Cell`** 和 **`RefCell`**，这被称为**内部可变性（Interior Mutability）**。它们通过运行时检查来维持这种安全性。

**你需要我举一个关于 `RefCell` 如何打破这些规则（但保持安全）的例子吗？**

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
