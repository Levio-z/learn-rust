---
tags:
  - permanent
---
## 1. 核心观点  
- 自我借用导致借用持续整个函数，是因为 Rust 无法保证借用安全，所以采取了保守策略。它反映了 Rust **保证内存安全和可变唯一性**的基本原则。
- 因此，它会将这个借用延长到**包含它的整个作用域**（通常是整个函数）。
目的
- 这样做是为了避免出现**可变别名**：如果允许提前结束借用，`cur` 和 `nxt` 可能同时对同一块内存进行可变访问，违反 Rust 的安全规则。
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### Rust 自我借用导致借用持续整个函数的原因
在 Rust 中，**自我借用**指的是一个变量直接或间接地对自身创建引用，然后尝试使用原变量的情况。例如：
```rust
fn main() {
    let mut cur = &mut 7;
    let mut nxt: &mut i32 = &mut *cur;
    cur = nxt;
}
```
详细实例：
```rust
fn main() {
    let mut y = &mut 8;
    let mut cur = &mut 7;
    let mut nxt: &mut i32 = &mut *cur;

    y = nxt;
    print!("{y}");
    print!("{nxt}");

    cur = nxt;
    print!("{nxt}");
}
```
---

- **自我借用破坏显式生命周期分析**：编译器无法静态判断借用何时结束。
- 因此，借用会被保守地延长至函数结束。
#### 总结

- Rust 的生命周期分析依赖**可静态推断的作用域**。自我借用产生**循环依赖**：
    - `cur` 的生命周期依赖于 `nxt`
    - `nxt` 的生命周期依赖于 `cur`
- 这种循环关系让编译器无法精确计算借用何时结束。
- 由于无法静态证明借用结束，Rust 将借用延长到**包含它的整个作用域**（通常是整个函数）。
- 这样做可以保证：
    - 在函数内部，不会出现两个同时活跃的可变引用指向同一数据。
    - 内存安全规则得到严格遵守。

- `nxt` 的借用与 `cur` 产生了循环依赖。
- 编译器无法确定 `nxt` 什么时候可以安全释放，因此延长其生命周期到函数末尾。
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
