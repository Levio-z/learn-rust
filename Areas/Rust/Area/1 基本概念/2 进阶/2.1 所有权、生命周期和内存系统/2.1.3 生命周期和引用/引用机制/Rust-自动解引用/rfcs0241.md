---
tags:
  - reference
---
https://rust-lang.github.io/rfcs/0241-deref-conversions.html
### 总结
- 本文按 RFC 提议，详细解释在 Rust 中引入基于 `Deref` / `DerefMut` 的**借用间隐式强制转换（deref coercion on borrows）**：
- `&T` → `&U`，当 `T: Deref<Target = U>`。
- `&mut T` → `&U`，当 `T: Deref<Target = U>`（从可变借用降级为不可变借用）。
- `&mut T` → `&mut U`，当 `T: DerefMut<Target = U>`（保持可变借用且需要 `DerefMut`）。
- 这些转换消除了写出 `&**v` 或调用 `as_slice` 等“交叉借用”的需要，从而提升了语言的易用性。
	- 这些转换**只在已有借用（`&` 或 `&mut`）的情况下发生**，不会导致对拥有值的隐式借用，从而在保证所有权可见性的前提下显著改善智能指针、集合与切片等用法的可读性与便捷性。
### 背景动机

Rust 现有的**隐式类型强制转换主要用于函数参数匹配。典型例子是，如果 `T: Trait`，那么 `&T` 可以自动转为 `&Trait`**：
```rust
trait MyTrait { ... }
struct MyStruct { ... }
impl MyTrait for MyStruct { ... }

fn use_trait_obj(t: &MyTrait) { ... }
fn use_struct(s: &MyStruct) {
    use_trait_obj(s); // 自动从 &MyStruct 转换到 &MyTrait
}

```
早期 Rust 中，向量等是内建类型，编译器提供了更多自动转换，例如：
- **自动借用（auto-borrowing）**：`T → &T`
- **自动切片（auto-slicing）**：`Vec<T> → &[T]`
- **交叉借用（cross-borrowing）**：`Box<T> → &T`
    

但随着这些内建类型迁移到标准库，这些隐式转换被移除。于是开发者必须写 `&**v` 或 `v.as_slice()`。

这种“可读性回退”曾被承诺会通过更通用的机制改善。本文即是对这一问题的修复。

---

### 设计原则

1. **所有权与借用的中心地位**  
    Rust 的核心设计是所有权与借用。旧模型中的自动借用（例如 `foo(bar)` 自动借用 `bar`）使得读者无法直观判断所有权流向。因此 Rust 移除了自动借用。
    

> 原则：**强制转换不能隐式地从拥有值中借用。**

2. **限制隐式执行的代码**  
    Rust 的函数调用不会执行任意隐式代码，而只有 Deref 方法属于受限机制。  
    Deref 的特点：
    

- 每种类型至多 deref 到一个目标类型；
    
- Deref 主要用于智能指针等封装类型；
    
- 执行范围有限，便于推理。
    

> 原则：**强制转换只允许通过 Deref。**

---

### 提案内容

引入以下强制转换（递归适用，类似于方法调用的自动解引用）：

- `&T → &U` 当 `T: Deref<U>`
    
- `&mut T → &U` 当 `T: Deref<U>`
    
- `&mut T → &mut U` 当 `T: DerefMut<U>`
    

伪代码逻辑如下：

`HasCoercion(T, U):   if HasBasicCoercion(T, U) then true   else if T = &V and V: Deref<W> then HasCoercion(&W, U)   else if T = &mut V and V: Deref<W> then HasCoercion(&W, U)   else if T = &mut V and V: DerefMut<W> then HasCoercion(&W, U)   else false`

---

### 使用示例

`fn use_ref(t: &T) { ... } fn use_mut(t: &mut T) { ... }  fn use_rc(t: Rc<T>) {     use_ref(&*t);  // 现在必须写     use_ref(&t);   // 提案后可直接写 }  fn use_mut_box(t: &mut Box<T>) {     use_mut(&mut *t); // 现在必须写     use_mut(t);       // 提案后可直接写     use_ref(*t);      // 现在必须写     use_ref(t);       // 提案后可直接写 }  fn use_nested(t: &Box<T>) {     use_ref(&**t);  // 现在必须写     use_ref(t);     // 提案后可直接写（支持递归解引用） }`

若 `Vec<T>: Deref<[T]>`，切片也可自动发生：

`fn use_slice(s: &[u8]) { ... }  fn use_vec(v: Vec<u8>) {     use_slice(v.as_slice()); // 现在必须写     use_slice(&v);           // 提案后可直接写 }  fn use_vec_ref(v: &Vec<u8>) {     use_slice(v.as_slice()); // 现在必须写     use_slice(v);            // 提案后可直接写 }`

---

### 设计特点

- 不会隐式借用拥有值，只在已有 `&` 或 `&mut` 时触发。
    
- 仅作用于 Deref 类型，隐式执行范围有限，保持可推理性。
    
- 让 `&` 更接近“借用操作符”的语义，而不是单纯“指针”。
    

---

### 缺点

- 隐式调用 `Deref` 仍增加了一定理解成本。
    
- `&` 的语义由“指针”转向“借用”，可能让学习者更困惑。
    

---

### 替代方案

另一种是 **交叉借用 RFC**：

- 允许 `Box<T> → &T`、`Vec<T> → &[T]` 直接发生。
    
- 优点：更简洁，连 `&` 都可省略。
    
- 缺点：影响所有权推理，需要查函数签名才能知道值是否被移动。
    

---

### 附录：Rust 当前的所有权隐式规则

- 函数/方法参数的所有权转移或借用都是显式的。
    
- 唯一的例外：
    
    - **方法调用中的 self**（move/borrow 根据方法签名推断）；
        
    - **宏展开**（宏可展开为任意代码）。