---
tags:
  - permanent
---
## 1. 核心观点  

`*p` 原来的数据会被 **立即 Drop（销毁）**，当你对一个解引用的位置进行赋值时，编译器会自动处理旧值的“身后事”

## 2. 背景/出处  
- 来源：
	- [方法调用表达式](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 1. 赋值即“替换”

当你执行 `*p = node.next.take();` 时，发生了一场“内存接力”：

1. **右侧：** `node.next.take()` 将 `Option` 中的值取出来，获得了该值的所有权。
    
2. **左侧：** `*p` 是一个指向某处的“坑位”。
    
3. **动作：**
    
    - Rust 检查 `*p` 所在的这个坑位里是否已经有值。
        
    - 如果有，它会**先调用该旧值的 `drop` 函数**。
        
    - 然后，把右侧拿到的新值填入这个坑位。
        

---

### 2. 深度拆解这个过程

假设你在处理一个链表节点，代码可能长这样：

Rust

```
let mut some_node = Some(Box::new(ListNode::new(1)));
let p = &mut some_node; // p 是一个指向 Option 的可变借用

// 此时 *p 里面是 1
// node.next.take() 拿到了 2
*p = node.next.take(); 
```

**发生了什么？**

- **内存释放：** 原本 `*p` 里的 `Box(1)` 瞬间失去了所有者，Rust 立即释放掉 `Box(1)` 占用的堆内存。
    
- **所有权转移：** `node.next` 里的 `Box(2)` 被挪到了 `*p` 指向的地址。
    
- **结果：** 旧的 `1` 彻底消失了（Drop），新的 `2` 成功上位。
    

---

### 3. 为什么一定要 Drop？

如果不 Drop，就会造成**内存泄漏（Memory Leak）**。

因为 `*p` 只能持有一个所有权，如果你直接把新值塞进去而不清理旧值，旧值占用的堆空间（比如 `Box` 或 `String`）就再也没有人能访问到了，这违背了 Rust 的安全原则。

---

### 4. 特殊情况：没有 Drop 的情况

有两种情况 `*p` 的旧数据不会被“销毁”：

1. **数据类型实现了 `Copy` trait**：
    
    如果 `*p` 是 `i32` 或 `bool` 这种简单的类型，它们没有 `drop` 的概念，旧值会被直接通过位拷贝（Bitwise Copy）覆盖掉。
    
2. **手动使用 `std::ptr::write`**：
    
    如果你在写底层不安全（unsafe）代码，使用 `ptr::write(p, new_val)`，它会直接覆盖内存而**不调用**旧值的 `drop`。这通常用于初始化未初始化的内存，否则会对“垃圾数据”调用 `drop` 导致崩溃。
    

### 总结

在你的链表代码中：

- `node.next.take()` 返回的东西**活了下来**（搬到了 `*p`）。
    
- `*p` 原本指向的东西**死掉了**（被自动 Drop）。
    

**你是不是在担心在循环中处理链表时，会不小心把后面还要用的节点给 Drop 掉了？如果是这样，通常需要先用一个临时变量把 `*p` 原本的值“换”出来。**

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：
	- [Rust-方法调用-方法调用表达式](../方法调用/Rust-方法调用-方法调用表达式.md)

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 原子笔记整理
	- [x] 整理基本概念的笔记
	- [x] String中的自动解引用，String的本质
	- [x] 自动解引用规则
