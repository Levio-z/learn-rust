### 基本定义

在作用域中添加 `use` 和路径类似于在文件系统中创建符号链接。use只会在特定作用范围创建快捷方式，use只会在所在的作用域内有效。不必每次写出调用函数的路径，创建一个路径的快捷方式

- **`use`关键字**：在作用域内， `use`关键字创建快捷方式项以**减少长路径的重复**。在任何可以引用的范围内 `crate::garden::vegetables::Asparagus` ，您可以使用 `use crate::garden::vegetables::Asparagus;` 创建一个快捷方式，从那时起，您只需编写`Asparagus`即可在范围内使用该类型。
### 基本使用
#### 使用use引入函数
从使用简洁性来说，引入函数自然是更甚一筹，但是在某些时候，引入模块会更好：
- 需要引入同一个模块的多个函数
- 作用域中存在同名函数
在以上两种情况中，使用 `use front_of_house::hosting;` 引入模块要比 `use front_of_house::hosting::add_to_waitlist;` 引入函数更好。

**原因**： 在调用函数时指定父模块可以**清楚地表明该函数不是在本地定义的**，同时仍将完整路径的重复降至最低。
#### use引入结构体、枚举和其他项
- 使用use引入其他项：另一方面，当引入结构、枚举和其他项时，**指定完整路径是惯用**的。
```rust
use std::collections::HashMap; 
fn main() { 
let mut map = HashMap::new();
 map.insert(1, 2); 
 }
```
##### 将两个具有相同名称的类型使用父模块标识
这个习语的例外是，如果我们使用 `use` 语句将两个同名的项目带入范围，因为 Rust 不允许这样做。示例 7-15 显示了如何将两个具有相同名称但父模块不同的结果类型纳入作用域，以及如何引用它们。
```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
}

fn function2() -> io::Result<()> {
    // --snip--
}
```
>将两个具有相同名称的类型放入同一作用域需要使用它们的父模块。

#### 使用as关键字解决同名问题：
```rust
use std::fmt::Result; 
use std::io::Result as IoResult;
```
#### pub重新导出

为了使调用我们代码的代码能够引用该名称，就像该名称已在该代码的作用域中定义一样，我们可以将pub并use。这种技术称为重新导出，因为我们将一个项目带入范围，同时也使该项目可供其他人带入他们的范围。

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```
使用 pub use即可实现。这里use代表引入 hosting模块到当前作用域，pub表示将该引入的内容再度设置为可见。例如统一使用一个模块来提供对外的 API，那该模块就可以引入其它模块中的 API，然后进行再导出，最终对于用户来说，**所有的 API 都是由一个模块统一提供的**。

#### 使用外部包

怎么导入外部package

1. 在_Cargo.toml_中添加`rand`作为依赖项，告诉 Cargo 下载 `rand`包和来自[crates.io](https://crates.io/)的任何依赖项并使`rand`可用于我们的项目。
2. 然后，为了将`rand`定义纳入我们的包的范围，我们添加了一个 `use`以包名`rand`开头的行，并列出我们想要纳入范围的项目。
示例：
```rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
```
标准包
- 请注意，标准`std`库也是我们包外部的一个包。由于标准库是随 Rust 语言一起提供的，因此我们不需要更改Cargo.toml以包含`std` 。但我们确实需要使用`use`来引用它

#### 使用{}清理大型use列表
【示例】如果我们使用在同一个 crate 或同一个模块中定义的多个项目，则将每个项目列在自己的行上会占用文件中的大量垂直空间。例如

```rust
    // --snip--
    use std::cmp::Ordering;
    use std::io;
    // --snip--
```

将相同的项引入范围。
- 我们通过**指定路径的公共部分，后跟两个冒号，然后用花括号括住路径不同部分的列表来实现这一点**
    
    ```rust
    // --snip--
    use std::{cmp::Ordering, io};
    // --snip--
    ```

【示例2：子路径】

- **示例 7-19：两个**`use`**语句，其中一个是另一个的子路径**

    ```rust
    use std::io;
    use std::io::Write;
    ```

- **示例 7-20：将示例 7-19 中的路径组合成一个**`use`**语句**

    ```rust
    use std::io::{self, Write};
    ```
#### self

上面使用到了模块章节提到的 `self` 关键字，用来替代模块自身，结合上一节中的 `self`，可以得出它在模块中的两个用途：

- `use self::xxx`，表示加载当前模块中的 `xxx`。此时 `self` 可省略
- `use xxx::{self, yyy}`，表示，加载当前路径下模块 `xxx` 本身，以及模块 `xxx` 下的 `yyy`


#### `*`表示引入全部项
如果我们想将路径中定义的所有公共项目纳入范围，我们可以指定该路径，后跟`*`glob 运算符：
```
use std::collections::*;
```
- 当使用 `*`来引入的时候要格外小心，因为你很难知道到底哪些被引入到了当前作用域中，有哪些会和你自己程序中的名称相冲突：
```rust
use std::collections::*;

struct HashMap;
fn main() {
   let mut v =  HashMap::new();
   v.insert("a", 1);
}
```
- 以上代码中，`std::collections::HashMap` 被 `*` 引入到当前作用域，但是由于存在另一个同名的结构体，因此 `HashMap::new` 根本不存在，因为**对于编译器来说，本地同名类型的优先级更高**。
- 在实际项目中，这种引用方式**往往用于快速写测试代码**，它可以把所有东西一次性引入到 `tests` 模块中。

