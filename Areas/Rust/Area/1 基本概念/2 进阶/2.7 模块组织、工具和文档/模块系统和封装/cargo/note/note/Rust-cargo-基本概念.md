---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层

_Cargo_ 是 Rust 的包管理器。它是一个允许 Rust 进行包管理的工具。 [_软件包_](https://doc.rust-lang.org/cargo/appendix/glossary.html#package "\"package\" (glossary entry)")会声明其各种依赖项，以确保始终获得可重复的构建结果。
### 核心特性
- 两个文件：引入两个元数据文件，其中包含各种软件包信息。
- 依赖：获取并构建软件包的依赖项。
- 调用其他构建工具：cargo帮你使用正确的参数调用 `rustc` 或其他构建工具来构建您的软件包。
- 规范化：在很大程度上，Cargo 对构建特定应用所需的命令进行了规范化。引入约定，使使用 Rust 包更加容易。同一个命令可以用来构建不同的的程序。
	- 同一个命令可以用来构建不同的[Rust-cargo-Cargo  artifact](atomic/Rust-cargo-Cargo%20%20artifact.md)。

>参考[核心特性](#核心特性)


### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 核心特性
#### 1. Cargo 统一化构建流程，规范化
- **核心观点**：Cargo 把 Rust 项目的构建命令标准化了。让 cargo 来负责构建正确的 `rustc` 调用。
- **含义**：
    - 在没有 Cargo 时，你可能需要手动写 `rustc main.rs --crate-name foo ...` 之类的复杂命令。
    - 使用 Cargo 后，只需要执行 `cargo build`，Cargo 会根据项目结构自动生成正确的 `rustc` 命令，确保编译输出正确的二进制文件或库。

#### 2. 不关心具体名字，命令可复用
- **核心观点**：同一个 Cargo 命令可以构建不同的产物。
- **含义**：
    - 不管你的库或可执行文件叫什么，`cargo build` 都会根据 `Cargo.toml` 的配置自动生成对应的构建目标。
    - 你不必记住每个源文件的名字或手动指定输出文件。
#### 3. 自动处理依赖
- **核心观点**：Cargo 会自动下载并集成依赖。
- **含义**：
    - 如果 `Cargo.toml` 中定义了依赖库（比如 `serde = "1.0"`），Cargo 会从官方 registry（crates.io）下载对应版本。
    - 它会把依赖编译进你的项目中，无需手动去管理外部库。
### 创建
```rust
cargo new hello_world
```
- Cargo 默认使用 `--bin` 生成二进制程序。
- 要生成库文件，使用 `--lib` 参数。

### 编译
```rust
cargo build
```
### 运行
```
./target/debug/hello_world
```
### 编译+运行
```
cargo run
```

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 深入阅读 xxx
- [x] 验证这个观点的边界条件
