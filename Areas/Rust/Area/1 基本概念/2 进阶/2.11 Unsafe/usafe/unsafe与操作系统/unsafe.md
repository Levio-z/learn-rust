解引用裸指针是不安全的行为：代码第 14 行，我们将 `.bss` 段内的一个地址转化为一个 **裸指针** (Raw Pointer)，并将它指向的值修改为 0。这在 C 语言中是一种司空见惯的操作，但在 Rust 中我们需要将他包裹在 unsafe 块中。这是因为，Rust 认为对于裸指针的 **解引用** (Dereference) 是一种 unsafe 行为。

相比 C 语言，Rust 进行了**更多的语义约束来保证安全性**（内存安全/类型安全/并发安全），这在编译期和运行期都有所体现。但在某些时候，尤其是**与底层硬件打交道的时候，在 Rust 的语义约束之内没法满足我们的需求**，这个时候我们就需要将**超出了 Rust 语义约束的行为包裹在 unsafe 块中，告知编译器不需要对它进行完整的约束检查**，而是**由程序员自己负责保证它的安全性**。
- 当代码不能正常运行的时候，我们往往**也是最先去检查 unsafe 块中的代码**，因为它没有受到编译器的保护，出错的概率更大。

C 语言中的指针相当于 Rust 中的裸指针，它无所不能但又太过于灵活，程序员对其不谨慎的使用常常会引起很多内存不安全问题，最常见的如悬垂指针和多次回收的问题，Rust 编译器没法确认程序员对它的使用是否安全，因此将其划到 unsafe Rust 的领域。在 safe Rust 中，我们有引用 `&/&mut` 以及各种功能各异的智能指针 `Box<T>/RefCell<T>/Rc<T>` 可以使用，只要按照 Rust 的规则来使用它们便可借助编译器在编译期就解决很多潜在的内存不安全问题。