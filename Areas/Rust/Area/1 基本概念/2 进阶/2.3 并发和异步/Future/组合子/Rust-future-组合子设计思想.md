---
tags:
  - note
---

## 1. 核心观点  

**组合子（Combinators）** 让你能像处理数组（Iterator）一样处理异步任务，而不需要自己去定义 `struct`、实现 `poll` 或者手动管理 `Option<Future>`。
- **代码简洁：** 像流水线一样清晰。
- **逻辑组合：** 很容易实现“如果 A 失败了就运行 B”。

| **缺点**                                                |
| ----------------------------------------------------- |
| **类型复杂：** 嵌套层数多了，报错信息非常恐怖（这就是为什么现在更推荐 `async/await`）。 |
| **所有权：** 在闭包里处理变量的所有权有时比 `async` 块更麻烦。                |
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 1. 为什么叫“组合子”？

在 Rust 中，每个 `async` 函数都会生成一个独特的匿名类型。如果你想把两个异步操作连起来，最原始的方法就是像你之前看的那样，手写一个 `AndThenFut` 结构体。

**组合子则是为你自动生成这些结构体的方法。**

- **迭代器（Iterator）：** 处理的是**空间**中的一组数据。
- **组合子（Future Combinators）：** 处理的是**时间**中的一组操作。

---
### 2. 核心特点：不等待，只转换

这段话里最关键的一句是：**“这些组合子不再等待未来，而是返回自己一个未来。”**
这意味着它们是**惰性（Lazy）**的：

1. 当你调用 `.map()` 时，它并**没有**开始运行你的异步任务。
2. 它只是把你的原始 Future “包装”在了一个新的结构体里（类似于 `Map<OriginalFuture, Closure>`）。
3. 只有当你最终对这个“包装后的 Future”调用 `.await` 或将其交给执行器时，整个链条才会开始从头轮询（Poll）。
    
---

### 3. 代码对比：手动 vs 组合子

假设你要做两件事：先获取用户 ID，然后把 ID 转成字符串。

#### 方案 A：手动实现（正如你之前的代码）

你需要定义 `struct GetIdThenString { ... }` 并手动处理 `poll` 逻辑，还要判断第一个任务是否 Ready。

#### 方案 B：使用组合子（声明式）

Rust

```
use futures::FutureExt; // 引入组合子扩展

let future = get_user_id()
    .map(|id| id.to_string()); // 立即返回一个新的 Future，不阻塞

// 此时什么都没发生，直到：
let id_str = future.await; 
```

---

### 4. 常见的组合子成员

- **`.map(|val| ...)`**: 当 Future 完成时，对结果进行转换（同步操作）。
- **`.then(|val| async { ... })`**: 当第一个 Future 完成后，启动**另一个**异步任务。
- **`.or_else(|err| ...)`**: 如果失败了，执行错误处理逻辑。
- **`.boxed()`**: 将 Future 放到堆上，方便作为返回值传递。
    

---

### 5. 组合子的优缺点

| **优点**                          | **缺点**                                                |
| ------------------------------- | ----------------------------------------------------- |
| **代码简洁：** 像流水线一样清晰。             | **类型复杂：** 嵌套层数多了，报错信息非常恐怖（这就是为什么现在更推荐 `async/await`）。 |
| **逻辑组合：** 很容易实现“如果 A 失败了就运行 B”。 | **所有权：** 在闭包里处理变量的所有权有时比 `async` 块更麻烦。                |

---

### 总结

组合子是 **`async/await` 语法普及之前的统治者**。虽然现在我们大部分时间都在写 `async { ... }`，但组合子在某些场景下依然无可替代，比如：

- **在非异步函数中返回一个异步逻辑。**
    
- **对流（Stream）进行高效率的过滤和映射。**
    

**你现在是在阅读一些较老（或是底层）的异步库源码吗？因为在现代 Rust 业务开发中，大部分组合子已经被 `async/await` 这种更直观的“伪同步”语法取代了。**

## 4. 与其他卡片的关联  
- 前置卡片：
	- [Rust-异步编程-await-基本概念](../../Async和Await/Rust-异步编程-await-基本概念.md)
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 深入阅读更多详情请参阅 [_Rust中的零成本 futures_](https://aturon.github.io/blog/2016/08/11/futures/) 文章，它宣布了 futures 被加入 Rust 生态系统的消息。
  
