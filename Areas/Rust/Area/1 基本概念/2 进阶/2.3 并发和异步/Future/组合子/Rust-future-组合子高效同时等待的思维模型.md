---
tags:
  - note
---

## 1. 核心观点  

- “高效地同时等待”，这是异步设计的**终极目的**。
	- **将“做什么”和“什么时候做”完全解耦。** [Rust-future-解耦做什么和什么时候做](Rust-future-解耦做什么和什么时候做.md)
	- **组合异步调用链：** 组合子解决什么时候做，future调用链将构建一个**极为复杂的逻辑迷宫**。像搭积木一样，把几十个复杂的异步调用链拼在一起。
	- **统一调度：** * 你可以用 `join!(fut1, fut2, fut3)` 把它们打包。
		- 此时，执行器手里拿到的不再是零散的代码，而是一个**完整且巨大的状态机**。
		- 执行器可以**像“海王”一样，同时关注这几十个任务的进度**。只要有一个任务的 IO 信号到了，它就去推一下那个任务对应的那个分支。

- 为什么会这样：
	- [Rust-future-组合设计传染性](Rust-future-组合设计传染性.md)，为了实现不阻塞线程定义处理流水线


---

### 2. 什么是“对轮询应用映射操作”？

这段话里有一个核心概念：**组合器不等待，它只做包装。**

当你写 `future_a.map(f)` 时，并没有发生计算。它只是创建了一个新的结构体，这个结构体内部持有 `future_a` 和函数 `f`。

- **轮询（Poll）的重定向：** 当执行器（Executor）去 `poll` 这个新的组合 Future 时，组合 Future 内部会去 `poll` `future_a`。
    
- **映射（Map）：** 只有当 `future_a` 返回 `Ready(value)` 时，组合 Future 才会立即执行 `f(value)`，并将结果返回。
    

这就实现了“**在不阻塞线程的情况下，定义好数据到达后的处理流水线**”。

---

### 形象类比：物流流水线

- **同步：** 你买了一件衣服，必须等快递员送到门口，你当面拆开，然后再去买下一件。
    
- **异步组合器：**
    
    1. 你下了一个订单（Future A）。
        
    2. 你给物流公司发了个指令（Map）：**“等衣服到了，直接把它洗了（函数 f）”**。
        
    3. 你又发个指令（Then）：**“洗完之后，把它晾起来（Future B）”**。
        
- **结果：** 你并没有等任何一个环节。你只是在家里贴了一张**“流程清单”**。只有当衣服真的寄到、洗好、晾干后，你才会在 `main` 节点（家里）收到最终的反馈。而在等待的过程中，你甚至可以同时给另外 10 件衣服贴同样的清单。
    


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

## 4. 与其他卡片的关联  
- 前置卡片：
	- [Rust-异步编程-await-基本概念](../../Async和Await/Rust-异步编程-await-基本概念.md)
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 深入阅读更多详情请参阅 [_Rust中的零成本 futures_](https://aturon.github.io/blog/2016/08/11/futures/) 文章，它宣布了 futures 被加入 Rust 生态系统的消息。
  
