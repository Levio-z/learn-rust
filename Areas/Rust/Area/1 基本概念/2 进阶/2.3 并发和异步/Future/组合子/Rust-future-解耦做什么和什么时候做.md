---
tags:
  - note
---

## 1. 核心观点  
### 总结

- **“做什么”**：是你在组合器（`map`, `then`）里写的闭包函数。
- **“什么时候做”**：是底层的 `Poll` 机制和 `Waker` 信号决定的。（类似于线程，但是少了很多开销）

这种解耦让 Rust 程序能够用极少的线程（甚至是单线程）去管理海量的、在不同时间点发生的复杂业务逻辑。

| **维度**     | **同步编程 (Coupled)**     | **异步组合器 (Decoupled)**  |
| ---------- | ---------------------- | ---------------------- |
| **顺序控制**   | **代码行号** 决定了执行时间。      | **事件状态** 决定了执行时间。      |
| **CPU 参与** | CPU 必须在现场等待事件发生。       | CPU 只有在事件发生时才“闪现”一下。   |
| **逻辑依赖**   | 显式等待：`wait(A); do(B);` | 声明式链条：`A.on_ready(B);` |
在物流类比中，这种解耦带来的最大好处是：**并发能力**。

如果你没有解耦“做什么”和“什么时候做”，你（CPU）一次只能处理一件衣服。你必须盯着第一件衣服洗完，才能去下第二个订单。

因为解耦了，你可以在 1 秒钟内下 100 个订单，并为这 100 个订单各贴一张“洗晾清单”。你随后可以去睡觉（挂起线程），这 100 件事会在未来不同的时间点，由物流公司（OS/Runtime）根据包裹到达的时间**自动触发**。

### 什么是“对轮询应用映射操作”？

#### 形象类比：物流流水线

- **同步：** 你买了一件衣服，必须等快递员送到门口，你当面拆开，然后再去买下一件。
- **异步组合器：**
    1. 你下了一个订单（Future A）。
    2. 你给物流公司发了个指令（Map）：**“等衣服到了，直接把它洗了（函数 f）”**。
    3. 你又发个指令（Then）：**“洗完之后，把它晾起来（Future B）”**。
        
- **结果：** 你并没有等任何一个环节。你只是在家里贴了一张**“流程清单”**。只有当衣服真的寄到、洗好、晾干后，你才会在 `main` 节点（家里）收到最终的反馈。而在等待的过程中，你甚至可以同时给另外 10 件衣服贴同样的清单。

#### 1. 逻辑定义的阶段（做什么 - What）

当你调用 `.map()` 或 `.and_then()` 时，你实际上是在**编写剧本**，而不是在**演戏**。
- **解耦点：** 你的代码在 `main` 函数启动的那一毫秒就运行完了。你定义了“洗衣服”和“晾衣服”的操作。
- **状态：** 此时，衣服可能还没出库。你已经把所有的逻辑逻辑预存到了一个复合的 `Future` 对象里。
- **体现：** 即使此时没有任何网络 IO 发生，你的逻辑流水线已经完整地存在于内存中了。

#### 2. 执行触发的阶段（什么时候做 - When）

“什么时候做”完全交给了**环境（操作系统/执行器）**和**事件（数据到达）**。
- **解耦点：** 你的代码里不再有 `while (!ready) { ... }` 这样的轮询逻辑。
- **触发机制：** 只有当快递员敲门（OS 产生中断信号）并通知执行器时，“拆包”这个动作才会被触发。执行器根据你留下的“清单”，自动引导下一步操作。
- **体现：** “洗衣服”这个动作的开始时间，是由“快递什么时候到”决定的，而不是由你的代码逻辑顺序决定的。




## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

## 4. 与其他卡片的关联  
- 前置卡片：
	- [Rust-异步编程-await-基本概念](../../Async和Await/Rust-异步编程-await-基本概念.md)
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [x] 深入阅读更多详情请参阅 [_Rust中的零成本 futures_](https://aturon.github.io/blog/2016/08/11/futures/) 文章，它宣布了 futures 被加入 Rust 生态系统的消息。
  
