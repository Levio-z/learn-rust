---
tags:
  - note
---
## 1. 核心观点  

简单来说：**唤醒错了不会导致灾难，但会导致“死锁”或“永久沉睡”**。为了防止这种情况，Rust 规定了 `Future` 和执行器（Executor）之间的一套**“联系方式实时同步协议”

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  


### 1. 为什么“唤醒错了”是致命的？

如果 `Future` 从 **车间 A** 移动到了 **车间 B**，但你手里拿的是 **车间 A 的 Waker**：

- 你调用 `wake()`，**车间 A** 醒了，它看了一眼自己的任务清单，发现：“咦？那个 Future 已经不在我这儿了。”于是车间 A 继续干别的或者去睡觉。
- **车间 B** 还在死等信号，但它的电话永远不会响。
- **结果**：这个 `Future` 就像掉进了时空裂缝，再也不会被执行。
    

### 2. Rust 如何通过 `poll` 机制防止“唤醒错人”？

这就是为什么你在代码里看到**必须每次 `poll` 都更新 Waker** 的原因。Rust 的机制保证了“最后一次 `poll` 总是能校准地址”。

1. **移动发生时**：当 `Future` 被移动到 **车间 B** 后，执行器（Executor）**一定会**主动调用一次 `poll`。
2. **地址同步**：在这次 `poll` 中，执行器会把 **车间 B 的 Waker** 传给这个 `Future`。
3. **覆盖旧地址**：你的 `Future` 代码（比如 `TimerFuture`）接收到这个新 Waker 后，会把原本存着的“车间 A 地址”覆盖掉，换成“车间 B 地址”。
4. **精准唤醒**：当时间到了，计时线程拿到的就是最新的、属于车间 B 的联系方式。

### 3. 如果在“移动”和“下一次 poll”之间醒了怎么办？

你可能会问：_“如果 Future 刚准备搬家，还没来得及在车间 B 进行第一次 poll，此时计时线程正好执行了旧的（车间 A）wake()，会出事吗？”_

**答案是：不会。**

- **Waker 是幂等的（Safe to over-wake）**：在 Rust 中，多唤醒一次任务是没有副作用的。
    
- **状态保护**：即使车间 A 被唤醒了，它发现任务不在了也没关系。因为一旦这个 `Future` 在车间 B 落地，车间 B 的调度器会**立即、自动**对其进行至少一次 `poll`。这次 `poll` 就像是新员工报到，会把最新的 Waker 重新注册给底层的计时器。
	- 最新的waker也要兼容唤醒逻辑，如果此时有数据了，甚至不用注册唤醒。即使唤醒信号发错人了，只要“副作用（数据）”留在了 Future 的本地，新的车间在第一次 `poll` 时就能直接通关，根本不需要等待下一次唤醒。
---



## 4. 与其他卡片的关联  
- 前置卡片：
	- [Rust-future-基本概念-TOC](../Rust-future-基本概念-TOC.md)
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
