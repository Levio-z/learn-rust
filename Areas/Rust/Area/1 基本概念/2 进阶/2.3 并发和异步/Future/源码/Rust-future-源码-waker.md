---
tags:
  - note
---
## 1. 核心观点  

- **隔离性：** 它把任务的执行环境（Context）与任务本身的逻辑分离。
    
- **携带信息：** 如果未来 Rust 异步需要增加新的调度信息（比如任务优先级），可以直接加在 `Context` 里，而不需要改动成千上万个库的 `poll` 签名。

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  


假设一个服务器同时处理 10,000 个请求，其中 **请求 #404** 的数据包到了：

1. **内核触发：** 操作系统内核通过 `epoll` 发现网卡有数据属于 **请求 #404**。
2. **查找 Waker：** 运行时（如 Tokio）的驱动层会找到之前 **请求 #404** 挂起时留下的那个特定 `Waker`。
3. **精准唤醒：** 驱动层调用 `waker.wake()`。
4. **重新入队：** 这个操作仅仅把 **请求 #404** 对应的 Future 重新放回执行器的“就绪队列”。
5. **精准 Poll：** 执行器只针对 **请求 #404** 调用 `poll`。**其他 9,999 个请求依然在睡觉，完全没受到干扰。**

`Context`（上下文）目前看起来只是 `Waker` 的包装盒，它的设计是为了**未来的扩展性**：

```
fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
    // 1. 从上下文中拿到 Waker
    let waker = cx.waker(); 
    
    // 2. 将这个 Waker 注册到某个地方（比如定时器或 IO 驱动）
    // 这样当事件发生时，别人能找到它并唤醒
    my_io_driver.register(waker.clone());
    
    Poll::Pending
}
```


### 为什么要用faker
在你之前看到的简化版代码中，`wake` 只是一个简单的函数指针。但在现实的大规模并发中，它面临三个难题：

- **多线程安全（Thread Safety）：** 任务可能在线程 A 运行，但唤醒它的信号可能来自线程 B（网卡中断）。`Waker` 必须是线程安全的（实现了 `Send` 和 `Sync`）。
    
- **资源回收（Memory Management）：** 执行器需要知道什么时候可以安全地释放一个任务。`Waker` 内部使用了引用计数，确保只要还有硬件在等它，它就不会被销毁。
    
- **特定任务绑定：** **每一个 `Waker` 都像是一张“带编号的准考证”，它内部保存了对应任务在执行器队列中的具体位置**。
    
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [Rust-future-组合设计的思想-基本概念](../组合子/Rust-future-组合设计的思想-基本概念.md)
	- [Rust-future-状态机](../Rust-future-状态机.md)
	- [Rust-Pinning-基本概念](../../Pin/Rust-Pinning-基本概念.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
