---
tags:
  - note
---
## 1. 核心观点  

Rust 的 `Future` 很懒：除非被积极驱动完成，否则什么都做不了。推动未来完成的一种方法是在`async`函数中`wait`它，但这只会把问题推高一级：谁来运行从顶层`async`函数返回的未来？答案是我们需要一个`future`执行人。

**`future`执行者会收集一组顶层`future` s，在`future`取得进展时通过`poll`来完成它们**。通常，遗嘱执行人会先`poll`一次未来。当`future`  表示准备通过调用 `wake（）` 进行进展时，它们会被重新放入队列，再次调用`poll` ，重复直到`future`完成。

在本节中，我们将编写一个能够同时运行大量顶层未来至完结的简单执行者。

在这个例子中，我们依赖`future`箱来获得 `ArcWake` 特质，这为构建 `Waker` 提供了一种简单的方法。编辑 `Cargo.toml` 添加一个新的依赖：
```rust
[package]
name = "timer_future"
version = "0.1.0"
authors = ["XYZ Author"]
edition = "2021"

[dependencies]
futures = "0.3"
```
我们的执行者通过发送任务在通道上运行来工作。执行人会从通道中提取事件并运行。当任务准备继续工作（被唤醒）时，它可以通过重新进入通道来安排再次轮询。

在这种设计中，执行者本身只需要任务通道的接收端。用户会获得发送端，以便生成新的未来。任务本身就是可以重新调度的未来，所以我们会将它们存储为未来，并与任务可以用来重新排队的发送者一起存储。


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  


## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [Rust-future-执行器-基本概念](Rust-future-执行器-基本概念.md)
	- [Rust-future-执行器-基本概念](Rust-future-执行器-基本概念.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
