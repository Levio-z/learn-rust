
```
    let tmp_path = NamedTempFile::new()?.into_temp_path();
    let file: std::fs::File = std::fs::File::create(&tmp_path)?;
```

### 1. `NamedTempFile` 的生命周期语义
- `NamedTempFile` = **文件句柄 + 路径**
- 当 `NamedTempFile` 被 **drop** 时，文件会被自动删除。
- 所以如果你直接传 `NamedTempFile` 给 `File::create` 或 drop 掉原值：
    - 原来的文件就会被删除。
    - 你就没法“多次打开”或继续复用这个路径。
---
### 2. `into_temp_path()` 的作用

- 调用 `.into_temp_path()` 会从 `NamedTempFile` 中 **拿出路径**，变成 `TempPath`。
- `TempPath` 只管理“路径删除”，而不再持有文件句柄。
- 它的行为：
    - 当 `TempPath` drop 时，对应文件会删除。
    - 但在此之前，你可以用 `&tmp_path` 多次 `File::open` / `File::create`，因为它就是一个路径。

### 这个可以使用吗？
    // 使用tempfile crate创建临时文件
    let temp_file = NamedTempFile::new()?;
    let temp_path = temp_file.path().to_path_buf();

#### 1. `.path()` + `.to_path_buf()`

- `.path()` 返回的是 `&Path` 引用，指向 `NamedTempFile` 当前持有的临时文件路径。
    
- `.to_path_buf()` 把它复制成一个独立的 `PathBuf`。
    
- **问题**：文件的生命周期依然绑定在 `NamedTempFile` 上。
    
    - 一旦 `temp_file` 被 `drop`，底层临时文件会立即被删除。
        
    - 这时 `temp_path` 虽然还存在，但它指向的文件已不复存在。
        

所以如果 `temp_file` 生命周期比 `temp_path` 短，你会得到一个“悬空路径”（dangling path）。

---

#### 2. `.into_temp_path()`

- `.into_temp_path()` 会 **接管文件的删除责任**，让 `TempPath` 成为新的所有者。
    
- 在 `TempPath` drop 之前，文件会一直存在。
    
- 因此你可以安全地在 `TempPath` 生命周期内多次打开、写入文件。