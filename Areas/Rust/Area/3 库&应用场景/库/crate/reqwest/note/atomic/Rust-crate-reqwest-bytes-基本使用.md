---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层

### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
| 方法                    | 说明                            |                                                                                             |
| --------------------- | ----------------------------- | ------------------------------------------------------------------------------------------- |
| `len()`               | 返回字节长度                        |                                                                                             |
| `is_empty()`          | 判断是否为空                        |                                                                                             |
| `as_ref()`            | 返回 `&[u8]` 切片                 |                                                                                             |
| `to_vec()`            | 将 `Bytes` 转成 `Vec<u8>`（会拷贝数据） |                                                                                             |
| `slice(start..end)`   | 生成共享的子切片，不拷贝数据                | 根据给定的范围 `begin..end`，返回一个新的 `Bytes` 对象，该对象只包含原 `Bytes` 中指定的部分。仅仅是增加引用计数和记录新的偏移范围。不会遍历或复制数据。 |
| `copy_to_slice(dest)` | 将数据拷贝到已有缓冲区                   |                                                                                             |
#### 3.1 和很容易转换成`&[u8]`

- `AsRef<[u8]>` 和 `deref到[u8]`

```
 trait：impl AsRef<[u8]> for Bytes
 impl Deref for Bytes type Target = [u8];
```

#### 3.1.1 Deref 实例
因为 `Deref` 指向 `[u8]`，所以 `*tmp` 被解引用成 `[u8]`，再取全切片 `[..]` 得到 `&[u8]`。
```
let x: &[u8] = &resp.bytes().await?[..];
```


## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
