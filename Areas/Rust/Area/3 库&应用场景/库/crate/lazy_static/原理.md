#### 1\. `lazy_static!` 的工作原理

-   Rust 的普通 `static` 变量要求在 **编译时就能初始化**：
    ```rust
    static X: u32 = 42; // ok
    static Y: Mutex<u32> = Mutex::new(0); // ❌ Mutex::new 不是 const fn
    ```
-   但是 `SerialPort::new` 和 `Mutex::new` **不是 const fn**，因此不能直接用 `static`。
-   `lazy_static!` 的做法：
    1.  在第一次访问时初始化实际对象。
    2.  返回一个 **`&'static` 引用**，指向全局唯一的堆内存位置。
---
#### 2\. 内部机制

大致等价于：

```rust
pub struct SERIAL1_Inner;

impl SERIAL1_Inner {
    fn get() -> &'static Mutex<SerialPort> {
        static mut VALUE: Option<Mutex<SerialPort>> = None;
        unsafe {
            if VALUE.is_none() {
                let mut serial_port = SerialPort::new(0x3F8);
                serial_port.init();
                VALUE = Some(Mutex::new(serial_port));
            }
            VALUE.as_ref().unwrap()
        }
    }
}

pub static ref SERIAL1: &'static Mutex<SerialPort> = SERIAL1_Inner::get();
```

-   初始化在 **第一次访问** 时执行（lazy）。
    
-   返回值是 `'static` 生命周期的引用。
    
-   所以 `lazy_static!` 生成的都是 **`&'static T` 类型**。
    

---

#### 3\. 为什么是引用而不是值？

-   Rust 不允许返回一个局部变量的引用。
    
-   `lazy_static!` 必须保证 **引用在程序整个生命周期内有效**：
    
    -   所以它把对象存放在 **静态内存中（`Box::leak` 或类似机制）**。
        
    -   返回 `'static` 引用给用户。
        
-   如果直接返回值（`Mutex<SerialPort>`），每次访问都会创建新实例，这就破坏了全局唯一性。
    

---

#### 4\. 使用示例

```rust
fn write_serial(byte: u8) {
    use spin::MutexGuard;

    let mut port = SERIAL1.lock(); // 这里 lock() 是 Mutex 的方法
    port.send(byte);
}
```

-   `SERIAL1` 是 `&'static Mutex<SerialPort>`。
    
-   可以直接调用 `.lock()` 获取互斥访问。
    
-   `'static` 引用保证 **整个程序期间都是有效的全局实例**。
    

---

### ✅ 总结

1.  **lazy\_static! 的核心作用**：
    
    -   在运行时第一次访问时初始化非 const 静态值。
        
    -   保证全局唯一性。
        
2.  **为什么是引用**：
    
    -   对象必须存放在 `'static` 内存中。
        
    -   返回 `'static` 引用而不是值，保证：
        
        -   不会被移动或销毁
            
        -   可以安全地全局访问
            
3.  **方法论**：
    
    -   任何非 `const fn` 初始化的全局资源，都可以用 `lazy_static!`。
        
    -   注意类型是 `&'static T`，不是直接值。
        
4.  **练习建议**：
    
    -   用 `lazy_static!` 定义全局计数器（`Mutex<u32>`），在多个函数中访问。
        
    -   打印 `SERIAL1` 的地址，验证全局唯一性。

You: 

全局实例可以吗？

ChatGPT: 

可以，但要注意区别 **普通全局变量** 和 **全局实例 + 初始化时机**。在 Rust 裸机或 `no_std` 环境下，直接写全局实例有一些限制：

---

### 1\. 普通全局实例

```rust
static mut SERIAL1: Mutex<SerialPort> = Mutex::new(SerialPort::new(0x3F8));
```

-   **问题**：
    
    1.  `SerialPort::new` 不是 `const fn`，普通 `static` 需要在编译时初始化 → ❌。
        
    2.  `static mut` 是可变静态变量，需要 `unsafe` 才能访问 → ❌ 易出错。
        
    3.  没有懒初始化机制，如果初始化顺序依赖外部状态（如 I/O 端口），直接初始化可能不安全。
        

---

### 2\. 使用 `lazy_static!` 或 `spin::Once` 的全局实例

```rust
lazy_static! {
    pub static ref SERIAL1: Mutex<SerialPort> = {
        let mut serial_port = unsafe { SerialPort::new(0x3F8) };
        serial_port.init();
        Mutex::new(serial_port)
    };
}
```

-   **优点**：
    
    1.  **懒初始化**：首次访问时才构造实例。
        
    2.  **全局唯一**：保证整个程序生命周期只有一个实例。
        
    3.  **安全访问**：通过 `Mutex` 或 `spin::Mutex` 访问，无需 `unsafe`。
        

---

### 3\. 使用 `OnceLock` / `LazyLock`（Rust 1.63+）

在现代 Rust 中，可以用标准库的 `OnceLock` 或 `LazyLock`：

```rust
use std::sync::OnceLock;

static SERIAL1: OnceLock<Mutex<SerialPort>> = OnceLock::new();

fn get_serial() -> &'static Mutex<SerialPort> {
    SERIAL1.get_or_init(|| {
        let mut port = unsafe { SerialPort::new(0x3F8) };
        port.init();
        Mutex::new(port)
    })
}
```

-   与 `lazy_static!` 原理相同。
    
-   不需要宏，类型安全更强。
    

---

### 4\. 总结

| 方法 | 可用性 | 初始化时机 | 安全性 |
| --- | --- | --- | --- |
| `static mut` + `Mutex` | 可用 | 编译期/全局 | 需 `unsafe` |
| `lazy_static!` | 可用 | 首次访问 | 安全 |
| `OnceLock` / `LazyLock` | 可用 | 首次访问 | 安全 |

-   **结论**：全局实例当然可以，但直接用普通 `static` 初始化非 `const` 对象不行。
    
-   **推荐方式**：
    
    -   使用 `lazy_static!` 或 `OnceLock/LazyLock`，结合 `Mutex` 保证安全访问。
        

---