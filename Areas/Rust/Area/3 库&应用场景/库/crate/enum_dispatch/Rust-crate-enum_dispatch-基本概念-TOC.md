---
tags:
  - fleeting
---
## 1. 核心观点  
### Ⅰ. 概念层
**`enum_dispatch` 的作用是消除“动态分发”（Dynamic Dispatch）带来的性能开销，同时保留类似 Trait 的多态特性。**

好处
- **提高开发效率**：使用宏精简代码
	- 替代手工自动生成机械性代码：类似手工编写的命令执行分发代码，如匹配不同子命令并执行对应操作。
- 代码简化: 减少了大量重复的match模式匹配代码，使代码**更简洁易维护**。
### Ⅱ. 应用层

- 自动去将trait实现和枚举关联，如果Trai名字为X
	- 在枚举上写`#[enum_dispatch(X)]`
	- 在`trait`上写`#[enum_dispatch]`

- 异步应用!send的传染性：[Rust-crate-strum-和async fn的配合](note/atomic/Rust-crate-strum-和async%20fn的配合.md)
### Ⅲ. 实现层

### **IV**.原理层
- `enum_dispatch` 通过宏，自动为你生成那些枯燥的 `match` 结构，让你**以枚举的性能，享受 Trait 的开发体验**。
- [方案对比](#方案对比)
- [Rust-crate-enum_dispatch-展开后源码](note/atomic/Rust-crate-enum_dispatch-展开后源码.md)
## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 方案对比
#### 方案 A：Trait 对象 (`dyn Trait`)
使用 `Box<dyn MyTrait>`。
- **缺点**：存在 **动态分发** 开销。每次调用方法都要查虚表（vtable），且无法被编译器内联（Inline），性能较差。
#### 方案 B：手动枚举 (`enum`)
定义一个 `enum` 包含所有类型，然后在每个方法里写 `match`。
- **缺点**：代码极其冗余。每增加一个 Trait 方法，你都要手动写一遍 `match self { ... }` 逻辑。
### 2. `enum_dispatch` 的救场

#### 性能
- **动态->静态**：将动态分发转换为枚举匹配，所有类型信息在编译时确定
- **零虚表开销**：避免堆分配Box，直接跳转到函数地址。
- **支持内联**：编译器可以把编码逻辑直接塞进调用处，减少函数调用开销。
- **更多优化**：函数无副作用，可以直接删除

|**特性**|**手动 Enum + Match**|**enum_dispatch**|**Box<dyn Trait>**|
|---|---|---|---|
|**性能**|极高（静态）|极高（静态）|较低（动态）|
|**样板代码**|很多（需手动 match）|极少（自动生成）|少|
|**内存布局**|栈分配（大小固定）|栈分配（大小固定）|堆分配（Box）|
|**灵活性**|低|中|高（支持运行时扩展）|
### 性能测试
- 测试环境：Ryzen 7 2700x CPU
- 测试结果：
    - 编译器优化场景：0ns/iter（完全优化掉）
    - 黑盒测试：471,748ns/iter（比次优方案快5倍）
    - 同质向量测试：479,638ns/iter（比传统方式快10-12倍）
- 优势场景：
    - 大量trait对象存储在Vec中时性能优势最明显
    - 减少间接访问和虚表查找
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- 
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
