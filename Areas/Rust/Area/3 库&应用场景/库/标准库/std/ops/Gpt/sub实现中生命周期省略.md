这是一个关于 Rust **引用类型**和 **Trait 泛型**的极好的问题！表面上看是语法上的差异，实则是对 Rust 类型系统规则的遵守程度不同。

我们来详细对比这两个表达式：

1. **`impl Sub<&f32> for &f32`**
    
2. **`impl<'a> Sub<i32> for &'a i32`**
    

### 1. 为什么 `impl Sub<&f32> for &f32` **没有**显式生命周期？

当你在 Rust 代码中看到一个没有显式生命周期标注的引用时，比如 `&f32`，它往往依赖于 **生命周期省略规则 (Lifetime Elision Rules)**。

#### 规则：**输入生命周期省略**

在 `impl` 块中，对于 Trait 的泛型参数（这里的 $Rhs$）和实现类型（这里的 $Self$）中的引用，如果满足某些条件，**编译器可以自动推断或分配生命周期**。

对于一个 Trait 实现签名，如果生命周期省略了，编译器会尝试应用以下规则：

1. **`Self` 类型上的生命周期：** 如果 $Self$ 类型是引用，并且 $Rhs$ 类型是裸类型（如 `i32`），则 $Self$ 上的生命周期通常会被自动推断（但为了清晰，标准库通常会显式写出，见第 2 点）。
    
2. **多个输入生命周期：**
    
    - 在 `impl Sub<&f32> for &f32` 中，有两个输入引用：左侧 `&f32`（作为 $Self$）和右侧 `&f32`（作为 $Rhs$）。
        
    - 尽管它们看起来没有生命周期，但编译器会应用生命周期省略规则，将它们理解为：
        
        $$\text{impl<'a, 'b> Sub<\&'b f32> for \&'a f32}$$
        
    - 并且由于浮点数的运算结果 $Output$ 是一个值（`f32`），不包含任何借用的数据，所以**不需要**将 `'a` 或 `'b` 绑定到输出类型或相互约束。
        

**总结：** 在这个场景中，**没有**显式生命周期，是因为标准库使用了宏来生成实现，或者依靠**更复杂的、内部的**生命周期省略规则来避免冗余。在泛型上下文之外，Rust 确实允许省略引用类型上的生命周期标注。实际上，它被视为具有**两个不同的、省略的输入生命周期**。

### 2. 为什么 `impl<'a> Sub<i32> for &'a i32` **有**显式生命周期？

这个 Trait 实现是在为**引用类型** `&i32` 实现 `Sub` Trait，其中右操作数是值类型 `i32`。

$$\mathbf{impl<'a>} \text{ Sub<i32> for } \mathbf{\&'a \ i32}$$

**原因：**

1. **显式泛型声明是最佳实践 (Best Practice)：**
    
    - 虽然 Rust 的生命周期省略规则在函数签名中非常强大，但在**Trait 实现签名**中，尤其是在为**泛型 Trait** (`Sub<i32>`) 实现**泛型类型** (`&'a i32`) 时，**明确声明并绑定生命周期 `'a` 是标准且最清晰的做法。**
        
    - $\mathbf{\&'a \ i32}$ 的类型本身就是**泛型**的，它通过生命周期 `'a` 对所有可能的借用时间进行了抽象。为了让 `impl` 块涵盖所有可能的 `&i32`（不管是短时间借用还是 `'static` 借用），必须使用 `<'a>` 语法将其作为泛型参数引入。
        
2. **避免歧义和限制：**
    
    - 如果不写 `<'a>`，签名将变成 `impl Sub<i32> for &i32`。这可能被解释为只针对**默认的、隐式的**生命周期（例如 `'static`），从而限制了实现的适用性。
        
    - 通过写出 `impl<'a> ... for &'a i32`，您明确告诉编译器和用户：**“这个实现适用于任何生命周期 `'a` 的 `&i32`”**，从而实现了通用性。
        

### 最终总结

|**表达式**|**实际类型 (隐式/显式)**|**机制差异**|
|---|---|---|
|`impl Sub<&f32> for &f32`|`impl<'a, 'b> Sub<&'b f32> for &'a f32`|**依赖省略规则**。输入有多个引用，编译器仍能推断并处理。在标准库中，这类多引用组合经常通过宏生成，省略是为了代码简洁。|
|`impl<'a> Sub<i32> for &'a i32`|`impl<'a> Sub<i32> for &'a i32`|**显式声明泛型**。`&'a i32` 本身就是一个带生命周期的泛型类型。在 `impl` 签名中显式引入 `<'a>` 是为了确保这个实现对所有生命周期的 `&i32` 都有效。|

简而言之，第一个例子是**省略**的结果，第二个例子是**清晰地声明泛型**（生命周期泛型）的结果。两者都是正确的 Rust 语法，但后者在 Trait 实现中被认为更具表现力。