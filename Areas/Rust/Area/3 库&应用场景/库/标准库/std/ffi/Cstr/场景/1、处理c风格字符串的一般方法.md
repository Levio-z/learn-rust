```rust
    // 1. 使用buf读取到结束符号
    buf.read_until(b'\0', &mut ret)?;
    // 2. 转换为c_str
    let c_str = CStr::from_bytes_with_nul(&ret).expect("Invalid C string");
    // 3. 转换为`to_str()` 方法会尝试把这个 **C 风格字符串** 转换为 Rust 的 **`&str`**（UTF-8 字符串切片）。
    let header = c_str.to_str().context(" .git/objects file header isn't valid utf-8")?;
    let Some((kind, size)) = header.split_once(' ') else {
        anyhow::bail!(".git/objects file header did not start with a konw type {header}");

    };
```


- [from_bytes_with_nul](../methods/from_bytes_with_nul.md)读取C风格字符串
	- Rust 的普通 `&str` **不允许包含 NUL 字节**，因为它约定是 UTF-8 序列，而 `\0` 会导致 C 风格接口、某些库误判为结束。
- Rust 标准库 `std::ffi::CStr` 表示一个 **C 风格字符串**，以 `\0` 结尾。
- .to_str()
	- 零拷贝  
	- `to_str()` 会尝试把 **不包含结尾 `\0` 的部分** 解释为 UTF-8。
- split_once
	- 处理空格

