>https://rustwiki.org/zh-CN/std/sync/struct.Arc.html
### 定义

`Arc<T>` 是 Rust 标准库提供的一个 **原子引用计数智能指针**（Atomic Reference Counted）。  
全称为 **Atomically Reference Counted pointer**，位于 `std::sync::Arc`。
### 作用
-   **共享所有权**：允许多个线程同时持有某个数据的所有权。
-   **自动释放**：当最后一个 `Arc<T>` 指针被销毁时，内部的对象也会被自动释放。
-   **线程安全**：与 `Rc<T>` 的区别在于，`Arc<T>` 使用 **原子操作** 维护引用计数，保证跨线程共享时的安全。
### 源码原理（简化版）

核心在于：
1.  `Arc<T>` 内部存储一个指针，指向一个堆上的 **数据块**：
    -   数据部分（`T`）
    -   引用计数（`AtomicUsize`）
2.  `clone()` 时：调用 `fetch_add(1, Ordering::Relaxed)` 增加计数。
3.  `drop()` 时：调用 `fetch_sub(1, Ordering::Release)`，若计数归零，执行 `drop_in_place` 释放数据和内存。
### 使用场景

-   **多线程共享数据**：  
    当多个线程需要访问同一数据（不可变共享），但又不希望复制时使用。
    ```rust
    use std::sync::Arc;
    use std::thread;
    
    fn main() {
        let numbers = Arc::new(vec![1, 2, 3]);
        let mut handles = vec![];
    
        for _ in 0..3 {
            let numbers_cloned = Arc::clone(&numbers);
            let handle = thread::spawn(move || {
                println!("{:?}", numbers_cloned);
            });
            handles.push(handle);
        }
    
        for h in handles {
            h.join().unwrap();
        }
    }
    ```
结果：
```
[1, 2, 3]
[1, 2, 3]
[1, 2, 3]
```
-   **跨线程缓存、配置数据、只读结构**。
-   **结合锁（Mutex/RwLock）**：当需要跨线程共享可变数据时，`Arc<Mutex<T>>` 或 `Arc<RwLock<T>>` 是常见模式。

- move
	- 显示所有权转移
- `Arc::clone(&numbers)` → 更显式，强调这是**Arc 的 clone**，不是数据 clone。
	- `numbers.clone()` → 调用了 `Clone` trait 的实现，行为相同。
### 原理
实际上是增加引用计数器的值。
### 与 Rc 的区别

| 特性     | Rc<T>   | Arc<T>        |
| ------ | ------- | ------------- |
| 是否线程安全 | ❌ 否     | ✅ 是           |
| 内部计数   | `usize` | `AtomicUsize` |
| 开销     | 小       | 较大（需要原子操作）    |
| 典型场景   | 单线程共享数据 | 多线程共享数据       |

### 扩展知识点

-   **避免循环引用**：和 `Rc<T>` 一样，`Arc<T>` 也可能产生引用环，导致内存泄漏。通常需要 `Weak<T>` 打破循环。
-   **不可替代所有权转移**：`Arc<T>` 只能共享，不改变原本的所有权模型。
-   **配合 Weak**：  
    `Arc::downgrade(&arc)` 生成 `Weak<T>`，不增加强引用计数，不会阻止数据释放，适合缓存、图结构。
---
### 总结
-   `Arc<T>` = **线程安全的引用计数智能指针**，用于跨线程共享数据。
-   核心实现：内部维护 `AtomicUsize` 作为引用计数，`clone` 增计数，`drop` 减计数，计数归零时释放内存。
-   使用场景：多线程共享不可变数据，或 `Arc<Mutex<T>>`/`Arc<RwLock<T>>` 支持共享可变数据。
-   重点关注：与 `Rc<T>` 的区别、Weak 的用法、防止循环引用。
### 学习方法论
1.  **源码阅读**：分析 `std::sync::Arc` 实现，重点理解 `AtomicUsize` 与内存顺序语义。
2.  **对比实验**：写出 `Rc<T>` 与 `Arc<T>` 的多线程共享示例，观察编译器报错与运行结果。
3.  **配合 Mutex 使用**：实现 `Arc<Mutex<Vec<T>>>` 的并发写入案例。
4.  **内存泄漏实验**：构造循环引用，观察泄漏，再用 `Weak` 修复。

### 习题

1.  用 `Arc` 实现一个多线程计算数组平方和的程序。
2.  写出 `Rc<T>` 在多线程下无法编译的代码，并解释原因。
3.  使用 `Arc<Mutex<T>>` 实现一个线程安全的全局计数器。
4.  设计一个图结构，节点用 `Arc<Node>`，边用 `Weak<Node>`，避免循环引用。