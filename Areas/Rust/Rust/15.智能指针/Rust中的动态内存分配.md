### 静态与动态内存分配
#### 静态分配
- 基本定义：在程序编译时就确定并分配内存空间的方式
	- 程序员视角：在代码中声明变量类型
	- 编译器视角：编译程序时已经知道这些变量所占的字节大小，于是给它们分配一块固定的内存将它们存储其中，这样变量在栈帧/数据段中的位置就被固定了下来
	- 内存视角：其分配的内存大小和位置在程序运行期间是固定的
#### 动态分配
- 随着应用运行动态增减的内存空间
- 实现机制：应用所依赖的基础系统库（如 Linux 中的 glibc 库等）会直接通过系统调用（如类 Unix 内核提供的 sbrk 系统调用）来向内核请求增加/缩减应用地址空间内堆的大小
#### 动态分配的本质
态分配是一项非常基础的功能，很多高级语言的系统标准库中都实现了它。以 C 语言为例，C 标准库中提供了如下两个动态分配 的接口函数：
```rust
void* malloc (size_t size); void free (void* ptr);
```
- `malloc`
    - 其中，`malloc` 的作用是从堆中分配一块大小为 `size` 字节的空间，并返回一个指向它的指针。而后续不用的时候，将这个指针传给 `free` 即可在堆中回收这块空间。
- 指针是在栈上的，通过指针间接访问堆空间上的数据。
    - 我们通过返回的指针变量来 **间接** 访问堆空间上的数据。
    - 事实上，我们在程序中能够 **直接** 看到的变量都是被静态分配在栈或者全局数据段上的，它们大小在编译期已知。
    - 比如我们可以把固定大小的指针放到栈（局部变量）或数据段（全局变量）上，然后通过指针来指向运行时才确定的堆空间上的数据，并进行访问。这样就可以通过确定大小的指针来实现对编译时大小不确定的堆数据的访问。
- 灵活调整变量的生命周期
    - 局部变量生命周期随着函数的结束而结束
    - 静态分配在数据段中的全局变量在整个运行期都存在
    - 动态分配允许构造一种不一定绑定在函数调用的变量生命周期，参数或返回值提供夸函数使用
- 缺点
    - 运行着复杂的连续内存分配算法，相比静态分配会带来一些额外的开销
    - 分配过于频繁，会带来内存碎片
### Rust堆中的堆数据机构
#### 基本概念
- 指针
	- 是包含内存地址的变量的一般概念。此地址引用或“指向”其他数据。
 - 引用
	 - 最常见的指针类型是引用：用&符号表示，并借用它们指向的值。除了引用数据之外，它们没有任何特殊功能，并且没有开销。严格的 **借用检查** (Borrow Check) ，来确保在编译期就解决掉很多内存不安全问题。
- 裸指针 `*const T/*mut T` 
	- 基本等价于 C/C++ 里面的普通指针 `T*` ，它自身的内容仅仅是一个地址。它最为灵活，但是也最不安全。编译器只能对它进行最基本的可变性检查（只读的数据不能写）。
- 智能指针
	- 额外功能：**相比较于普通指针（裸指针），除了位置信息，还携带额外信息，以提供管理和控制**。拥有它们指向的数据。
    - 额外大小：因此智能指针的大小通常大于裸指针，这被称作 **胖指针** (Fat Pointer)。
        - 如果智能指针仅**用堆维护元信息**（如针对 `Sided` 类型的 `Arc` 与 `Rc`），那么它们“胖”在堆上，指针本身仍然是 8 字节的；
        - 反之，如果**指针本身维护元信息**（如 `Mutex` 和 `Vec`），指针本身就会大于 8 字节。
#### 特点
- 虽重但强，可以提供比引用更多的功能特性。
![](Pasted%20image%2020250604193144.png)
#### 分类
- `Box<T>` 在创建时会在堆上分配一个类型为 `T` 的变量，它自身也只保存在堆上的那个变量的位置。而和裸指针或引用不同的是，**当 `Box<T>` 被回收的时候，它指向的那个变量（位于堆上）也会被回收**。`Box<T>` 可以对标 C++ 的 `std::unique_ptr` 。
- `Rc<T>` 
	- 多所有权支持：是一个**单线程上使用的引用计数类型，它提供了多所有权支持**，即可同时存在多个智能指针指向同一个堆上变量的 `Rc<T>` ，它们都可以拿到指向变量的不可变引用来访问这同一个变量。
	- 引用计数：而它同时也是一个引用计数，事实上在堆上的另一个位置维护了这个变量目前被引用的次数 N ，即存在 N 个 `Rc<T>` 智能指针。这个计数会随着 `Rc<T>` 智能指针的创建或复制而增加，并在 `Rc<T>` 智能指针生命周期结束时减少。当这个**计数变为零之后，这个智能指针变量本身以及被引用的变量都会被回收**。 
	- **`Arc<T>` 与 `Rc<T>` 功能相同，只是 `Arc<T>` 可以在多线程上使用**。 `Arc<T>` 类似于 C++ 的 `std::shared_ptr` 。
- `RefCell<T>` 与 `Box<T>` 等智能指针不同，其 **借用检查** **在运行时进行**。对于 `RefCell<T>` ，如果违反借用规则，程序会编译通过，但会在运行时 panic 并退出。使用 `RefCell<T>` 的好处是，可在**其自身是不可变的情况下修改其内部的值**。在Rust语言中，在不可变值内部改变值是一种内部可变性的设计模式。
- `Mutex<T>` 是一个**互斥锁，在多线程中使用**。它可以保护里层的堆上的变量同一时间只有一个线程能对它进行操作，从而避免数据竞争，这是并发安全的问题，会在后面详细说明。同时，它也能够提供内部可变性 。**`Mutex<T>` 时常和 `Arc<T>` 配套使用**，因为它是用来保护多线程（线程概念在后面会讲，这里可简单理解为运行程序）可同时访问的数据，其前提就是多个线程都拿到指向同一块堆上数据的 `Mutex<T>` 。于是，要么这个 **`Mutex<T>` 作为全局变量被分配到数据段上**，要么将 `Mutex<T>` 包裹上一层多所有权 `Arc` ，变成 **`Arc<Mutex<T>>`** 这种经典组合结构，让最里层基于泛型 `T` 数据结构的变量可以在线程间安全传递。
- 在讲解 **同步互斥** 之前我们通过 `RefCell<T>` 来获得内部可变性。可以将 `Mutex<T>` 看成 `RefCell<T>` 的多线程版本， 因为 `RefCell<T>` 是只能在单线程上使用的。而且 `RefCell<T>` 并不会在堆上分配内存，它仅用于基于数据段的静态内存分配。
- `String`和`Vec<T>` 这些类型算作智能指针，因为它们拥有一些内存，并允许你 来操纵它。它们还**具有元数据和额外的功能或保证。**
    - `String`将其容量存储为元数据，并具有额外的能力来确保其数据始终是有效的 UTF-8。
#### 实现
- 智能指针通常使用结构体实现，实现了`Deref`和`Drop`特征
    - `Deref` 特征允许智能指针结构体的实例**表现得像一个引用** 因此您可以写出同时支持智能指针和引用的代码，例如 `*T`
    - `Drop`特征允许您**自定义**智能指针**实例超出范围时运行的代码**。在本章中，我们将讨论这两个特征并说明它们对智能指针的重要性。
### 参考链接
- https://learningos.cn/rCore-Tutorial-Book-v3/chapter4/1rust-dynamic-allocation.html
- https://rust-book.cs.brown.edu/
