- 未初始化
    - 未初始化但不使用：
        - `let` **可以声明变量而不初始化，**添加类型注解，让编译器可以推断类型，编译器会警告
    - **未初始化但使用会无法编译**
- 赋值
    - **let变量绑定**
        - 简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，**绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人**
    - 解构（Note: 解构式赋值只能在 Rust 1.59 或者更高版本中使用）
        - 在 [Rust 1.59](https://course.rs/appendix/rust-versions/1.59.html) 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了
- 不可变
	-  Rust 的变量在默认情况下是**不可变的**。
		- **再次分配不可变变量新值就会提示**：
			- consider making this binding mutable
		        - 不能对不可变变量二次分配
			    - **“绑定可变绑定”**（mutable binding）是指在某些编程语言中，**变量的绑定**（即变量与值的关联）是**可变的**，也就是说，可以在赋值后再次修改该变量的值。
	- 注意点：**变量不能分配给与其原始类型不同类型的值**。
	- 为什么这么设计：**不必自己追踪，降低心智负担，增加可读性**
	    - 如果我们的代码的一部分在假设值永远不会改变的情况下运行，而代码的另一部分更改了该值，则代码的第一部分可能不会执行其设计目的。事后很难追查这种错误的原因，尤其是当第二段代码有时只更改值时。 **Rust 编译器保证，当你声明一个值不会改变时，它确实不会改变，所以你不必自己跟踪它。因此，您的代码更容易推理。**
	    - 这种规则让我们的代码变得非常清晰，**只有你想让你的变量改变时，它才能改变，这样就不会造成心智上的负担**，也给别人阅读代码带来便利。
- 可变
	- 加mut
- 声明了变量但没有使用
	- 编译器会发出警告
	- 故意不使用某个变量，但不想看到这个警告
		-  **加“\_”** ：变量前加上可以让编译器不警告注明这是有意预留的变量
		- `#[allow(unused_variables)]`：`#[allow(unused_variables)]` 是 **Rust 的属性（attribute）**，用于告诉编译器**不要对未使用的变量发出警告**。
			```rust
			#[allow(unused_variables)]
			fn main() {
			    let x = 1;
			}
			```
		- 范围：函数、模块、代码块