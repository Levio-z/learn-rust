---
tags:
  - permanent
---
## 1. 核心观点  
### Ⅰ. 概念层

结构化并发是一种设计并发程序的理念。要使程序完全遵循结构化并发的原则，**需要特定的语言特性和库，但即使没有这些特性，遵循这种理念也能获得许多好处**。**结构化并发独立于语言和并发原语（例如线程与异步等）**。许多人发现，在使用 Rust 异步编程时，结构化并发的思想非常有用。

### Ⅱ. 应用层


### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 核心思想
#### 1. 任务组织为树
结构化并发的核心在于**任务以树形结构组织**：
- **父任务**负责管理其**子任务**。
- 子任务在父任务启动后才启动，并且**必须在父任务结束前完成**。
- 这种结构保证了任务的生命周期和依赖关系清晰，有利于错误和结果的传播。
#### 2. 结果与错误传播
- 子任务完成后，其结果可以传递回父任务。
- 如果子任务出现错误，这种错误也会被传播到父任务，使父任务能够统一处理异常。
- 取消操作同样会沿树向下传播，即**父任务被取消时，其所有子任务也会被取消**。
#### 3. 时间作用域与词法作用域
- **时间作用域**通常遵循**词法作用域**，即任务的生命周期不应超过它所在的函数或代码块。即任务的启动与结束绑定在其所在的函数或代码块中。任务必须在父作用域结束前完成，不能“逃逸”到外部作用域。
	-  **结构化并发的基本约束**  
		- 在结构化并发模型中，任务（task / coroutine / async job）的**生命周期默认受词法作用域控制**：
	    - 在某个函数或代码块中创建的任务
	    - 必须在该作用域结束之前完成（成功、失败或被取消）
- 这使任务形成一棵**严格嵌套的任务树**，父作用域退出时，不允许仍然存在“游离”的子任务。
- 这保证了资源管理的安全性，避免出现悬挂任务或资源泄漏。这种约束确保了资源（如内存、文件句柄、锁等）的管理安全：父任务结束时，所有子任务已经完成，资源不会被悬挂任务持有，从而避免泄漏或未定义行为。
- 如果需要生命周期较长的任务，可以通过某种对象或句柄显式表示其存在时间，但这并不是结构化并发的强制要求，而是一种扩展手段。
	- **核心目标不是“限制功能”，而是“约束默认行为”**  
	- 结构化并发的目的不是禁止长生命周期任务，而是
		- 让**默认写法就是安全的**
		- 避免“无意中”创建后台任务（fire-and-forget）
##### 3.1 如果语言或运行时**默认允许任务逃逸作用域**：
- 很容易出现
	- 悬挂任务（dangling task）：创建它的作用域已经结束，但任务本身仍在执行或等待执行的任务。任务的**时间生命周期**已经超出了它的**语义所有者**（函数 / 作用域 / 管理对象），导致：
		- 没有人对它负责
		- 没有明确的回收、取消、错误处理点
	- 父函数返回后仍在访问已释放资源：
		- 持有指向栈变量的引用
		- 持有指向已 Drop 对象的指针
		- 假设某个资源“仍然存在”
	- 错误和取消无法向上传播
- 调试成本和系统复杂度急剧上升

### TODO diagram  所有图表

结构化并发的名称源于对[结构化编程的](https://en.wikipedia.org/wiki/Structured_programming)类比，其思想是使用函数、循环等来构建控制流，而不是使用任意跳转（ `goto` ）。

在探讨结构化并发之前，我们不妨先思考一下常见的并发设计在哪些方面属于非结构化。一种典型的模式是，使用某种启动语句启动一个任务。然后，该任务会与其他任务（包括启动它的任务本身）并发运行直至完成。对于哪个任务先完成，没有任何限制。程序本质上就是一个由独立运行且随时可能终止的任务组成的集合。任务之间的任何通信或同步都是临时性的，程序员无法保证其他任务会继续运行。

**非结构化并发的实际缺点在于，任务返回结果的方式必须超越语言本身，语言层面无法保证何时以及如何返回结果。**

>语言的函数返回机制、类型系统、作用域规则，已经无法描述“这个并发任务的结果何时、由谁、以什么方式被接收”。因此，结果的传递不得不依赖： 回调（callback）| 全局变量 / 共享状态 | Channel / Queue  | Promise / Future 被“到处传” | 事件监听 / 消息系统  
>这些都属于**语言外部协议或运行时约定**，而不是函数签名和作用域本身能保证的语义。

- **并发程序难以理解和维护**，这种结构上的缺失是并发编程被认为比顺序编程更难的原因之一。
	- 错误无法被捕获：由于语言的错误处理机制无法应用于非结构化并发不受约束的控制流，因此错误可能无法被捕获。
	- 无法保证任务的相对状态：此外，我们也无法保证任务的相对状态——任何任务都可能正在运行、成功终止、错误终止或被外部取消，而与其他任何任务的状态无关 [¹](https://rust-lang.github.io/async-book/part-reference/structured.html#footnote-join) 。

值得注意的是，结构化并发**是一种编程规范，它会对程序施加一些限制**。就像函数和循环不如 goto 语句灵活一样，结构化并发也不如直接生成任务灵活。然而，与结构化编程一样，**结构化并发在灵活性方面的不足会被其在可预测性方面的优势所弥补**。

### [结构化并发原则](https://rust-lang.github.io/async-book/part-reference/structured.html#principles-of-structured-concurrency)

在分析实现了结构化并发的程序时，一个关键的新事实是：如果一个任务处于活动状态，那么它的所有父任务也必须处于活动状态。但这并不保证它们处于良好状态——它们可能正在关闭或处理错误，但它们必须以某种形式运行。**这意味着对于任何任务（根任务除外），总有一个活动任务可以接收结果或错误**。实际上，理想的做法是扩展语言的错误处理机制，使错误始终传播到父任务。在 Rust 中，这应该同时适用于返回 `Result::Err` 和触发 panic。

此外，子任务的生命周期可以在父任务中体现。
- **任务的时间作用域与其创建时所在的词法作用域绑定**
	- 通常情况下，任务的生命周期（即其时间作用域）与其启动的词法作用域相关联。例如，函数内部启动的所有任务都必须在函数返回之前完成。这是一个非常强大的推理工具。
- **任务绑定到一个显式对象**：当然，这种方法对于所有情况都过于严格，因此任务的时间作用域可以通过在程序中使用一个对象（通常称为“作用域”或“育婴室”）来扩展到词法作用域之外。这样的对象可以被传递或存储，因此可以拥有任意的生命周期。
- **重要的推理工具：与该对象关联的任务的生命周期不能超过该对象本身**（在 Rust 中，这一特性使我们能够将任务与生命周期系统集成起来）。
	- 只要你还能访问这个“作用域对象”，它所管理的任务才可能还在运行；一旦这个对象被销毁（drop），这些任务就必须已经结束或被强制取消。
优势：
- 它使我们能够跨多个任务进行资源管理。当资源不再使用时（例如，关闭文件句柄），会调用清理代码。
>在顺序代码中，何时调用清理代码的问题通过确保对象超出作用域时调用析构函数来解决。然而，在并发代码中，对象可能仍在被其他任务使用，因此何时清理并不明确（引用计数或垃圾回收在很多情况下都是解决方案，但这会使对象生命周期的推断变得困难，从而可能导致错误，并且还会带来运行时开销）。

取消的传播性：父任务的生命周期长于其子任务的原则对取消操作有着重要的启示：如果一个任务被取消，那么它的所有子任务也必须被取消，并且它们的取消必须在父任​​务取消完成之前完成。这反过来又对如何在结构并发系统中实现取消操作产生了影响。
todo: 传播性可以整理出一个单独的原子知识点

结论是：**父任务不能在子任务仍然存活的情况下结束**。
因此必须满足两个规则：
1. 父任务返回前，所有子任务必须结束
2. 若父任务是“异常结束”，则必须**触发对子任务的取消（cancellation）**
- 如果一个任务由于错误而提前完成（在 Rust 中，这可能意味着 panic 或提前返回），那么在返回之前，该任务必须等待其所有子任务完成。实际上，提前返回必须触发子任务的取消。这类似于 Rust 中的 panic：panic 会先触发当前作用域中的析构函数，然后沿着调用栈向上遍历，在每个作用域中调用析构函数，直到程序终止或 panic 被捕获。在结构并发中，提前返回必须触发子任务的取消（从而清理这些任务中的对象），并沿着任务树向下遍历，取消所有（传递的）子任务。

|Rust panic|结构化并发|
|---|---|
|沿调用栈向上|沿任务树向上 + 向下|
|清理栈帧资源|清理子任务资源|
|Drop 本地对象|取消并回收子任务|
有些设计在结构化并发环境下运行得非常自然（例如，每个工作任务只负责完成一项任务），而另一些则不太适用。通常，这些模式的特点是无需绑定到特定任务，例如工作线程池或后台线程。即使使用这些模式，任务的生命周期通常也不应该超过整个程序，因此总会有一个任务可以作为父任务。


#### 4. 核心优势
- 生命周期管理清晰：任务自动随父任务启动和结束。
- 错误处理一致：错误统一向上传播。
- 资源安全：遵循词法作用域，降低泄漏风险。
- 可取消性：父任务取消立即影响子任务。




## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
