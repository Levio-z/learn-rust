---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层

演员模型是一种处理**并行与分布式计算**的数学模型。它不把程序看作一系列顺序执行的步骤，而是看作一个由许多**“演员（Actors）”**组成的社会。

### Ⅱ. 应用层


### Ⅲ. 实现层

### **IV**.原理层

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 1. 什么是演员（Actor）？

在演员模型中，**Actor 是最小的计算单元**。它像是一个封装极好的“黑盒”，拥有自己的：
- **状态（State）：** 只有 Actor 自己能修改，别人读不到也改不了。
- **行为（Behavior）：** 定义了它收到消息时要做什么。
- **邮箱（Mailbox）：** 存放还没来得及处理的消息。

### 2. 它是如何运作的？（三个基本动作）

当一个 Actor 收到一条消息时，它只能做三件事：

1. **发送消息：** 给其他 Actor 发送有限数量的消息。
2. **创建 Actor：** 像细胞分裂一样，创建新的 Actor。
3. **指定行为：** 决定下一次收到消息时该怎么做（例如改变内部状态）。


### 3. 为什么它能解决并发难题？

传统的并发（如多线程）最怕**“竞态条件”**：两个线程同时去改同一个变量，导致数据错乱。为了解决这个，程序员必须加锁（Lock），但加锁容易导致死锁和性能大幅下降。

**演员模型的哲学是：不要通过共享内存来通信，而要通过通信来共享内存。**

- **无锁：** Actor 之间不共享任何东西。
- **天然异步：** 发送者把消息丢进对方邮箱就走人，不需要等回复。
- **高扩展性：** 既然是通过消息通信，Actor 在同一台电脑上还是在地球另一端，逻辑是一样的。这就是为什么它非常适合**分布式系统**（如 Erlang 语言和 Akka 框架）。


---

### 4. 为什么它会留下“流量控制”和“重试”难题？

正如你提到的，演员模型在追求极致性能和解耦的同时，也带来了一些工程痛点：

#### A. 流量控制（Flow Control）

发送者发消息很快，但接收者处理很慢，接收者的“邮箱”就会爆掉。

- **问题：** 演员模型标准里没说邮箱满了怎么办。是丢弃消息？还是让发送者停下来？这就是所谓的“背压（Backpressure）”难题。
    

#### B. 消息投递的不确定性（Delivery Guarantees）

- **可丢弃的消息：** 在分布式环境下，网络可能断开，消息可能丢失。
    
- **重试逻辑：** 如果 Actor A 发给 B 的消息丢了，谁来负责重试？重试了两次结果 B 收到了重复消息怎么办（幂等性问题）？
    

#### C. 故障传播

如果一个 Actor 崩溃了，它的状态就丢了。虽然有“监督机制”（Supervisor），但如何优雅地恢复复杂的业务逻辑依然很头疼


## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
