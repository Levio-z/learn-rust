```rust
use actix_web::{App, HttpResponse, HttpServer, Responder, web};

use serde::Deserialize;

  

#[actix_web::main]

async fn main() -> std::io::Result<()> {

    // 设置路由

    let server = HttpServer::new(|| {

        App::new()

            .route("/", web::get().to(get_index))

            .route("/gcd", web::post().to(post_gcd))

    });

    println!("Serving on http://localhost:3000...");

  

    // 绑定端口，监听

    server

        .bind("0.0.0.0:3000")

        .expect("error binding server to address")

        .run()

        .await

}

// 定义响应

async fn get_index() -> HttpResponse {

    HttpResponse::Ok().content_type("text/html").body(

        r#"

                <title>GCD Calculator</title>

                <form action="/gcd" method="post">

                <input type="text" name="n"/>

                <input type="text" name="m"/>

                <button type="submit">Compute GCD</button>

                </form>

            "#,

    )

}

  

#[derive(Deserialize)]

struct GcdParameters {

    n: u64,

    m: u64,

}

async fn post_gcd(form: web::Form<GcdParameters>) -> impl Responder {

    if form.n == 0 || form.m == 0 {

        return HttpResponse::BadRequest().body("Both numbers must be positive non-zero integers.");

    }

    let result = gcd(form.n, form.m);

    HttpResponse::Ok().content_type("text/html").body(format!(

        "The greatest common divisor of {} and {} is <b>{}</b>",

        form.n, form.m, result

    ))

}

  

fn gcd(mut n: u64, mut m: u64) -> u64 {

    assert!(n != 0 && m != 0);

    // 余数不为0

    while m != 0 {

        // 如果m小于n，交换

        if m < n {

            std::mem::swap(&mut m, &mut n);

        }

        // 需要保留两者中小的数

        // 计算出两者的余数，作为下一轮计算的参数

        // 不需要保留大的数，大的数就等于余数

        m %= n;

    }

    n

}
```