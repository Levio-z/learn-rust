那如果数组中每个元素都是一个 Box 对象呢？来看看 Vec<Box<\i32>> 的内存布局：

```rust
                    (heap)
(stack)    (heap)   ┌───┐
┌──────┐   ┌───┐ ┌─→│ 1 │
│ vec2 │──→│B1 │─┘  └───┘
└──────┘   ├───┤    ┌───┐
           │B2 │───→│ 2 │
           ├───┤    └───┘
           │B3 │─┐  ┌───┐
           ├───┤ └─→│ 3 │
           │B4 │─┐  └───┘
           └───┘ │  ┌───┐
                 └─→│ 4 │
                    └───┘

```
上面的 B1 代表被 Box 分配到堆上的值 1。 可以看出智能指针 vec2 依然是存储在栈上，然后指针指向一个堆上的数组，该数组中每个元素都是一个 Box 智能指针，最终 Box 智能指针又指向了存储在堆上的实际值。
```rust
fn main() {
    let arr = vec![Box::new(1), Box::new(2)];
    let (first, second) = (arr[0], arr[1]);
    //let sum = **first + **second;
}
```
以上代码有几个值得注意的点：
- 使用 `&` 借用数组中的元素，否则会报所有权错误
- 表达式不能隐式的解引用，因此必须使用 `*` 做两次解引用，第一次将 `&Box<i32>` 类型转成 `Box<i32>`，第二次将 `Box<i32>` 转成 `i32`

### 拓展
#### 为什么使用 `&` 借用数组中的元素，否则会报所有权错误
#### 为什么
- Box<\T> 不实现 Copy，不能隐式复制
	- 在 Rust 中，是否能“隐式复制”一个值，取决于该类型是否实现了 `Copy` trait。
- `vec[index]` 默认是 move，不能 move 出去
	- 如果一个类型实现了 `Copy` trait，那么在 move 语义发生的位置，编译器就会自动做“隐式复制”。这意味着值不会发生所有权转移，而是静默地复制了一份副本。
	- Copy 类型例外：隐式复制，不受rust的所有权类型管理
		- **Rust 的 `Copy` trait 之所以只对某些类型生效，核心原因正是“这些类型的复制成本极低（通常是位拷贝）”，而且不涉及资源管理（如堆内存、文件句柄等）**。
			- 栈上值生命周期固定，由作用域控制，成本低，一般 `Copy` 即可
			- 堆上值（如 `Box`, `String`, `Vec`）涉及手动分配 / 释放，更容易出现内存安全问题，所以强制使用所有权 + Drop
##### 解决方案1：直接用索引转移所有权
```rust
fn main() {
    let mut arr = vec![Box::new(1), Box::new(2)];
    let first = arr.remove(0);   // 从 vec 中移除并拿走第一个元素的所有权
    let second = arr.remove(0);  // 再拿走第二个元素的所有权
    let sum = *first + *second;
    println!("{}", sum);
}

```
- `arr.remove(0)` 移除并返回该位置元素的所有权，原数组缩短。
- 这样 `first`、`second` 就是 `Box<i32>` 类型，拥有所有权。
- 解引用一次 `*first` 就得到堆上整数 `i32`。
##### 解决方案2：如何通过解构来移动所有权？：
如果你一定要一次性解构整个数组并拿走所有权，可以用 `vec!` 生成的数组解构：
```rust
fn main() {
    let arr = vec![Box::new(1), Box::new(2)];
    let [first, second]: [Box<i32>; 2] = arr.try_into().unwrap();
    let sum = *first + *second;
    println!("{}", sum);
}
```
这里做了什么？
- `arr.try_into()` 把 `Vec<Box<i32>>` 转换成固定长度数组 `[Box<i32>; 2]`，要求元素个数严格匹配。
- 赋值给 `[first, second]`，完成所有权解构。
- 这样 `first` 和 `second` 是 `Box<i32>` 类型，拥有所有权，可以直接解引用。