# 第 24 章 面向对象应用测试（Testing Object-Oriented Applications）总结

本章聚焦面向对象（OO）软件的测试特殊性，从 OO 模型的前期评审，到单元、集成、确认测试的策略调整，再到针对性的测试方法（如随机测试、行为测试），系统构建了适配 OO 特性（封装、继承、多态、类间协作）的测试体系，具体内容如下：

## 一、OO 测试的核心前提：拓宽测试定义，覆盖模型评审

OO 软件的测试需突破 “仅测试代码” 的传统认知，将**分析与设计模型的评审**纳入测试范畴，核心原因是 OO 语义构造（类、属性、操作、消息）在分析、设计、代码阶段高度复用，早期发现模型问题可避免后续连锁缺陷。

### 1. OO 模型的两大评审维度

#### （1）语义正确性评审（Semantic Correctness）

- 核心目标：验证模型是否贴合真实业务领域，无偏离需求的设计；
- 评审方法：
    1. 邀请领域专家（如业务负责人）审查类定义与层级，排查遗漏（如 “电商系统” 是否缺失 “订单类”）与歧义（如 “商品类” 的 “库存” 属性是否未明确单位）；
    2. 评估类关系（如关联、聚合）是否反映真实世界对象连接（如 “用户类” 与 “订单类” 的 “1 对多” 关系是否符合实际业务）。

#### （2）类模型一致性评审（Class Model Consistency）

基于 CRC 模型（类 - 职责 - 协作模型）与对象关系模型，按 5 步排查一致性问题，避免职责混乱或协作冗余：

  

1. 回溯 CRC 卡片与对象关系模型，确认类的职责描述；
2. 检查 CRC 卡片中 “委托的职责” 是否属于协作类的定义（如 “订单类” 委托 “计算金额” 给 “支付类”，需确认 “支付类” 是否确实包含该职责）；
3. 反向验证协作关系：确保协作类接收的服务请求来自合理的发起者（如 “日志类” 不应接收来自 “商品类” 的 “修改库存” 请求）；
4. 基于反向验证结果，判断是否需新增类或调整职责分组（如多个类均需 “数据验证” 职责，可考虑抽取为 “验证工具类”）；
5. 合并高频请求的职责：将多个类频繁请求的同一职责（如 “格式转换”）合并为单一职责，减少冗余协作。

## 二、OO 测试策略：从单元到确认的全流程调整

OO 软件的测试层级仍分为 “单元 - 集成 - 确认”，但因 “封装、继承、协作” 特性，各层级的测试目标与方法需针对性调整：

### 1. 单元测试（Unit Testing）：从 “模块” 转向 “封装类”

#### （1）测试单元的变化

传统软件的单元是 “独立模块 / 函数”，OO 软件的**最小测试单元是封装类**，而非单个操作（方法）—— 原因是 OO 类的操作依赖内部状态（属性）与其他操作的协作，单个操作无法孤立测试（如 “订单类” 的 “计算总价” 操作依赖 “添加商品” 操作设置的商品列表属性）。

#### （2）测试核心

聚焦类的**完整生命周期与状态行为**，需覆盖：

  

- 属性初始化与修改：验证属性的默认值、修改逻辑是否正确（如 “用户类” 的 “注册时间” 默认值是否为当前时间）；
- 操作逻辑：测试类的所有方法，包括正常场景与异常场景（如 “账户类” 的 “取款” 方法，需测试 “余额充足”“余额不足”“账户冻结” 场景）；
- 状态流转：验证类在不同操作下的状态变化是否符合预期（如 “账户类” 从 “未激活”→“正常”→“冻结” 的流转）。

### 2. 集成测试（Integration Testing）：从 “模块接口” 转向 “类间协作”

OO 软件的集成测试核心是验证 “类间消息传递与协作逻辑”，而非传统的 “模块接口参数匹配”，主要有 3 种策略：

  

|策略|核心逻辑|实施步骤|适用场景|
|---|---|---|---|
|**线程测试（Thread-Based）**|集成 “响应同一输入 / 事件” 的所有类，验证事件驱动的协作正确性|1. 识别触发事件（如 “用户下单” 事件）；  <br>2. 梳理该事件涉及的类（订单类、商品类、支付类、库存类）；  <br>3. 设计测试用例模拟事件，验证类间消息传递与数据流转|事件驱动型 OO 系统（如 GUI 应用、实时响应系统）|
|**用例测试（Use-Based）**|按 “依赖层级” 集成：先测 “独立类”（无依赖或依赖少的类），再测 “依赖类”（依赖独立类的类）|1. 识别独立类（如 “工具类”，不依赖其他业务类）；  <br>2. 测试独立类，确保其功能正常；  <br>3. 集成依赖该类的下一层级类（如 “订单类” 依赖 “工具类” 的格式验证功能），逐步扩展；  <br>4. 每集成一层，执行回归测试|分层架构清晰的 OO 系统（如分层业务系统）|
|**集群测试（Cluster-Based）**|集成 “协作紧密的类集群”（从 CRC 模型与对象关系模型中识别），验证协作逻辑缺陷|1. 识别协作集群（如 “用户管理集群” 含用户类、权限类、日志类）；  <br>2. 设计测试用例覆盖集群内的所有协作场景（如 “用户登录” 需用户类调用权限类验证、日志类记录操作）；  <br>3. 排查协作中的消息丢失、权限越界等问题|类间耦合度高、协作频繁的 OO 系统（如复杂业务组件）|

### 3. 确认测试（Validation Testing）：回归用例，复用黑盒方法

- 核心目标：验证 OO 软件整体是否符合客户需求，此时类间的具体连接细节不再是重点；
- 测试依据：以需求模型中的用例（Use-Case）为核心，覆盖用户真实操作场景（如 “电商系统” 的 “浏览商品→加入购物车→结算” 用例）；
- 测试方法：复用传统黑盒测试技术（如等价类划分、边界值分析），无需关注类的内部实现，仅验证输入输出是否符合用例要求。

## 三、OO 测试用例设计规范（Berard 方法）

OO 测试用例需结构化设计，确保可追溯、可复现，Berard 提出的规范包含 5 大核心要素：

  

1. **唯一标识**：为每个测试用例分配唯一 ID，关联到待测试的类（如 “Test_Account_001” 对应 “账户类” 的测试）；
2. **测试目的**：明确测试要验证的类特性（如 “验证账户类的取款操作在余额不足时抛出异常”）；
3. **测试步骤清单**：包含 5 类关键信息：
    - 待测试对象的指定状态（如 “账户类初始状态为‘正常’，余额 1000 元”）；
    - 需执行的消息与操作（如 “调用 withdraw (1500) 方法”）；
    - 可能触发的异常（如 “余额不足异常（InsufficientBalanceException）”）；
    - 外部环境条件（如 “数据库连接正常，无并发操作”）；
    - 辅助信息（如 “测试前需初始化账户数据”）；
4. **预期结果**：明确测试通过的判断标准（如 “抛出 InsufficientBalanceException，余额保持 1000 元”）；
5. **关联类**：标注测试用例涉及的所有协作类（如 “账户类测试需关联日志类，验证取款失败时是否记录日志”）。

## 四、OO 专用测试方法

针对 OO 软件的特性，需采用 4 类针对性测试方法，覆盖类的内部行为与类间交互：

### 1. 故障导向测试（Fault-Based Testing）

- 核心思路：基于 “可能的故障点” 设计测试用例，主动验证是否存在缺陷；
- 实施步骤：
    1. 识别 OO 软件的典型故障点（如继承导致的方法重写错误、多态导致的类型转换异常、类间消息传递错误）；
    2. 设计测试用例针对性触发这些故障点（如 “测试子类重写父类方法时，是否未调用父类的初始化逻辑”）；
- 优势：聚焦高风险区域，提升缺陷发现效率。

### 2. 随机测试（Random Testing）

- 核心思路：生成随机但有效的操作序列，覆盖类的多种使用场景，避免测试盲区；
- 实施步骤：
    1. 识别类的所有可执行操作（如 “账户类” 的 open ()、deposit ()、withdraw ()、close ()）；
    2. 定义操作的使用约束（如 “close () 需在账户状态为‘正常’时调用，且余额为 0”）；
    3. 生成 “最小测试序列”（覆盖类的基本生命周期，如 “open ()→deposit ()→withdraw ()→close ()”）；
    4. 扩展生成复杂随机序列（如 “open ()→deposit ()→deposit ()→withdraw ()→query ()→close ()”），验证类在多样场景下的稳定性；
- 适用场景：类的操作组合较多，难以手动覆盖所有场景时。

### 3. 划分测试（Partition Testing）

- 核心思路：按 “操作对类的影响” 对操作分组，每组设计少量测试用例，减少冗余，类似传统软件的等价类划分；
- 三种划分维度：
    
    |划分类型|核心逻辑|示例（账户类）|
    |---|---|---|
    |**状态基划分**|按操作是否改变类的状态分组|- 状态改变操作：deposit ()、withdraw ()、close ()  <br>- 状态不变操作：query ()、getBalance ()|
    |**属性基划分**|按操作使用的属性分组|- 使用 “余额” 属性：deposit ()、withdraw ()、getBalance ()  <br>- 使用 “账户状态” 属性：open ()、close ()、freeze ()|
    |**类别基划分**|按操作的通用功能分组|- 账户管理操作：open ()、close ()、freeze ()  <br>- 资金操作：deposit ()、withdraw ()  <br>- 查询操作：query ()、getBalance ()|
    

### 4. 行为测试（Behavior Testing）

- 核心思路：基于类的状态图，设计测试用例覆盖所有允许的状态流转，确保类的行为符合预期；
- 实施步骤：
    1. 绘制类的状态图（如 “账户类” 的状态：未激活→正常→冻结→关闭）；
    2. 设计操作序列，确保类能遍历所有状态（如 “未激活→open ()→正常→deposit ()→withdraw ()→正常→freeze ()→冻结→unfreeze ()→正常→close ()→关闭”）；
    3. 验证每个状态转换的正确性（如 “冻结状态下调用 withdraw ()，是否抛出‘账户冻结异常’”）；
- 示例（账户类）：需覆盖 “未激活、正常、冻结、关闭” 所有状态，确保无遗漏的流转路径。

## 五、继承层级的测试注意事项

继承虽提升 OO 软件的复用性，但会增加测试复杂度，需特别注意：

  

- **子类不可跳过测试**：即使子类继承了父类的所有操作，也需单独测试 —— 子类可能重写父类方法（引入新逻辑）、新增属性（影响父类方法的执行）、或继承的方法在子类语境下存在缺陷（如父类 “计算折扣” 方法未考虑子类 “VIP 用户” 的特殊规则）；
- **测试重点**：子类需测试 “继承的操作 + 重写的操作 + 新增的操作”，尤其关注重写操作是否破坏父类的封装性（如子类重写父类方法时，直接修改父类的私有属性）。

## 核心总结

OO 软件测试的核心是 “适配 OO 特性，从模型到代码全流程覆盖”：

  

1. 前期通过模型评审（正确性、一致性）提前消除设计缺陷，避免后续连锁问题；
2. 单元测试聚焦 “封装类” 的生命周期与状态行为，而非孤立操作；
3. 集成测试围绕 “类间协作”，按线程、用例、集群三种策略逐步集成；
4. 确认测试回归用户用例，复用黑盒方法验证需求符合性；
5. 专用测试方法（随机、划分、行为测试）覆盖 OO 软件的复杂场景，同时需重视继承层级的测试风险。

  

通过这套策略，可有效应对 OO 软件的封装、继承、多态带来的测试挑战，提升测试的全面性与效率。