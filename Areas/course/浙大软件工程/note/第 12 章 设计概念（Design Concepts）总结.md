# 第 12 章 设计概念（Design Concepts）总结

本章围绕软件设计的核心理念、范畴、质量要求、基础概念及模型构成展开，构建了 “从理念到落地、从原则到实践” 的软件设计框架，核心解决 “如何通过科学设计实现高质量软件” 的问题，具体内容如下：

## 一、软件设计的核心理念与范畴

### （一）设计的核心目标：三大支柱（Mitch Kapor 的软件设计宣言）

Lotus 1-2-3 创始人 Mitch Kapor 提出，优秀软件设计需满足三大核心特性，奠定设计的价值导向：

  

1. **稳固性（Firmness）**：软件无阻碍功能实现的缺陷，核心功能稳定运行；
2. **适用性（Commodity）**：软件贴合预设用途，满足用户实际需求（如 “电商系统需支持‘下单 - 支付 - 物流’全流程”）；
3. **愉悦性（Delight）**：用户使用体验愉悦，交互流畅、反馈及时（如 “界面布局直观，操作路径短”）。

### （二）软件设计的范畴与软件工程设计的分层

#### 1. 软件设计的核心构成

软件设计是 “原则、概念、实践” 的集合，三者共同支撑高质量系统开发：

  

- **原则（Principles）**：指导设计的底层理念（如 “模块化”“信息隐藏”）；
- **概念（Concepts）**：设计需掌握的核心思想（如抽象、架构、模式）；
- **实践（Practices）**：随技术演进的落地方法（如基于 UML 的建模、敏捷设计）。

#### 2. 软件工程设计的四大分层

软件工程设计需按 “从宏观到微观” 的逻辑，覆盖四个关键层面，确保设计完整落地：

  

|设计分层|核心目标与操作|
|---|---|
|**数据 / 类设计（Data/Class Design）**|将需求分析阶段的 “分析类” 转化为可实现的 “设计类” 与数据结构（如 “将‘用户’分析类细化为包含‘用户名、密码加密逻辑’的设计类”）。|
|**架构设计（Architectural Design）**|定义软件核心结构元素间的关系（如 “电商系统分为‘用户模块、商品模块、订单模块’，模块间通过接口通信”），确保系统整体逻辑清晰。|
|**接口设计（Interface Design）**|定义软件与外部（用户、硬件、其他系统）及内部组件的通信规则（如 “用户登录接口需接收‘账号 / 密码’参数，返回‘token / 错误码’”）。|
|**组件级设计（Component-Level Design）**|将架构元素转化为具体的过程描述（如 “‘订单生成’组件需包含‘库存校验 - 价格计算 - 订单存储’的算法逻辑”）。|

## 二、从分析模型到设计模型的转化

分析模型（需求阶段产物）是设计模型的输入，需通过系统性转化，将 “需求描述” 转化为 “设计方案”，转化关系如下：

### （一）分析模型的核心元素

分析模型包含四类关键元素，覆盖 “用户场景、流程、数据、行为”：

  

- **场景化元素**：用例（文本 / 图）、活动图、泳道图（描述用户与系统的交互流程）；
- **面向流程元素**：数据流图、控制流图、处理说明（描述数据在系统内的流转与处理）；
- **面向类元素**：类图、分析包、CRC 模型（描述核心数据对象与关系）；
- **行为元素**：状态图、序列图、协作图（描述系统对外部事件的响应逻辑）。

### （二）转化逻辑

分析模型的各类元素分别对应设计模型的不同层面，形成完整转化链路：

  

- 场景化 / 面向流程元素 → 架构设计、接口设计（如 “登录用例” 转化为 “登录模块架构” 与 “用户 - 系统交互接口”）；
- 面向类元素 → 数据 / 类设计（如 “用户分析类” 转化为 “用户设计类” 与数据库表结构）；
- 行为元素 → 组件级设计（如 “订单状态流转” 转化为 “订单状态管理组件的逻辑”）。

## 三、设计的质量要求：标准与原则

高质量设计需满足 “明确的质量标准” 与 “严格的设计原则”，确保设计可落地、可维护、可扩展。

### （一）设计质量的三大核心标准

设计需从 “需求匹配、可理解性、完整性” 三个维度验证质量：

  

1. **需求全覆盖**：既实现分析模型中的**显式需求**（如 “支持手机号登录”），也容纳用户的**隐式需求**（如 “登录失败需提示具体原因，而非‘登录错误’”）；
2. **可理解性**：设计文档清晰可读，能指导编码、测试与维护（如 “架构图标注模块职责，组件说明包含‘输入 / 输出 / 算法逻辑’”）；
3. **完整性**：从 “数据、功能、行为” 三个域全面描述软件（如 “既定义‘用户数据结构’，也说明‘登录功能逻辑’，还覆盖‘用户登录失败后的重试行为’”）。

### （二）设计质量指南：八大实践标准

为达成质量目标，设计需遵循八大可落地的指南，确保设计科学性：

  

1. 架构需基于 “可识别的架构风格 / 模式”（如 “电商系统用分层架构”），组件具备良好设计特性，支持增量实现；
2. 软件需模块化，逻辑上划分为独立子系统 / 元素（如 “将‘支付’拆分为独立模块，不与‘商品浏览’耦合”）；
3. 设计需区分 “数据、架构、接口、组件” 的独立表示（如 “用类图描述数据，用架构图描述结构，用接口文档描述通信规则”）；
4. 数据结构需适配设计类，基于可识别的数据模式（如 “用‘键值对’存储配置数据，用‘关系表’存储用户订单”）；
5. 组件需功能独立（如 “‘库存校验’组件仅负责库存判断，不处理订单生成”）；
6. 接口需降低复杂度（如 “组件间仅通过‘统一 API’通信，避免直接访问对方内部数据”）；
7. 设计需基于 “可重复的方法”，且驱动源为需求分析信息（如 “每次设计都先梳理需求，再拆分模块，避免无依据设计”）；
8. 设计需用 “精准的符号” 表达（如 “用 UML 类图描述类关系，用流程图描述算法逻辑”）。

### （三）设计原则：十大底层准则（Davis 提出）

设计需遵循十大不可违背的底层原则，避免设计偏差：

  

1. 避免 “隧道视野”：不局限于局部设计，需考虑系统整体逻辑（如 “设计‘库存模块’时，需关联‘订单模块’的库存扣减需求”）；
2. 设计可追溯到分析模型：每个设计决策都能对应需求（如 “‘密码加密存储’设计对应‘用户数据安全’需求”）；
3. 不重复造轮子：复用成熟设计模式、组件或框架（如 “用‘单例模式’设计‘日志管理器’，而非从零开发”）；
4. 最小化 “认知距离”：设计与现实世界问题逻辑一致（如 “‘电商购物车’设计贴合用户‘选商品 - 结算’的真实流程”）；
5. 统一性与集成性：设计风格、命名规范、接口规则统一（如 “所有模块的‘查询接口’均以‘queryXXX’命名”）；
6. 支持变更：设计预留扩展空间（如 “用‘配置文件’存储‘支付渠道列表’，新增渠道无需修改代码”）；
7. 容错性：异常场景下 “平缓降级”（如 “网络中断时，软件提示‘请检查网络’，而非直接崩溃”）；
8. 设计≠编码：设计是 “方案规划”，编码是 “方案实现”，避免跳过设计直接编码；
9. 实时质量评估：设计过程中持续检查质量（如 “拆分模块后，立即评估‘耦合度’是否过低”），而非事后补救；
10. 评审降错：通过设计评审发现 “概念性错误”（如 “模块职责重叠”），避免后续编码阶段返工。

## 四、软件设计的基础概念：十二大核心思想

软件设计的落地依赖十二大基础概念，是设计实践的 “工具箱”：

### （一）抽象（Abstraction）：隐藏细节，聚焦核心

抽象是 “忽略非关键细节，仅保留核心特征” 的设计思想，分为三类：

  

- **数据抽象**：描述数据对象的核心属性，隐藏存储细节（如 “‘门’数据抽象包含‘制造商、型号、开关方向’，不关注‘木材材质’等非核心属性”）；
- **过程抽象**：描述操作的核心目标，隐藏实现步骤（如 “‘开门’过程抽象仅定义‘从‘关’到‘开’的状态变化’，不关注‘拧把手 - 推开门’的具体步骤”）；
- **控制抽象**：描述控制逻辑的核心规则，隐藏执行顺序（如 “‘登录重试’控制抽象仅定义‘失败 3 次锁定账号’，不关注‘每次重试的时间间隔判断’”）。

### （二）架构（Architecture）：软件的 “骨架”

架构是 “软件的整体结构及确保结构概念完整性的规则”[SHA95a]，需覆盖三个关键维度：

  

1. **结构属性**：定义核心组件（如模块、对象、过滤器）及组件的打包与交互方式（如 “对象通过‘方法调用’交互，模块通过‘接口’通信”）；
2. **额外功能属性**：确保架构满足性能、可靠性、安全性等非功能需求（如 “高并发场景下，架构需支持‘负载均衡’”）；
3. **相关系统家族适配**：复用同类系统的架构模式（如 “所有管理系统均采用‘MVC 架构’”），降低设计成本。

### （三）模式（Patterns）： proven 设计方案的复用

设计模式是 “已验证有效解决方案的核心 essence”，需通过标准模板描述，确保可复用：

  

- 模板包含：模式名称、意图（解决什么问题）、别名、动机（示例场景）、适用性（适用设计情境）、结构（类 / 组件关系）、参与者（组件职责）、协作方式、后果（设计权衡）、相关模式。

### （四）关注点分离（Separation of Concerns）：分而治之

核心逻辑：复杂问题可通过 “拆分为独立子问题” 降低难度，每个子问题可单独优化（如 “将‘电商系统’拆分为‘用户、商品、订单、支付’四大关注点，分别设计”）；“关注点” 即需求模型中定义的特征或行为。

### （五）模块化（Modularity）：逻辑分区，降低复杂度

#### 1. 核心价值

Myers 提出 “模块化是软件唯一能降低智力复杂度的属性”：单模块的 “巨型软件” 无法被工程师理解（控制路径多、变量多、逻辑复杂），拆分后可逐个掌握。

#### 2. 模块化的权衡：最优模块数量

模块数量需平衡 “开发成本” 与 “集成成本”：

  

- 模块过少：每个模块功能复杂，开发难度高、bug 多；
- 模块过多：模块间交互频繁，集成成本高（如 “100 个小模块需定义大量接口”）；
- 最优数量：开发成本与集成成本之和最小的临界点（需结合项目规模与复杂度判断）。

### （六）信息隐藏（Information Hiding）：受控接口，降低耦合

#### 1. 核心逻辑

模块通过 “受控接口” 对外提供服务，隐藏内部 “秘密”（如算法、数据结构、资源分配策略），仅暴露必要操作（如 “‘订单计算’模块仅暴露‘calculateOrder (订单信息)’接口，隐藏‘折扣规则算法’”）。

#### 2. 核心好处

- 减少 “副作用”（修改模块内部逻辑不影响外部调用）；
- 限制局部设计决策的全局影响（如 “修改‘密码加密算法’仅影响‘用户模块’，不波及‘商品模块’”）；
- 避免全局数据滥用，推动封装（高内聚设计的核心）。

### （七）功能独立（Functional Independence）：高内聚、低耦合

功能独立是模块设计的核心目标，通过 “内聚” 与 “耦合” 两个指标衡量：

  

1. **内聚（Cohesion）**：模块功能的专注度 —— 理想状态是 “单一功能”（如 “‘手机号校验’模块仅负责判断手机号格式，不处理登录逻辑”）；
2. **耦合（Coupling）**：模块间的依赖程度 —— 理想状态是 “低耦合”（如 “模块间仅通过‘参数传递’交互，不直接访问对方内部数据”）。

### （八）逐步细化（Refinement）：从抽象到具体的迭代

核心逻辑：对抽象设计逐步补充细节，直至可落地（如 “‘开门’抽象→细化为‘走到门边→伸手拧把手→开门→进门→关门’→再细化为‘拧把手时若转不动，需取钥匙插入锁孔’”），确保设计不遗漏关键步骤。

### （九）方面（Aspects）：处理横切关注点

#### 1. 横切关注点定义

若需求 A 的实现 “必须依赖需求 B”（B 无法独立于 A 存在），则 B 是 A 的 “横切关注点”（如 “‘摄像头监控访问’需求 A，必须依赖‘用户身份验证’需求 B——B 是 A 的横切关注点”）；“方面” 即横切关注点的设计表示（如 “‘用户验证’的设计方案是‘摄像头监控’的方面”）。

#### 2. 示例（SafeHome WebApp）

- 需求 A：“通过互联网访问摄像头监控”（需设计 “监控模块”）；
- 需求 B：“注册用户需先验证身份”（所有功能均需依赖，横切关注点）；
- 方面：需求 B 的设计方案（如 “token 验证逻辑”），需嵌入需求 A 的设计中。

### （十）重构（Refactoring）：优化内部结构，不改变外部行为

Fowler 定义：“重构是在不改变软件外部行为的前提下，优化内部结构以提升可维护性、降低复杂度”。重构需针对以下设计问题：

  

- 冗余设计（如重复的代码逻辑）、未使用元素（如废弃的类 / 方法）；
- 低效算法（如 “用线性查找替代二分查找”）、不合适的数据结构（如 “用数组存储动态增长的订单列表”）。

### （十一）面向对象（OO）设计概念

OO 设计需围绕 “设计类” 与三大特性展开，适配 OO 开发范式：

#### 1. 设计类的三种类型

- **实体类（Entity Classes）**：对应业务领域的核心数据对象（如 “用户、订单”），由分析类细化而来；
- **边界类（Boundary Classes）**：负责用户与系统的交互接口（如 “登录界面、订单详情页”），管理实体类向用户的展示逻辑；
- **控制类（Controller Classes）**：协调实体类与边界类，处理复杂逻辑（如 “订单生成时，控制‘库存校验→价格计算→订单存储’的流程”）。

#### 2. OO 核心特性

- **继承（Inheritance）**：子类自动继承父类的所有职责（如 “‘VIP 用户’子类继承‘普通用户’的‘登录、下单’功能”）；
- **消息（Messages）**：对象间通过 “消息” 触发行为（如 “‘订单’对象向‘库存’对象发送‘扣减库存’消息”）；
- **多态（Polymorphism）**：同一消息可触发不同对象的不同行为（如 “‘支付’消息，‘支付宝’对象执行‘支付宝支付逻辑’，‘微信支付’对象执行‘微信支付逻辑’”），降低扩展成本。

#### 3. 设计类的四大特性

- **完整且充分**：包含实现类意图的所有必要属性 / 方法（完整），无冗余元素（充分）；
- **原始性**：每个方法仅提供单一服务（如 “‘用户’类的‘getUserName ()’仅返回用户名，不处理密码校验”）；
- **高内聚**：类功能聚焦（如 “‘购物车’类仅负责‘添加商品 - 删除商品 - 计算总价’”）；
- **低耦合**：减少与其他类的协作（如 “‘购物车’仅通过‘订单接口’传递数据，不直接操作‘订单’类的内部属性”）。

## 五、设计模型的构成：五大核心元素

设计模型是设计的最终产物，包含 “数据、架构、接口、组件、部署” 五大元素，全面覆盖软件的 “静态结构” 与 “动态实现”：

### （一）数据元素（Data Elements）

将分析阶段的 “数据模型” 转化为可实现的数据结构与数据库架构：

  

- 数据结构：如 “‘用户’类的属性（用户名、加密密码、手机号）”；
- 数据库架构：如 “用户数据存储在 MySQL 的‘user’表，订单数据存储在‘order’表，两表通过‘user_id’关联”。

### （二）架构元素（Architectural Elements）

基于三大来源构建软件架构，确保架构贴合业务与技术需求：

  

1. **应用域信息**：业务领域的特性（如 “金融系统需强调‘安全性’，架构需包含‘加密模块’”）；
2. **需求模型元素**：分析类、数据流图、协作关系（如 “‘用户 - 订单’的协作关系，决定架构中‘用户模块’与‘订单模块’的接口”）；
3. **架构模式 / 风格**：复用成熟方案（如 “微服务架构用于高并发系统，分层架构用于管理系统”）。

### （三）接口元素（Interface Elements）

定义软件与内外部的所有通信规则，分为三类：

  

1. **用户接口（UI）**：用户与软件的交互界面（如 “登录页面的输入框、按钮布局，操作反馈逻辑”）；
2. **外部接口**：软件与其他系统 / 设备的通信规则（如 “电商系统与第三方支付接口的‘参数格式、签名逻辑’”）；
3. **内部接口**：软件内部组件的通信规则（如 “‘订单模块’与‘库存模块’的‘扣减库存’接口”）；

  

- 建模工具：用 UML 协作图（UML 1.x 称 “协作图”）描述接口交互逻辑。

### （四）组件元素（Component Elements）

描述每个组件的内部细节，确保可编码实现：

  

- 核心定义：数据结构（组件内局部数据的存储方式）、算法逻辑（组件处理功能的步骤，如 “订单折扣计算算法”）、接口（组件对外提供的操作）；
- 建模工具：UML 组件图（展示组件关系）、UML 活动图（描述算法流程）、伪代码（PDL）、流程图。

### （五）部署元素（Deployment Elements）

定义软件功能与子系统在 “物理计算环境” 中的分配方式，确保可落地运行：

  

- 建模工具：UML 部署图，分为两类：
    1. **描述符形式**：仅展示计算环境（如 “服务器、客户端设备”），不包含具体配置；
    2. **实例形式**：标注具体硬件配置（如 “‘订单服务’部署在 2 台 8 核 16G 服务器上”），后期设计阶段生成；
- 示例（SafeHome 系统）：“控制面板连接 CPI 服务器，用户通过‘个人电脑’或‘外部访问设备’访问‘安全监控’与‘家庭管理’功能”。

## 六、核心总结

软件设计是 “将需求转化为可实现方案” 的关键环节，其核心逻辑可概括为：

  

1. **理念导向**：以 “稳固、适用、愉悦” 为目标，确保设计的价值性；
2. **分层落地**：通过 “数据 / 类→架构→接口→组件” 的分层设计，覆盖从宏观到微观的所有细节；
3. **质量管控**：以 “需求匹配、可理解、完整” 为标准，以 “十大原则、八大指南” 为约束，避免设计偏差；
4. **概念支撑**：依赖 “抽象、模块化、信息隐藏、重构” 等核心概念，提升设计的科学性与可维护性；
5. **模型交付**：最终输出包含 “数据、架构、接口、组件、部署” 的设计模型，为编码、测试、维护提供完整依据。

  

设计的本质是 “平衡”—— 平衡需求与实现、平衡复杂度与可维护性、平衡当前功能与未来扩展，最终实现 “高质量、易落地” 的软件方案。