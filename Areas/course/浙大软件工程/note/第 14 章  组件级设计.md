# Ch.14 Component-Level Design

## 1. What is a Component?

OMG 统一建模语言规范（[OMG01]）将组件定义为：

  

> “…… 系统中模块化、可部署且可替换的部分，它封装了实现细节并公开一组接口。”

  

从不同视角对组件的解读如下：

  

- **面向对象（OO）视角**：组件包含一组协作的类。
- **传统视角**：组件包含处理逻辑、实现处理逻辑所需的内部数据结构，以及使组件能够被调用并传递数据的接口。

## 2. OO Component（面向对象组件）

（注：文档中该部分含图示，核心属性与方法整理如下）

  

|类 / 组件|核心属性|核心方法|
|---|---|---|
|Print Job|numberOfPages、numberOfSides、paperType、magnification、productionFeatures|computeJobCost()、computeJob()、passJobtoPainter()、initiateJob()|
|（接口相关）|higherOfSks、paperInge、ekcFeatures、CEut:eOg1:es、bdagorlem|cmmgAicfajeCnt()、cmxgSicfagEiC(st t)、cutcFrcdCmt()、cwoguteTiatAjatCest()、takeWorkOrder()、checkPriority()、assignToPrinter()、computeFarCost()、computeFroCost()、computeTotalCost()|

## 3. Conventional Component（传统组件）

（注：文档中该部分含图示，核心功能与数据流程整理如下）

### 3.1 核心功能模块

- getJobData：获取作业数据，包括页数（numberPages）、文档数（numberDocs）、作业尺寸（jobSize）、面数（sides）、颜色（color）、页面尺寸（pageSize）、页面成本（pageCost）等。
- ComputePageCost：计算页面成本，依赖基础页面成本（BPC）、尺寸因子（SF）、作业复杂度因子（JCF）等参数。
- accessCostsDB：访问成本数据库，根据作业尺寸、颜色、页面尺寸等查询 BPC、SF 等数据。

### 3.2 关键计算公式

- 作业尺寸（JS）：`JS = numberPages * numberDocs`
- 作业复杂度因子（JCF）：`JCF = 1 + [(sides - 1) * sideCost + SF]`
- 页面成本（pageCost）：`pageCost = BPC * JCF`

## 4. Basic Design Principles（基本设计原则）

1. **开放 - 封闭原则（OCP）**：模块（组件）应**对扩展开放，对修改封闭**。
2. **里氏替换原则（LSP）**：子类应能**替换其基类**并保证程序功能正常。
3. **依赖倒置原则（DIP）**：依赖于**抽象（接口）**，而非依赖于具体实现（类）。
4. **接口隔离原则（ISP）**：多个**客户专用接口**优于一个通用接口。
5. **发布 - 复用等价原则（REP）**：复用的粒度与发布的粒度**保持一致**。
6. **共同封闭原则（CCP）**：**一起变化的类应归为一组**（同属一个组件）。
7. **共同复用原则（CRP）**：**不一起复用的类不应归为一组**（避免不必要的依赖）。

## 5. Design Guidelines（设计指南）

### 5.1 组件（Components）

- 应为架构模型中指定的组件建立**命名规范**，并在组件级模型中进一步细化和完善。

### 5.2 接口（Interfaces）

- 接口不仅提供**通信与协作信息**，还能帮助实现开放 - 封闭原则（OCP）。

### 5.3 依赖与继承（Dependencies and Inheritance）

- 建模时建议：
    - 依赖关系从**左到右**绘制；
    - 继承关系从**下（派生类）到上（基类）** 绘制。

## 6. Cohesion（内聚性）

内聚性衡量组件 / 类内部元素的关联程度，不同视角的定义与层级如下：

### 6.1 定义

- **传统视角**：模块的 “专一性”（仅专注于一个功能）。
- **OO 视角**：组件或类仅封装与其自身**紧密相关的属性和操作**。

### 6.2 内聚性层级（从高到低）

1. Functional（功能内聚）：组件仅实现一个明确功能，内聚性最高。
2. Layer（层内聚）：组件对应系统中的某一层（如业务逻辑层、数据访问层）。
3. Communicational（通信内聚）：组件内元素共享同一数据源或通信路径。
4. Sequential（顺序内聚）：组件内元素按顺序执行，前一操作的输出为后一操作的输入。
5. Procedural（过程内聚）：组件内元素按特定流程执行，但无严格数据依赖。
6. Temporal（时间内聚）：组件内元素在同一时间段执行（如初始化、销毁操作）。
7. Utility（工具内聚）：组件仅包含通用工具方法（如数学计算、字符串处理），内聚性最低。

## 7. Coupling（耦合性）

耦合性衡量组件 / 类与外部元素的关联程度，不同视角的定义与层级如下：

### 7.1 定义

- **传统视角**：组件与其他组件及外部环境的 “连接程度”。
- **OO 视角**：类之间相互依赖的 “定性度量”。

### 7.2 耦合性层级（从高到低，高耦合应避免）

1. Content（内容耦合）：一个组件直接访问另一个组件的内部数据，耦合最高。
2. Common（公共耦合）：多个组件共享全局数据或公共数据区。
3. Control（控制耦合）：一个组件向另一个组件传递控制信号（如开关状态、分支条件）。
4. Stamp（标记耦合）：组件间传递复合数据结构（如结构体、对象），但仅使用部分字段。
5. Data（数据耦合）：组件间仅传递简单数据（如整数、字符串），耦合性较低。
6. Routine call（过程调用耦合）：一个组件通过调用接口调用另一个组件的方法。
7. Type use（类型使用耦合）：组件间仅依赖对方的接口或抽象类型。
8. Inclusion or import（包含 / 导入耦合）：组件通过导入头文件、包等引用外部声明，无直接逻辑依赖。
9. External（外部耦合）：组件与外部系统（如数据库、第三方 API）的耦合。

## 8. Component Level Design（组件级设计步骤）

### 8.1 步骤 I（基础类与接口设计）

1. 识别所有对应**问题域**的设计类；
2. 识别所有对应**基础设施域**的设计类（如日志、数据库连接）；
3. 细化所有非复用的设计类：
    - 3a. 指定类或组件协作时的**消息细节**；
    - 3b. 为每个组件识别**合适的接口**。

### 8.2 步骤 II（属性、行为与部署设计）

1. 3c. 细化属性，定义实现所需的**数据类型与数据结构**；
2. 3d. 详细描述每个操作内的**处理流程**（如算法、分支逻辑）；
3. 描述**持久化数据源**（数据库、文件），识别管理这些数据源的类；
4. 为类或组件开发并细化**行为表示**（如状态图、活动图）；
5. 细化**部署图**，提供更多实现细节（如组件部署到哪些服务器）；
6. 对所有组件级设计表示进行**重构**，并考虑替代方案。

## 9. 组件级设计相关图表

### 9.1 Collaboration Diagram（协作图）

（文档含图示，核心交互流程如下）

  

|参与者|交互步骤|操作|
|---|---|---|
|ProductionJob|1|buildJob(WOnumber)|
|WorkOrder|2|submitJob(WOnumber, JobQueue)|

### 9.2 Refactoring（重构示例）

（文档含图示，重构前后核心组件变化如下）

  

|重构前（PrintJob）|重构后（ProductionJob）|
|---|---|
|方法：computeJob、initiateJob|方法：buildWorkOrder ()、passJobToProduction ()、submitJob、checkPriority ()|
|接口依赖：buildJob、getJobDescription|接口依赖：buildJob、getJobDescription|

### 9.3 Activity Diagram（活动图）

文档含图示，核心用于描述组件内部或组件间的**流程步骤**（如作业提交、成本计算的步骤顺序），支持分支（如 “是否满足打印条件”）、循环（如 “重复检查作业状态”）等逻辑。

### 9.4 Statechart（状态图）

文档含图示，核心用于描述组件或对象的**状态变化**（如 PrintJob 的状态：“待初始化”→“已接收”→“处理中”→“已完成”→“已取消”），包含状态触发条件（如 “接收作业” 触发 “待初始化”→“已接收”）。

## 10. Component Design for WebApps（Web 应用的组件设计）

### 10.1 Web 应用组件的定义

Web 应用组件分为两类：

  

1. 具有明确内聚功能的组件：处理内容、提供计算或数据处理能力（如用户登录验证、订单计算）；
2. 内容与功能结合的组件：为用户提供特定能力的内容包（如视频播放窗口、商品列表模块）。

  

因此，Web 应用的组件级设计通常融合**内容设计**与**功能设计**。

### 10.2 Content Design for WebApps（Web 应用的内容设计）

- 核心：聚焦**内容对象**及其向用户呈现的打包方式。
- 示例（[SafeHomeAssured.com](https://safehomeassured.com/)的视频监控功能）：
    1. 空间布局内容组件：楼层平面图（含传感器、摄像头图标）；
    2. 缩略图内容组件：视频截图集合（每个截图为独立数据对象）；
    3. 流媒体内容组件：特定摄像头的实时视频窗口。
- 特点：每个内容组件可独立命名和操作。

### 10.3 Functional Design for WebApps（Web 应用的功能设计）

#### 10.3.1 Web 应用功能组件的核心能力

1. 本地化处理：动态生成内容与导航（如根据用户角色显示不同菜单）；
2. 业务域计算：提供与业务相关的数据处理（如电商的折扣计算）；
3. 数据库交互：复杂的数据库查询与访问（如多表联查、事务处理）；
4. 外部系统集成：与企业外部系统建立数据接口（如支付网关、物流 API）。

#### 10.3.2 Web 应用的客户端类型

|客户端类型|架构特点|限制|
|---|---|---|
|Thin web-based client（瘦客户端）|仅在设备上实现**接口层**；业务层、数据层通过 Web / 云服务实现|依赖网络；实时性较差|
|Rich client（富客户端）|在设备上实现**接口层、业务层、数据层**|受移动设备资源限制（如内存、算力）|

## 11. Designing Conventional Components（传统组件设计）

传统组件设计的核心要素由以下原则约束：

  

- **处理逻辑**：遵循算法设计与结构化编程原则（如顺序、分支、循环）；
- **数据结构**：由系统数据模型定义（如关系模型、层次模型）；
- **接口**：由组件必须参与的**协作关系**决定（如与其他组件的输入 / 输出参数）。

## 12. Component-Based Development（基于组件的开发，CBD）

### 12.1 复用组件的选择问题

软件团队在考虑复用时，需回答以下问题：

  

1. 是否有**商业现成组件（COTS）** 可实现需求？
2. 是否有**内部开发的可复用组件**可实现需求？
3. 可用组件的接口是否与待构建系统的架构**兼容**？

### 12.2 Impediments to Reuse（复用的障碍）

1. 极少企业有完善的软件复用计划；
2. 多数软件开发者未使用支持复用的工具或组件；
3. 缺乏帮助工程师理解和应用复用的培训；
4. 许多从业者认为 “复用麻烦大于价值”；
5. 企业鼓励的开发方法不支持复用；
6. 企业缺乏对 “生产可复用组件” 的激励机制。

## 13. The CBSE Process（基于组件的软件工程流程）

### 13.1 Domain Engineering（领域工程，复用的基础）

领域工程是识别和创建可复用组件的过程，步骤如下：

  

1. 定义待研究的**领域**（如电商、医疗、金融）；
2. 对从领域中提取的元素进行**分类**；
3. 收集领域内的**代表性应用样本**；
4. 分析每个样本应用的结构与功能；
5. 为领域对象开发**分析模型**（如类图、用例图）。

### 13.2 Identifying Reusable Components（识别可复用组件）

判断组件是否可复用，需评估以下问题：

  

- 组件功能是否在**未来项目中需要**？
- 组件功能在领域内的**通用性**如何？
- 领域内是否存在组件功能的**重复实现**？
- 组件是否依赖**硬件**？硬件在不同项目中是否不变？能否将硬件相关逻辑剥离到其他组件？
- 组件设计是否足够**优化**以支持下一个项目？
- 能否通过**参数化**将不可复用组件改为可复用？
- 组件是否只需**少量修改**即可在多个项目中复用？修改复用是否可行？
- 能否将不可复用组件**分解**为可复用组件？分解的有效性如何？

## 14. Component-Based SE（基于组件的软件工程）

### 14.1 核心要求

1. 需具备**组件库**（存储可复用组件）；
2. 组件需有**一致的结构**；
3. 需遵循行业标准，如：
    - OMG/CORBA（跨平台组件通信）；
    - Microsoft COM（Windows 平台组件）；
    - Sun JavaBeans（Java 平台组件）。

### 14.2 CBSE Activities（CBSE 核心活动）

1. **Component qualification（组件认证）**：验证组件是否满足需求（如功能、性能、安全性）；
2. **Component adaptation（组件适配）**：调整组件以适应系统架构（如接口适配、功能扩展）；
3. **Component composition（组件组合）**：将多个组件集成到系统中，确保协作正常；
4. **Component update（组件更新）**：替换旧版本组件，保证系统兼容性与功能迭代。

## 15. 主流组件标准详解

### 15.1 OMG/CORBA（跨平台组件标准）

#### 15.1.1 核心定义

- 由对象管理组织（OMG）制定的**公共对象请求代理架构**，支持可复用组件（对象）跨位置通信。
- 核心组件：**对象请求代理（ORB）**，提供组件间通信服务（无论组件在系统中的位置）。

#### 15.1.2 关键机制

1. **接口定义语言（IDL）**：为每个组件创建 IDL 接口，确保组件无需修改即可集成；
2. **客户端请求**：客户端通过 IDL 或运行时动态调用 ORB 服务器的服务；
3. **接口仓库（Interface Repository）**：存储服务请求与响应格式的所有必要信息。

#### 15.1.3 ORB Architecture（ORB 架构）

（文档含图示，核心组件如下）

  

- 客户端侧：Client、Dynamic Invocation（动态调用）、IDL Stubs（IDL 存根）；
- 服务端侧：Server、ORB Object Adapter（ORB 对象适配器）、IDL Stubs（IDL 存根）；
- 共享组件：Interface Repository（接口仓库）、ORB 核心。

### 15.2 Microsoft COM（Windows 平台组件标准）

#### 15.2.1 核心定义

- **组件对象模型（COM）**：定义 Windows 系统中使用多厂商组件的规范，支持单个应用集成不同来源的组件。

#### 15.2.2 核心元素

1. **COM 接口**：以 COM 对象形式实现，定义组件的方法与属性；
2. **通信与注册机制**：一套用于组件注册、组件间消息传递的机制。

### 15.3 Sun JavaBeans（Java 平台组件标准）

#### 15.3.1 核心定义

- 基于 Java 语言的**可移植、跨平台 CBSE 基础设施**，支持组件在不同 Java 环境中复用。

#### 15.3.2 核心工具：Bean Development Kit（BDK）

BDK 提供以下能力：

  

1. 分析现有 Bean（组件）的工作原理；
2. 自定义 Bean 的行为与外观；
3. 建立 Bean 间的协作与通信机制；
4. 开发特定应用的自定义 Bean；
5. 测试与评估 Bean 的行为。

## 16. 组件分类与索引

### 16.1 Classification（组件分类方法）

1. **Enumerated classification（枚举分类）**：定义层级结构，将组件分为类与不同级别的子类（如 “数据组件”→“数据库组件”→“MySQL 组件”）；
2. **Faceted classification（面分类）**：分析领域，识别一组基本描述特征（如 “功能类型”“平台”“复杂度”），每个组件对应多个特征值；
3. **Attribute-value classification（属性 - 值分类）**：为领域内所有组件定义一组属性，每个组件用 “属性 - 值” 对描述（如 “功能 = 登录验证，平台 = Web，语言 = Java”）。

### 16.2 Indexing（组件索引方法）

（文档含图示，核心分类如下）

  

|索引维度|具体类型|说明|
|---|---|---|
|Vocabularies（词汇表）|Controlled（受控词汇）|预定义术语表（如主题词表），术语从文本中提取|
||Uncontrolled（非受控词汇）|自由术语，术语不从文本中提取|
|Classed（分类索引）|Enumerated（枚举）|基于枚举分类的索引，含描述符（如 “数据组件 - 数据库”）|
||Faceted（面索引）|基于面分类的索引，含主题标题|
|Keyword（关键词索引）|-|无语法约束，基于关键词匹配（如 “登录”“支付”）|

## 17. The Reuse Environment（复用环境）

复用环境需包含以下核心组件：

  

1. **组件数据库**：存储软件组件及检索所需的分类信息；
2. **库管理系统**：提供数据库访问能力（如组件查询、新增、删除）；
3. **组件检索系统**：如对象请求代理（ORB），支持客户端从库服务器检索组件与服务；
4. **CBSE 工具**：支持将复用组件集成到新设计或实现中（如接口适配工具、组件测试工具）。