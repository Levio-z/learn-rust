# 第 30 章 产品度量（Product Metrics）总结

本章围绕 “软件产品度量” 展开，从基础概念（度量、指标、指示器）、核心原则与流程，到针对需求、设计、代码、测试、维护等全生命周期阶段的专项度量方法，系统构建了 “以数据驱动软件质量评估与改进” 的知识体系，具体内容如下：

## 一、产品度量的基础概念与核心原则

### 1. 三大核心术语辨析

产品度量的基础是明确 “测量、度量、指示器” 的区别与联系，三者共同构成量化分析的基础：

  

|术语|定义|示例|
|---|---|---|
|**测量（Measure）**|对产品或过程属性的 “定量描述”，是原始数据的收集结果|某模块的代码行数（LOC=500）、需求文档的页数（20 页）|
|**度量（Metric）**|基于测量数据计算的 “定量指标”，反映属性的程度或水平（IEEE 定义）|代码行密度（LOC / 模块数）、需求变更率（变更需求数 / 总需求数）|
|**指示器（Indicator）**|单个或多个度量的组合，用于洞察过程、项目或产品的状态|若 “缺陷密度（缺陷数 / LOC）>0.01” 且 “测试覆盖率 < 80%”，则 “质量风险” 指示器触发预警|

### 2. 测量的四大核心原则

确保度量结果科学、有效，需遵循以下原则：

  

1. **先定目标再收集数据**：明确 “为何测量”（如评估设计复杂度、预测测试工作量），避免无目标的数据收集；
2. **度量定义无歧义**：每个技术度量需明确计算逻辑（如 “耦合度” 需定义 “耦合的判断标准”）；
3. **基于领域理论推导**：度量需贴合技术场景的核心概念（如设计度量需基于 “耦合、内聚” 等设计原则）；
4. **适配具体产品与过程**：根据软件类型（如 Web / 移动应用、OO 软件）调整度量方法（如 OO 软件需额外度量 “继承深度”）。

### 3. 测量的五大流程步骤

测量是闭环过程，需按 “formulation→collection→analysis→interpretation→feedback” 逐步推进：

  

1. **制定（Formulation）**：推导适配当前软件的度量指标（如针对需求模型，确定 “功能点”“需求类型分布” 等度量）；
2. **收集（Collection）**：建立数据收集机制（如通过工具自动统计代码行数、人工统计需求变更次数）；
3. **分析（Analysis）**：计算度量值并应用数学工具（如统计分析、趋势分析）；
4. **解读（Interpretation）**：评估度量结果，提炼洞察（如 “缺陷密度上升” 可能意味着代码质量下降）；
5. **反馈（Feedback）**：将解读结果转化为改进建议，传递给软件团队（如建议优化高复杂度模块的设计）。

## 二、目标导向的软件测量（Goal-Oriented Measurement）

目标导向是确保度量 “有用” 的关键，核心是 “目标 - 问题 - 度量（Goal/Question/Metric, GQM）” 范式，需按标准化流程执行：

### 1. GQM 范式三步骤

1. **明确测量目标**：聚焦需评估的过程活动或产品属性（如 “评估订单模块的设计复杂度”）；
2. **定义核心问题**：将目标拆解为可回答的问题（如 “订单模块的耦合度是否过高？”“模块内聚是否符合标准？”）；
3. **设计度量指标**：确定能回答问题的具体度量（如用 “耦合度度量”“内聚度度量” 回答上述问题）。

### 2. 目标定义模板（标准化表述）

plaintext

```plaintext
分析{需测量的活动/属性名称}
为了{分析的总体目标}
针对{活动/属性的具体方面}
从{利益相关者视角}（如开发者、测试者、管理者）
在{测量的环境背景}（如敏捷项目、医疗软件）下。
```

  

示例：“分析订单模块的设计，为了评估其可维护性，针对耦合与内聚特性，从开发团队视角，在电商系统迭代项目背景下。”

## 三、优质度量的六大属性

一个 “好的度量” 需同时满足以下条件，避免无效或误导性数据：

  

1. **简单可计算**：易于理解计算逻辑，无需过度投入时间（如 “代码行数” 比 “基于复杂算法的复杂度” 更易计算）；
2. **经验与直觉说服性**：结果符合工程师的直觉认知（如 “模块代码行数越多，复杂度越高” 符合直觉）；
3. **一致客观**：无论谁计算，结果均无歧义（如 “需求数” 按 “每个独立功能点计 1 个” 的标准统计，结果一致）；
4. **单位与维度一致**：计算过程中单位组合合理，无逻辑矛盾（如 “缺陷数 / LOC” 是合理的，“缺陷数 + 代码行数” 是无意义的）；
5. **独立于编程语言**：基于分析 / 设计模型或程序结构，不依赖具体语言（如 “类的继承深度” 适用于所有 OO 语言）；
6. **质量反馈有效**：能为工程师提供改进方向（如 “低内聚模块” 提示需重构以提升模块功能集中度）。

## 四、全生命周期的产品度量方法

软件产品的度量需覆盖 “需求 - 设计 - 代码 - 测试 - 维护” 全阶段，各阶段的度量目标与方法差异显著：

### 1. 需求模型的度量（Metrics for the Requirements Model）

聚焦 “需求的规模与质量”，核心是功能导向与规格导向两类度量：

#### （1）功能导向度量：功能点（Function Point, FP）

功能点是衡量需求 “功能规模” 的经典度量，基于信息域值计算，步骤如下：

  

- **Step 1：定义 5 个信息域值**（可直接统计）：
    - 外部输入（EIs）：系统接收的外部数据（如用户输入的订单信息）；
    - 外部输出（EOs）：系统输出的外部数据（如订单确认邮件）；
    - 外部查询（EQs）：用户发起的查询请求（如 “查询订单状态”）；
    - 内部逻辑文件（ILFs）：系统内部存储的业务数据（如订单数据库表）；
    - 外部接口文件（EIFs）：系统与外部系统共享的数据（如支付系统的接口数据）；
- **Step 2：确定权重因子**：按 “简单 / 平均 / 复杂” 为每个信息域值分配权重（如 EIs 的权重：简单 = 3，平均 = 4，复杂 = 6）；
- **Step 3：计算功能点**：功能点 =Σ（信息域值数量 × 对应权重）。

#### （2）规格导向度量：需求类型分布

统计不同类型需求的数量及占比，评估需求完整性与合理性：

  

- 需求类型：功能需求、非功能需求（性能、安全、易用性）、约束需求；
- 示例：若 “性能需求仅占 5%”，可能意味着需求对非功能属性关注不足。

### 2. 设计模型的度量（Metrics for the Design Model）

设计度量覆盖 “架构设计、OO 设计、组件设计、接口设计”，适配不同设计阶段的特点：

#### （1）架构设计度量：聚焦整体复杂度

- **结构复杂度**：基于 “扇出（fan-out，模块调用的子模块数）” 计算，扇出越大，结构复杂度越高；
- **数据复杂度**：基于 “输入 / 输出变量数” 与 “扇出” 计算，反映数据流转的复杂程度；
- **系统复杂度**：综合结构复杂度与数据复杂度，评估整体架构质量；
- **HK 度量**：以 “扇入（fan-in，调用当前模块的上级模块数）” 与 “扇出” 为核心，量化架构耦合与依赖；
- **形态学度量**：基于 “模块数” 与 “模块间接口数”，评估架构的模块化程度。

#### （2）OO 设计度量：适配封装、继承、多态特性

OO 设计需度量 9 大核心特性（Whitmire 分类），并衍生出多个经典度量集：

  

|OO 设计特性|核心度量目标|经典度量示例（按提出者分类）|
|---|---|---|
|**规模（Size）**|衡量类 / 操作的体量|- Chidamber-Kemerer（C&K）：加权方法数（WMC，类中方法的复杂度加权和）  <br>- Lorenz-Kidd：类大小（属性 + 方法数）、平均操作大小|
|**复杂度（Complexity）**|类间关系的复杂程度|- C&K：继承树深度（DIT，类在继承树中的层级）、子类数（NOC，某类的直接子类数）|
|**耦合（Coupling）**|类间依赖程度|- C&K：对象类间耦合（CBO，类依赖的其他类数量）  <br>- MOOD：耦合因子（CF，衡量类间交互频率）|
|**内聚（Cohesion）**|类内操作的功能集中度|- C&K：方法内聚缺失度（LCOM，类中方法共享属性的程度，值越高内聚越低）|
|**充分性（Sufficiency）**|类的抽象是否覆盖所需特性|- 自定义度量：类的属性 / 方法是否满足业务需求（如 “订单类” 是否包含 “订单状态” 属性）|
|**完整性（Completeness）**|类的可复用潜力|- 自定义度量：类是否包含通用接口（如序列化、克隆方法）|
|**原生性（Primitiveness）**|操作是否原子化|- Lorenz-Kidd：操作复杂度（如判断操作是否可拆分为更小原子操作）|
|**相似性（Similarity）**|类间结构 / 功能的相似程度|- 自定义度量：类的属性重叠率、方法名相似度|
|**易变性（Volatility）**|类被修改的可能性|- 自定义度量：类的历史修改次数、依赖该类的模块数（依赖越多越易变）|

  

- **特殊说明**：Berard 指出 OO 度量需适配 5 大特性 —— 本地化（信息集中）、封装（数据与操作打包）、信息隐藏（接口保护内部细节）、继承（职责传递）、抽象（聚焦核心细节），避免用传统度量（如代码行数）完全替代 OO 专用度量。

#### （3）组件级设计度量：聚焦模块细节

- **内聚度量**：基于 “数据对象的定义位置”，评估模块功能集中度（如 “功能内聚” 需模块所有操作围绕同一数据对象）；
- **耦合度量**：基于 “输入 / 输出参数、全局变量、调用模块数”，评估模块依赖程度（如 “数据耦合” 优于 “控制耦合”）；
- **复杂度度量**：以 “环路复杂度（Cyclomatic Complexity）” 为代表，量化模块的逻辑分支复杂程度（值越高，测试与维护难度越大）。

#### （4）接口设计度量：聚焦用户交互

- **布局适宜性**：基于 “布局元素数量、地理位置、切换成本”，评估界面布局的合理性（如 “常用按钮是否在显眼位置”“操作路径是否简短”）。

#### （5）Web 与移动应用设计度量：适配专项场景

需结合 Web / 移动应用的特性，通过 “问题导向” 设计度量，核心问题包括：

  

- 界面是否提升可用性？（如导航是否直观）；
- 美学设计是否适配领域且用户满意？（如医疗 App 是否简洁专业）；
- 内容是否 “以最小 effort 传递最多信息”？（如是否避免冗余文本）；
- 架构是否适配用户目标与导航流程？（如电商 App 的 “商品→购物车→结算” 路径是否高效）；
- 组件设计是否降低复杂度、提升正确性与性能？（如移动端组件是否适配小屏幕操作）。

### 3. 代码度量（Code Metrics）

代码度量聚焦 “代码质量与复杂度”，以经典的 “Halstead 软件科学” 为代表：

  

- **核心思想**：基于 “运算符（如 +、if、for）” 与 “操作数（如变量、常量）” 的数量与出现频次，推导多个度量：
    - 程序长度（N）= 运算符总数 + 操作数总数；
    - 程序体积（V）= N × log₂（运算符种类数 + 操作数种类数）；
    - 难度（D）=（运算符种类数 / 2）×（操作数总数 / 操作数种类数）；
- **争议说明**：Halstead 的 “定律”（如 “程序工作量与体积成正比”）存在争议，理论有缺陷，但在部分编程语言中已通过实验验证（如 [FEL89]），可作为参考而非绝对标准。

### 4. 测试度量（Metrics for Testing）

测试度量聚焦 “测试工作量与可测试性”，核心包括：

  

- **测试工作量估算**：基于 Halstead 度量（如程序体积）推导测试用例数与测试时间；
- **OO 系统可测试性度量**（Binder 提出）：
    - 方法内聚缺失度（LCOM）：LCOM 高→测试难度大；
    - 公共 / 保护成员占比（PAP）：占比过高→测试需覆盖更多外部依赖；
    - 数据成员公共访问率（PAD）：访问越自由→测试需考虑更多数据修改场景；
    - 根类数（NOR）、扇入（FIN）、子类数（NOC）、继承树深度（DIT）：这些指标影响测试用例的覆盖范围。

### 5. 维护度量（Metrics for Maintenance）

维护度量聚焦 “软件产品的稳定性”，以 IEEE 标准的 “软件成熟度指数（Software Maturity Index, SMI）” 为核心：

  

- **计算所需数据**（基于版本迭代）：
    - MT：当前版本的模块总数；
    - Fc：当前版本中被修改的模块数；
    - Fa：当前版本新增的模块数；
    - Fd：上一版本被删除的模块数；
- **SMI 计算公式**：  
    SMI = [MT - (Fa + Fc + Fd)] / MT
- **解读**：SMI 越接近 1.0，产品越稳定（如 SMI=0.9→仅 10% 的模块有变更，稳定性高）；SMI 低（如 < 0.5）→产品仍在频繁迭代，稳定性差。

## 核心总结

产品度量是 “用数据说话” 的软件质量保障手段，其核心价值在于：

  

1. **量化评估**：将 “代码质量”“需求完整性” 等抽象属性转化为可衡量的指标；
2. **早期预警**：通过趋势分析（如缺陷密度上升）提前发现质量风险；
3. **持续改进**：基于度量反馈优化过程与产品（如重构高复杂度模块）。

  

实践中需避免 “为度量而度量”，始终以 “目标导向” 为核心，选择适配场景的度量方法，同时结合工程直觉与经验，才能让度量真正服务于软件质量提升。