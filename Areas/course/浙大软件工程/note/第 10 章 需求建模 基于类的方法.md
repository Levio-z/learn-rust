# 第 10 章 需求建模：基于类的方法（Requirements Modeling: Class-Based Methods）总结

本章聚焦 “基于类的需求建模”，围绕面向对象分析（OOA）核心思想，从概念定义、建模流程、工具方法到验证优化，系统梳理了如何通过 “类” 刻画软件需求，同时对比结构化分析方法，明确面向对象建模的优势与实践路径，具体内容如下：

## 一、需求建模的两大核心策略

需求建模主要分为两类思路，核心差异在于对 “数据与过程” 的关系处理：

  

| 建模策略                                 | 核心思想                                      | 关键要素                                            | 适用场景                                |
| ------------------------------------ | ----------------------------------------- | ----------------------------------------------- | ----------------------------------- |
| **结构化分析（Structured Analysis）**       | 将 “数据” 与 “处理数据的过程” 视为独立实体，关注数据流转          | - 数据对象：定义属性与关系  <br>- 过程模型：描述数据在系统中的转换流程（如数据流图） | 需求中 “数据处理逻辑” 清晰、过程与数据耦合度低的场景        |
| **面向对象分析（Object-Oriented Analysis）** | 以 “类” 为核心，将数据（属性）与操作数据的过程（方法）封装为整体，关注类间协作 | - 类与对象：封装属性与方法  <br>- 类层次：继承关系  <br>- 类间协作：交互关系 | 需求中 “实体及交互” 复杂、需复用或迭代优化的场景（如复杂业务系统） |

## 二、面向对象的核心概念

面向对象分析的基础是对核心概念的理解，这些概念构成类建模的 “积木”：

| 概念                     | 定义                                           | 关键说明                                                                                            |
| ---------------------- | -------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| **类（Class）**           | 对一组相似对象的 “模板” 或 “通用描述”，包含属性与方法               | - 类的来源：外部实体、事物、事件、角色、组织单元、地点、结构（如 “椅子”“用户”“订单”）  <br>- 元类（超类）：建立类层次结构的基础（如 “家具” 是 “椅子”“桌子” 的超类） |
| **对象（Object）**         | 类的具体实例，具有独特的属性值                              | 一个类可生成多个对象（如 “椅子类” 的实例：客厅椅、办公椅）                                                                 |
| **属性（Attribute）**      | 类所描述的 “数据特征”，是类的静态信息                         | 如 “用户类” 的属性：用户名、密码、手机号                                                                          |
| **方法（Method）**         | 封装在类中的 “可执行过程”，用于操作类的属性，通过消息传递调用             | 也称为 “操作” 或 “服务”，如 “用户类” 的方法：登录（verifyPassword ()）、修改信息（modifyInfo ()）                           |
| **封装（Encapsulation）**  | 将类的 “属性” 与 “方法” 打包为整体，隐藏内部实现细节，仅通过方法对外交互     | - 核心价值：实现 “信息隐藏”，降低耦合度，提升可维护性  <br>- 对外仅暴露 “接口”（方法），内部数据仅由自身方法操作                                |
| **实例化（Instantiation）** | 从类创建对象的过程                                    | 如通过 “用户类” 创建对象 “用户 A”，为其属性赋值                                                                    |
| **继承（Inheritance）**    | 子类（Subclass）从超类（Superclass）继承属性与方法，同时可扩展自身特性 | - 形成类层次结构（如 “家具”→“椅子”→“办公椅”）  <br>- 减少代码冗余，提升复用性                                                |

## 三、基于类的建模流程与核心任务

面向对象分析的核心是构建 “类模型”，需完成四大迭代任务，确保类的定义与协作符合需求：

### 1. 任务 1：识别分析类

通过 “语法解析” 从问题描述中提取潜在类，筛选标准包含 6 个维度：

  

- 需提供**必要服务**（如 “订单类” 需提供 “计算金额” 服务）；
- 包含**多个属性**（仅 1 个属性的实体更适合作为其他类的属性，而非独立类）；
- 与其他类有**共同属性**（如 “学生”“教师” 共同属性为 “姓名”“ID”，可抽象为 “人员类”）；
- 与其他类有**共同操作**（如 “学生”“教师” 均有 “登录” 操作）；
- 对应**核心需求**（类需支撑业务核心目标，如 “支付类” 支撑 “交易” 需求）；
- 需**存储信息**（类的属性需长期保留，而非临时数据）。

  

同时，明确类的三大类型，确保职责边界清晰：

  

|类类型|核心职责|示例|
|---|---|---|
|**实体类（Entity Class）**|直接从问题描述中提取，对应业务核心实体，存储业务数据|“订单类”“用户类”“商品类”|
|**边界类（Boundary Class）**|构建用户与系统的交互接口，处理输入输出|“登录界面类”“报表显示类”“按钮控件类”|
|**控制类（Controller Class）**|管理 “工作单元”，协调其他类完成复杂流程|“订单处理类”（协调 “用户类”“商品类”“支付类” 完成下单）、“数据验证类”（验证输入合法性）|

### 2. 任务 2：定义类的属性与方法

- **属性**：刻画类的静态特征，需与类的职责匹配（如 “安防系统类” 的属性：systemID、telephoneNumber、masterPassword、systemStatus）；
- **方法**：实现类的动态行为，操作自身属性或与其他类协作（如 “安防系统类” 的方法：program ()（编程配置）、display ()（显示状态）、call ()（触发报警电话））。

### 3. 任务 3：建立类间关系

类间关系是需求建模的核心，需明确 “关联”“依赖”“聚合” 等关系，刻画类的协作逻辑：

#### （1）关联关系（Association）

- 定义：两个类间的静态联系，需通过 “多重度（Multiplicity）” 明确数量对应关系（即数据建模中的 “基数”）；
- 多重度表示：常用 “0.._”（0 到多个）、“1”（恰好 1 个）、“1.._”（1 到多个）等，如 “墙（Wall）” 与 “墙单元（WallSegment）” 的关联：1 个墙由 0.._个墙单元构成（Wall 1 → 0.._ WallSegment）。

#### （2）依赖关系（Dependency）

- 定义：一个类（客户端）需依赖另一个类（服务端）的服务才能完成职责，是 “临时、动态” 的关系；
- 表示：UML 中用带箭头的虚线标注，可补充依赖类型（如 “<<access>>” 表示访问依赖）；
- 示例：“摄像头类（Camera）” 需依赖 “显示窗口类（DisplayWindow）” 显示画面，且需密码验证（标注 {password}）。

#### （3）聚合 / 组合关系（Aggregation/Composition）

- 定义：“整体 - 部分” 关系，属于关联的特殊形式；
- 示例：“玩家类（Player）” 由 “玩家腿（PlayerLegs）”“玩家身体（PlayerBody）”“玩家手臂（PlayerArm）” 组成（组合关系，部分不能脱离整体存在）。

### 4. 任务 4：分配类的职责

遵循 5 大原则，确保职责分配合理、低耦合高内聚：

  

1. 系统智能**分散到多个类**，避免单个类承担过多职责（如 “订单处理” 不集中在 “用户类”，而由 “订单控制类” 协调）；
2. 每个职责**表述通用化**，提升类的复用性（如 “验证” 职责表述为 “验证输入合法性”，而非 “验证手机号”）；
3. “信息” 与 “操作信息的行为”**归属于同一类**（如 “用户姓名” 属性与 “修改姓名” 方法均在 “用户类” 中）；
4. 同一事物的信息**集中在单个类**，避免分散（如 “用户地址” 不拆分到 “订单类”“支付类”，仅在 “用户类” 中定义）；
5. 相关类间**合理共享职责**（如 “订单类” 与 “支付类” 共享 “验证金额” 职责）。

## 四、类建模的核心工具与验证方法

### 1. 核心工具：类图（Class Diagram）

类图是类模型的可视化表达，UML 规范中包含三大核心部分，直观展示类的结构与关系：

  

- **类名**：居中，明确类的标识（如 “安防系统（SecuritySystem）”）；
- **属性**：位于类名下方，列出类的静态特征（如 systemID、telephoneNumber）；
- **方法**：位于属性下方，列出类的动态行为（如 program ()、display ()）；
- 扩展元素：通过线条标注类间关联、依赖、继承关系，补充多重度等信息（如 “Wall” 与 “WallSegment” 的 1→0..* 关联）。

### 2. 协作建模：CRC 模型（Class-Responsibility-Collaborator Model）

CRC 模型通过 “索引卡” 形式，记录类的 “职责” 与 “协作对象”，明确类间交互逻辑：

  

- **组成要素**：每张卡片包含 3 部分 —— 类名、职责（类的属性与方法）、协作对象（完成职责需依赖的其他类）；
- **示例**：“楼层平面图类（FloorPlan）” 的 CRC 卡：
    - 职责：定义平面图名称 / 类型、管理平面图位置、缩放平面图用于显示、整合墙 / 门 / 窗、显示摄像头位置；
    - 协作对象：墙（Wall）、摄像头（Camera）；
- **核心价值**：简化类间协作关系，为后续评审提供直观依据。

### 3. 模型验证：CRC 模型评审

通过 “场景走查” 验证 CRC 模型是否满足需求，步骤如下：

  

1. 评审参与者每人持有部分 CRC 卡片，**协作类的卡片需分发给不同人**（避免单人掌控依赖关系）；
2. 整理用例场景，评审 leader 逐句朗读用例；
3. 当读到用例中的 “对象” 时，将 “令牌” 传递给持有对应类卡片的人，此人需描述类的职责；
4. 团队判断该职责是否满足用例需求，若不满足则修改：
    - 新增类及 CRC 卡；
    - 调整现有类的职责或协作对象；
5. 重复走查所有用例，确保模型覆盖全部需求。

### 4. 模型组织：分析包（Analysis Packages）

将分析模型的元素（用例、类）按 “业务领域” 或 “功能模块” 分组，形成分析包，便于管理与复用：

  

- **可见性控制**：通过符号标注元素访问权限：
    - “+”：公共可见（可被其他包访问）；
    - “-”：私有（仅包内可见）；
    - “#”：保护（仅包内及子类可见）；
- **核心作用**：降低模型复杂度，明确模块边界（如 “安防系统” 的分析包可分为 “用户管理包”“设备控制包”“报警处理包”）。

## 五、关键补充：类间关系的细化表达

### 1. 多重度（Multiplicity）

明确类间关联的数量对应关系，常见表述及含义：

  

|多重度符号|含义|示例|
|---|---|---|
|0..1|0 或 1 个|“用户” 与 “会员卡”：1 个用户可拥有 0 或 1 张会员卡|
|1|恰好 1 个|“学生” 与 “学号”：1 个学生恰好有 1 个学号|
|0..*|0 到多个|“墙” 与 “窗”：1 个墙可包含 0 到多个窗|
|1..*|1 到多个|“订单” 与 “订单项”：1 个订单至少包含 1 个订单项|

### 2. 依赖关系的类型

除 “访问依赖（<<access>>）” 外，常见依赖还包括：

  

- <<use>>：客户端使用服务端的功能（如 “报表类” 使用 “数据统计类”）；
- <<extend>>：客户端扩展服务端的功能（如 “高级搜索类” 扩展 “基础搜索类”）；
- <<derive>>：客户端从服务端推导数据（如 “订单金额类” 从 “订单项类” 推导总金额）。