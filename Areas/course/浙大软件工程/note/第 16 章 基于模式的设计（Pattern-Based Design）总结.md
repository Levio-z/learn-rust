# 第 16 章 基于模式的设计（Pattern-Based Design）总结

本章围绕 “设计模式” 的核心理论与实践展开，从模式的定义、分类、描述规范，到基于模式的设计流程、常见场景（架构、组件、UI、Web / 移动应用）及典型问题，系统构建了 “以模式驱动设计” 的知识体系，具体内容如下：

## 一、设计模式的基础概念（16.1）

设计模式是 “问题与解决方案的结构化描述”，核心价值是**复用软件工程领域的设计知识**，避免重复造轮子。

### 1. 设计模式的核心三要素

模式本质是 “上下文 - 问题 - 解决方案” 的三元规则，三者相互关联、缺一不可：

  

|要素|核心定义|作用|
|---|---|---|
|**上下文（Context）**|问题所处的环境与边界条件（如 “电商系统的订单处理模块”“移动端的登录界面”）|帮助设计者判断 “何种解决方案适用于当前场景”|
|**作用力系统（Forces）**|影响问题解读与解决方案落地的约束与需求（如性能要求、用户习惯、技术限制）|明确解决方案需平衡的因素（如 “高并发” 与 “低延迟” 的权衡）|
|**解决方案（Solution）**|针对特定上下文与作用力的、经验证的设计方案|提供可直接复用的设计思路，而非具体代码|

### 2. 有效模式的 5 个判定标准（Coplien, 2005）

并非所有 “设计思路” 都是有效模式，需满足以下条件：

  

1. **解决具体问题**：不只是抽象原则或策略，需针对实际设计痛点（如 “如何统一对象创建逻辑” 而非 “面向对象设计思想”）；
2. **经实践验证**：基于真实项目经验，而非理论推测（如工厂模式已在大量系统中验证有效性）；
3. **解决方案非显而易见**：需通过间接、巧妙的设计解决复杂问题（如单例模式通过私有构造函数避免多实例，而非简单定义全局变量）；
4. **描述深层关系**：不仅描述模块本身，更需刻画系统结构与组件间的协作机制（如观察者模式描述 “主题 - 观察者” 的依赖与通知关系）；
5. **含有人为因素**：需兼顾易用性与美观性，最小化人工干预（如 UI 模式需符合用户直觉，减少学习成本）。

### 3. 设计模式的两大分类体系

#### （1）按抽象层级与应用场景分类（通用分类）

|模式类型|核心解决的问题|示例|
|---|---|---|
|**架构模式（Architectural）**|系统级、宽范围的设计问题，关注整体结构|分层架构（用户层 - 服务层 - 数据层）、微服务架构|
|**数据模式（Data）**|数据导向的重复问题，关注数据建模|关系型数据库的 “一对一 / 一对多” 表设计模式|
|**组件模式（Component/Design）**|子系统或组件级问题，关注组件协作与实现|工厂模式（组件创建）、适配器模式（组件接口兼容）|
|**接口设计模式（Interface Design）**|用户界面问题，关注端用户交互体验|表单的 “分步提交” 模式、列表的 “分页加载” 模式|
|**Web 应用模式（WebApp）**|Web 应用特有的问题，融合其他模式类型|页面的 “面包屑导航” 模式、接口的 “RESTful” 设计模式|

#### （2）按对象交互维度分类（Gang of Four, 1995）

GOF 将模式分为三类，聚焦 “对象创建、结构组织、行为协作” 三大核心场景：

  

|模式类型|核心目标|典型模式示例|
|---|---|---|
|**创建型模式（Creational）**|控制对象的创建、组合与表示，解耦 “创建逻辑” 与 “使用逻辑”|- 抽象工厂模式：集中管理工厂类的实例化，适配多产品族  <br>- 工厂方法模式：定义创建对象的接口，由子类决定具体实现|
|**结构型模式（Structural）**|优化类与对象的组织方式，构建灵活的系统结构|- 适配器模式：将一个类的接口转换为客户端期望的接口，解决兼容性问题  <br>- 聚合模式（组合模式变体）：将对象组合为树形结构，统一处理单个对象与组合对象|
|**行为型模式（Behavioral）**|明确对象间的责任分配与通信方式|- 责任链模式：将请求传递给多个处理对象，直到有对象处理它（如日志分级处理）  <br>- 命令模式：将请求封装为对象，实现 “请求的存储、传递与撤销”（如编辑器的撤销功能）|

### 4. 模式与框架的区别

框架（Framework）是 “实现特定领域的骨架结构”，与模式的核心差异在于：

  

- **框架**：是 “可复用的迷你架构”，包含具体的代码骨架与 “插件点”（hooks/slots），需开发者填充问题特定的类或功能（如 Spring 框架的 IOC 容器、Android 的 Activity 框架）；
- **模式**：是 “设计思路的描述”，无具体代码，仅提供解决方案的逻辑（如工厂模式可在任何框架中应用）；
- 关系：框架通常包含多个模式的实现（如 Spring 的 Bean 创建使用了工厂模式，MVC 框架使用了观察者模式）。

### 5. 设计模式的标准描述规范

为确保模式可理解、可复用，需按统一模板描述，核心包含 12 个要素：

  

1. 模式名称（Pattern Name）：简洁表达模式本质（如 “单例模式”“适配器模式”）；
2. 问题（Problem）：明确模式解决的具体痛点；
3. 动机（Motivation）：通过场景示例说明问题的必要性；
4. 上下文（Context）：模式适用的环境条件；
5. 作用力（Forces）：模式需平衡的约束与需求；
6. 解决方案（Solution）：模式的设计思路与结构；
7. 意图（Intent）：模式的核心目标（如 “保证一个类仅有一个实例”）；
8. 协作（Collaborations）：模式中各角色（类 / 组件）的交互方式；
9. 后果（Consequences）：应用模式后的效果与 trade-off（如单例模式节省资源但不利于测试）；
10. 实现（Implementation）：模式落地的技术细节与注意事项；
11. 已知应用（Known Uses）：模式在真实系统中的应用案例（如单例模式用于数据库连接池）；
12. 相关模式（Related Patterns）：与当前模式关联的其他模式（如工厂模式与抽象工厂模式的区别与协作）。

## 二、基于模式的软件设计流程（16.2）

基于模式的设计需遵循 “从宏观到微观、从需求到落地” 的结构化流程，确保模式与需求精准匹配。

### 1. 模式驱动设计的核心流程（Shalloway and Trott, 2005）

共 6 步，形成 “理解 - 提取 - 应用 - 细化” 的闭环：

  

1. **理解全局上下文**：通过需求模型明确软件所处的业务领域与核心目标（如 “电商系统需支持高并发订单处理”）；
2. **提取宏观模式**：从全局视角识别适用的高层模式（如架构模式 “分层架构”）；
3. **以宏观模式搭建骨架**：用高层模式定义设计的基础框架，为后续细化提供约束（如 “用户层 - 订单服务层 - 数据层” 的分层结构）；
4. **向内细化：提取低层级模式**：基于宏观框架，在子系统 / 组件层寻找适用模式（如订单服务层用 “工厂模式” 创建订单对象）；
5. **迭代完善**：重复步骤 1-4，直到覆盖所有设计模块（如从 “订单处理” 到 “支付集成” 再到 “物流通知”）；
6. **适配问题场景**：针对具体业务需求调整模式细节（如将通用 “工厂模式” 适配为 “订单类型专属工厂”）。

### 2. 关键设计任务与优先级

为避免模式滥用，需按以下步骤有序开展设计：

  

1. 分析需求模型，建立 “问题层级”（从核心问题到次要问题）；
2. 检查目标领域是否有成熟的 “模式语言”（如电商领域的订单模式、支付模式）；
3. 从最宽泛的问题入手，优先应用架构模式（如 “微服务” 解决系统拆分问题）；
4. 基于架构模式的协作关系，在组件 / 子系统层应用组件模式（如 “服务注册发现” 解决微服务通信问题）；
5. 针对 UI 需求，从 UI 模式库中匹配适用模式（如 “表单分步提交” 解决长表单用户体验问题）；
6. 验证模式匹配度：对比问题与模式的上下文、作用力，避免 “强行套用”；
7. 按设计质量标准（如低耦合、高内聚）细化模式实现。

### 3. 模式组织工具：模式组织表

为管理多层级、多场景的模式，可通过 “二维表” 分类记录，横向按 “问题领域” 划分，纵向按 “设计层级” 划分，示例如下：

  

|设计层级 \ 问题领域|数据 / 内容|架构|组件级|用户界面|
|---|---|---|---|---|
|数据库应用|问题：如何统一数据访问逻辑  <br>模式：数据访问对象（DAO）|问题：如何拆分数据库负载  <br>模式：读写分离|问题：如何处理数据库事务  <br>模式：事务脚本|-|
|基础设施|问题：如何同步分布式数据  <br>模式：数据传输对象（DTO）|问题：如何实现跨服务通信  <br>模式：服务网格（Service Mesh）|问题：如何缓存高频数据  <br>模式：缓存代理|-|
|Web 应用|问题：如何展示列表数据  <br>模式：分页（Pagination）|问题：如何组织页面结构  <br>模式：MVC|问题：如何处理用户输入验证  <br>模式：表单验证器|问题：如何优化导航体验  <br>模式：面包屑导航|

### 4. 常见设计错误与规避

基于模式设计时易出现 4 类问题，需重点规避：

  

1. **理解不深导致模式选错**：未充分分析问题的上下文与作用力，仅凭 “表面相似” 选择模式（如用 “单例模式” 处理多线程共享资源，却忽略线程安全问题）；
2. **强行套用错误模式**：发现模式不匹配后，仍修改问题适配模式，而非更换模式（如为用 “观察者模式”，强行将无依赖关系的组件设计为 “主题 - 观察者”）；
3. **忽略模式未覆盖的作用力**：未考虑问题中模式未涉及的约束（如用 “工厂模式” 创建对象，却未考虑对象创建的性能瓶颈）；
4. **模式应用过于僵化**：未根据业务场景调整模式细节（如直接复用 “PC 端表单模式”，未适配移动端的小屏幕交互）。

## 三、不同层级的模式应用场景（16.3-16.7）

设计模式需结合具体应用场景，本章重点覆盖 “架构、组件、UI、Web 应用、移动应用” 五大核心场景，提供针对性的模式示例与思路。

### 1. 架构模式（16.3）

架构模式解决**系统级设计问题**，关注 “并发、持久化、分布式” 等宏观需求，核心是为系统搭建 “骨架”。

  

- **核心作用**：定义系统的整体结构与组件间的协作规则，确保系统扩展性与稳定性；
- **示例：房屋与厨房模式（类比）**：
    - 厨房模式的上下文：“家庭住宅的厨房空间”；
    - 作用力：“烹饪流程效率”“工具存储便捷性”“用户操作安全”；
    - 解决方案：按 “存储区（冰箱 / 橱柜）- 预处理区（台面）- 烹饪区（灶台）- 清洁区（水槽）” 划分功能区域，工具按使用频率就近摆放；
    - 软件领域类比：如 “分层架构模式” 按 “展示层 - 业务层 - 数据层” 划分系统，各层职责明确、单向依赖。

### 2. 组件级模式（16.4）

组件级模式解决**子系统或组件的局部设计问题**，聚焦功能实现细节，是架构模式的 “细化补充”。

  

- **核心作用**：优化组件的内部逻辑与外部协作，确保组件高内聚、低耦合；
- **示例：[SafeHomeAssured.com](https://safehomeassured.com/)的产品搜索问题**：
    - 设计子问题：“如何让用户快速获取 SafeHome 设备的规格与相关信息”；
    - 适用模式：搜索领域的专用模式，如 “高级搜索（AdvancedSearch）”“搜索提示（SearchTips）”“搜索结果分页（SearchResults）”“搜索框优化（SearchBox）”；
    - 落地逻辑：通过 “SearchBox” 提供基础搜索入口，“SearchTips” 引导用户输入关键词，“AdvancedSearch” 支持多条件筛选，“SearchResults” 分页展示结果，形成完整搜索流程。

### 3. 用户界面（UI）模式（16.5）

UI 模式解决**用户与系统交互的设计问题**，核心目标是 “提升易用性、符合用户直觉”，覆盖从整体界面到局部元素的全维度。

  

- **9 大设计焦点与对应模式方向**：
    
    |设计焦点|核心问题|模式示例|
    |---|---|---|
    |整体 UI 结构|如何设计系统的全局导航与布局|仪表盘（Dashboard）、主导航栏（Main Navigation Bar）|
    |页面布局|如何组织 Web 页面或应用屏幕的元素|两栏布局（Two-Column Layout）、卡片式布局（Card Layout）|
    |表单与输入|如何优化长表单或复杂输入场景|分步表单（Wizard）、输入提示（Input Hint）、即时验证（Real-Time Validation）|
    |表格数据|如何展示与操作大量结构化数据|排序表格（Sortable Table）、可筛选表格（Filterable Table）、行内编辑（Inline Edit）|
    |直接数据操作|如何让用户便捷修改数据|拖放排序（Drag-and-Drop Sort）、批量操作（Bulk Action）|
    |导航|如何帮助用户定位与跳转|面包屑（Breadcrumb）、返回顶部（Back to Top）、标签页（Tab Navigation）|
    |搜索|如何帮助用户快速找到信息|自动补全（Auto-Complete）、搜索历史（Search History）、无结果提示（No Results Suggestion）|
    |页面元素|如何设计局部交互元素|模态框（Modal）、下拉菜单（Dropdown）、加载动画（Loading Spinner）|
    |电商场景|如何优化电商类 UI 的转化效率|购物车悬浮（Floating Cart）、商品对比（Product Comparison）、限时折扣标签（Discount Badge）|
    

### 4. Web 应用模式（16.6）

Web 应用模式是**Web 场景特有的模式集合**，融合架构、组件、UI 模式的特点，聚焦 “信息组织、导航、交互、内容展示、功能实现” 五大维度：

  

|模式类别|核心解决的 WebApp 问题|示例|
|---|---|---|
|信息架构模式|如何组织 WebApp 的信息空间，方便用户查找|分类树（Category Tree）、标签云（Tag Cloud）、站点地图（Site Map）|
|导航模式|如何设计 WebApp 的链接结构，优化跳转体验|层级导航（Hierarchical Navigation）、环形导航（Ring Navigation）、引导式导航（Guided Tour）|
|交互模式|如何设计用户与 WebApp 的交互反馈，提升易用性|操作确认（Confirmation Dialog）、内容展开 / 折叠（Expand/Collapse）、加载状态提示（Loading Status）|
|展示模式|如何呈现内容，突出重点且符合阅读习惯|标题层级（Heading Hierarchy）、相关内容推荐（Related Content）、图文结合（Image-Text Combination）|
|功能模式|如何实现 WebApp 的核心算法与流程逻辑|表单提交异步化（Async Form Submission）、会话保持（Session Persistence）、数据缓存（Data Caching）|

### 5. 移动应用模式（16.7）

移动应用模式针对**移动端特有的场景与约束**（如小屏幕、触摸交互、网络不稳定），分为 “UI 交互模式” 与 “核心架构模式” 两类：

  

- **（1）移动 UI 交互模式**：聚焦移动端用户界面的高频场景，示例包括：
    - 导航类：自定义标签导航（Custom Tab Navigation）、侧边抽屉（Drawer Navigation）；
    - 流程类：注册流程（Sign-up Flows）、签到界面（Check-in Screens）、邀请机制（Invitations）；
    - 组件类：弹窗（Popovers）、地图集成（Maps）、列表加载（Pagination）；
- **（2）移动核心架构模式**：支撑移动端功能实现的底层设计模式，示例包括：
    - 架构类：模型 - 视图 - 控制器（MVC）、应用控制器（Applications Controller）；
    - 数据类：数据传输对象（DTO）、领域模型（Domain Model）、同步机制（Synchronization）；
    - 性能类：延迟加载（Lazy Acquisition）、分页加载（Pagination）、可靠会话（Reliable Sessions）；
    - 通信类：通信器（Communicator）、实体转换器（Entity Translator）、事务脚本（Transaction Script）。