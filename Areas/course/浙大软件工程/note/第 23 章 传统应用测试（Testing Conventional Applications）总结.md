# 第 23 章 传统应用测试（Testing Conventional Applications）总结

本章围绕传统应用测试的核心基础、测试方法体系（白盒测试与黑盒测试）、专项测试技术及优化工具展开，构建了 “从测试前提到落地执行” 的完整测试框架，核心内容如下：

## 一、测试基础：可测试性与 “好测试” 的标准

### （一）可测试性（Testability）：测试实施的前提条件

可测试性是衡量软件是否易于开展测试的核心指标，包含 7 个关键维度，直接影响测试效率与效果：

  

- **可操作性（Operability）**：软件运行稳定、无异常崩溃，为测试提供可靠环境；
- **可观察性（Observability）**：测试用例的执行结果可直接观察（如输出日志、界面反馈），便于判断是否存在缺陷；
- **可控制性（Controllability）**：测试过程可自动化（如脚本执行测试用例）、可优化（如批量调整输入参数），降低人工成本；
- **可分解性（Decomposability）**：能针对软件特定模块 / 功能开展定向测试（如仅测试支付模块），无需全流程执行；
- **简洁性（Simplicity）**：软件架构与逻辑简化，减少测试场景复杂度（如避免过度嵌套的条件判断）；
- **稳定性（Stability）**：测试期间需求 / 代码变更少，避免测试用例频繁失效；
- **可理解性（Understandability）**：设计文档清晰，测试人员能快速掌握软件逻辑，精准设计测试用例。

### （二）“好测试” 的核心标准（What is a “Good” Test?）

一个高质量的测试用例需满足 4 个条件，确保测试资源高效利用：

  

1. **高缺陷发现概率**：能精准命中软件潜在缺陷（如针对边界条件设计的测试用例）；
2. **无冗余性**：避免重复设计功能 / 场景一致的测试用例，减少无效工作量；
3. **最优性（Best of Breed）**：在同类测试用例中，能以最少步骤覆盖最多风险点；
4. **复杂度适中**：既不过于简单（如仅测试正常输入，遗漏异常场景），也不过于复杂（如测试流程过长，难以定位缺陷根源）。

### （三）测试的两种核心视角（Internal and External Views）

测试可从 “软件内部逻辑” 与 “外部功能” 两个维度切入，对应不同测试思路：

  

- **外部视角（黑盒思维）**：不关注软件内部实现，仅依据需求规格说明书，验证每个功能是否正常运行、是否存在功能缺陷；
- **内部视角（白盒思维）**：了解软件内部工作机制（如代码逻辑、模块交互），验证内部操作是否符合设计规范、所有组件是否被充分调用（“所有齿轮都啮合”）。

## 二、测试用例设计的核心原则与挑战

### （一）设计目标与约束

- **核心目标**：全面发现软件缺陷（Boris Beizer 提出 “缺陷潜伏在角落，聚集在边界”，需重点覆盖边缘场景）；
- **设计标准**：以 “最小的时间与人力成本”，实现 “完整的缺陷覆盖”。

### （二）测试的核心挑战：穷举测试不可行（Exhaustive Testing）

穷举测试指覆盖软件所有可能的执行路径，但实际中完全不可行：  
示例：一个包含 “循环 < 20 次” 逻辑的程序，可能存在1014条执行路径，即使每毫秒执行 1 个测试用例，也需 3170 年才能完成 —— 因此必须采用**选择性测试（Selective Testing）**，通过科学方法筛选关键路径，平衡测试覆盖度与效率。

## 三、白盒测试（White-Box Testing）：聚焦内部逻辑覆盖

白盒测试基于软件内部结构（如代码、控制流）设计测试用例，核心目标是 “确保所有语句、条件、路径被充分执行”，避免因逻辑遗漏导致的缺陷。

### （一）白盒测试的核心逻辑：为何需要 “覆盖”（Why Cover?）

覆盖测试的必要性源于 3 个关键问题：

  

1. 逻辑错误与错误假设的发生概率，与路径执行概率成反比（越容易被忽略的路径，越可能存在缺陷）；
2. 对 “路径是否会被执行” 的主观判断常与实际不符（如认为 “异常分支不会触发”，但实际场景中可能被触发）；
3. 拼写错误等随机缺陷具有偶然性，未测试的路径更可能包含此类问题。

### （二）基础路径测试（Basis Path Testing）：基于环路复杂度的路径筛选

基础路径测试是白盒测试的核心方法，通过 “环路复杂度” 确定最小测试路径集合，确保覆盖所有独立路径，步骤如下：

#### 1. 计算环路复杂度（Cyclomatic Complexity, V (G)）

环路复杂度衡量程序控制流的复杂程度，是确定 “最小测试路径数” 的关键指标，计算方法有两种：

  

- 方法 1：流图中 “封闭区域数 + 1”；
- 方法 2：通过代码逻辑（如条件判断、循环）推导。  
    示例：某程序流图的环路复杂度 V (G)=4，意味着至少需设计 4 条独立路径，即可覆盖所有核心逻辑。

#### 2. 推导独立路径与测试用例

- 独立路径：指包含 “至少一个新的边” 的路径，彼此无完全包含关系；  
    示例（基于 V (G)=4）：  
    Path 1: 1→2→3→6→7→8  
    Path 2: 1→2→3→5→7→8  
    Path 3: 1→2→4→7→8  
    Path 4: 1→2→4→7→2→4→…→7→8（包含循环的路径）
- 设计测试用例：为每条独立路径设计输入参数，确保路径被执行，验证输出是否符合预期。

#### 3. 注意事项

- 无需依赖流程图，但流程图可辅助路径追踪；
- 复合条件判断（如 “a>0 且 b<5”）需拆分为多个简单条件，分别覆盖；
- 优先对核心模块（如支付、数据处理模块）应用基础路径测试。

### （三）其他白盒测试技术

#### 1. 控制结构测试（Control Structure Testing）

针对程序控制流逻辑设计测试用例，包含两类核心方法：

  

- **条件测试（Condition Testing）**：覆盖所有逻辑条件（如 “真 / 假” 分支），验证条件判断的正确性（如避免 “逻辑与 / 或” 使用错误导致的分支遗漏）；
- **数据流测试（Data Flow Testing）**：根据变量的 “定义（DEF）” 与 “使用（USE）” 位置筛选路径，确保变量在 “定义后被正确使用”，避免 “未定义使用”“定义未使用” 等问题。  
    核心概念：
    - DEF (S)：语句 S 中定义的变量集合（如 “int x=5” 中，DEF (S)={x}）；
    - USE (S)：语句 S 中使用的变量集合（如 “y=x+3” 中，USE (S)={x}）；
    - 定义 - 使用链（DU 链）：变量 X 的 [X, S, S'] 链条，其中 S 定义 X、S' 使用 X，且 S 中 X 的定义在 S' 处有效。

#### 2. 循环测试（Loop Testing）：覆盖循环场景的关键缺陷

循环是程序缺陷的高发区域（如边界值处理错误、死循环），需按循环类型针对性测试：

  

|循环类型|测试策略|
|---|---|
|**简单循环**|覆盖 5 种关键场景：①跳过循环；②1 次循环；③2 次循环；④m 次循环（m <最大次数 n）；⑤(n-1)、n、(n+1) 次循环（验证边界处理）|
|**嵌套循环**|从最内层循环开始，外层循环设为最小迭代次数；测试内层关键场景后，逐步向外层扩展，外层设为关键次数，内层设为典型次数|
|**串联循环**|若循环独立（如无参数依赖），按简单循环测试；若循环依赖（如循环 1 的计数器为循环 2 的初始值），按嵌套循环测试|
|**非结构化循环**|先重构为结构化循环（如将 “goto” 改为 “for/while”），再按上述策略测试（非结构化逻辑易导致测试遗漏）|

## 四、黑盒测试（Black-Box Testing）：聚焦外部功能验证

黑盒测试不关注软件内部实现，仅依据需求规格说明书，验证软件 “输入 - 输出” 是否符合预期，核心解决 “功能有效性、行为正确性” 问题，需回答 7 个关键问题：

  

1. 功能有效性如何验证？（如 “登录功能是否能正确验证账号密码”）；
2. 系统行为与性能如何测试？（如 “并发 100 人登录时响应时间是否 < 2 秒”）；
3. 哪些输入类别能构成优质测试用例？（如正常输入、异常输入）；
4. 系统对特定输入是否敏感？（如 “输入含特殊字符时是否崩溃”）；
5. 如何隔离数据类的边界？（如 “年龄输入的最大 / 最小值边界”）；
6. 系统能承受的数据速率与体积是多少？（如 “文件上传支持的最大尺寸”）；
7. 数据组合对系统操作有何影响？（如 “同时输入空账号 + 错误密码时的反馈”）。

### 黑盒测试的核心方法

#### 1. 基于图的方法（Graph-Based Methods）

通过 “对象 - 关系图” 建模软件中的数据对象、组件及交互关系，设计测试用例覆盖所有对象与关系：

  

- 图中元素：节点（代表对象，如 “文档”“窗口”）、边（代表关系，如 “窗口包含文档”）、权重（如 “生成文档时间 < 1 秒”）；
- 测试目标：确保所有对象的交互逻辑符合需求（如 “点击‘新建’能生成文档，且生成时间达标”）。

#### 2. 等价类划分（Equivalence Partitioning）

将输入 / 输出域划分为 “等价类”（即具有相同行为的输入集合），从每个等价类中选 1 个用例测试，减少冗余：

  

- **有效等价类**：符合需求的输入（如 “年龄 18-60 岁”）；
- **无效等价类**：不符合需求的输入（如 “年龄 < 0 或> 150 岁”）。  
    常见等价类类型：用户命令、系统提示响应、文件名、计算数据、物理参数、边界值、图形数据（如鼠标点击位置）等。

#### 3. 边界值分析（Boundary Value Analysis, BVA）

基于 “缺陷聚集在边界” 的规律，重点测试等价类的边界值（而非中间值），示例：

  

- 输入域 “年龄 18-60 岁”：测试 17（下界 - 1）、18（下界）、19（下界 + 1）、59（上界 - 1）、60（上界）、61（上界 + 1）；
- 输出域 “计算结果 0-100”：测试 - 1、0、1、99、100、101。

#### 4. 比较测试（Comparison Testing）

适用于可靠性要求极高的场景（如载人航天软件），核心思路：

  

- 多个独立团队基于同一需求，开发不同版本的软件；
- 用相同测试数据测试所有版本，验证输出是否完全一致；
- 并行执行所有版本，实时对比结果，确保一致性（若某版本输出不同，需定位缺陷）。

#### 5. 正交阵列测试（Orthogonal Array Testing）

当输入参数少且取值范围明确时，通过 “正交阵列” 筛选 “参数组合”，用最少用例覆盖最多组合场景，避免组合爆炸：

  

- 示例：3 个参数（A 有 2 个取值、B 有 3 个取值、C 有 2 个取值），无需测试 2×3×2=12 种组合，通过正交阵列仅需 6 个用例即可覆盖核心组合。

#### 6. 基于模型的测试（Model-Based Testing）

基于软件 “行为模型”（描述软件对外部事件的响应逻辑）设计测试用例，步骤如下：

  

1. 分析或构建行为模型（如状态机模型，包含 “状态 - 事件 - 过渡”）；
2. 遍历模型，确定触发 “状态过渡” 的输入（事件）；
3. 记录每个过渡对应的预期输出；
4. 执行测试用例，对比实际与预期输出，定位缺陷。

## 五、软件测试模式（Software Testing Patterns）

测试模式与设计模式类似，是对 “典型测试问题” 的可复用解决方案，以 “场景测试（ScenarioTesting）” 为例：

  

- **模式名称**：ScenarioTesting（场景测试）；
- **核心思想**：单元测试与集成测试后，从用户视角设计 “真实使用场景”（如 “用户登录→浏览商品→下单支付”），验证软件是否满足用户可见需求；
- **价值**：若场景测试失败，直接表明软件未达成用户核心需求（如 “下单后支付页面崩溃”），为最终验收提供关键依据。