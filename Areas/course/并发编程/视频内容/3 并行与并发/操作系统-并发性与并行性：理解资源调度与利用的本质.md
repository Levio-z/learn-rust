

## 1. 核心观点  
### Ⅰ. 概念层

## 并发性与并行性：理解资源调度与利用的本质
在现代计算体系中，并发性（**Concurrency**）与并行性（**Parallelism**）是构建高性能系统的核心概念，二者既密切相关又本质不同。
- [操作系统-并发性](../../../../../Projects/on%20hold/开源操作系统训练营/2025春夏/第二阶段：rcore/rCore-Turial-note/概念合集/操作系统-并发性.md)
- [操作系统-并行性](../../../../../Projects/on%20hold/开源操作系统训练营/2025春夏/第二阶段：rcore/rCore-Turial-note/概念合集/操作系统-并行性.md)
### 并发 ≠ 并行，但它们可以重叠

-   **并发是问题域（Concurrency is about dealing with lots of things at once）**：你有多个任务要处理，它们可能竞争资源。
-   **并行是解决方式之一（Parallelism is about doing lots of things at once）**：你有多个资源可以同时使用。

并发是一种组织代码的方式，而并行是一种资源。
- **并行性越高，在固定时间内可以完成的计算就越多**（假设计算速度相同）。
	- 对于并行性和性能而言，**真正重要的只有处理器核心的数量**，而不是代码如何组织以实现并发（例如，线程数）。
	- **增加系统的并发性而不增加并行性，永远无法提高系统速度**（尽管它可以提高系统的响应速度，并且可能使一些原本不切实际的优化成为可能）。

二者的关系可以用下图概括：

```markdown
┌────────────┐
         │   并发性   │ ← 问题：如何协调共享资源
         └────┬───────┘
              │
         可用并行资源
              ↓
         ┌────────────┐
         │   并行性   │ ← 手段：提高处理效率
         └────────────┘
```

---


### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层
### 并发设计

#### ✅ “平凡”并发（Trivial Concurrency）：

-   特征：完全不共享资源。 名义上并行，但**时间上并不重叠**。
-   优点：**安全**。
-   缺点：**资源利用率不高**。
    

#### ✅ “可扩展”并发（Scalable Concurrency）：

-   特征：**真正同时**访问**共享可变资源**。
-   示例：每秒处理百万请求的高并发系统，如 Redis、RabbitMQ。
-   优点：高性能、高吞吐量。
-   难点：**高效但难以保证安全性**并且复杂
	-   解决：需设计高效的同步机制（如 CAS、自旋锁、事务等）以避免竞争和死锁。


| 概念  | 关注点     | 本质问题           | 工程挑战            |
| --- | ------- | -------------- | --------------- |
| 并发性 | 正确性、协调性 | 多任务对共享资源的调度    | 状态同步、线程安全、死锁规避等 |
| 并行性 | 性能、吞吐量  | 多个任务在多个资源上同时执行 | 资源分配、负载均衡、调度策略等 |

并发性是结构，决定你\*\*“能不能做对”**；并行性是能力，决定你**“能不能做快”\*\*。优秀的系统设计往往要求两者兼顾：既能正确协调资源，又能高效利用资源。

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  






## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
