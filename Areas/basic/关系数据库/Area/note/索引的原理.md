---
tags:
  - note
---
## 1. 核心观点  
1. 在二级索引树上找到 `'完成'` 的所有主键；
    
2. 根据主键去聚簇索引中**回表**取整行数据。



## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
`INDEX(order_status)` 是一个 **B+ 树**，内部存储结构大致如下：
```
        [根节点]
           |
   -----------------
   |      |        |
 完成   未完成   (其他值)

```

每个叶子节点保存：

- 索引键（例如 `'完成'`）
    
- 主键引用（即对应行的 order_id）

SELECT * FROM orders WHERE order_status = '完成';

MySQL 执行步骤为：

1. 在二级索引树上找到 `'完成'` 的所有主键；
    
2. 根据主键去聚簇索引中**回表**取整行数据。

#### 2️⃣ 95% 都是“完成”时的问题

- 这意味着索引项里，几乎所有主键都属于 `'完成'`；
    
- 扫描 `'完成'` 的索引叶节点几乎等价于**扫描全表主键**；
    
- 然后还要逐条“回表”，导致大量随机 I/O；
    
- 反而不如直接**顺序扫描整张表**（顺序 I/O 快得多）


“如果索引命中行数超过全表的 30%~40%，那我干脆不走索引，直接全表扫描更快。”



## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- [分区表](分区表.md)
	- [随机IO和顺序IO的性能差异](随机IO和顺序IO的性能差异.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 物理层面更有效地优化这种查询。
- [ ] 
