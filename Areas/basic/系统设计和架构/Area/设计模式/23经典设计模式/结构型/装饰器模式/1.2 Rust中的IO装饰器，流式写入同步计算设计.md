
[实现 trait write](../../../../../../../Rust/Area/3%20库&应用场景/库/标准库/std/io/write/实现%20trait%20write.md)
```rust
struct HashWriter<W> {
    writer: W,
    hasher: Sha1,
}

```
- `W` 是一个泛型，约束为实现了 `std::io::Write` 的类型。
- `writer` 是真正的底层写入对象（例如 `File`、`TcpStream`、`Vec<u8>`）
- `hasher` 是一个 `Sha1` 实例，用来同步计算哈希。
```rust
impl<W> Write for HashWriter<W>

where

    W: Write,

{

    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {

        let n = self.writer.write(buf)?;

        self.hasher.update(&buf[..n]);

        Ok(n)

    }

  

    fn flush(&mut self) -> std::io::Result<()> {

        self.writer.flush()

    }

}
```
### 设计解析
- **`write` 方法逻辑**
    1. 调用底层 `writer.write(buf)` 执行真正的写入。
    2. 取实际写入的前 `n` 个字节，用 `hasher.update(&buf[..n])` 更新哈希状态。
	    1. **因为 I/O 写入不是总能一次完成
    3. 返回写入的字节数。
    4. 优点
	    1. **透明包装**： 对外表现依然是 `Write`，可以替代任何写入目标。调用者**无需关心哈希逻辑**，依旧使用标准 `write`/`flush`。

| 特性       | `update` 分块累加          | 一次性计算         |
| -------- | ---------------------- | ------------- |
| 大数据，内存友好 | **高效，内存可控，不必分配整个数据副本** | 需要整个数据在内存中    |
| CPU效率    | 略低，但通常忽略不计             | 略高，少函数调用开销    |
| 流式处理     | 支持流式、边读边计算             | 不支持，必须先完整获取数据 |

### 使用场景
- 对于小数据（如几 KB），一次性计算通常略快。
- 对于大数据（几 MB、GB 或流数据），`update` 分块计算更高效且可控内存。

### 设计模式思想解析
这正是典型的 **装饰器**：
- 不改变原有接口（仍然实现 `Write`），
- 在调用底层逻辑的同时增加额外功能（哈希更新）。

你提供的代码是一个典型的 **组合装饰器模式**（Decorator Pattern）在 Rust I/O 中的应用，核心思想是 **在写入数据的同时进行哈希计算**。我们逐步分析其巧妙之处。
#### Rust如何实现装饰器模式
- **泛型 `W`**：允许 `HashWriter` **包装任意实现了 `Write` 的类型**，例如：
    - `File`
    - `Vec<u8>`
    - `TcpStream`
- **组合而非继承**：Rust 没有继承，利用组合和 trait 实现类似“装饰器”的能力。



