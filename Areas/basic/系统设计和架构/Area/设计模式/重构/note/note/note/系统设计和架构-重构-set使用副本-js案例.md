---
tags:
  - note
---
## 1. 核心观点  
### Ⅰ. 概念层

**在设值这一行为发生时，通过“复制”来切断类内部与外部源数据的联系。**

- **Getter 隔离：** 保护内部不被外部破坏。
- **Setter 隔离：** 保护内部不被外部源数据的变化所牵连。
### Ⅱ. 应用层

	
### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
	- book-refactoring
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  


### 1. 你想的“传入一个副本”：防御性输入

这是最符合逻辑的理解。当外部数据进入类时，我们在内部立刻克隆一份，确保类持有的数据是独立的。
JavaScript

```
// 你的理解：在存入时复制
set defaultOwner(arg) {
    this._defaultOwner = { ...arg }; // 存入的是副本
}
```

**目的：** 防止外部的 `arg` 在之后被修改时，无意中改变了类内部的 `_defaultOwner`。这就是 Rust 里通过所有权转移或显式 `.clone()` 解决的问题。

---

### 2. 另一种可能：Setter 返回“更新后的结果”

在函数式编程或追求**不可变性**的场景下，Setter 确实可能“返回”一个副本。但这通常意味着它**不修改原对象**，而是返回一个全新的、带有新值的对象。

JavaScript

```
// 函数式风格：Setter 返回一个新的实例
function withNewOwner(originalStore, newOwner) {
    return {
        ...originalStore,
        defaultOwner: { ...newOwner } // 返回一个全新的副本
    };
}
```

这种做法在 React 的 `setState` 或 Redux 的 `reducer` 中非常常见。它不叫“修改变量”，而叫“产生新状态”。

---

### 3. 为什么作者的表述让你感到奇怪？

在《重构》的某些语境下，作者讨论的可能是**“取值函数（Getter）返回副本”**的对称操作。

如果你看原句的语境，他其实是在对比：

- **取值时（Out）：** 我给你一份拷贝，你随便改，不影响我。
    
- **设值时（In）：** 你给我一份数据，我拷贝一份存起来，你之后怎么改你那份，都不影响我。
    

---

### 总结：你的理解是对的

在传统的命令式编程（非函数式）中，**“传入并存储一个副本”** 才是最地道的术语。作者这里想表达的核心点是：**双向隔离。**

- **Getter 隔离：** 保护内部不被外部破坏。
- **Setter 隔离：** 保护内部不被外部源数据的变化所牵连。
    

**之所以觉得奇怪，是因为 Rust 已经帮你把这些“防御性动作”自动化了。在 Rust 里，你直接传递所有权（Move），本质上就是最高级的“隔离”——原数据直接在外部消失了，根本不需要考虑副本。**

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
	- 
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
