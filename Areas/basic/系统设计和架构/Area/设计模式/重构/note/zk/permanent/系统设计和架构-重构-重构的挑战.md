---
tags:
  - permanent
---
## 1. 核心观点  
### Ⅰ. 概念层


### Ⅱ. 应用层
你需要了解一件事背后的权衡取舍，才能决定何时何地应用它。我认为重构是一种很有价值的技术，大多数团队都应该更多地重构，但它也不是完全没有挑战的。有必要充分了解重构会遇到的挑战，这样才能做出有效应对。
- [延缓新功能开发](#延缓新功能开发)
	- **“重构会拖慢进度”这种看法仍然很普遍，这可能是导致人们没有充分重构的最大阻力所在。**
	- 本质：**重构应该总是由经济利益驱动**，让我们开发更快，用更少的工作量创造更大的价值。
		- ->我们之所以重构，因为它能让我们更快——添加功能更快，修复 bug 更快。
		- ->轻松地把现有代码组合配置，快速构造出复杂的新功能。
		- 详情见：
			- [系统设计和架构-重构-为何重构](系统设计和架构-重构-为何重构.md)
		- 判断和取舍：[系统设计和架构-重构-何时重构](系统设计和架构-重构-何时重构.md)
	- [领导的角度：如果你是一支团队的技术领导，一定要向团队成员表明，你重视改善代码库健康的价值。](#领导的角度：如果你是一支团队的技术领导，一定要向团队成员表明，你重视改善代码库健康的价值。)
- [代码所有权](#代码所有权)
	- 代码所有权的边界会妨碍重构，因为一旦我自作主张地修改，就一定会破坏使用者的程序
		- [代码所有权的边界解决方案之一](#代码所有权的边界解决方案之一)
			- 保留原来的函数声明，使其把调用传递给新的函数
	- [代码所有权共享+责任分工：监控自己责任区内发生的修改，而不是禁止别人修改](系统设计和架构-重构-重构的挑战.md#代码所有权共享+责任分工：监控自己责任区内发生的修改，而不是禁止别人修改)
	- [跨团队可以基于开源的pr机制](系统设计和架构-重构-重构的挑战.md#跨团队可以基于开源的pr机制)
- [分支](#分支)
	- [常见的特性分支做法及其优缺点](系统设计和架构-重构-重构的挑战.md#常见的特性分支做法及其优缺点)
		- 特性分支加剧了合并的难度，加剧了重构的难度
	- [持续集成与重构可以良好配合](#持续集成与重构可以良好配合)
- [测试与重构](#测试与重构)
	- [关键就在于“快速发现错误”](#关键就在于“快速发现错误”)
		- 重构会频繁修改代码，避免错误的关键就是快速发现和定位错误
	- [自测试的代码更安全，频繁测试可以快速发现错误](系统设计和架构-重构-重构的挑战.md#自测试的代码更安全，频繁测试可以快速发现错误)
		- 并且限定错误的范围
	- [缺乏测试的重构方案](#缺乏测试的重构方案)
- [遗留代码:运用重构手法创造出接缝](系统设计和架构-重构-重构的挑战.md#遗留代码%20运用重构手法创造出接缝)

### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
	- book-refactoring
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 延缓新功能开发

**我从同事那里听到的证据表明，在我们这个行业里，重构不足的情况远多于重构过度的情况**。

#### 领导的角度：**如果你是一支团队的技术领导，一定要向团队成员表明，你重视改善代码库健康的价值**。

合理判断何时应该重构、何时应该暂时不重构，这样的判断力需要多年经验积累。对于重构缺乏经验的年轻人需要有意的指导，才能帮助他们加速经验积累的过程。


### 代码所有权

很多重构手法不仅会影响一个模块内部，还会影响该模块与系统其他部分的关系。

#### 案例
##### 重构可能无法实施

**调用方代码可能由另一支团队拥有**，而我没有权限写入他们的代码库；
- 这个函数可能是一个**提供给客户的 API，这时我根本无法知道是否有人使用它，至于谁在用、用得有多频繁就更是一无所知**。
- 这样的函数属于**已发布接口（published interface**）：接口的使用者（客户端）与声明者彼此独立，声明者无权修改使用者的代码。

##### 代码所有权的边界解决方案之一

**代码所有权的边界会妨碍重构，因为一旦我自作主张地修改，就一定会破坏使用者的程序**。这不会完全阻止重构，我仍然可以做很多重构，但确实会对重构造成约束。
- **为了给一个函数改名，我需要使用函数改名（124），但同时也得保留原来的函数声明，使其把调用传递给新的函数。这会让接口变复杂，但这就是为了避免破坏使用者的系统而不得不付出的代价**。
- 我可以把旧的接口标记为“不推荐使用”（deprecated），等一段时间之后最终让其退休；但有些时候，旧的接口必须一直保留下去。
##### 代码所有权共享+责任分工：监控自己责任区内发生的修改，而不是禁止别人修改

- 代码库共享：**如果这三个人都直接去代码库里做修改，事情会简单得多。我推荐团队代码所有制，这样一支团队里的成员都可以修改这个团队拥有的代码，即便最初写代码的是别人**。

- 责任分工：程序员可能各自分工负责系统的不同区域，但这种责任应该体现为**监控自己责任区内发生的修改，而不是简单粗暴地禁止别人修改**。
##### 跨团队可以基于开源的pr机制
这种较为宽容的代码所有制甚至可以应用于跨团队的场合。有些团队鼓励类似于开源的模型：B 团队的成员也可以在一个分支上修改 A 团队的代码，然后把提交发送给 A 团队去审核。这样一来，如果团队想修改自己的函数，他们就可以同时修改该函数的客户端的代码；只要客户端接受了他们的修改，就可以删掉旧的函数声明了。对于涉及多个团队的大系统开发，在“强代码所有制”和“混乱修改”两个极端之间，这种类似开源的模式常常是一个合适的折中。

### 分支
#### 常见的特性分支做法及其优缺点

常见的做法是在分支上开发完整的功能，直到功能可以发布到生产环境，才把该分支合并回主线

- 保持主线不受尚未完成的代码侵扰，能保留清晰的功能添加的版本记录，并且在某个功能出问题时能容易地撤销修改。
- 在隔离的分支上工作得越久，将完成的工作集成（integrate）回主线就会越困难。
	- 解决方案之一：
	- 频繁地从主线合并（merge）
		- 同时修改，直到她将自己的修改与主线集成；此时我就必须把她的修改合并到我的特性分支，这可能需要相当的工作量
	- **合并其中困难的部分是处理语义变化。现代版本控制系统都能很好地合并程序文本的复杂修改，但对于代码的语义它们一无所知**。如果我修改了一个函数的名字，版本控制工具可以很轻松地将我的修改与 Rachel 的代码集成。但如果在集成之前，她在自己的分支里新添调用了这个被我改名的函数，集成之后的代码就会被破坏。
- 分支合并本来就是一个复杂的问题，**随着特性分支存在的时间加长，合并的难度会指数上升**。
- **采用特性分支的团队常会发现重构加剧了分支合并的困难，并因此放弃了重构**，这种情况我们曾经见过多次。CI 和重构能够良好配合，所以 Kent Beck 在极限编程中同时包含了这两个实践。

##### 持续集成与重构可以良好配合
- 在使用 CI 时，每个团队成员每天至少向主线集成一次。这个实践避免了任何分支彼此差异太大，从而极大地降低了合并的难度。
- 你必须使用相关的实践以**确保主线随时处于健康状态，必须学会将大功能拆分成小块**，还**必须使用特性开关（feature toggle，也叫特性旗标，feature flag）将尚未完成又无法拆小的功能隐藏掉。**
- CI 与重构能良好配合


**对于开源项目，特性分支可能是合适的做法，因为不时会有你不熟悉（因此也不信任）的程序员偶尔提交修改。但对全职的开发团队而言，特性分支对重构的阻碍太严重了**。即便你没有完全采用 CI，我也一定会催促你尽可能频繁地集成。而且，用上 CI 的团队在软件交付上更加高效，我真心希望你认真考虑这个客观事实[Forsgren et al]。

### 测试与重构
#### 关键就在于“快速发现错误”
- 不会改变程序可观察的行为，这是重构的一个重要特征。如果仔细遵循重构手法的每个步骤，我应该不会破坏任何东西，但万一我犯了个错误怎么办？人总会有出错的时候，**不过只要及时发现，就不会造成大问题**。既然每个重构都是很小的修改，即便真的造成了破坏，我也只需要检查最后一步的小修改——就算找不到出错的原因，只要回滚到版本控制中最后一个可用的版本就行了。
- 要做到这一点，我的代码应该有一套完备的测试套件，并且运行速度要快，否则我会不愿意频繁运行它。也就是说，绝大多数情况下，如果想要重构，我得先有可以自测试的代码[mf-stc]。

#### 自测试的代码更安全，频繁测试可以快速发现错误
- 自测试的代码不仅使重构成为可能，而且使添加新功能更加安全，因为我可以**很快发现并干掉新近引入的 bug**
- 一旦测试失败，我只需要查看上次测试成功运行之后修改的这部分代码；如果测试运行得很频繁，这个查看的范围就只有几行代码。知道必定是这几行代码造成 bug 的话，排查起来会容易得多。

#### 缺乏测试的重构方案

- 自动化重构
- 一组经过验证是安全的重构手法
### 遗留代码:运用重构手法创造出接缝
**如果你面对一个庞大而又缺乏测试的遗留系统，很难安全地重构清理它**。
>重构可以很好地帮助我们理解遗留系统。引人误解的函数名可以改名，使其更好地反映代码用途；糟糕的程序结构可以慢慢理顺，把程序从一块顽石打磨成美玉。整个故事都很棒，但我们绕不开关底的恶龙：遗留系统多半没测试。

运用重构手法创造出接缝——这样的重构很危险，因为没有测试覆盖，但这是为了取得进展必要的风险.《修改代码的艺术》，照书里的指导来做。

就算有了测试，我也不建议你尝试一鼓作气把复杂而混乱的遗留代码重构成漂亮的代码。我更愿意随时重构相关的代码：**每次触碰一块代码时，我会尝试把它变好一点点**——至少要让营地比我到达时更干净。如果是一个大系统，越是频繁使用的代码，改善其可理解性的努力就能得到越丰厚的回报。

### 数据库
- 去看渐进式数据库重构这本书

- 案例
	- 改变函数声明（124）一样，我要找出结构的声明处和所有调用处，然后一次完成所有修改
	- 来基于旧字段的数据，也要转为使用新字段。我会写一小段代码来执行数据转化的逻辑，并把这段代码放进版本控制
- 关键还是小步修改
	- 比如，要改名一个字段，我的第一次提交会新添一个字段，但暂时不使用它
	- 然后我会修改数据写入的逻辑，使其同时写入新旧两个字段
	- 随后我就可以修改读取数据的地方，将它们逐个改为使用新字段
	- 这步修改完成之后，我会暂停一小段时间，看看是否有 bug 冒出来。确定没有 bug 之后，我再删除已经没人使用的旧字段





## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
