### 封装性
**封装（Encapsulation）**是软件设计中的一个核心思想：将模块内部的实现细节隐藏起来，只通过预先定义好的公共接口（Public Interface）向外部暴露功能。外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。

>核心思想：**信息隐藏（Information Hiding）**，由 David Parnas 提出。封装也叫作**信息隐藏或者数据访问保护。

- **公共接口（Public API）**：其他代码可以调用的部分，例如函数、方法、结构体字段（如果标记为 `pub`）。
- **私有实现（Private Implementation）**：不对外暴露，模块内部自己维护，其他代码无法直接依赖。

### 前置要求
- 需要语言提供访问权限控制功能。
	- **Rust 可见性修饰符**：`pub`, `pub(crate)`, `pub(super)` 等用于控制访问范围。
	- **面向对象语言中的封装**：通常通过 `private/protected/public` 来实现。

#### 封装的意义
##### 调用者
1. **隐藏实现细节**：调用者不需要关心内部逻辑，只要知道输入和输出即可。
2. **降低认知负担**：因为1，开发者只需记住接口，而不必时刻跟踪底层实现。
##### 开发者
1. **便于高内聚和低耦合=>可读可维护：
	- 代码组织：高内聚、低耦合的角度来看，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，可能增加出错的概率和数据不一致的风险，势必影响代码的可读性、可维护性。
	- 重构：只要公共接口不变，内部实现随时可以重构，不影响使用者。
2. **增强安全性**：防止外部直接访问内部状态，避免误用或破坏不变量。
### 应用场景
- **库开发**：提供清晰的 API，隐藏复杂实现逻辑。
- **操作系统内核**：外部模块只通过系统调用访问功能，不直接操作内核数据结构。
- **大型工程**：降低模块之间的耦合度，提高代码可维护性。
### 具体实例
针对不同的属性，不同的访问方式
- id和创建时间：
	- 不提供任何修改方法： 在创建钱包的时候就确定好了，之后不应该再被改动，
	- 初始设置对调用者是透明的（不用关心）：我们在 Wallet 类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。
- 钱包余额：
	- 从业务的角度来说，只能增或者减，不会被重新设置：
		- 只暴露increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法
-  balanceLastModifiedTime
	- 完全封装在了increaseBalance和 decreaseBalance方法中，不对外暴露任何修改这个属性的方法和业务细节
### 扩展知识
- **抽象屏障（Abstraction Barrier）**：公共接口就是一堵墙，屏蔽了内部实现。