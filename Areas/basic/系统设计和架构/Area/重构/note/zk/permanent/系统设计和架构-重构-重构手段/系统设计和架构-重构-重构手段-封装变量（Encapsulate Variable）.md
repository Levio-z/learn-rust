---
tags:
  - permanent
---
## 1. 核心观点  
### Ⅰ. 概念层
#### 封装变量 (Encapsulate Variable)
解决全局数据的第一步不是立刻消灭它（有时确实需要全局配置），而是**接管它的访问权**。


### Ⅱ. 应用层
- [2. 封装数据的策略：化“数据”为“函数”](系统设计和架构-重构-重构手段-封装变量（Encapsulate%20Variable）.md#2.%20封装数据的策略：化“数据”为“函数”)
- [4. 什么时候使用封装](#4.%20什么时候使用封装)
- [6. 步骤和案例](#6.%20步骤和案例)
	- [6.1 案例](#6.1%20案例)
### Ⅲ. 实现层
-  [6.1 案例](#6.1%20案例)
- [系统设计和架构-重构-set使用副本-js案例](../../../note/note/系统设计和架构-重构-set使用副本-js案例.md)
### **IV**.原理层
- [1. 为什么数据比函数更难重构？](系统设计和架构-重构-重构手段-封装变量（Encapsulate%20Variable）.md#1.%20为什么数据比函数更难重构？)
- [3. 数据封装的价值](系统设计和架构-重构-重构手段-封装变量（Encapsulate%20Variable）.md#3.%20数据封装的价值)
- [5. 但是封装可变仍然小于不可变数据](#5.%20但是封装可变仍然小于不可变数据)

## 2. 背景/出处  
- 来源：
	- book-refactoring
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 动机
#### 1. 为什么数据比函数更难重构？
重构的本质是**调整程序元素**。
- **函数（易）：** 具有单一的入口（调用）。重构时可以通过**“转发函数”**（Forwarding Function）作为过渡，新旧逻辑可以并存，实现渐进式重构。
- **数据（难）：** 缺乏转发机制。一旦数据位置或结构改变，所有引用它的代码必须**同步修改**，否则程序会崩溃。**数据的作用域越大，重构的风险和成本就呈指数级增长**。
#### 2. 封装数据的策略：化“数据”为“函数”
为了应对大规模数据的搬移，最有效的办法是：**先封装，再重构。**
- **转化思路：** 将对数据的直接访问改为通过函数访问（Getter/Setter）。
- **结果：** 成功的将“重新组织数据”这个困难任务，转化成了“重新组织函数”这个简单任务。
#### 3. 数据封装的价值

- **建立“观测点”：从被动到主动**
	- 直接访问数据是“静默”的，而通过函数访问数据是“显性”的。
- **监控与调试：**  你可以在 Setter 中**添加日志、断点或监控，瞬间定位是谁在什么时候修改了数据**。当你发现某个全局变量被意外修改时，如果没有封装，你必须搜索全工程的引用。有了封装，你只需在 `setter` 函数中打一个断点或加一行日志，就能瞬间捕捉到是谁在什么时候修改了它。提供清晰的观测点，可以记录数据的变化轨迹。
- **行为注入/逻辑拓展：** 封装让数据操作变成了**事件**。你可以在数据改变时触发其他逻辑（如更新 UI、发送通知、记录审计日志），而无需在每一处调用点手动添加这些逻辑。
	- 可以在读取或修改数据时，轻松插入**验证逻辑**或**副作用逻辑**。
- **逐步替换：** 有了函数封装，你可以更容易地将这个变量迁移到某个具体的对象中，而不需要修改数千处调用点。**只需要修改这一个函数内部的实现**，而那 1000 处调用点（get）**完全不需要动**。
- **降低耦合**：减少代码对特定数据结构的依赖，隐藏实现细节。
- **防御性编程**：防止外部代码随意修改内部状态，维护对象的不变性。
- **处理遗留代码的破窗效应**：
	- **防止耦合恶化：** 遗留系统中的全局或大范围可变数据通常是“重灾区”。
	- **渐进式改进：** 不要试图一次性重构整个系统，而是**每次修改相关逻辑时，先给数据套上“壳子”（封装）。这样，新写的代码就是基于受控接口的，旧的耦合会逐渐被隔离**。
#### 4. 什么时候使用封装

**对于所有可变的数据，只要它的作用域超出单个函数，我就会将其封装起来，只允许通过函数访问**

面向对象方法如此强调对象的数据应该保持私有（private），背后也是同样的原理。**每当看见一个公开（public）的字段时，我就会考虑使用封装变量（在这种情况下，这个重构手法常被称为封装字段）来缩小其可见范围**。

>一些更激进的观点认为，即便在类内部，也应该通过访问函数来使用字段——这种做法也称为“自封装”。大体而言，我认为自封装有点儿过度了——如果一个类大到需要将字段自封装起来的程度，那么首先应该考虑把这个类拆小。不过，在分拆类之前，自封装字段倒是一个有用的步骤。？？拆分类的自封装的好处，我只需要关注“访问函数”如何连接到新对象，而不需要搜索并替换类中几十处 `this.shippingState`


### 5. 但是封装可变仍然小于不可变数据
**不可变数据的逻辑是：** 数据一旦创建就永远保持那个状态。
- 既然数据不会变，就不存在“变坏”的可能性。
- 你不需要在代码各处检查“是谁偷偷改了我的值”，因为根本没人能改。
### 6. 步骤和案例

- 创建封装函数，在其中访问和更新变量值。
- 执行静态检查。
- 逐一修改使用该变量的代码，将其改为调用合适的封装函数。每次替换之后，执行测试。
- 限制变量的可见性。
	- 一来是检查是否遗漏了变量的引用，二来可以保证以后的代码也不会直接访问该变量。
	- 实践：在 JavaScript 中，我可以把变量和访问函数搬移到单独一个文件中，并且只导出访问函数，这样就限制了变量的可见性.
	- 如果没办法，就起个有意义又难看的名字（例如`__privateOnly_defaultOwner`），提醒后来的客户端。

>有时没办法阻止直接访问变量。若果真如此，可以**试试将变量改名，再执行测试，找出仍在直接使用该变量的代码**。
- 测试。
- 如果变量的值是一个记录，考虑使用封装记录（162）。

#### 6.1 案例

- [系统设计和架构-重构-封装全局变量-rust案例](../../../note/note/系统设计和架构-重构-封装全局变量-rust案例.md)
	- 该案例主要解决不统一的问题
	- [软件工程-为什么“没有统一的地方”是问题](../../../../../../../软件工程/note/note/atomic/软件工程-为什么“没有统一的地方”是问题.md)


## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
