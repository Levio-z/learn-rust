---
tags:
  - permanent
---
## 1. 核心观点  
### Ⅰ. 概念层
### 核心定义





### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
	- book-refactoring
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 重构改建软件的设计
[软件工程-软件腐败](../../../../../../软件工程/note/note/atomic/软件工程-软件腐败.md)
短期修改和需求会导致代码腐败，并且代码结构的流失有累积效应，逐渐失去结构。**越难看出代码所代表的设计意图，就越难保护其设计，于是设计就腐败得越快**。

设计的重要改进方向，减少代码重复
- 可以利用重复的代码。
- 重复代码越多，做正确的修改就越困难，因为有更多代码需要理解。我在这里做了点儿修改，系统却不如预期那样工作，因为我没有修改另一处
### 重构使软件更容易理解

**编程不仅是与机器的沟通，更是与人类（包括未来的自己）的跨时空对话。人的时间 > 机器的时间**

**对开发者而言：** 理解 $100$ 行高度抽象的代码只需要 5 分钟，而理解散落在各处的 $500$ 行重复代码可能需要 1 小时。

>哲学：**事实上，对于任何能够立刻查阅的东西，我都故意不去记它**，因为我怕把自己的脑袋塞爆。我总是尽量把该记住的东西写进代码里，这样我就不必记住它了。这么一来，下班后我还可以喝上两杯 Maudite 啤酒，不必太担心它杀光我的脑细胞。

#### 持久化代码逻辑

- **初次编写时：** 我们的大脑里装满了业务逻辑、边界条件和临时的 Hack 方案。代码往往是这些思考的“草稿”。
    
- **重构时：** 我们在做“语义对齐”。通过重命名变量、提取函数，我们将那些**只有在编写那一刻才存在的“上下文信息”固化到代码结构中**。
#### 懒惰程序员的“外挂大脑”
- **混乱的代码：** 强制你把整个系统的调用链路都装进脑子里，一旦中断（比如下班或接个电话），缓存就会失效，重建成本极高。
    
- **重构后的代码：** 遵循**最小惊讶原则（Principle of Least Astonishment）**。当你看到一个函数名，你就能准确猜出它做了什么，而不需要点进去看实现。这时候，代码本身就是文档。
#### 复利
| **状态**         | **修改成本（第一天）** | **修改成本（六个月后）**        |
| -------------- | ------------- | --------------------- |
| **未重构（代码腐败）**  | 1 小时          | 1 周 (因为要先考古、找 Bug、测试) |
| **持续重构（设计清晰）** | 1.5 小时        | 1 小时 (逻辑直观，信心十足)      |
### 帮助找到 bug:重构本质上是一种“动态的深度阅读”

如果对代码**进行重构，我就可以深入理解代码的所作所为，并立即把新的理解反映在代码当中。搞清楚程序结构的同时，我也验证了自己所做的一些假设**，于是想不把 bug 揪出来都难

“我不是一个特别好的程序员，我只是一个有着一些特别好的习惯的还不错的程序员。”

你提到的 Kent Beck 是重构和测试驱动开发（TDD）的先驱。他的那句话揭示了软件工程的一个真理：**顶尖的程序员不靠智力硬扛复杂度，而是靠习惯规避复杂度。** 重构能够帮助我更有效地写出健壮的代码。

### 重构提高编程速度

**一开始他们进展很快，但如今想要添加一个新功能需要的时间就要长得多。他们需要花越来越多的时间去考虑如何把新功能塞进现有的代码库，不断蹦出来的 bug 修复起来也越来越慢**。

**代码库看起来就像补丁摞补丁，需要细致的考古工作才能弄明白整个系统是如何工作的**。这份负担不断拖慢新增功能的速度，到最后程序员恨不得从头开始重写整个系统。
![](asserts/Pasted%20image%2020251231111600.png)
但有些团队的境遇则截然不同。他们添加新功能的速度越来越快，因为他们能利用已有的功能，基于已有的功能快速构建新功能。
![](asserts/Pasted%20image%2020251231111612.png)
两种团队的区别就在于软件的内部质量。
- 需要添加新功能时，内部质量良好的软件让我可以**很容易找到在哪里修改、如何修改**。
- 良好的模块划分使我**只需要理解代码库的一小部分，就可以做出修改**。
- **如果代码很清晰，我引入 bug 的可能性就会变小，即使引入了 bug，调试也会容易得多**。理想情况下，我的代码库会逐步演化成一个平台，在其上可以很容易地构造与其领域相关的新功能。

我把这种现象称为“设计耐久性假说”：**通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速**。我还无法科学地证明这个理论，所以我说它是一个“假说”。但我的经验，以及我在职业生涯中认识的上百名优秀程序员的经验，都支持这个假说。



## 4. 与其他卡片的关联  
- 前置卡片：
	- [软件工程-技术债](../../../../../../软件工程/note/note/atomic/软件工程-技术债.md)
	- [软件工程-加速：全球软件交付调查](../../../../../../软件工程/note/note/atomic/软件工程-加速：全球软件交付调查.md)
- 后续卡片：
	- [软件工程-软件腐败](../../../../../../软件工程/note/note/atomic/软件工程-软件腐败.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
