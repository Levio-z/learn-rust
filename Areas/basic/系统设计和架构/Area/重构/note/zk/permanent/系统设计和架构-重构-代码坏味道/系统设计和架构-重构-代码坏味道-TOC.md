---
tags:
  - permanent
---
## 1. 核心观点  
### Ⅰ. 概念层



### Ⅱ. 应用层

	
### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
	- book-refactoring
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

### 3.1 神秘命名（Mysterious Name）
- 好的名字能节省未来用在猜谜上的大把时间：整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。
### 3.2 重复代码
**如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好**。一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。

最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。这时候你需要做的就是采用提炼函数（106）提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。如果重复代码只是相似而不是完全相同，请首先尝试用移动语句（223）重组代码顺序，把相似的部分放在一起以便提炼。如果重复的代码段位于同一个超类的不同子类中，可以使用函数上移（350）来避免在两个子类之间互相调用。

### 3.3 过长函数（Long Function）

#### 小函数的优势
据我们的经验，活得最长、最好的程序，其中的函数都比较短。初次接触到这种代码库的程序员常常会觉得“计算都没有发生”——程序里满是无穷无尽的委托调用。但和这样的程序共处几年之后，你就会明白这些小函数的价值所在。间接性带来的好处——**更好的阐释力、更易于分享、更多的选择**——都是由小函数来支持的。

- **阐释力：** 良好的函数命名可以替代注释。当你看到 `applyDiscounts(order)` 而不是 50 行嵌套的 `if` 逻辑时，你的大脑处理的是业务意图而非实现算法。
    
- **分享与复用：** 越小的逻辑单元，在不同上下文中被复用的概率越高。
    
- **现代环境的加持：** 现代编译器（如 Rust 的 `rust-analyzer`）几乎消除了函数调用开销，且 IDE 的跳转功能解决了上下文切换的负担。

现代编程语言几乎已经完全免除了进程内的函数调用开销。
- 内联优化 (Inlining)：**你享受了小函数带来的清晰结构，而机器运行的是大块代码的高效指令。**
- 分支预测器：现代 CPU 拥有极其强大的**分支预测器 (Branch Predictor)**。即使没有被内联，对于这种频繁、确定的跳转，CPU 也能提前预取指令，使函数调用的时钟周期损耗降至几乎可以忽略不计。

现代 IDE 如何抵消“上下文切换”的负担
- 固然，小函数也会给代码的阅读者带来一些负担，因为你必须经常切换上下文，才能看明白函数在做什么。但**现代的开发环境让你可以在函数的调用处与声明处之间快速跳转，或是同时看到这两处，让你根本不用来回跳转**。不过说到底，让小函数易于理解的关键还是在于良好的命名。**如果你能给函数起个好名字，阅读代码的人就可以通过名字了解函数的作用，根本不必去看其中写了些什么**。
#### 原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名
哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，**而在于函数“做什么”和“如何做”之间的语义距离**。

#### 如何确定该提炼哪一段代码呢？寻找注释

一个很好的技巧是：**寻找注释**。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去。

**条件表达式和循环常常也是提炼的信号**。你可以使用分解条件表达式（260）处理条件表达式。对于庞大的 switch 语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用。如果有多个 switch 语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。

**至于循环，你应该将循环和循环内的代码提炼到一个独立的函数中**。如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环（227）将其拆分成各自独立的任务。
#### 实际指南
百分之九十九的场合里，要把函数变短，只需使用提炼函数（106）。找到函数中适合集中在一起的部分，将它们提炼出来形成一个新函数。

如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。如果你尝试运用提炼函数（106），最终就会把许多参数传递给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常运用以查询取代临时变量（178）来消除这些临时元素。引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些。

如果你已经这么做了，仍然有太多临时变量和参数，那就应该使出我们的杀手锏——以命令取代函数（337）。

### 3.4 过长参数列表（Long Parameter List）

刚开始学习编程的时候，老师教我们：把函数所需的所有东西都以参数的形式传递进去。这可以理解，因为除此之外就只能选择全局数据，而**全局数据很快就会变成邪恶的东西。但过长的参数列表本身也经常令人迷惑**。

如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）去掉这第二个参数。如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法，直接传入原来的数据结构。如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象。如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数（314）。

使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组合成类（144），将这些共同的参数变成这个类的字段。如果戴上函数式编程的帽子，我们会说，这个重构过程创造了一组部分应用函数（partially applied function）。
### 3.5 全局数据（Global Data）

**全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改**。一次又一次，全局数据造成了那些诡异的 bug，而问题的根源却在遥远的别处，想要找到出错的代码难于登天。全局数据最显而易见的形式就是全局变量，但类变量和单例（singleton）也有这样的问题。

首要的防御手段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招。你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。随后，最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。

可以被修改的全局数据尤其可憎。如果能保证在程序启动之后就不再修改，这样的全局数据还算相对安全，不过得有编程语言提供这样的保证才行。

全局数据印证了帕拉塞尔斯的格言：良药与毒药的区别在于剂量。有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。即便只是少量的数据，我们也愿意将它封装起来，这是在软件演进过程中应对变化的关键所在。

[系统设计和架构-重构-重构手段-封装变量（Encapsulate Variable）](../系统设计和架构-重构-重构手段/系统设计和架构-重构-重构手段-封装变量（Encapsulate%20Variable）.md)



## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
