---
tags:
  - permanent
---
## 1. 核心观点  
### Ⅰ. 概念层

- [先写出可调优的软件，然后调优它以求获得足够的速度。](系统设计和架构-重构-重构与性能.md#先写出可调优的软件，然后调优它以求获得足够的速度。)
- [性能优化使用特定流程](#性能优化使用特定流程)
- [一个构造良好的程序可从两方面帮助这一优化方式](系统设计和架构-重构-重构与性能.md#一个构造良好的程序可从两方面帮助这一优化方式)
	- 代码清楚，理解时间的下降
	- 进行性能分析时便有较细的粒度

### Ⅱ. 应用层

	
### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
	- book-refactoring
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 先写出可调优的软件，然后调优它以求获得足够的速度。
- 虽然重构可能使软件运行更慢，但它也使软件的性能优化更容易。除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是：先写出可调优的软件，然后调优它以求获得足够的速度。
### 开发快速软件的方法
#### 时间预算法

- **硬约束：** 在设计阶段将系统总资源（CPU 时间、内存空间）强行拆解并分配给每个组件。
- **绝对边界：** 组件开发必须在预算内完成，不允许超出。延迟等同于系统失效。

- **成本高昂：** 需要极高的预先设计成本和极细颗粒度的资源监控。
- **缺乏弹性：** 无法利用组件间的闲置资源动态互补。
- **适用性窄：** 对于非实时系统（如企业信息系统），这种方法会导致开发进度极其缓慢，且往往是“过度设计”。

#### 持续关注法
- **直觉驱动：** 开发者基于对底层机制（编译器、硬件）的**主观臆测**，在业务逻辑中穿插各种所谓的“高性能写法”
- **碎片化：** 性能优化行为散落在代码库的各个角落，没有统一的视角。

负面影响（为何通常不起作用）
- **损害可维护性：** 为了微小的性能提升，牺牲了代码的清晰度和结构。复杂的逻辑导致后续重构和功能扩展变得极其困难。
- **认知偏见：** 程序员往往无法准确预判程序的性能瓶颈（90% 的性能损耗通常集中在 10% 的代码中）。
- **收益抵消：** 在错误的点进行优化，其效果往往被糟糕的架构设计（如频繁的数据库查询、不合理的算法）轻松抵消。


哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的。——Ron Jeffries

##### 90%的代码的优化都是白费劲

关于性能，一件很有趣的事情是：如果你对大多数程序进行分析，就会发现它把大半时间都耗费在一小半代码身上。如果你一视同仁地优化所有代码，90％的优化工作都是白费劲的，因为被你优化的代码大多很少被执行。你花时间做优化是为了让程序运行更快，但如果因为缺乏对程序的清楚认识而花费时间，那些时间就都被浪费掉了。

第三种性能提升法就是利用上述的 90%统计数据。采用这种方法时，我编写构造良好的程序，不对性能投以特别的关注，直至进入性能优化阶段——那通常是在开发后期。一旦进入该阶段，我再遵循特定的流程来调优程序性能。

#### 性能优化使用特定流程

**在性能优化阶段，我首先应该用一个度量工具来监控程序的运行**，让它告诉我程序中哪些地方大量消耗时间和空间。这样我就可以找出性能热点所在的一小段代码。然后我应该集中关注这些性能热点，并使用持续关注法中的优化手段来优化它们。由于把注意力都集中在热点上，较少的工作量便可显现较好的成果。即便如此，我还是必须保持谨慎。和重构一样，我会小幅度进行修改。每走一步都需要编译、测试，再次度量。如果没能提高性能，就应该撤销此次修改。我会继续这个“发现热点，去除热点”的过程，直到获得客户满意的性能为止。

##### 一个构造良好的程序可从两方面帮助这一优化方式

- 首先，它让我有**比较充裕的时间进行性能调整，因为有构造良好的代码在手**，我能够更快速地添加功能，也就有更多时间用在性能问题上（准确的度量则保证我把这些时间投在恰当地点）。
- 其次，面对构造良好的程序，**我在进行性能分析时便有较细的粒度。度量工具会把我带入范围较小的代码段中，而性能的调整也比较容易些**。由于代码更加清晰，因此我能够更好地理解自己的选择，更清楚哪种调整起关键作用。



## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
