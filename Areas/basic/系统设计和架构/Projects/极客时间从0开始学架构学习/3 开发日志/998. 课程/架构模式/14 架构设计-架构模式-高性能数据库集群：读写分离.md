---
tags:
  - note
---

## 1. 核心观点  

详细方案设计就是将方案涉及的关键技术细节给确定下来

## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 读写分离原理

读写分离的基本原理是将数据库读写操作分散到不同的节点上，下面是其基本架构图。
![](asserts/Pasted%20image%2020251213200849.png)

读写分离的基本实现是：数据库服务器搭建主从集群，一主一从、一主多从都可以。
- 数据库主机负责读写操作，从机只负责读操作。数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。
- 业务服务器将写操作发给数据库主机，将读操作发给数据库从机。

- 需要注意的是，这里用的是“主从集群”​，而不是“主备集群”​。​“从机”的“从”可以理解为“仆从”​，仆从是要帮主人干活的，​“从机”是需要提供读数据的功能的；而“备机”一般被认为仅仅提供备份功能，不提供访问功能。所以使用“主从”还是“主备”​，是要看场景的，这两个词并不是完全等同的。读写分离的实现逻辑并不复杂，但有两个细节点将引入设计复杂度：主从复制延迟和分配机制。

### 复制延迟

以MySQL为例，主从复制延迟可能达到1秒，如果有大量数据同步，延迟1分钟也是有可能的。

写入到数据库主服务器后立刻（1秒内）进行读取
- 主从复制延迟会带来一个问题：如果业务服务器将数据写入到数据库主服务器后立刻（1秒内）进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。例如，用户刚注册完后立刻登录，业务服务器会提示他“你还没有注册”​，而用户明明刚才已经注册成功了。
### 复杂度
#### 解决方案
1.**写操作后的读操作指定发给数据库主服务器**例如，注册账号完成后，登录时读取账号的读操作也发给数据库主服务器。这种方式**和业务强绑定，对业务的侵入和影响较大**，如果哪个新来的程序员不知道这样写代码，就会导致一个bug。

2.**读从机失败后再读一次主机这就是通常所说的“二次读取”​**，二次读取和业务无绑定，**只需要对底层数据库访问的API进行封装即可**，实现代价较小，不足之处在于**如果有很多二次读取，将大大增加主机的读操作压力**。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。

3.**关键业务读写操作全部指向主机，非关键业务采用读写分离例如**，对于一个用户管理系统来说，**注册+登录的业务读写操作全部访问主机，用户的介绍、爱好、等级等业务，可以采用读写分离**，因为即使用户改了自己的自我介绍，在查询时却看到了自我介绍还是旧的，业务影响与不能登录相比就小很多，还可以忍受。

### 分配机制

#### 1.程序代码封装

程序代码封装指**在代码中抽象一个数据访问层**（所以有的文章也称这种方式为“中间层封装”​）​，实现读写操作分离和数据库服务器连接的管理。例如，基于Hibernate进行简单封装，就可以实现读写分离，基本架构是：

![](asserts/Pasted%20image%2020251213201427.png)

程序代码封装的方式具备几个特点：
- 实现简单，而且可以根据业务做较多定制化的功能。
- 每个编程语言都需要自己实现一次，无法通用，如果一个业务包含多个编程语言写的多个子系统，则重复开发的工作量比较大。
- 故障情况下，如果主从发生切换，则可能需要所有系统都修改配置并重启。


目前开源的实现方案中，淘宝的TDDL（Taobao Distributed Data Layer，外号:头都大了）是比较有名的。它是一个通用数据访问层，所有功能封装在jar包中提供给业务代码调用。其基本原理是一个基于集中式配置的 jdbc datasource实现，具有主备、读写分离、动态数据库配置等功能，基本架构是：


![](asserts/Pasted%20image%2020251213201544.png)




#### 2.中间件封装

中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供SQL兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。其基本架构是：
![](asserts/Pasted%20image%2020251213201818.png)

数据库中间件的方式具备的特点是：

**能够支持多种编程语言**，因为数据库中间件对业务服务器提供的是标准SQL接口。数据库中间件要支持完整的SQL语法和数据库服务器的协议（例如，MySQL客户端和服务器的连接协议）​，实现比较复杂，细节特别多，很容易出现bug，需要较长的时间才能稳定。

数据库中间件自己不执行真正的读写操作，但**所有的数据库操作请求都要经过中间件，中间件的性能要求也很高**。

**数据库主从切换对业务服务器无感知**，数据库中间件可以探测数据库服务器的主从状态。例如，向某个测试表写入一条数据，成功的就是主机，失败的就是从机。

**由于数据库中间件的复杂度要比程序代码封装高出一个数量级，一般情况下建议采用程序语言封装的方式，或者使用成熟的开源数据库中间件**。如果是大公司，可以投入人力去实现数据库中间件，因为这个系统一旦做好，接入的业务系统越多，节省的程序开发投入就越多，价值也越大。

目前的开源数据库中间件方案中，MySQL官方先是提供了MySQL Proxy，但MySQL Proxy一直没有正式GA，现在MySQL官方推荐MySQL Router。MySQL Router的主要功能有读写分离、故障自动切换、负载均衡、连接池等，其基本架构如下：
![](asserts/Pasted%20image%2020251214103013.png)

奇虎360公司也开源了自己的数据库中间件Atlas，Atlas是基于MySQL Proxy实现的，基本架构如下：


![](asserts/Pasted%20image%2020251214103047.png)


Atlas是一个位于应用程序与MySQL之间中间件。在后端DB看来，Atlas相当于连接它的客户端，在前端应用看来，Atlas相当于一个DB。Atlas作为服务端与应用程序通信，它实现了MySQL的客户端和服务端协议，同时作为客户端与MySQL通信。它对应用程序屏蔽了DB的细节，同时为了降低MySQL负担，它还维护了连接池。

### 适合场景
#### 一、数据库读写分离的本质作用

**读写分离（Read/Write Splitting）**的核心目标只有一个：

> **把“写入一致性要求高的事务路径”和“读多写少的查询压力”在物理层面拆开**

其本质不是“高并发写”，而是：

- **缓解主库的读压力**
    
- **提升整体读吞吐**
    
- **延缓数据库成为系统瓶颈的时间点**
    

写仍然是**单点主库**。

#### 二、典型应用场景（什么情况下“值得上”）

#### 1️⃣ 读远大于写（Read >> Write）

这是**必要条件**，典型比例：

- 90% 读 / 10% 写
    
- 99% 读 / 1% 写
    

常见业务：

- 内容平台（文章、帖子、评论）
    
- 电商商品详情
    
- 用户资料、配置类数据
    
- 社交 Feed / Timeline（非强一致）
#### 2️⃣ 对“读一致性”要求可放宽

读写分离**天然引入复制延迟**：

- 主库写成功
    
- 从库稍后才可见
    

适合：

- **最终一致性**
    
- 秒级延迟可接受
    

不适合：

- 下单后立即查余额
    
- 强事务依赖的核心路径

#### 3️⃣ 单表 / 单库写 QPS 已接近上限

一个常见临界点：

- 主库 CPU / IO 已被 **大量 SELECT 打满**
    
- 但写 QPS 并不高
    

👉 读写分离是**最具性价比的第一步扩展**
#### 三、它能支撑多大的业务规模？（量级判断）
##### 1️⃣ 写能力上限（决定天花板）

读写分离 **不提升写能力**：

- 单主库写 QPS ≈
    
    - MySQL：几千 ～ 1~2 万（强依赖 schema / 事务）
        
    - 再往上 → 锁、日志、IO 成为瓶颈
        

👉 **写 QPS 决定系统最大规模**

---

##### 2️⃣ 读能力扩展性（理论上接近线性）

读可以通过加从库扩展：

- 1 主 + N 从
    
- 读 QPS ≈ 单机读能力 × N
    

现实中常见规模：

- **百万级 QPS 读**（内容型业务）
    
- 单个业务支撑 **DAU 百万～千万** 很常见
    

---

##### 3️⃣ 一个经验量级总结

|架构阶段|可支撑规模（粗略）|
|---|---|
|单库单机|日活 1～5 万|
|主从读写分离|日活 10 万～1000 万|
|分库分表|日活 千万～上亿|
|多活 / 分区|超大规模|

> 读写分离是**中等规模系统的“黄金阶段”**
#####  四、读写分离解决不了什么（非常重要）

#### ❌ 不能解决的问题

- 写热点（单行频繁更新）
- 强一致读需求
- 跨库事务
- 写扩展（横向）

#### ❌ 常见误区

- “上了读写分离就高并发了”
- “写慢了再加从库”
- “可以无限加从库”
👉 **写路径永远是瓶颈****
#### 五、架构演进中的“正确位置”
```
单库
 ↓
加缓存（Redis）
 ↓
读写分离   ←【性价比最高】
 ↓
分库分表
 ↓
服务拆分 / 多活

```

>为系统争取“时间窗口”，而不是终极方案

#### 总结

数据库读写分离适用于“读多写少、最终一致、写未成为瓶颈”的业务阶段，  
它能把读扩展到百万级 QPS，但写能力仍受限于单主库，天花板清晰、边界明确。

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
