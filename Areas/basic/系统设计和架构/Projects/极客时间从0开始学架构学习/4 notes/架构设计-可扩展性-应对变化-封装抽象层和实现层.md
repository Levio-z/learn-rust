---
tags:
  - permanent
---
## 1. 核心观点  

提炼出“抽象层”和“实现层”是一种**代码结构层面的设计原则**，核心思想是：

- **抽象层（Stable Abstraction Layer）**：定义稳定、通用的接口或规则，代表系统能力的抽象描述，长期不变。
    
- **实现层（Concrete Implementation Layer）**：根据业务需求提供具体实现，可自由扩展，不修改抽象层即可新增功能。
    

本质是**实现“开闭原则”**：对扩展开放，对修改封闭。


## 2. 背景/出处  

## 3. 展开说明  
### 原理

1. **稳定的抽象**
    - 将系统中最核心、最不可能改变的部分抽象成接口、trait、抽象类。
    - 抽象层只定义行为，不包含业务逻辑实现。
2. **可扩展的实现**
    - 每个具体实现遵循抽象层定义的接口。
    - 新增实现时，不修改抽象层，仅增加新的实现类。
3. **依赖反转原则**
    - 高层模块依赖抽象层，而不是具体实现。
    - 低层模块实现抽象层接口。
4. **组合而非修改**
    - 功能扩展通过增加新实现类或组合已有实现，而非修改抽象层。

抽象层是稳定的，**实现层可以根据具体业务需要定制开发，当加入新的功能时，只需要增加新的实现，无须修改抽象层**。这种方案典型的实践就是设计模式和规则引擎。考虑到绝大部分技术人员对设计模式都非常熟悉，我以设计模式为例来说明这种方案的复杂性。


以设计模式的“装饰者”模式来分析，下面是装饰者模式的类关系图。

[1.0 装饰器模式](../../../../../../Projects/设计模式/23经典设计模式/结构型/装饰器模式/1.0%20装饰器模式.md)

![](asserts/Pasted%20image%2020251115095117.png)

### 抽象的规则
图中的 Component 和 Decorator 就是抽象出来的规则，这个规则包括几部分：
这个规则一旦抽象出来后就固定了，不能轻易修改。例如，把规则 3 去掉，就无法实现装饰者模式的目的了。

1.Component和Decorator类。
2.Decorator类继承Component类。 
3.Decorator类聚合了Component类。

这个规则一旦抽象出来后就固定了，不能轻易修改。例如，把规则 3 去掉，就无法实现装饰者模式的目的了。
### 抽象总结

装饰者模式相比传统的继承来实现功能，确实灵活很多。例如，《设计模式》中装饰者模式的样例“TextView”类的实现，用了装饰者之后，能够灵活地给 TextView 增加额外更多功能，比如可以增加边框、滚动条、背景图片等，这些功能上的组合不影响规则，只需要按照规则实现即可。但装饰者模式相对普通的类实现模式，明显要复杂多了。本来一个函数或者一个类就能搞定的事情，现在要拆分成多个类，而且多个类之间必须按照装饰者模式来设计和调用。

规则引擎和设计模式类似，都是通过灵活的设计来达到可扩展的目的，但“灵活的设计”本身就是一件复杂的事情，不说别的，光是把 23 种设计模式全部理解和备注，都是一件很困难的事情。

## 4. 与其他卡片的关联  
- 前置卡片：
	- [架构设计-可扩展性-基本概念](架构设计-可扩展性-基本概念.md)
- 后续卡片：
	- [架构设计-规则引擎](架构设计-规则引擎.md)
	- [1.0 装饰器模式](../../../../../../Projects/设计模式/23经典设计模式/结构型/装饰器模式/1.0%20装饰器模式.md)
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
