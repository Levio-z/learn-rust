---
tags:
  - permanent
---
## 1. 核心观点  

简单原则宣言：​“简单优于复杂”​。

- 组件复杂性
	- 组成复杂系统的组件数量更多；
	- 同时这些组件之间的关系也更加复杂。
	- 问题：
		- 第一个问题是**组件越多，就越有可能其中某个组件出现故障，从而导致系统故障**。
		- 第二个问题是，**某个组件改动，会影响关联的所有组件，这些被影响的组件同样会继续递归影响更多的组件**。
		- 第三个问题是，**定位一个复杂系统中的问题总是比简单系统更加困难**
	- 我的理解：
		- 清晰或减少组件之间的关联
- 逻辑的复杂性
	- 耦合性强
		- 一次修改，系统全盘崩溃
		- 冲突和合并增多
		- 上线会互相影响
	- 算法复杂性
		- 复杂算法导致的问题**主要是难以理解，进而导致难以实现、难以修改，并且出了问题难以快速解决**。
	- 为什么复杂的电路就意味更强大的功能，而复杂的架构却有很多问题呢？
		- **根本原因在于电路一旦设计好后进入生产，就不会再变，复杂性只是在设计时带来影响；而一个软件系统在投入使用后，后续还有源源不断的需求要实现，因此要不断地修改系统，复杂性在整个系统生命周期中都有很大影响**。
## 2. 背景/出处  

## 3. 展开说明  

软件架构设计是一门技术活。所谓技术活，从历史上看，无论是瑞士的钟表，还是瓦特的蒸汽机；无论是莱特兄弟发明的飞机，还是摩托罗拉发明的手机，无一不是越来越精细、越来越复杂。因此当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也才能够将架构做成一件艺术品。

由于软件架构和建筑架构表面上的相似性，我们也会潜意识地将对建筑的审美观点移植到软件架构上面。我们惊叹于长城的宏伟、泰姬陵的精美、悉尼歌剧院的艺术感、迪拜帆船酒店的豪华感，因此，对于我们自己亲手打造的软件架构，我们也希望它宏伟、精美、艺术、豪华……总之就是不能寒酸、不能简单。

团队的压力有时也会有意无意地促进我们走向复杂的方向，因为**大部分人在评价一个方案水平高低的时候，复杂性是其中一个重要的参考指标**。例如设计一个主备方案，如果你用心跳来实现，可能大家都认为这太简单了。但如果你引入ZooKeeper来做主备决策，可能很多人会认为这个方案更加“高大上”一些，毕竟ZooKeeper使用的是ZAB协议，而ZAB协议本身就很复杂。其实，**真正理解ZAB协议的人很少（我也不懂）​，但并不妨碍我们都知道ZAB协议很优秀**。

刚才我聊的这些原因，会在潜意识层面促使初出茅庐的架构师，**不自觉地追求架构的复杂性**。然而，​“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”​。

### 软件领域的复杂性体现在两个方面：
#### 1.结构的复杂性
结构复杂的系统几乎毫无例外具备两个特点：
组成复杂系统的组件数量更多；
同时这些组件之间的关系也更加复杂。
我以图形的方式来说明复杂性：
2个组件组成的系统：
![](asserts/Pasted%20image%2020251118111847.png)


3个组件组成的系统：
![](asserts/Pasted%20image%2020251118111857.png)

5个组件组成的系统：
![](asserts/Pasted%20image%2020251118111911.png)

结构上的复杂性存在的

##### 第一个问题是**组件越多，就越有可能其中某个组件出现故障，从而导致系统故障**。

这个概率可以算出来，假设组件的故障率是10%（有10%的时间不可用）​，那么有3个组件的系统可用性是（1-10%）×（1-10%）×（1-10%）= 72.9%，有5个组件的系统可用性是（1-10%）×（1-10%）×（1-10%）×（1-10%）×（1-10%）=59%，两者的可用性相差13%。

##### **结构上的复杂性存在的第二个问题是，某个组件改动，会影响关联的所有组件**，这些被影响的组件同样会继续递归影响更多的组件。

还以上面图中5个组件组成的系统为例，组件A修改或者异常时，会影响组件B/C/E，D又会影响E。这个问题会影响整个系统的开发效率，因为一旦变更涉及外部系统，需要协调各方统一进行方案评估、资源协调、上线配合。

##### 结构上的复杂性存在的第三个问题是，定位一个复杂系统中的问题总是比简单系统更加困难。

首先是组件多，每个组件都有嫌疑，因此要逐一排查；其次组件间的关系复杂，有可能表现故障的组件并不是真正问题的根源。

#### 2.逻辑的复杂性

意识到结构的复杂性后，我们的第一反应可能就是“降低组件数量”​，毕竟组件数量越少，系统结构越简。最简单的结构当然就是整个系统只有一个组件，即系统本身，所有的功能和逻辑都在这一个组件中实现。

不幸的是，这样做是行不通的，原因在于除了结构的复杂性，**还有逻辑的复杂性，即如果某个组件的逻辑太复杂，一样会带来各种问题。**

逻辑复杂的组件，一个典型特征就是单个组件承担了太多的功能。以电商业务为例，常见的功能有：商品管理、商品搜索、商品展示、订单管理、用户管理、支付、发货、客服……把这些功能全部在一个组件中实现，就是典型的逻辑复杂性。

逻辑复杂几乎会导致软件工程的每个环节都有问题，假设现在淘宝将这些功能全部在单一的组件中实现，可以想象一下这个恐怖的场景：

系统会很庞大，可能是上百万、上千万的代码规模，​“clone”一次代码要30分钟。

几十、上百人维护这一套代码，**某个“菜鸟”不小心改了一行代码，导致整站崩溃**。
- 需求像雪片般飞来，为了应对，开几十个代码分支，**然后各种分支合并、各种分支覆盖**。
- 产品、研发、测试、项目管理不停地开会讨论版本计划，协调资源，解决冲突。
- 版本太多，**每天都要上线几十个版本，系统每隔1个小时重启一次**。
- **线上运行出现故障，几十个人扑上去定位和处理**，一间小黑屋都装不下所有人，整个办公区闹翻天。

但是，为什么复杂的电路就意味更强大的功能，而复杂的架构却有很多问题呢？**根本原因在于电路一旦设计好后进入生产，就不会再变，复杂性只是在设计时带来影响；而一个软件系统在投入使用后，后续还有源源不断的需求要实现，因此要不断地修改系统，复杂性在整个系统生命周期中都有很大影响**。

功能复杂的组件，另外一个典型特征就是采用了复杂的算法。复杂算法导致的问题**主要是难以理解，进而导致难以实现、难以修改，并且出了问题难以快速解决**。

以ZooKeeper为例，ZooKeeper本身的功能主要就是选举，为了实现分布式下的选举，采用了ZAB协议，所以ZooKeeper功能虽然相对简单，但系统实现却比较复杂。相比之下，etcd就要简单一些，因为etcd采用的是Raft算法，相比ZAB协议，Raft算法更加容易理解，更加容易实现。

综合前面的分析，我们可以看到，无论是结构的复杂性，还是逻辑的复杂性，都会存在各种问题，所以架构设计时如果简单的方案和复杂的方案都可以满足需求，最好选择简单的方案。​《UNIX编程艺术》总结的KISS（Keep It Simple, Stupid!）原则一样适应于架构设计。




## 4. 与其他卡片的关联  
- 前置卡片：
	- [架构设计-三原则-基本概念](架构设计-三原则-基本概念.md)
- 后续卡片：
	- 
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
