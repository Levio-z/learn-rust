---
tags:
  - note
---
## 1. 核心观点  

计算机内部复杂度**最关键的地方就是操作系统**。
- 性能由硬件驱动->发挥硬件性能的关键是操作系统->操作系统是软件系统的运行环境->操作系统的复杂度直接决定了软件系统的复杂度
- => 操作系统和性能**最相关的就是进程和线程**。
- =>**解决手工操作带来的低效**，监控程序负责代替手工操作和尽量减少任务切换的批处理作业运作方式的批处理系统
- =>**一个任务因io卡住，其他程序不能利用cpu，进程概念诞生**，多道批处理系统，让多个程序在内存中。
- =>**任务之间会通信，任务设计会更高效**
	- 两个任务之间能够在运行过程中就进行通信，会让任务设计变得更加灵活高效。**进程间通信的各种方式**被设计出来了。
- =>**多进程内部的子任务也需要并行，线程被设计出来**
	- 多进程让多任务能够并行处理任务，但本身还有缺点，单个进程内部只能串行处理，而实际上很**多进程内部的子任务**并不要求是严格按照时间顺序来执行的，**也需要并行处理**。为了解决这个问题，人们又发明了线程，线程是进程内部的子任务，但这些子任务都共享同一份进程数据。
	- 多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到**时间上真正的并行**。
- =>**怎么做到时间上真正的并行，让多个 CPU 能够同时执行计算任务**
	- SMP（Symmetric Multi-Processor，对称多处理器结构）、NUMA（Non-Uniform Memory Access，非一致存储访问结构）、MPP（Massive Parallel Processing，海量并行处理结构）。
	- 其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP 方案。
- =>如果我们要完成一个高性能的软件系统，需要考虑如**多进程、多线程、进程间通信、多线程并发**等技术点，而且这些技术并不是最新的就是最好的，也不是非此即彼的选择。
	- 在做架构设计的时候，需要花费很大的精力来结合业务进行**分析、判断、选择、组合**，这个过程同样很复杂。举一个最简单的例子：Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程，这些系统都实现了高性能，但内部实现差异却很大。
-  演进过程参考：[1.2 什么是操作系统](../../../../../../../../Projects/开源操作系统训练营/2025春夏/第二阶段：rcore/rCore-Turial-note/1.0%20操作系统概述/1.2%20什么是操作系统.md)中的演变，

## 2. 背景/出处  

## 3. 展开说明  




## 4. 与其他卡片的关联  
- 前置卡片：
	- [04 复杂性来源-高性能](../../../3%20开发日志/998.%20课程/04%20复杂性来源-高性能.md)
- 后续卡片：
	- 
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
