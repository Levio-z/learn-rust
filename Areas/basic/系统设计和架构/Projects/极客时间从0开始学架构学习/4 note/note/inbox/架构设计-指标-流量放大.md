---
tags:
  - fleeting
---
## 1. 核心观点  
### Ⅰ. 概念层

流量放大是指：**一个用户级请求 / 页面访问，在系统内部被拆解、复制或级联，最终形成多倍的系统请求量**。

**本质**
- 从 **业务事件 → 系统事件** 的映射放大
- 属于**结构性放大**，不是异常
    

**核心公式**

系统总 QPS=入口 QPS×放大系数


### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明 
### 放大的主要来源

**1️⃣ 页面资源放大**

- HTML / CSS / JS / 图片 / 字体
    
- 1 PV → 多个 HTTP 请求
    

**2️⃣ 前后端分离放大**

- 1 页面 → N 个 API
    
- SPA 中 5–20 个 API 非常常见
    

**3️⃣ 服务拆分放大（微服务）**

- 1 外部 API → N 个内部 RPC
    
- 典型 2–10 倍
    

**4️⃣ 重试与超时放大**

- 网络抖动 / 超时
    
- 客户端、网关、SDK 可能同时重试
### 放大系数

| 架构形态       | 放大倍数   |
| ---------- | ------ |
| 单体 + MPA   | 1–2×   |
| 前后端分离      | 3–5×   |
| 微服务        | 5–10×  |
| 微服务 + 重试失控 | 10–30× |

### 放大不可见但可致命

**典型现象**

- 入口 QPS 看起来不高
    
- 下游 DB / RPC 被打爆
    

**原因**

- 放大发生在 **系统内部**
    
- 监控只盯入口
    

**工程原则**

> **容量评估必须看“全链路 QPS”**


### 放大与缓存的关系


**缓存的作用**

- 不是消灭请求
    
- 而是**阻断放大链路**
    

**示例**

- 命中缓存：1 请求
    
- 未命中：RPC + DB
    

**结论**

> **缓存命中率每提升 10%，系统放大量可能下降一个数量级**


### 放大的可控与不可控
**可控放大**

- 接口拆分粒度
    
- BFF / API 聚合
    
- 缓存设计
    

**不可控放大**

- 网络抖动
    
- 超时 + 重试风暴
    
- 雪崩场景

### 放大的工程对策
**结构性对策**

- BFF 聚合接口
    
- 降低服务依赖深度
    
- 合理接口粒度
    

**运行时对策**

- 限流
    
- 熔断
    
- 退避重试


## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：
	- 

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
