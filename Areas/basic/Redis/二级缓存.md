```java
import com.google.common.cache.*;
import org.apache.commons.lang3.StringUtils;

import java.util.concurrent.*;
import java.util.function.Function;

/**
 * 通用本地缓存封装，支持：
 * 1. 本地缓存自动加载
 * 2. 异步二级缓存写入（可选）
 * 3. 空值防护，防止缓存穿透
 * 
 * @param <K> Key 类型
 * @param <V> Value 类型
 */
public class GenericLoadingCache<K, V> {

    private final LoadingCache<K, V> cache;

    /**
     * @param maxSize        本地缓存最大条数
     * @param expireMinutes  过期时间（分钟），基于访问
     * @param loader         数据加载函数，传入 Key 返回 Value
     * @param emptyValue     空值标记，防止缓存穿透
     */
    public GenericLoadingCache(long maxSize, long expireMinutes,
                               Function<K, V> loader, V emptyValue) {

        this.cache = CacheBuilder.newBuilder()
                .maximumSize(maxSize)
                .expireAfterAccess(expireMinutes, TimeUnit.MINUTES)
                .removalListener((RemovalListener<K, V>) notification -> {
                    K key = notification.getKey();
                    V value = notification.getValue();
                    if (emptyValue != null && emptyValue.equals(value)) {
                        System.out.println("缓存空值被移除 key=" + key);
                    } else if (value != null) {
                        System.out.println("缓存数据被移除 key=" + key + " value=" + value);
                    }
                })
                .build(new CacheLoader<>() {
                    @Override
                    public V load(K key) {
                        try {
                            V value = loader.apply(key);

                            if (value == null || (emptyValue != null && emptyValue.equals(value))) {
                                // 返回空值标记
                                return emptyValue;
                            }
                            return value;
                        } catch (Exception e) {
                            System.err.println("加载缓存失败 key=" + key);
                            e.printStackTrace();
                            return emptyValue;
                        }
                    }
                });
    }

    /**
     * 获取缓存数据
     */
    public V get(K key) {
        try {
            return cache.get(key);
        } catch (ExecutionException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 手动刷新指定 key
     */
    public void refresh(K key) {
        cache.refresh(key);
    }

    /**
     * 清空所有缓存
     */
    public void clear() {
        cache.invalidateAll();
    }
}


```



| 情况    | Redis TTL | 说明                               |
| ----- | --------- | -------------------------------- |
| 数据存在  | 6 小时      | 数据存在且相对稳定，允许较长时间缓存，减少 DB 访问      |
| 数据不存在 | 2 小时      | 空值标记用于防止缓存穿透，不希望缓存太久，避免长期阻塞新数据写入 |

- 本地缓存的主要作用是 **减少 Redis 访问**，降低网络延迟。
- 本地缓存时间可以短于 Redis，保证热点数据在本地快速访问，同时允许数据更新（Redis TTL 6 小时）后刷新本地缓存。
- 本地缓存还需要设置限制，占据虚拟机缓存。
- 本地缓存 TTL 不宜太长，否则会导致，数据过期策略失效，数据可能不再使用
