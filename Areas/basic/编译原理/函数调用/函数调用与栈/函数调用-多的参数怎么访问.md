---
tags:
  - permanent
---

## 1. 核心观点  
### Ⅰ. 概念层

callee 通过 `FP / SP + 偏移` 就能访问调用者压栈的多余参数。

### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
### 初始设置｜栈上传递参数的访问机制

当 **函数参数超过寄存器可用数量**，多余参数被 **压栈**，调用者（callee）访问这些参数的方式如下。

---

### 1️⃣ 栈上参数存放位置

假设 RISC-V 64，函数调用：

```c
void bar(int a0,int a1,int a2,int a3,int a4,int a5,int a6,int a7,int a8,int a9);
```

调用时：

1. **前 8 个参数**：放寄存器 `a0 ~ a7`
2. **第 9、10 个参数**：
    - 压入调用者栈（caller stack frame）
    - 栈从高地址向低地址增长
    - 栈顶就是当前 sp，压栈顺序按照 ABI 规定（通常先压 a8，再压 a9，低地址存 a9，高地址存 a8）

> 注意：此时 sp 指向“栈顶”，即 a9 所在的地址，a8 在它上方。
---

### 2️⃣ 被调用者（callee）如何访问

callee 的序言（prologue）：
```asm
addi sp, sp, -frame_size    # 分配自己的栈帧
sd s0, offset(sp)           # 保存 callee-saved 寄存器
```

- **frame pointer（fp / s0）** 指向 **当前函数栈帧顶端或基准点**
- 栈上参数位于 **调用者栈帧区域**，在 callee 栈帧“之下”

访问方式：

```asm
# 假设 s0 = fp = 当前函数帧顶端
ld t0, offset(s0)   # 取栈上第9个参数
ld t1, offset(s0+8) # 取栈上第10个参数
```

- `offset` = ABI 规定的偏移量（callee 通过 FP + 常数或 SP + 常数访问）
- 栈上参数是 **调用者压入的**，callee 不需要自己压入，只需知道偏移。
---

### 3️⃣ 图示理解

假设栈地址从高到低：
```
高地址
-------------
| caller ra    |
| caller fp    |
| a8           | <-- 栈上第9个参数
| a9           | <-- 栈顶
-------------
低地址 (sp)
```
- callee 分配自己的栈帧后：
```
高地址
-------------
| callee saved s0 |
| local vars      |
| ...             |
| a8 (from caller)| <-- FP + offset
| a9 (from caller)| <-- FP + offset
-------------
低地址 (sp)
```

> callee 通过 `FP / SP + 偏移` 就能访问调用者压栈的多余参数。
---

### 4️⃣ 关键点

1. **栈上参数属于调用者**，callee 只读访问即可。
    
2. **FP / SP** 提供稳定基准：
    
    - FP 指向当前函数栈帧顶端
        
    - 通过固定偏移访问栈上参数
        
3. **ABI 规定偏移和顺序**：
    
    - 必须一致，否则参数传递错误
        
4. **优化**：
    
    - 编译器可将栈上参数复制到寄存器，提高访问速度
        

---

### 总结｜方法论｜练习｜重点

**总结**

- 多余参数由 **调用者压栈**
    
- 被调函数通过 **FP/SP + 固定偏移** 访问
    
- 栈上参数属于调用者栈帧，callee 无需自己再压入
    

**方法论**

1. 熟悉 ABI 对寄存器数量、参数顺序和栈布局的规定
    
2. 理解 FP/SP 是访问栈上参数的统一基准
    
3. 调试时观察 sp/fp 偏移即可定位栈上参数
    

**练习**

1. 写 10+ 参数的函数，观察前 8 个在寄存器，第 9+10 个在栈
    
2. gdb 打断点，打印 fp+offset，确认栈上参数
    
3. 修改参数顺序，观察偏移变化
    

**高价值底层知识**

- 调用约定（ABI）对寄存器和栈传参的管理
    
- 栈帧布局与 FP/SP 偏移访问
    
- 调用者/被调者责任划分（caller push / callee read）
## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 深入阅读 xxx  
- [ ] 验证这个观点的边界条件  
