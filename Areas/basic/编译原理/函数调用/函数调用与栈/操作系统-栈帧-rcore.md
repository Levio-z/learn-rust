我们知道程序在执行函数调用时，调用者函数和被调用函数使用的是同一个栈。在通常的情况下，我们并不需要区分调用者函数和被调用函数分别使用了栈的哪个部分。但是，当我们需要在执行过程中对函数调用进行调试或backtrace的时候，这一信息就很重要了。简单的说，栈帧（stack frame）就是一个函数所使用的栈的一部分区域，所有函数的栈帧串起来就组成了一个完整的函数调用栈。一般而言，当前执行函数的栈帧的两个边界分别由**栈指针 (Stack Pointer)寄存器和栈帧指针（frame pointer）寄存器**来限定。

![](asserts/Pasted%20image%2020250909195746.png)
函数调用与栈帧：如图所示，我们能够看到在程序依次调用 a、调用 b、调用 c、c 返回、b 返回整个过程中栈帧的分配/回收以及 `sp` 寄存器的变化。 图中标有 a/b/c 的块分别代表函数 a/b/c 的栈帧。


**数据结构中的栈与实现函数调用所需要的栈**

从数据结构的角度来看，栈是一个 **后入先出** (Last In First Out, LIFO) 的线性表，支持向栈顶压入一个元素以及从栈顶弹出一个元素两种操作，分别被称为 push 和 pop。从它提供的接口来看，它只支持访问栈顶附近的元素。因**此在实现的时候需要维护一个指向栈顶的指针来表示栈当前的状态**。

我们这里的栈与数据结构中的栈原理相同，在很多方面可以一一对应。栈指针 `sp` 可以对应到指向栈顶的指针，对于栈帧的分配/回收可以分别对应到 `push` / `pop` 操作。如果将我们的栈看成一个内存分配器，**它之所以可以这么简单，是因为它回收的内存一定是 _最近一次分配_ 的内存，从而只需要类似 `push` / `pop` 的两种操作即可**。

在合适的编译选项设置之下，一个函数的栈帧内容可能如下图所示：

![](asserts/Pasted%20image%2020250909200022.png)

函数栈帧中的内容

它的开头和结尾分别在 sp(x2) 和 fp(s0) 所指向的地址。按照地址从高到低分别有以下内容，它们都是通过 `sp` 加上一个偏移量来访问的：

- `ra` 寄存器保存其返回之后的跳转地址，是一个被调用者保存寄存器；
- 父亲栈帧的结束地址 `fp` ，是一个被调用者保存寄存器；
- 其他被调用者保存寄存器 `s1` ~ `s11` ；
- 函数所使用到的局部变量。


因此，栈上多个 `fp` 信息实际上保存了一条完整的函数调用链，通过适当的方式我们可以实现对函数调用关系的跟踪。

`ra` 、 `sp` 和 `fp` 是和函数调用紧密相关的寄存器，我们用一个例子来展示真实编译器生成的汇编代码会如何使用这些寄存器。首先，无论对于内核本身还是第二章后出现的应用程序，我们修改 `.cargo/config` :

```rust
// .cargo/config

[build]
target = "riscv64gc-unknown-none-elf"

[target.riscv64gc-unknown-none-elf]
rustflags = [
    "-Clink-args=-Tsrc/linker.ld", "-Cforce-frame-pointers=yes"
]

```
这可以设置我们的默认编译目标，同时调整编译选项，设置链接脚本以及强制打开 `fp` 选项，这样才会避免 `fp` 相关指令被编译器优化掉。随后，我们可以使用 `rust-objdump` 工具反汇编内核或者应用程序可执行文件，并找到某个函数的入口。然后，我们能够看到在函数的开场和结尾阶段，编译器会生成类似的汇编代码：

```
# 开场
# 为当前函数分配 64 字节的栈帧
addi        sp, sp, -64
# 将 ra 和 fp 压栈保存
sd  ra, 56(sp)
sd  s0, 48(sp)
# 更新 fp 为当前函数栈帧顶端地址
addi        s0, sp, 64

# 函数执行
# 中间如果再调用了其他函数会修改 ra

# 结尾
# 恢复 ra 和 fp
ld  ra, 56(sp)
ld  s0, 48(sp)
# 退栈
addi        sp, sp, 64
# 返回，使用 ret 指令或其他等价的实现方式
ret
```
- `addi sp, sp, -64`
    - 作用：为当前函数分配 **64 字节** 的栈帧空间（栈向下增长）。
    - 计算：`sp_new = sp_old + (-64)` → `sp_new = sp_old - 64`。
    - 结果：之后所有以 `sp` 为基准的内存访问都以 `sp_new` 为基准。
    - 目标 源 立即数
- `sd ra, 56(sp)`
    - 指令语义：将寄存器 `ra` 的 8 字节（RV64）内容存到地址 `sp + 56`（即 `sp_new + 56`）。
    - 偏移计算：`sp_new + 56 = (sp_old - 64) + 56 = sp_old - 8`。（计算分步：`-64 + 56 = -8`）
    - 等价位置：用帧指针 `s0` 表示（下面会设置 `s0 = sp + 64 = sp_old`），该地址就是 `fp - 8`。
    - 含义：把当前函数的返回地址保存到栈上，防止它在本函数中调用其他函数时被覆盖（`jal` 会改写 `ra`）。
- `sd s0, 48(sp)`
    - 指令语义：把旧的帧指针（`s0`）保存到 `sp + 48`（即 `sp_old - 16`）。
    - 偏移计算：`sp_new + 48 = (sp_old - 64) + 48 = sp_old - 16`（`-64 + 48 = -16`）。
    - 等价位置：`fp - 16`。保存旧 `fp` 以便函数返回时恢复父帧链。
- `addi s0, sp, 64`
    - 作用：将新的帧指针设为 `sp + 64`（即 `s0 = sp_new + 64 = sp_old`）。
    - 解释：`s0`（frame pointer, fp）**被设成进入本函数前的 `sp` 值，之后可以通过 `s0`（或 `fp`）以固定偏移访问保存的寄存器和局部变量。**
    - 确认：`s0 = sp_old`，因此之前保存的 `ra` 在 `s0 - 8`，旧 `s0` 在 `s0 - 16`。
- （函数体：可能有局部变量、溢出寄存器或对别的函数的调用）
    - 说明：如果本函数再次调用其它函数，`ra` 会被覆盖，但因为已将 `ra` 存到 `fp - 8`（即 `sp + 56`），退出时可恢复正确返回地址。
- `ld ra, 56(sp)`
    - 作用：从 `sp + 56` 加载先前保存的 `ra` 回寄存器，用于恢复返回地址。偏移同上，等于 `fp - 8`。
- `ld s0, 48(sp)`
    - 作用：恢复父函数的帧指针（`s0`），使 `fp` 链回到上一级。
- `addi sp, sp, 64`
    - 作用：释放栈帧，`sp` 恢复为 `sp_old`（因为 `sp_new + 64 = sp_old`）。 
- `ret`
    - 语义：伪指令，等价于 `jalr x0, 0(ra)`（或 `jalr x0, 0(x1)`），直接跳转到 `ra` 中的地址并返回调用者。

至此，我们基本上说明了函数调用是如何基于栈来实现的。不过我们可以暂时先忽略掉这些细节，因为我们现在只是需要在初始化阶段完成栈的设置，也就是设置好栈指针 `sp` 寄存器，编译器会帮我们自动完成后面的函数调用相关机制的代码生成。麻烦的是， `sp` 的值也不能随便设置，至少我们需要保证它指向合法的物理内存，而且不能与程序的其他代码、数据段相交，因为在函数调用的过程中，栈区域里面的内容会被修改。如何保证这一点呢？

### 基本调用示例



- 调用过程：
	- 调用者保存返回地址和寄存器到栈
	- 压入局部变量
	- 压入被调用函数参数
	- 执行函数调用
- 栈帧结构：每个函数调用形成独立的栈帧，大小固定
- 参数传递：通过栈传递参数和返回值