1. **Prologue（序言/开始部分）**：
    - 函数的prologue是函数体开始时执行的代码，通常包括以下几个步骤：
        - 保存旧的栈帧基址。在x86架构中，这通常通过将当前栈顶指针`ESP`（或在x86-64中是`RSP`）压入栈来完成。
        - 调整栈指针以分配新的栈帧。这可能涉及到将栈指针减去一定数值来为局部变量腾出空间。
        - 保存寄存器。如果函数需要修改某些寄存器的值，而这些寄存器的原始值需要在函数返回后仍然可用，则需要将这些寄存器的值压入栈中保存。
    - Prologue的目的是为了设置函数的执行环境，包括为局部变量分配空间和保存必要的寄存器状态。
2. **Epilogue（结束部分）**：
    - 函数的epilogue是函数体结束前执行的代码，通常执行以下操作：
        - 恢复寄存器状态。这可能涉及到将之前保存在栈中的寄存器值恢复到它们的原始状态。
        - ld s0, 48(sp)，恢复栈指针。撤销在prologue中对栈指针所做的调整，以便栈指针指向函数调用前的栈顶。
        - ld ra, 56(sp)，从栈中弹出返回地址（如果使用了`call`或`ret`指令）。
        - 最后，执行`ret`指令返回到调用者。
    - Epilogue的目的是清理函数的执行环境，确保调用者的环境没有被破坏，并且正确地将控制权返回给调用者。
3. **调用约定**：
    - 函数的prologue和epilogue的实现细节可能会根据使用的调用约定（calling convention）而有所不同。调用约定定义了函数参数如何传递、哪些寄存器是易失的（可能会被破坏），以及哪些是持久的（需要被保存）。
4. **重要性**：
    - 正确编写prologue和epilogue对于确保程序的正确性和性能至关重要。它们确保了函数调用的栈平衡，以及寄存器状态的正确保存和恢复。
5. **汇编语言中的实现**：
    - 在汇编语言中，程序员需要手动编写prologue和epilogue代码。这要求对底层硬件和调用约定有深入的理解。
6. **高级语言中的抽象**：
    - 在大多数高级编程语言中，编译器会自动生成prologue和epilogue代码，从而抽象出这些底层细节，让程序员能够更专注于业务逻辑。
## 1. 核心观点  
### Ⅰ. 概念层



### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  
详细阐述这个观点，包括逻辑、例子、类比。  
- 要点1  
- 要点2  

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  
