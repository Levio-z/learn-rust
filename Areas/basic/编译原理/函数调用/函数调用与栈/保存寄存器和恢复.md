[函数调用-rcore](函数调用-rcore.md)
**=>ra寄存器需要在调用子函数前后保持不变，否则就会跳转到错误的位置，他不能被覆盖**
- 由于我们是在 ra 寄存器中保存返回地址的，我们**要保证它在函数执行的全程不发生变化，不然在 ret 之后就会跳转到错误的位置**。事实上编译器除了函数调用的相关指令之外确实基本上不使用 ra 寄存器。也就是说，如果在函数中没有调用其他函数，那 ra 的值不会变化，函数调用流程能够正常工作。但遗憾的是，在实际编写代码的时候我们常常会遇到函**数多层嵌套调用 的情形。我们很容易想象，如果函数不支持嵌套调用，那么编程将会变得多么复杂**。如果我们试图在一个函数中调用一个子函数，**在跳转到子函数 的同时，ra 会被覆盖成这条跳转指令的下一条的地址，而 ra 之前所保存的函数 的返回地址将会 永久丢失** 。

**=>不仅仅ra寄存器，其他寄存器也可能被影响，所以也需要在调用子函数前后保持不变，这些寄存器集成为函数调用上下文**
因此，若想正确实现嵌套函数调用的控制流，我们必须通过某种方式保证：在一个函数调用子函数的前后，ra 寄存器的值不能发生变化。但实际上，这并不仅仅局限于 ra 一个寄存器，而是作用于所有的通用寄存器。这是因为，编译器是独立编译每个函数的，因此一个函数并不能知道它所调用的子函数修改了哪些寄存器。而站在一个函数的视角，在**调用子函数的过程中某些寄存器的值被覆盖的确会对它接下来的执行产生影响**。因此这是必要的。我们将由于函数调用，在控制流转移前后**需要保持不变的寄存器集合称之为 函数调用上下文 (Function Call Context) 。**

**=>由于每个 CPU 只有一套寄存器，我们若想在子函数调用前后保持函数调用上下文不变，就需要物理内存的帮助**。
- 确切的说，在**调用子函数之前**，我们需要在物理内存中的一个区域 **保存 (Save) 函数调用上下文中的寄存器**；
- 而在**函数执行完毕后**，我们会从内存中同样的区域读取并 **恢复 (Restore) 函数调用上下文中的寄存器**。
- 实际上，这一工作是由子函数的调用者和被调用者（也就是子函数自身）合作完成。
函数调用上下文中的寄存器被分为如下两类：
- **被调用者保存(Callee-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要被**调用的函数来保存的寄存器，即由被调用的函数来保证在调用前后，这些寄存器保持不变**；
	- 被调用函数：在被调用函数的起始，先保存函数执行过程中被用到的 **被调用者保存寄存器** ，然后执行函数，最后在函数退出之前恢复这些寄存器。
- **调用者保存(Caller-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要发**起调用的函数来保存的寄存器，即由发起调用的函数来保证在调用前后，这些寄存器保持不变**。
	-  调用函数：首先保存不希望在函数调用过程中发生变化的 **调用者保存寄存器** ，然后通过 jal/jalr 指令调用子函数，返回之后恢复这些寄存器。


我们发现无论是调用函数还是被调用函数，都会因调用行为而需要**两段匹配的保存和恢复寄存器的汇编代码，可以分别将其称为 开场 (Prologue) 和 结尾 (Epilogue)**，它们会**由编译器帮我们自动插入，来完成相关寄存器的保存与恢复**。一个函数既有可能作为调用者调用其他函数，也有可能作为被调用者被其他函数调用。


> **寄存器保存与编译器优化**
> 
> 这里值得说明的是，调用者和被调用者实际上只需分别按需保存调用者保存寄存器和被调用者保存寄存器的一个子集。
> 对于**调用函数而言**，在调用子函数的时候，即使**子函数修改了调用者保存寄存器**，编译器在调用函数中插入的代码会恢复这些寄存器；
> **保存的必要性**取决于两个条件：    
        1. 调用者后续会用到这个寄存器。    
        2. callee（子函数）可能会修改这个寄存器。    
   **优化情况**：
		3. 如果调用者**之后不会再用这个寄存器**，根本不需要保存/恢复。
		4. 如果 callee 根本不修改这个寄存器，也不需要保存/恢复。
> 而对于被调用函数而言，在其执行过程中没有使用到的被调用者保存寄存器也无需保存。
> **保存的必要性**取决
> 	1. 函数内部是否会修改该 callee-saved 寄存器。
> **优化情况**：
> 	**但如果修改了，就必须保存/恢复**，即使调用者不使用这个寄存器。
> 编译器在进行后端代码生成时，知道在这两个场景中分别有哪些值得保存的寄存器。从这一角度也可以理解**为何要将函数调用上下文分成两类**：可以**让编译器尽可能早地优化掉一些无用的寄存器保存与恢复操作，提高程序的执行性能**。

### 调用规范
