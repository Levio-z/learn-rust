假如 CPU 依次执行的指令的物理地址序列为{an}，那么这个序列会符合怎样的模式呢？

**不同的指令序列执行模式，即控制流结构。**
- 连续执行
    - 其中最简单的无疑就是 CPU 一条条连续向下执行指令，也即满足递推公式an+1=an+L，这里我们假设该平台的指令是定长的且均为L字节（常见情况为 2/4 字节）
- 跳转指令
    - 但是执行序列并不总是符合这种模式，当位于物理地址an的指令是一条跳转指令的时候，该模式就有可能被破坏。跳转指令对应于我们在程序中构造的 **控制流** (Control Flow) 的多种不同结构，比如分支结构（如 if/switch 语句）和循环结构（如 for/while 语句）。用来实现上述两种结构的跳转指令，只需实现跳转功能，也就是将 pc 寄存器设置到一个指定的地址即可。
- 函数调用
    - 我们大概清楚调用函数整个过程中代码执行的顺序，如果是从源代码级的视角来看，我们会去执行被调用函数的代码，等到它返回之后，我们会回到调用函数对应语句的下一行继续执行。那么我们如何用汇编指令来实现这一过程？
        - 调用的时候**跳转到被调用函数的位置**：首先在调用的时候，需要有一条指令跳转到被调用函数的位置，这个看起来和其他控制结构没什么不同；
        - 函数执行完**返回那条跳转过来的指令的下一条**：但是在被调用函数返回的时候，我们却需要**返回那条跳转过来的指令的下一条**继续执行。
	        - 调用之前不知道：这次用来返回的跳转究竟跳转到何处，在对应的函数调用发生之前是不知道的。
	        - **跳转的不同之处**：比如，我们在两个不同的地方调用同一个函数，显然函数返回之后会回到不同的地址。这是一个很大的不同：其他控制流都只需要跳转到一个 **_编译期固定下来_** 的地址，而函数调用的返回跳转是跳转到一个 **_运行时确定_** （确切地说是在函数调用发生的时候）的地址。
![](asserts/Pasted%20image%2020250909162726.png)
对此，指令集必须给用于函数调用的跳转指令一些额外的能力，而不只是单纯的跳转。在 RISC-V 架构上，有两条指令即符合这样的特征：
RISC-V 函数调用跳转指令
![](asserts/Pasted%20image%2020250909162801.png)
> **RISC-V 指令各部分含义**
> 
> 在大多数只与通用寄存器打交道的指令中， rs 表示 **源寄存器** (Source Register)， imm 表示 **立即数** (Immediate)，是一个常数，二者构成了指令的输入部分；而 rd 表示 **目标寄存器** (Destination Register)，它是指令的输出部分。rs 和 rd 可以在 32 个通用寄存器 x0~x31 中选取。但是这三个部分都不是必须的，某些指令只有一种输入类型，另一些指令则没有输出部分。

**保存当前跳转指令的下一条指令地址**：从中可以看出，这两条指令**在设置 pc 寄存器完成跳转功能之前，还将当前跳转指令的下一条指令地址保存在 rd 寄存器**中，即
```
rd←pc+4
```
这条指令的含义。（这里假设所有指令的长度均为 4 字节）在 RISC-V 架构中，通常使用`ra`寄存器（即`x1`寄存器）作为其中的`rd`对应的具体寄存器，因此在函数返回的时候，只需跳转回`ra`所保存的地址即可。

**函数执行完成后返回调用之前的位置继续执行**：事实上在函数返回的时候我们常常使用一条 **汇编伪指令** (Pseudo Instruction) 跳转回调用之前的位置： `ret` 。它会被汇编器翻译为 `jalr x0, 0(x1)`，含义为跳转到寄存器 `ra` 保存的物理地址，由于 `x0` 是一个恒为 `0` 的寄存器，在 `rd` 中保存这一步被省略。
