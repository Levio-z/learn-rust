```java
OUTPUT_ARCH(riscv)                /* 指定目标架构为 RISC-V */
ENTRY(_start)                     /* 指定程序的入口函数为 _start（通常定义在汇编启动代码中） */
BASE_ADDRESS = 0x80200000;       /* 设置内核加载的起始地址（物理地址） */

SECTIONS
{
    . = BASE_ADDRESS;            /* 设置链接器当前位置（当前地址）为 BASE_ADDRESS */
    skernel = .;                 /* 定义符号 skernel，标记内核镜像的起始地址 */

    stext = .;                   /* 定义代码段起始地址 stext */
    .text : {
        *(.text.entry)          /* 按照这个表达式匹配，放入启动入口函数的代码（通常用于启动汇编） */
        *(.text .text.*)        /* 按照这个表达式匹配所有text代码，放入其他所有代码段 */
    }

    . = ALIGN(4K);               /* 对齐到 4KB 边界，符合页对齐要求 */
    etext = .;                   /* 定义代码段结束地址 etext */

    srodata = .;                 /* 只读数据段起始地址 */
    .rodata : {
        *(.rodata .rodata.*)     /* 放入所有 .rodata 段（常量等） */
        *(.srodata .srodata.*)   /* 放入小型只读数据段 */
    }

    . = ALIGN(4K);               /* 再次进行页对齐 */
    erodata = .;                 /* rodata 结束地址 */

    sdata = .;                   /* 可读写数据段起始地址 */
    .data : {
        *(.data .data.*)         /* 放入所有已初始化的全局变量 */
        *(.sdata .sdata.*)       /* 放入小型数据段 */
    }

    . = ALIGN(4K);               /* 页对齐 */
    edata = .;                   /* data 段结束地址 */

    .bss : {
        *(.bss.stack)            /* 放入栈空间的预留区域（常用于裸机） */
        sbss = .;                /* bss 起始地址 */
        *(.bss .bss.*)           /* 放入所有未初始化的全局变量 */
        *(.sbss .sbss.*)         /* 放入小型未初始化变量 */
    }

    . = ALIGN(4K);               /* 再次页对齐 */
    ebss = .;                    /* bss 段结束地址 */
    ekernel = .;                 /* 内核镜像末尾地址，用于计算内核大小 */

    /DISCARD/ : {
        *(.eh_frame)             /* 丢弃异常处理框架相关信息（裸机/OS 通常不需要） */
    }
}

```

- `. = BASE_ADDRESS;`
    - 这行命令**设置链接器的当前地址为 `BASE_ADDRESS`**。换句话说，接下来的符号和段将从 `BASE_ADDRESS` 开始布局。
- `ENTRY(_start)`
    - 在链接器脚本中，**`ENTRY` 命令用于指定程序的入口点，也就是程序开始执行的位置**。它告诉链接器，当程序加载时，应该从哪里开始执行代码
- `SECTIONS`
    - 块中的内容告诉链接器**如何布局和分配内存给不同的段**。
- 从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 `.` 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 `.` 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 `.` 从而记录这一时刻的位置。我们还能够看到这样的格式：
    
    ```java
    .rodata : {
        *(.rodata)
    }
    ```
    
    - **冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中**，每一行格式为 `<ObjectFile>(SectionName)`，表示目标文件 `ObjectFile` 的名为 `SectionName` 的段需要被放进去。
    - 我们也可以使用通配符来书写 `<ObjectFile>` 和 `<SectionName>` 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 `.text, .rodata .data, .bss` 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 `.text` 段的开始和结束地址分别是 `stext` 和 `etext` ）。
    - `.data .data.*` → 在 `()` 内列出多个 **section 名称模式**，它们之间用 **空格分隔**。
- 第 12 行我们将包含内核第一条指令的 `.text.entry` 段放在最终的 `.text` 段的最开头，同时注意到在最终内存布局中代码段 `.text` 又是先于任何其他段的。因为所有的段都从 `BASE_ADDRESS` 也即 `0x80200000` 开始放置，这就能够保证内核的第一条指令正好放在 `0x80200000` 从而能够正确对接到 Qemu 上。