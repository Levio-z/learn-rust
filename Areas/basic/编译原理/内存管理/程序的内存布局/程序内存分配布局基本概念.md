但我们知道这些字节至少可以分成**代码和数据**两部分，在程序运行起来的时候它们的功能并不相同：
- 代码部分由一条条可以**被 CPU 解码并执行的指令**组成
- 而数据部分只是被 CPU 视作**可读写的内存空间**。
事实上我们还可以根据其功能进一步把两个部分划分为更小的单位： **段** (Section) 。

不同的段会被编译器放置在内存不同的位置上，这构成了程序的 **内存布局** (Memory Layout)。一种典型的程序相对内存布局如下所示：
![](asserts/Pasted%20image%2020250909102221.png)

在上图中可以看到，代码部分只有代码段 `.text` 一个段，存放程序的所有汇编代码。而数据部分则还可以继续细化：

- 已初始化数据段保存程序中那些已初始化的**全局数据**，分为 `.rodata` 和 `.data` 两部分。前者存放只读的全局数据，通常是一些常数或者是 常量字符串等；而后者存放可修改的全局数据。
	- `.data` 段（已初始化的全局/静态变量）必须在 **磁盘文件里存放初始化值**。
    
- 未初始化数据段 `.bss` 保存程序中那些**未初始化的全局数据**，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零；
	- 在 ELF 文件中只会记录 `.bss` 的 **大小信息**（比如 8 字节），但不会存放任何实际内容。
	- 所以文件体积不会因为定义了几万个零初始化的变量而变大。
    
- **堆** （heap）区域用来存放程序**运行时动态分配的数据**，如 C/C++ 中的 malloc/new 分配到的数据本体就放在堆区域，它向高地址增长；
    
- **栈** （stack）区域不仅用作**函数调用上下文的保存与恢复，每个函数作用域内的局部变量**也被编译器放在它的栈帧内，它向低地址增长。

**局部变量与全局变量**

在一个函数的视角中，它能够访问的变量包括以下几种：

- 函数的输入参数和局部变量：保存在一些寄存器或是该函数的栈帧里面，如果是在栈帧里面的话是基于当前栈指针加上一个偏移量来访问的；
    
- 全局变量：保存在数据段 `.data` 和 `.bss` 中，某些情况下 gp(x3) 寄存器保存两个数据段中间的一个位置，于是全局变量是基于 gp 加上一个偏移量来访问的。
    
- 堆上的动态变量：本体被保存在堆上，大小在运行时才能确定。而我们只能 _直接_ 访问栈上或者全局数据段中的 **编译期确定大小** 的变量。因此我们需要通过一个运行时分配内存得到的一个指向堆上数据的指针来访问它，指针的位宽确实在编译期就能够确定。该指针即可以作为局部变量放在栈帧里面，也可以作为全局变量放在全局数据段中。