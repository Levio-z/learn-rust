---
tags:
  - permanent
---
## 1. 核心观点  
### Ⅰ. 概念层

在[计算机领域](https://en.wikipedia.org/wiki/Computing "Computing") ， **后期绑定**或**动态链接** [[ 1 ]](https://en.wikipedia.org/wiki/Late_binding#cite_note-1) （尽管与[动态链接](https://en.wikipedia.org/wiki/Dynamic_linker "Dynamic linker")导入的代码[库](https://en.wikipedia.org/wiki/Library_\(computing\) "Library (computing)")并不完全相同）是一种[计算机编程](https://en.wikipedia.org/wiki/Computer_programming "Computer programming")机制，它允许在[运行](https://en.wikipedia.org/wiki/Run_time_\(program_lifecycle_phase\) "Run time (program lifecycle phase)")时通过名称查找[对象](https://en.wikipedia.org/wiki/Object_\(computer_science\) "Object (computer science)")上调用的[方法](https://en.wikipedia.org/wiki/Method_\(computer_programming\) "Method (computer programming)")或带参数调用的[函数](https://en.wikipedia.org/wiki/Subroutine "Subroutine") 。换句话说，名称是在运行时而非[编译](https://en.wikipedia.org/wiki/Compiler "Compiler")期间与特定操作或对象关联的。 **动态绑定**有时也被称为动态作用域 [[ 2 ]](https://en.wikipedia.org/wiki/Late_binding#cite_note-2) ，但更常用来指代[动态作用域](https://en.wikipedia.org/wiki/Dynamic_scope) 。

在[面向对象语言](https://en.wikipedia.org/wiki/Object-oriented_programming "Object-oriented programming")中， [早期绑定](https://en.wikipedia.org/wiki/Early_binding "Early binding") （或[静态绑定](https://en.wikipedia.org/wiki/Static_binding "Static binding") ）是指编译阶段确定所有[类型](https://en.wikipedia.org/wiki/Data_type "Data type")的[变量](https://en.wikipedia.org/wiki/Variable_\(computer_science\) "Variable (computer science)")和[表达式](https://en.wikipedia.org/wiki/Expression_\(computer_science\) "Expression (computer science)") 。这通常以偏移量的形式存储在已编译的程序中，位于[虚方法表](https://en.wikipedia.org/wiki/Virtual_method_table "Virtual method table") （“v 表”）中。 [[ 3 ]](https://en.wikipedia.org/wiki/Late_binding#cite_note-3) 相反，在后期绑定中，编译器不会读取足够的信息来验证方法是否存在或将其绑定到 v 表中。相反，方法是在运行时按名称查找方法。
### Ⅱ. 应用层




### Ⅲ. 实现层

### **IV**.原理层


## 2. 背景/出处  
- 来源：https://en.wikipedia.org/wiki/Virtual_method_table
- 引文/摘要：  
  - …  
  - …  

## 3. 展开说明  

**早期绑定（Early / Static Binding）**  
在编译期即可**确定变量的静态类型**以及**方法调用的目标实现**。编译器在生成代码时，已经知道要调用哪一个函数入口，通常通过**固定偏移量**或**直接符号地址**完成调用。

**后期绑定（Late / Dynamic Binding）**  
在编译期**无法完全确定方法的具体实现**，方法调用的解析被推迟到**运行期**。运行时根据对象的**实际类型**或**方法名**进行查找与分派，最终确定调用目标。


**早期绑定的核心作用**

- 提供**更强的编译期安全性**（方法是否存在、参数是否匹配）
- 生成**更高效的调用代码**（无额外间接层）
- 便于**内联、去虚化、常量传播**等优化
    

**后期绑定的核心作用**

- 支持**运行期多态**
- 提供**高度的扩展性与灵活性**
- 允许在**接口未知或弱类型场景**下进行方法调用


2000 年， [Alex Martelli](https://en.wikipedia.org/wiki/Alex_Martelli "Alex Martelli") 创造了“鸭子类型” [（duck typing](https://en.wikipedia.org/wiki/Duck_typing "Duck typing") ）一词来指代类似的概念，但侧重点有所不同。后期绑定通常关注实现细节，而鸭子类型则侧重于忽略类型，专注于对象当前拥有的方法。

## 4. 与其他卡片的关联  
- 前置卡片：
- 后续卡片：
- 相似主题：
	- [编译原理-虚方法表](编译原理-虚方法表.md)
## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
- [ ] 去看一下虚方法表
- [ ] 验证这个观点的边界条件  
