
 **思考： 0x80200000 可否改为其他地址？**
 

首先需要区分绝对地址和相对地址。

在**对编译器进行某些设置的情况**下，在**访问变量或函数**时，**可以通过它们所在地址与当前某个寄存器（如 PC）的相对地址而非它们位于的绝对地址来访问这些变量或函数**。
 - 比如，在一个起始地址（即上面提到的 ]+-+`BASE_ADDRESS` ）固定为 `0x80200000` 的内存布局中，某个函数入口位于 `0x80201111` 处，那么我们可以使用其绝对地址 `0x80201111` 来访问它。但是，如果一条位于 `0x80200111` 指令会调用该函数，那么这条指令也不一定要用到绝对地址 `0x80201111` ，而是用函数入口地址相对于当前指令地址 `0x80200111` 的相对地址 `0x1000` （**计算方式为函数入口地址与当前指令地址之差值**）来找到并调用该函数。
 **位置无关可执行文件**（PIE，Position-independent Executable）
 - 如果一个程序**全程都使用相对地址而不依赖任何绝对地址**，那么只要保持好各段之间的相对位置不发生变化，将程序整体加载到内存中的任意位置程序均可正常运行。
 - 在这种情况下， `BASE_ADDRESS` 可以为任意值，我们可以将程序在内存中随意平移。 。相对的，如果程序依赖绝对地址，那么它一定有一个确定的内存布局，而且该程序必须被加载到与**其内存布局一致的位置**才能正常运行。由于我们的**内核并不是位置无关的**，所以我们必须将**内存布局的起始地址设置为 `0x80200000`** ，与之匹配我们也必须将内核加载到这一地址。
