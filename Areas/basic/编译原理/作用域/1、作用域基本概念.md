#### 定义
**作用域（Scope）** 是程序中标识符（变量、函数、结构体、枚举、常量、模块等）的可见范围。
- 当我们在某个位置使用一个名字（如 `x`、`foo`），编译器需要根据作用域规则来解析它指代的对象。
- 作用域可以是嵌套的，一个名字在内层作用域中可以“遮蔽”（shadow）外层的名字。
#### 作用
1. **名称解析（Name Resolution）**：编译器需要判断一个名字具体指向什么。
2. **内存管理**：Rust 通过作用域边界决定变量生命周期（RAII + 所有权规则）。
3. **避免冲突**：在同一作用域不能定义两个同名实体。
4. **可读性**：程序员看到某个名字时，可以快速定位它的含义。

#### Rust 中的作用域示例
```rust
fn main() {
    let x = 10;      // x 在此作用域内有效
    {
        let y = 20;  // 新作用域，y 只在这里有效
        let x = 99;  // 内层作用域遮蔽外层 x
        println!("inner x = {}, y = {}", x, y);
    }
    // println!("y = {}", y); // 错误: y 已经超出作用域
    println!("outer x = {}", x); // outer x = 10
}
```

特点：
- 变量 **自动释放** 于作用域结束时。    
- **遮蔽（Shadowing）**：允许在新的作用域用同名变量覆盖之前的定义。
#### 模块作用域与可见性

作用域不仅仅是函数块，还包括 **模块系统**：
```rusmod utils {
    pub fn greet() {
        println!("Hello");
    }
    fn hidden() {} // 私有，不可见
}

fn main() {
    utils::greet(); // ✅
    // utils::hidden(); // ❌ 不在作用域
}
```

- `pub` 控制哪些名字暴露给外部作用域。
- `use` 可以将名字引入当前作用域：

```rust
use utils::greet;
fn main() {
    greet(); // 不需要 utils:: 前缀
}
```