---
tags:
  - reference
---

任何编程语言（包括 Rust）启动外部程序并捕获其输出时，底层几乎总是使用匿名管道连接父进程和子进程的stdin stdout
您的理解是**完全正确**的。这不仅仅是一个“几乎总是”的说法，在绝大多数主流操作系统（Unix-like/Linux、macOS、Windows）上，**启动子进程并捕获其标准 I/O（stdin/stdout/stderr）时，底层机制就是使用匿名管道。**

### 详细解释：启动子进程与匿名管道的关系

#### 1. 匿名管道的本质

匿名管道（Pipe）是操作系统内核提供的一种**单向通信通道**。它由两个文件描述符（在 Windows 上是句柄）组成：

- **读取端 (Read End)**：用于从管道中读取数据。
    
- **写入端 (Write End)**：用于向管道中写入数据。
    

#### 2. 父进程如何捕获子进程的 Standard I/O

当您在 Rust 中使用 `std::process::Command` 启动一个子进程并配置 `stdout(Stdio::piped())` 时，操作系统内核执行的步骤大致如下：

|**步骤**|**涉及对象**|**作用**|
|---|---|---|
|**1. 创建管道**|**内核**|内核创建一个**新的匿名管道**，生成一对文件描述符：`Pipe_R`（读取）和 `Pipe_W`（写入）。|
|**2. 创建子进程**|**父进程**|父进程调用 `fork()` (Unix) 或 `CreateProcess` (Windows) 创建子进程。子进程**继承**了父进程打开的所有文件描述符，包括 `Pipe_R` 和 `Pipe_W`。|
|**3. 重定向子进程 I/O**|**子进程**|在子进程执行新程序（例如 `exec`）之前： - 子进程关闭其继承的 `Pipe_R` 端。 - 子进程将其标准输出 (`stdout`，文件描述符 1) **重定向**到 `Pipe_W` 端。 - 子进程关闭其多余的 `Pipe_W` 副本。|
|**4. 父进程 I/O 准备**|**父进程**|父进程关闭其多余的 `Pipe_W` 端。 它保留 `Pipe_R` 端。|
|**5. 数据流动**|**父子进程**|子进程写入任何数据到其 `stdout` 时，实际上数据流向了 `Pipe_W` 端，进入内核缓冲区。父进程通过读取 `Pipe_R` 端来**捕获**这些数据。|

简而言之：**父进程和子进程通过管道的两端实现了连接。**

- **子进程的 `stdout` $\rightarrow$ 管道的写入端**
    
- **父进程 $\leftarrow$ 管道的读取端**
    

### 为什么选择管道？

1. **简单性：** 管道是 Unix 设计哲学中最简单的流式 IPC 机制。它直接利用了文件描述符的 I/O 抽象。
    
2. **效率：** 管道在同一机器的内核空间内传输数据，避免了昂贵的网络协议栈开销，效率很高。
    
3. **遵循 I/O 抽象：** 大多数程序默认将输出写入标准输出 (`stdout`)。管道机制允许操作系统在不修改子程序代码的情况下，将这个标准的 I/O 接口“插入”到另一个程序的 I/O 接口中。
    

所以，无论是 Rust 的 `Command`、Python 的 `subprocess`，还是 Node.js 的 `child_process`，当它们捕获子进程的输出时，底层都依赖于操作系统提供的匿名管道机制。