具体：[2.4 内核第一条指令（实践篇）](../../../../../Projects/开源操作系统训练营/2025春夏/第二阶段：rcore/rCore-Turial-note/2.0%20应用程序执行环境/2.4%20内核第一条指令（实践篇）.md)
地址：https://cnb.cool/docker.2025/rcore/-/tree/ch1

可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 `0x1000` 。我们可以检查一下 Qemu 的启动固件的内容：

| 输出字段                 | 含义                                         |
| -------------------- | ------------------------------------------ |
| `0x0000000000001000` | 当前程序计数器（PC）指向的地址。也就是 CPU 当前要执行/已执行的一条指令地址。 |
| `in ??`              | GDB **无法解析该地址所在的函数名称**（没有可匹配的符号表条目）。       |
| `()`                 | 表示这是函数调用的上下文，但由于没有解析出来函数名，所以是空的括号。         |

可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 `0x1000` 。我们可以检查一下 Qemu 的启动固件的内容：

```java
(gdb) x/10i $pc
=> 0x1000:  auipc   t0,0x0
0x1004:     addi    a1,t0,32
0x1008:     csrr    a0,mhartid
0x100c:     ld      t0,24(t0)
0x1010:     jr      t0
0x1014:     unimp
0x1016:     unimp
0x1018:     unimp
0x101a:     0x8000
0x101c:     unimp
```
[案例- 启动部分汇编指令](../../../../../Projects/开源操作系统训练营/2025春夏/第二阶段：rcore/RISC-V/汇编指令分析/案例-%20启动部分汇编指令.md)
- 这里 `x/10i $pc` 的含义是**从当前 PC 值的位置开始，在内存中反汇编 10 条指令**。不过可以看到 Qemu 的固件仅包含 5 条指令，从 `0x1014` 开始都是数据，**当数据为 0 的时候则会被反汇编为 `unimp` 指令**。 `0x101a` 处的数据 `0x8000` 是能够跳转到 `0x80000000` 进入启动下一阶段的关键。有兴趣的读者可以自行探究位于 `0x1000` 和 `0x100c` 两条指令的含义。总之，在执行位于 `0x1010` 的指令之前，寄存器 `t0` 的值恰好为 `0x80000000` ，随后通过 `jr t0` 便可以跳转到该地址。我们可以通过单步调试来复盘这个过程：

```java
(gdb) si
0x0000000000001004 in ?? ()
(gdb) si
0x0000000000001008 in ?? ()
(gdb) si
0x000000000000100c in ?? ()
(gdb) si
0x0000000000001010 in ?? ()
(gdb) p/x $t0
1 = 0x80000000
(gdb) si
0x0000000080000000 in ?? ()
```

其中， **`si` 可以让 Qemu 每次向下执行一条指令，之后屏幕会打印出待执行的下一条指令的地址**。可以看到，当位于 `0x1010` 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 `0x80000000` ，这意味着我们即将把控制权转交给 RustSBI 。

```java
(gdb) x/10i $pc
=> 0x80000000:      auipc   sp,0x28
0x80000004: mv      sp,sp
0x80000008: lui     t0,0x4
0x8000000a: addi    t1,a0,1
0x8000000e: add     sp,sp,t0
0x80000010: addi    t1,t1,-1
0x80000012: bnez    t1,0x8000000e
0x80000016: j       0x8001125a
0x8000001a: unimp
0x8000001c: addi    sp,sp,-48
(gdb) si
0x0000000080000004 in ?? ()
(gdb) si
0x0000000080000008 in ?? ()
(gdb) si
0x000000008000000a in ?? ()
(gdb) si
0x000000008000000e in ?? ()
```

我们可以用同样的方式反汇编 RustSBI 最初的几条指令并单步调试。不过由于 RustSBI 超出了本书的范围，我们这里并不打算进行深入。接下来我们检查控制权能否被移交给我们的内核

```java
(gdb) b *0x80200000
Breakpoint 1 at 0x80200000
(gdb) c
Continuing.

Breakpoint 1, 0x0000000080200000 in ?? ()
```

我们在内核的入口点，也即地址 `0x80200000` 处打一个断点。需要注意，当需要在一个特定的地址打断点时，需要在地址前面加上 `*` 。接下来通过 `c` 命令（Continue 的缩写）让 Qemu 向下运行直到遇到一个断点。可以看到，我们成功停在了 `0x80200000` 处。随后，可以检查内核第一条指令是否被正确执行：

```java
(gdb) x/5i $pc
=> 0x80200000:      li      ra,100
0x80200004: unimp
0x80200006: unimp
0x80200008: unimp
0x8020000a: unimp
(gdb) si
0x0000000080200004 in ?? ()
(gdb) p/d $x1
2 = 100
(gdb) p/x $sp
3 = 0x0
```

- 可以以十进制打印寄存器 `x1` 的值

### 1. `p/d $x1`
- `p/d` 是 GDB 命令：按 **十进制（decimal）** 打印表达式的值。
- `$x1` 是 **RISC-V 通用寄存器 x1**，也叫 **ra（return address）** 寄存器。
- 输出：`2 = 100`
    - 这里 `2` 是 GDB 输出的表达式编号，不影响寄存器值。
    - `x1 = 100`（十进制）
- **作用**：查看寄存器 `x1` 的当前值。

---
### 2. `p/x $sp`
- `p/x` 是按 **十六进制（hexadecimal）** 打印表达式的值。
- `$sp` 是 **栈指针（stack pointer）**，对应 RISC-V 寄存器 **x2**。
- 输出：`3 = 0x0`
    - 栈指针当前值为 `0x0`
- **作用**：查看当前栈顶地址（这里为 0 表示还未初始化或指向内存底部，典型裸机/早期引导阶段）。

可以看到我们在 `entry.asm` 中编写的第一条指令可以在 `0x80200000` 处找到。这里 `ra` 是寄存器 `x1` 的别名， `p/d $x1` 可以以十进制打印寄存器 `x1` 的值，它的结果正确。最后，作为下一节的铺垫，我们可以检查此时栈指针 `sp` 的值，可以发现它目前是 0 。下一节我们将设置好栈空间，使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码。 `p/d $x1`