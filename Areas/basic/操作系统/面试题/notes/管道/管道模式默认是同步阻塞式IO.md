---
tags:
  - note
---

## 1. 核心观点  

使用进程调用读取从空管道读取数据时，如果写入端仍打开，调用会阻塞，所以管道是一种同步阻塞式IO

## 2. 展开说明  

当一个进程调用 `read()` 尝试从一个空管道中读取数据时，默认会发生以下情况：

- **如果管道中有数据：** `read()` 调用会立即返回已读取的数据（同步且非阻塞）。
    
- **如果管道中没有数据，但写入端仍打开：** `read()` 调用会使该进程**阻塞（Block）**，暂停执行，直到：
    
    - 有新的数据被写入管道。
        
    - 所有写入端都被关闭（导致 EOF）。
        

**阻塞机制保证了生产者和消费者之间的同步**

- 当写入进程向已满的管道写入数据时，它会被**阻塞（block）**，直到读取进程从管道中取出一些数据腾出空间为止。
        
- 当读取进程从空管道读取数据时，它也会被**阻塞**，直到写入进程向管道写入数据为止。
        
- 这种阻塞机制保证了生产者和消费者进程之间的同步，并防止速度较快的生产者压垮速度较慢的消费者，同时也限制了管道占用的内存资源。

## 3. 与其他卡片的关联  
- 前置卡片：[IPC-管道-TOC](IPC-管道-TOC.md)
- 后续卡片：
	- 
	- 
- 相似主题：

## 4. 背景/出处  
- 来源：
	- 
- 引文/摘要：  
  - …  
  - …  

## 5. 应用/启发  
- 可以如何应用在工作、学习、生活中  
- 引发的思考与问题  

## 6. 待办/进一步探索  
 
  









关键参考：
