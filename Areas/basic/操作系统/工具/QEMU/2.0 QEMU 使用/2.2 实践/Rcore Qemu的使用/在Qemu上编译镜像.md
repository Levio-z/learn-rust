上面我们简单介绍了程序内存布局和编译流程特别是链接过程的相关知识。那么如何得到一个能够在 Qemu 上成功运行的内核镜像呢？

- 首先我们需要通过**链接脚本调整内核可执行文件的内存布局，使得内核被执行的第一条指令位于地址 `0x80200000` 处，同时代码段所在的地址应低于其他段**。这是因为 Qemu 物理内存中低于 `0x80200000` 的区域并未分配给内核，而是主要由 RustSBI 使用。
- 其次，我们需要将**内核可执行文件中的元数据丢掉得到内核镜像**，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它直接将输入的文件逐字节拷贝到物理内存中，因此也可以说这一步是我们在**帮助 Qemu 手动将可执行文件加载到物理内存中**。下一节我们将成功生成内核镜像并在 Qemu 上验证控制权被转移到内核。
    - 其次，我们需要将内核的 ELF 可执行文件**去除符号表、调试信息等元数据**，仅保留实际执行所需的代码和数据段，从而得到一个精简的**内核镜像**（kernel image）。
    - 之所以要这样做，是因为 **QEMU 的加载机制非常简单**——它不会识别 ELF 格式（不像 bootloader 或操作系统那样），而是**将指定的文件按字节直接写入物理内存的某个位置**，没有任何解释、解析行为。
    - 这意味着，我们必须手动完成链接器和加载器原本会做的事情：
        - **剥离符号和调试信息**（使用 `objcopy`）
        - **指定加载地址**（由链接脚本完成）
        - **构造正确的段布局**（`.text`、`.data`、`.bss` 按照期望的物理地址排列）
