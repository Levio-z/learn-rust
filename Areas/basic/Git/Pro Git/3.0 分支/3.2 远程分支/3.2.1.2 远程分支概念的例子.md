这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 `git.ourcompany.com` 的 Git 服务器。 如果你从这里克隆，Git 的 `clone` 命令会为你自动将其命名为 `origin`，拉取它的所有数据，创建一个指向它的 `master` 分支的指针，并且在本地将其命名为 `origin/master`。 Git 也会给你一个与 origin 的 `master` 分支在指向同一个地方的本地 `master` 分支，这样你就有工作的基础。

> ``origin'' 并无特殊含义:远程仓库名字 `origin'' 与分支名字` master'' 一样，在 Git 中并没有任何特别的含义一样。 同时 `master'' 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，`origin'' 是当你运行 `git clone` 时默认的远程仓库名字。 如果你运行 `git clone -o booyah`，那么你默认的远程分支名字将会是 `booyah/master`。

![](asserts/Pasted%20image%2020250730215843.png)
Figure 1. 克隆之后的服务器与本地仓库

**如果你在本地的 `master` 分支做了一些工作，然而在同一时间，其他人推送提交到 `git.ourcompany.com` 并更新了它的 `master` 分支，那么你的提交历史将向不同的方向前进。** 也许，只要你不与 origin 服务器连接，你的 `origin/master` 指针就不会移动。

![](asserts/Pasted%20image%2020250730215928.png)
Figure 2. 本地与远程的工作可以分叉

如果要同步你的工作，运行 `git fetch origin` 命令。 这个命令查找 origin 是哪一个服务器（在本例中，它是 git.ourcompany.com ），从中抓取本地没有的数据，并且更新本地数据库，移动 `origin/master` 指针指向新的、更新后的位置。
![](asserts/Pasted%20image%2020250730220625.png)
Figure 3. `git fetch` 更新你的远程仓库引用

为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 `git.team1.ourcompany.com`。 你可以运行 `git remote add` 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 [[_git_basics_chapter]](https://bingohuang.gitbooks.io/progit2/content/03-git-branching/sections/remote-branches.html#_git_basics_chapter) 中详细说明。 将这个远程仓库命名为 `teamone`，将其作为整个 URL 的缩写。

![](asserts/Pasted%20image%2020250730220852.png)
Figure 4. 添加另一个远程仓库
现在，可以运行 `git fetch teamone` 来抓取远程仓库 `teamone` 有而本地没有的数据。 因为那台服务器上现有的数据是 `origin` 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支 `teamone/master` 指向 `teamone` 的 `master` 分支。
>也就是说，`teamone` 是一个远程仓库，它**并不是一个完全独立的上游仓库**，而是 **部分从 `origin` 克隆/复制而来**。所以你本地很多对象其实已经从 `origin` 下载过了。

实际会做什么：
- **连接 `teamone` 仓库**；
- **列出其引用（refs）**（通过 `git ls-remote teamone` 可以看到）；
- 对于你本地还没有的对象（Git 对象如提交、树、blob），**才会真正下载（fetch）过来**
- 即使大多数对象已存在，本地还是会更新一组新的 **远程跟踪分支**：
![](asserts/Pasted%20image%2020250730220934.png)
Figure 5. 远程跟踪分支 `teamone/master`
