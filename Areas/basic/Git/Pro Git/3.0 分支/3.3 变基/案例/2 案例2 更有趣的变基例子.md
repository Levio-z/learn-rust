在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 [从一个特性分支里再分出一个特性分支的提交历史](https://bingohuang.gitbooks.io/progit2/content/03-git-branching/sections/rebasing.html#rbdiag_e) 中的例子这样。 你创建了一个特性分支 `server`，为服务端添加了一些功能，提交了 `C3` 和 `C4`。 然后从 `C3` 上创建了特性分支 `client`，为客户端添加了一些功能，提交了 `C8` 和 `C9`。 最后，你回到 `server` 分支，又提交了 `C10`。

![](asserts/Pasted%20image%2020250731095726.png)
Figure 5. 从一个特性分支里再分出一个特性分支的提交历史

假设你希望将 `client` 中的修改合并到主分支并发布，但暂时并不想合并 `server` 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 `git rebase` 命令的 `--onto` 选项，选中在 `client` 分支里但不在 `server` 分支里的修改（即 `C8` 和 `C9`），将它们在 `master` 分支上重演：

```console
$ git rebase --onto master server client
```
以上命令的意思是：“**取出 `client` 分支，找出处于 `client` 分支和 `server` 分支的共同祖先之后的修改，然后把它们在 `master` 分支上重演一遍**”。 这理解起来有一点复杂，不过效果非常酷。
![](asserts/Pasted%20image%2020250731095904.png)

Figure 6. 截取特性分支上的另一个特性分支，然后变基到其他分支

现在可以快进合并 `master` 分支了。（如图 [快进合并 master 分支，使之包含来自 client 分支的修改](https://bingohuang.gitbooks.io/progit2/content/03-git-branching/sections/rebasing.html#rbdiag_g)）：

```console
$ git checkout master
$ git merge client
```
![](asserts/Pasted%20image%2020250731102142.png)

Figure 7. 快进合并 master 分支，使之包含来自 client 分支的修改

接下来你决定将 `server` 分支中的修改也整合进来。 使用 `git rebase [basebranch] [topicbranch]` 命令可以直接将特性分支（即本例中的 `server`）变基到目标分支（即 `master`）上。这样做能省去你先切换到 `server` 分支，再对其执行变基命令的多个步骤。

```console
$ git rebase master server
```
如图 [将 server 中的修改变基到 master 上](https://bingohuang.gitbooks.io/progit2/content/03-git-branching/sections/rebasing.html#rbdiag_h) 所示，`server` 中的代码被“续”到了 `master` 后面。
![](asserts/Pasted%20image%2020250731102246.png)Figure 8. 将 server 中的修改变基到 master 上

然后就可以快进合并主分支 master 了：
```console
$ git checkout master
$ git merge server
```

至此，`client` 和 `server` 分支中的修改都已经整合到主分支里去了，你可以删除这两个分支，最终提交历史会变成图 [最终的提交历史](https://bingohuang.gitbooks.io/progit2/content/03-git-branching/sections/rebasing.html#rbdiag_i) 中的样子：

```console
$ git branch -d client
$ git branch -d server
```
![](asserts/Pasted%20image%2020250731102444.png)
Figure 9. 最终的提交历史