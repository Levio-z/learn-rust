为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。

或许你还记得 [[_getting_started]](https://bingohuang.gitbooks.io/progit2/content/03-git-branching/sections/nutshell.html#_getting_started) 的内容，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。

### commit生成提交对象
在进行提交操作时，Git 会保存一个提交对象（commit object）。
- 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 
- 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。
- 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，

### 底层详解
为了说得更加形象，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 
- **暂存操作会为每一个文件计算校验和**，生成blob对象
	- （使用我们在 [[_getting_started]](https://bingohuang.gitbooks.io/progit2/content/03-git-branching/sections/nutshell.html#_getting_started) 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：
```
$ git add README test.rb LICENSE
$ git commit -m 'The initial commit of my project'
```
当使用 git commit 进行提交操作时
- Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中将这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。
	-   Tree 对象保存的是目录结构和文件索引。它记录了**当前目录下的文件以及子目录，并将每个文件与相应的 blob 对象关联起来。**
	- 层级结构
		- 对于项目根目录的提交，Git 会创建一个树对象，它将指向根目录下的各个文件（这些文件是 blob 对象），并将它们组织成目录树结构。
		- 如果有子目录，树对象还会指向另一个树对象，形成层级结构。
		- 计算方式是自底向上的

现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。

![](asserts/Pasted%20image%2020250729112901.png)
Figure 1. 首次提交对象及其树结构
做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。
![](asserts/Pasted%20image%2020250730195104.png)
Figure 2. 提交对象及其父对象
### Git 内部对象模型

Git 使用四种基本对象来保存数据：

1.  **Blob (Binary Large Object)**：
    
    -   Blob 对象保存的是文件的内容，它不会存储任何文件名、目录结构等元数据。每个文件被提交时，Git 会为其生成一个独特的 SHA-1 哈希值（即文件的内容哈希值），并将文件的内容存储在 blob 对象中。
        
    -   例如，你的 `README`、`test.rb` 和 `LICENSE` 文件的内容，会被各自保存为 blob 对象。
        
2.  **Tree (树对象)**：
    
    -   Tree 对象保存的是目录结构和文件索引。它记录了**当前目录下的文件以及子目录，并将每个文件与相应的 blob 对象关联起来。**
        
    -   对于项目根目录的提交，Git 会创建一个树对象，它将指向根目录下的各个文件（这些文件是 blob 对象），并将它们组织成目录树结构。
        
    -   如果有子目录，树对象还会指向另一个树对象，形成层级结构。
        
3.  **Commit (提交对象)**：
    
    -   Commit 对象记录了提交的元数据，包括：提交信息、作者信息、提交时间、以及指向对应树对象的指针。
        
    -   每个提交对象都包含一个指向父提交对象的指针（除了第一次提交，没有父提交对象）。如果是一个合并提交（merge commit），它将指向多个父提交对象。
        
    -   这样，每个提交都包含了该提交时的文件快照（通过树对象）以及前一个提交的状态（通过父提交对象），形成了一个提交历史链条。
        
4.  **Tag (标签对象)**：
    
    -   标签对象并不是必需的，但它可以用来标记特定的提交，比如一个发布版本。
        
    -   标签可以作为对特定提交的引用，便于用户在仓库中快速定位到某个重要的提交点。
        

### 提交过程

1.  **暂存阶段 (`git add`)**：
    
    -   你通过 `git add` 将文件放入暂存区。Git 会计算文件内容的哈希值，并将其内容保存为 blob 对象。对于目录结构，Git 会为每个子目录计算哈希值，并将它们保存为树对象。
        
2.  **提交阶段 (`git commit`)**：
    
    -   执行 `git commit` 时，Git 会创建一个提交对象。该提交对象会包含以下内容：
        
        -   **指向树对象的指针**：该树对象表示你当前提交的文件和目录结构快照。
            
        -   **作者信息和提交信息**：包括提交人的姓名、邮箱以及提交时的消息。
            
        -   **父提交对象的指针**（如果有）：对于普通提交，指向前一个提交；对于合并提交，指向多个父提交。
            

### 合并提交

在 Git 中，**合并提交**是一个特殊的提交，通常由 `git merge` 命令产生。合并提交有多个父提交对象，因为它记录了多个分支的合并。Git 会通过合并算法将多个父提交的变更合并到一个新的提交对象中。

### 例子：创建一个提交

假设你有以下文件结构：

```
project/
├── README
├── test.rb
└── LICENSE
```

1.  执行 `git add README test.rb LICENSE` 后，Git 会计算每个文件的哈希值，并将文件内容保存在 blob 对象中。
    
2.  执行 `git commit -m 'The initial commit of my project'` 后，Git 会：
    
    -   创建一个树对象，表示根目录及其包含的文件。
        
    -   创建一个提交对象，记录提交的信息和指向树对象的指针。
        

最终，Git 仓库中会包含：

-   3 个 blob 对象（保存文件内容）
    
-   1 个树对象（保存文件目录结构）
    
-   1 个提交对象（保存提交元数据及指向树对象的指针）
    

### 总结

Git 的数据存储方式通过使用四种对象（blob、tree、commit、tag）来高效地管理版本历史。每次提交都会记录一个快照，并通过树对象和提交对象的指针建立文件、目录和提交的关系。通过这种方式，Git 能够保证高效的历史追溯与版本管理。