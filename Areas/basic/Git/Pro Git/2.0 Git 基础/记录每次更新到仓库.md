![](asserts/Pasted%20image%2020250706105158.png)

- 已跟踪
	- 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。
	- 未修改->已修改->暂存区
- 未跟踪
	- ->暂存区
	- 在状态报告中可以看到新建的 README 文件出现在 `Untracked files` 下面。 **未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件**”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。
- 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。

#### 检查当前文件状态
```console
$ git status
On branch master
nothing to commit, working directory clean
```
- 所有已跟踪文件在上次提交后都未被更改过
- 信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来
- 显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离
#### 跟踪新文件
```console
git add README
```
此时再运行 `git status` 命令，会看到 README 文件已被跟踪，并处于暂存状态
`git add` 命令**使用文件或目录的路径作为参数**
- 如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。
#### 暂存已修改文件

要暂存这次更新，需要运行 `git add` 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 **将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适**。 现在让我们运行 `git add` 将"CONTRIBUTING.md"放到暂存区，然后再看看 `git status` 的输出：

#### 状态简览
```console
git status -s
```

```console
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```

新添加的未跟踪文件前面有 `??` 标记，新添加到暂存区中的文件前面有 `A` 标记，修改过的文件前面有 `M` 标记。你可能注意到了 `M` 有两个可以出现的位置，出现在右边的 `M` 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 `M` 表示该文件被修改了并放入了暂存区。
- 例如，上面的状态报告显示： `README` 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,`lib/simplegit.rb` 文件被修改了并将修改后的文件放入了暂存区。
- 而 `Rakefile` 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。
#### 忽略文件
一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。
```console
$ cat .gitignore
*.[oa]
*~
```
- 第一行告诉 Git 忽略所有以 `.o` 或 `.a` 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。
- 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。
- 忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等
- **要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。**‘

文件 `.gitignore` 的格式规范如下：

- 所有空行或者以 `＃` 开头的行都会被 Git 忽略。
- 可以使用标准的 glob 模式匹配。
- 匹配模式可以以（`/`）开头防止递归。
- 匹配模式可以以（`/`）结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（`!`）取反。

星号（）匹配零个或多个任意字符；
`[abc]` 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；
问号（`?`）只匹配一个任意字符；
如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 `[0-9]` 表示匹配所有 0 到 9 的数字）。 
使用两个星号（) 表示匹配任意中间目录，比如`a/**/z` 可以匹配 `a/z`, `a/b/z` 或 `a/b/c/z`等。
### `build/`：相对路径匹配（任意层级）

```
build/
```
`build/`：相对路径匹配（任意层级）
- 忽略**任何路径中**名为 `build/` 的目录及其下的所有内容，**不管它位于哪一层目录中**。
- 它是一个**模式匹配通配符**，等价于：
```
**/build/
```
匹配示例：

|路径|匹配|说明|
|---|---|---|
|`build/main.o`|✅|顶层目录下|
|`target/build/hello.txt`|✅|子目录中也匹配|
|`a/b/c/build/log.txt`|✅|多层目录中的 build 也匹配|

### `/TODO`：根目录绝对匹配（不递归）

```
/TODO
```
只忽略**仓库根目录**下的 `TODO` 文件，不忽略其他目录中的 `TODO` 文件。

- 表示匹配仓库**根目录下名为 `TODO` 的路径**
- 无论这个路径是**文件还是目录**，只要匹配上，都将被忽略
### doc/*.txt
```
- 忽略 `doc/` 目录下**一级目录内的** `.txt` 文件：
  - `doc/notes.txt` ✅ 被忽略
  - `doc/server/arch.txt` ❌ 不匹配，因为它在 `doc/server/` 中
```

### `doc/**/*.pdf`

`**` 表示**任意层级的子目录**，所以该规则表示：

> 忽略 `doc/` 目录及其任意子目录中所有 `.pdf` 文件。

- `doc/guide.pdf` ✅
    
- `doc/server/slides/report.pdf` ✅
### 查看已暂存和未暂存的修改
git diff

`git diff` 将通过文件补丁的格式显示具体哪些行发生了改变

要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 `git diff`：

```console
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
```


若要查看已暂存的将要添加到下次提交里的内容，可以用 `git diff --cached` 命令。（Git 1.6.1 及更高版本还允许使用 `git diff --staged`，效果是相同的，但更好记些。）


请注意，**git diff 本身只显示尚未暂存的改动**，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 `git diff` 后却什么也没有，就是这个原因。

|   |   |
|---|---|
|Note|Git Diff 的插件版本<br><br>在本书中，我们使用 `git diff` 来分析文件差异。 但是，如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用 `git difftool` 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。 使用 `git difftool --tool-help` 命令来看你的系统支持哪些 Git Diff 插件。|

### 提交更新



好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（`master`）提交的，本次提交的完整 SHA-1 校验和是什么（`463dc4f`），以及在本次提交中，有多少文件修订过，多少行添加和删改过。

### 跳过使用暂存区域
 只要在提交的时候，给 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤：

```console
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
```
### 移除文件
**要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交**。 **可以用 `git rm` 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。**
如果只是简单地从工作目录中手工删除文件，运行 `git status` 时就会在 “Changes not staged for commit” 部分（也就是 _未暂存清单_）看到：

```console
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
```
然后再运行 `git rm` 记录此次移除文件的操作：

```console
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
```

下一次提交时，该文件就不再纳入版本管理了。
- commit状态的可以直接被移除
- **如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 `-f`（译注：即 force 的首字母）。**
	- 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。

另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。****

```console
$ git rm --cached README
```

`git rm` 命令后面可以列出文件或者目录的名字，也可以使用 `glob` 模式。 比方说：
```console
$ git rm log/\*.log
```

- 所以你必须 **转义 `*` 号（加 `\`）来防止 shell 抢先展开**，从而让 `git rm` 正确地处理 glob 模式。
- `\*`：告诉 shell “不要展开我，让 Git 自己处理这个 glob 模式”

注意到星号 `*` 之前的反斜杠 `\`， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 `log/` 目录下扩展名为 `.log` 的所有文件。 类似的比如：


```console
$ git rm \*~
```
匹配任意层级哦
