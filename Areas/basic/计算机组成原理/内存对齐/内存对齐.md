**内存地址对齐**

内存地址对齐（Memory Alignment）是指在内存中存放数据时，要求数据的起始地址满足一定的对齐约束（一般是数据大小的整数倍）。对齐的本质是计算机硬件设计上的折中：在保证内存访问效率的同时，简化 CPU 的总线控制逻辑。
### 为什么需要对齐
1. **硬件限制**
    - 某些架构（如 RISC-V、MIPS、ARM 的严格模式）要求访存必须对齐，否则触发异常。
    - 例如：访问 32 位整数时，其地址必须是 4 的倍数；访问 64 位整数时，其地址必须是 8 的倍数。
2. **性能优化**
    - 即使架构允许非对齐访问，CPU 也可能需要拆分成两次访存（例如先访问低地址字，再访问高地址字），增加了延迟。
    - 对齐后，单条指令即可完成访存，提升性能。
3. **简化硬件实现**
    - 内存控制器和总线设计更为简单，不必处理复杂的跨字访问逻辑。
### 基本类型数据对齐
基本类型数据对齐是指数据在内存中的偏移地址必须为一个字的整数倍，这种存储数据的方式，可以提升系统在读取数据时的性能。
- 定义：基本类型（如 `char`、`int`、`long long`）的存放地址必须是其大小的整数倍。
- 例如：
    - `int`（4字节）必须放在能被 4 整除的地址。
    - `double`（8字节）必须放在能被 8 整除的地址。
在 **RISC-V** 中：
- `lw`（load word, 32 位） → 地址必须是 4 的倍数。
- `ld`（load doubleword, 64 位） → 地址必须是 8 的倍数。
- 否则触发 **misaligned load/store exception**。

### 结构体数据对齐
**字段对齐**
- 结构体中的每个字段，都会按照其类型的对齐规则进行存储。
- 如果上一个字段结束后地址不是下一个字段所需的对齐倍数，就会填充 padding。

### RISC-V 下的对齐要求
- **强制对齐**：RISC-V 的基础 load/store 指令必须按数据大小对齐。
- **异常触发**：若 `lw` 地址不是 4 的倍数，或 `ld` 地址不是 8 的倍数，会抛出异常（`Load Address Misaligned`）。
- **软件处理**：内核或编译器需要插入额外指令（拆分成多个 byte/halfword load/store，再组合），代价较大。