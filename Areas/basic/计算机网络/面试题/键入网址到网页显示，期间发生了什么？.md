根据Web浏览器地址栏中指定的URL,Web浏览器从Web服务器端获取文件资源(resource)等信息，从而显示出Web页面。
### 1️⃣ URL 解析
- 浏览器识别输入是否为 [URL](../../../../../Zettelkasten/permanent/URL.md) 或搜索关键字；
- 解析出：
    - 协议（scheme）：`https://`
    - 主机（host）：`www.example.com`
    - 端口（port）：默认 80/443
    - 路径（path）：`/index.html`
    - 查询参数（query）：`?id=1`
### 2️⃣ [DNS-简述](../DNS/DNS-简述.md) 解析
- 查找域名对应的 IP 地址：
    1. 浏览器缓存（几分钟）
    2. 操作系统缓存（`/etc/hosts`）
    3. 路由器缓存
    4. 递归查询 DNS 服务器（Local DNS → 根域名服务器 → 顶级域 → 权威域）
- 结果：获得服务器 IP，例如 `93.184.216.34`
### 3️⃣ TCP 三次握手
建立可靠连接：
1. Client → Server：`SYN`
2. Server → Client：`SYN + ACK`
3. Client → Server：`ACK`
> OS 层通过 TCP 套接字完成此过程。Rust 中通过 `TcpStream::connect()` 发起连接。
### 4️⃣ TLS 握手（HTTPS 专属）
- 浏览器与服务器协商加密算法；
- 验证服务器数字证书；
- 交换密钥并建立安全信道；
- 生成对称加密会话密钥。
### 5️⃣ 发送 HTTP 请求
- 浏览器构造 HTTP 报文：
    `GET /index.html HTTP/1.1 Host: www.example.com User-Agent: Chrome/141.0 Accept: text/html Connection: keep-alive`
- 通过 TCP 发送至服务器；
- 若 HTTP/2：请求可能在同一连接中复用。
- 通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。
### 6️⃣ 服务器处理请求
- Web 服务器（如 Nginx）接收请求；
- 若是动态内容：
    - 转发给应用服务器（FastCGI、Servlet、Actix、Warp 等）
    - 执行业务逻辑、数据库查询；
- 生成 HTTP 响应：
    `HTTP/1.1 200 OK Content-Type: text/html Content-Length: 5120  <html>...</html>`
### 7️⃣ 浏览器渲染流程
1. **解析 HTML** → 构建 DOM 树；
2. **解析 CSS** → 构建 CSSOM；
3. **合并成 Render Tree**；
4. **计算布局（Layout）**；
5. **绘制（Painting）**；
6. **执行 JS（可能引起回流/重绘）**；
7. **显示到屏幕（GPU 合成层渲染）**。
### 8️⃣ TCP 四次挥手
连接关闭流程：
1. Client → FIN
2. Server → ACK
3. Server → FIN
4. Client → ACK
### 9️⃣ 缓存与连接复用
- **HTTP 缓存控制**：`ETag`、`Cache-Control`、`Last-Modified`
- **连接复用**：
    - HTTP/1.1：`keep-alive`
    - HTTP/2：多路复用
    - HTTP/3（基于 QUIC）：无队头阻塞



### TCP
接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。
- **源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。
- 接下来有包的**序**号，这个是为了解决包乱序的问题
- 接下来还有一些**状态位**。维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
- 窗口大小。TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。
- 拥塞控制
- 所以三次握手目的是**保证双方都有发送和接收的能力**。
	- syn
	- syn+ack
	- ack
	- TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看
- TCP 分割数据
- MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
- MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。数据会被以 MSS 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。
![](asserts/Pasted%20image%2020251014134527.png)
![](asserts/Pasted%20image%2020251014134554.png)

## Ip

在网络层（IP协议）​，网络层通过源目标IP，来寻找路线，**网络层（L3）** 决定了整个旅程的**下一跳**是谁（IP 地址）。
- 增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。
![](asserts/Pasted%20image%2020251014134634.png)
在 IP 协议里面需要有源地址 IP 和 目标地址 IP：
• 源地址IP，即是客户端输出的 IP 地址；
• 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。


因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06（十六进制），表示协议为 TCP。

**当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址**。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。

这个时候就需要根据路由表规则，来判断哪一个网卡作为源地址 IP。

在 Linux 操作系统，我们可以使用 route -n 命令查看当前系统的路由表。
![](asserts/Pasted%20image%2020251014134802.png)
举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 192.168.10.200。
![](asserts/Pasted%20image%2020251014134913.png)

1. 首先先和第一条目的子网掩码（Genmask）进行 **与运算**，得到结果为 192.168.10.0，但是第一个条目的 Destination 是 192.168.3.0，两者不一致所以匹配失败。
2. 再与第二条目的子网掩码进行 **与运算**，得到的结果为 192.168.10.0，与第二条目的 Destination 192.168.10.0 匹配成功，所以将使用 eth1 网卡的 IP 地址作为 IP 包头的源地址。

那么假设 Web 服务器的目标地址是 10.100.20.100，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

- 在本地，使用网关0.0.0.0表示**目标地址在本地局域网内 (On-link)：** 这条路由条目涵盖了本机连接的那个局域网（例如 192.168.1.0/24）。**不需要将数据包转发给任何路由器**。
- 第三条目比较特殊，它目标地址和子网掩码都是 0.0.0.0，这表示**默认网**关，如果其他所有条目都无法匹配，就会自动匹配这一行。**并且后续就把包发给路由器，Gateway 即是路由器的 IP 地址。**


## Mac
生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。
MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。
![](asserts/Pasted%20image%2020251014135935.png)
**数据链路层（L2）** 负责找到这个下一跳的**MAC 地址**，并完成**当前链路**上的物理发送。
- 数据链路层 (L2)、物理层 (L1)，数据链路头部 (MAC Header)： 
- **问题：** L2 只能识别 **MAC 地址**，但 L3 给的是 **IP 地址**。
- **解决方案：ARP 协议 (地址解析协议)**
    - 网络层（或其辅助协议 ARP）会查询下一跳 IP 地址 X 对应的 MAC 地址 M。
    - 如果 MAC 地址 M 在本地的 **ARP 缓存**中，直接使用。
    - 如果不在，主机/路由器会发送一个 **ARP 请求广播**到本地网络，询问：“谁是 IP 地址 X？请告诉我你的 MAC 地址。” 目标设备 X 会回复其 MAC 地址 M。
- **结果：** L3 成功获取了下一跳设备的 MAC 地址 M。
- **L2 的任务：** 数据链路层的工作就是将封装好的帧，通过其 MAC 地址，精确地发送到**物理相连**的下一个中转目标（路由器）。
	- 这里的“搜索”不是指全球搜索，而是指在**当前局域网（物理链路）上**的精确寻址和传输。
[MAC 包头里的协议类型（EtherType）和使用](../Mac/note/MAC%20包头里的协议类型（EtherType）和使用.md)
[Arp的广播和缓存机制](../ARP/Arp的广播和缓存机制.md)

>MAC 报文生成

至此，网络包的报文如下图。
![](asserts/Pasted%20image%2020251014143541.png)
## 出口 —— 网卡

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。

负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。

网卡驱动获取**网络包**之后，会将其**复制到网卡内的缓存区**中，接着会在其开头**加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。**

![](asserts/Pasted%20image%2020251014143649.png)

- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 FCS（帧校验序列）用来检查包传输过程是否有损坏
最后网卡会将包转为电信号，通过网线发送出去。

唉，真是不容易，发一个包，真是历经千辛万苦。致此，一个带有许多头部的数据终于踏上寻找目的地的征途了！
### 送别者 —— 交换机
下面来看一下包是如何通过交换机的。交换机的设计是将网络包**原样**转发到目的地。交换机工作在 MAC 层，也称为**二层网络设备**。
#### 交换机的包接收操作
转换：首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。

`FCS` 校验：然后通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。

交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，**交换机的端口不具有 MAC 地址**。

将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。

交换机的 MAC 地址表主要包含两个信息：

- 一个是设备的 MAC 地址，
- 另一个是该设备连接在交换机的哪个端口上。

![](asserts/Pasted%20image%2020251015155755.png)
举个例子，如果收到的包的接收方 MAC 地址为 `00-02-B3-1C-9C-F9`，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 `3` 号端口上，然后就可以通过交换电路将包发送到相应的端口了。

所以，**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。


#### 当 MAC 地址表找不到指定的 MAC 地址会怎么样？

地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。

这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后**只有相应的接收者才接收包，而其他设备则会忽略这个包**。

有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”

其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。

局域网中每秒可以传输上千个包，多出一两个包并无大碍。

此外，如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

数据包通过交换机转发抵达了路由器，准备要离开土生土长的子网了。此时，数据包和交换机离别时说道：“感谢交换机兄弟，帮我转发到出境的大门，我要出远门啦！”

### 出境大门 —— 路由器
#### 路由器与交换机的区别

网络包经过交换机之后，现在到达了**路由器**，并在此被转发到下一个路由器或目标设备。

这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。

不过在具体的操作过程上，路由器和交换机是有区别的。

- 因为**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 而**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。

#### 路由器基本原理

路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。

当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

#### **路由器的包接收操作**

首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

如果没问题则检查 MAC 头部中的**接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。
#### **查询路由表确定输出端口**
完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。

**MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

接下来，路由器会根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作。

转发操作分为几个阶段，首先是查询**路由表**判断转发目标。
![](asserts/Pasted%20image%2020251015160306.png)
### 路由器的发送操作

接下来就会进入包的**发送操作**。

首先，我们需要根据**路由表的网关列**判断对方的地址。

- 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。
- 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明**已抵达终点**。

知道对方的 IP 地址之后，接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。

路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。

接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。

网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。

发送出去的网络包会通过**交换机**到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

不知你发现了没有，在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

### 互相扒皮 —— 服务器 与 客户端
![](asserts/Pasted%20image%2020251015160817.png)

数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。










## TODO
- [x] 交换机下面的内容
- [x] 拥塞控制是什么？
# 参考
- https://xiaolincoding.com/network/1_base/what_happen_url.html#%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2-dns
- 《图解Http》

