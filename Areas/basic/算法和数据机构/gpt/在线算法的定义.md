---
tags:
  - backlog
---

### 一、在线算法的定义（Online Algorithm）

**在线算法（Online Algorithm）** 是指在**输入数据逐步到达**的过程中，算法**必须实时地、在未知未来输入的情况下**做出决策的一类算法。

换句话说：

> 在线算法无法预先获得全部输入，而是每次仅根据当前已知的信息作出最优或次优决策。

典型对比：

- **离线算法（Offline Algorithm）**：在处理前已知所有输入数据，可全局最优。
    
- **在线算法（Online Algorithm）**：输入一到即处理，无法回溯修改决策。
    

---

### 二、核心思想与原理

#### 1. 实时决策（Real-Time Decision Making）

在线算法的本质是“边输入边输出”。

- 输入序列：`x1, x2, x3, …, xn`
    
- 对每个输入 `xi`，算法必须立即给出响应 `yi`
    
- 无法等待或修改之前的决策
    

**数学抽象：**  
$$  
A_i = f(x_1, x_2, ..., x_i)  
$$  
即第 i 步的决策仅依赖前 i 个输入。

---

#### 2. 不确定性处理（Dealing with Uncertainty）

在线算法的最大挑战是：**未来输入未知**。

因此，它需要：

- **启发式策略（Heuristics）**：基于经验规则预测或贪心选择。
    
- **竞争比分析（Competitive Ratio）**：衡量在线算法相对于最优离线算法的性能。
    

**竞争比定义：**  
$$  
\text{Competitive Ratio} = \max_{inputs} \frac{\text{Cost(Online)}}{\text{Cost(Offline)}}  
$$

若一个在线算法在所有输入上都满足：  
$$  
\text{Cost(Online)} \leq c \times \text{Cost(Offline)} + k  
$$  
则称该算法为 **c-竞争（c-competitive）**。

---

#### 3. 增量构造（Incremental Construction）

在线算法通常采用**增量式构建状态**，每次输入更新当前状态。

典型模式：

1. **初始化状态 `S₀`**
    
2. **对每个输入 `xᵢ`：**
    
    - 更新状态 `Sᵢ = update(Sᵢ₋₁, xᵢ)`
        
    - 产出当前输出 `yᵢ = output(Sᵢ)`
        

这种“状态 + 输入 → 输出”的模式，使算法具备**在线性（online-ness）**。

---

### 三、经典案例

#### 1. Two Sum 一次哈希表解法

```rust
pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
    use std::collections::HashMap;
    let mut map = HashMap::new();
    for (i, n) in nums.iter().enumerate() {
        if let Some(&j) = map.get(&(target - n)) {
            return vec![j as i32, i as i32];
        }
        map.insert(*n, i);
    }
    vec![]
}
```

**在线特征：**

- 逐个读取元素 `nums[i]`
    
- 每次输入都立即更新哈希表（状态）
    
- 使用已有的历史信息判断当前输入是否有匹配解
    

**在线思想：**

> “当前输入 + 历史状态 → 即时判断解是否成立”，  
> 而不等待所有输入。

---

#### 2. LRU Cache（最近最少使用缓存）

- 输入：访问序列（每次访问一个页面）
    
- 输出：是否命中/缺页、缓存状态
    
- 算法每次必须立刻决定是否淘汰旧页
    

此类算法体现了典型的**局部最优 + 实时性**。

---

#### 3. 动态规划的在线版本

例如 **在线最短路径更新**：当图的边权改变时，实时更新最短路径。

这类算法通过**维护增量状态**来避免重新计算。

---

### 四、性能分析：竞争分析（Competitive Analysis）

#### 1. 离线最优对比

设：

- `C_online(I)`：在线算法在输入序列 I 上的代价
    
- `C_opt(I)`：最优离线算法代价
    

若对任意 I：  
$$  
C_{online}(I) \leq c \times C_{opt}(I) + k  
$$  
则称该算法的竞争比为 **c**。

#### 2. 示例

- LRU 算法在缓存大小为 k 时：  
    **竞争比 ≤ k**  
    意味着：在线 LRU 在最坏情况下最多比最优离线多花 k 倍代价。
    

---

### 五、应用场景

|领域|典型在线算法|核心思想|
|---|---|---|
|数据流|滑动窗口最大值、在线平均值|流式数据处理|
|算法交易|在线价格预测|基于历史趋势决策|
|内存管理|LRU、LFU|实时淘汰决策|
|网络调度|在线任务调度、路由优化|动态负载均衡|
|搜索推荐|在线学习（Online Learning）|实时模型更新|

---

### 六、扩展知识点

- **Online Learning**：机器学习中“在线学习算法”即是该思想的扩展。
    
- **Streaming Algorithms**：在输入流巨大时，只能保存有限状态。
    
- **Competitive Analysis vs Regret Minimization**：前者适用于确定性在线算法，后者用于统计/学习型在线算法。
    

---

### 七、总结

**核心总结：**

> 在线算法的精髓是：**以局部信息做实时决策**，在未知未来的情况下尽可能逼近全局最优。

**学习方法论：**

1. 理解输入流模型与状态转移。
    
2. 学习竞争分析的数学定义与证明。
    
3. 模拟典型在线算法的实时决策过程。
    
4. 从“离线转在线”的角度重构经典算法（如 Two Sum、LRU）。
    

**推荐练习：**

1. 实现 LRU Cache（LeetCode 146）
    
2. 实现在线滑动窗口最大值（LeetCode 239）
    
3. 改写 Two Sum 为在线流式输入版本
    
4. 比较贪心 vs 在线 vs 离线最优的性能差异
    

**重点关注的底层知识：**

- 状态机建模思想
    
- 哈希表与字典结构
    
- 竞争比数学定义与证明
    
- 在线学习与流式算法在现代系统中的应用