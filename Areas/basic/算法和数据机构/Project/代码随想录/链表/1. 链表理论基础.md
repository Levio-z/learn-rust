# 链表理论基础

## 定义

什么是链表，链表**是一种通过指针串联在一起的线性结构，每一个节点由两部分组成**，

- 一个是数据域一个是指针域（存放指向下一个节点的指针）
- 最后一个节点的指针域指向null（空指针的意思）。
- 链表的入口节点称为链表的头结点也就是head。

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=MzI2NjhhZjViMTYzZjNjY2VhZDk0OTM2MjY1N2M0ZjlfWDR1cFZyNVBvMHhhMFZkc0MyMVZlbG5yUU5RNlZkeFJfVG9rZW46U3JzSGJsRnV5b1ZtVnh4dFZIS2NHTWFzbktiXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

## 链表的类型

### 单链表

刚刚说的就是单链表。

### 双链表

单链表中的指针域只能指向节点的下一个节点。
双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
双链表 既可以向前查询也可以向后查询。
如图所示：

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=MjYwNWQxOGZhMWI5YzU2NjA4MmZlNjQ3OTcwODdkZjFfcW85ZkdIc0NzNmp2alZFY1VpTm5zRGY2Z3VzSHFQcEdfVG9rZW46VnlzNmJGMzRqb2JYTEl4UjVFR2M0UWJrbnZmXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

### 循环链表

循环链表，顾名思义，就是链表首尾相连。
循环链表可以用来解决约瑟夫环问题。

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNiZjMzN2QzN2FlZTRlYjVmNDg3ZmM2NzRjOTY1ZmZfVmE1N3hCUGROanhDN09LbWJ6eGd6NTJNaUtOeDJBTXJfVG9rZW46SzRRcGIwTHQ3b1hkUER4SUwxR2NBTWlhbjNmXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

## 链表的存储方式

了解完链表的类型，再来说一说链表在内存中的存储方式。
数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。
链表是通过指针域的指针链接在内存中各个节点。
所以**链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上**，分配机制取决于操作系统的内存管理。

如图所示：

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=N2NkMjE3YWE5YzQwMzExODY2NjBmMmE4OTdiMmMyNWJfZXVGQVNKajlrTk1MbHZmTzVLY2ZZa0lKd2VMVFhQNHZfVG9rZW46TWZPUWJuZ3p6b0c2TzJ4WThmNmNyQVl1bmVoXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。

## 链表的定义

接下来说一说链表的定义。
链表节点的定义，很多同学在面试的时候都写不好。
这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。
而在面试的时候，一旦要自己手写链表，就写的错漏百出。
定义链表节点方式，如下所示：

```Java
public class ListNode {
    // 结点的值
    int val;

    // 下一个结点
    ListNode next;

    // 节点的构造函数(无参)
    public ListNode() {
    }

    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }

    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

## 链表的操作

### 删除节点

删除D节点，如图所示：

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDlmNDJmYmViZjkyNzQ4ODM4Y2VkYmYxZmI3YjgzM2ZfZGxVVlFVWEhaV2J4b0d5RUJUdjNPdFBaNXlBY3BPSXRfVG9rZW46TmtuR2IzVDNQbzRzalh4eTJzQmNSUDhDbmxlXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

只要将C节点的next指针 指向E节点就可以了。
那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。
是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。
其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。

### 添加节点

如图所示：
![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=NWEyNGYyZTA0MDZjYTQxNjFiOTMyYzA4MWE4OGI0Y2NfMkllSFlSYjFRY0Vvd2x2YmxBNzRqTnFUcUJnVERSdDhfVG9rZW46S2pabWJkZVFYb0FWRVJ4S29LamNLMDA1bmxiXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。
但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

## 性能分析

再把链表的特性和数组的特性进行一个对比，如图所示：

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=NjljNmJhNjA0N2YyMDkwNzQxYTdlZGNjNmI2NWViNzNfYWxuWDlyY1RDMk14MkVWQnJURkVMa1VzRFc1WFBGY0RfVG9rZW46STFZOWJ0UUcxbzBzYjZ4d081VWNQS2F3blJiXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。
链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。
相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！

# 移除链表元素


# 设计链表

## 一、经典例题

> https://leetcode.cn/problems/design-linked-list/

## 二、思路

获取第n个节点

- 合法判断（小于0大于长度减一）
    

  

## 三、实现

### 3.1 单链表

```Java
class MyLinkedList {

    //size存储链表元素的个数
    int size;
    //虚拟头结点
    ListNode head;

    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }
    
    public int get(int index) {
        //如果index非法，返回-1
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode currentNode = head;
        //包含一个虚拟头节点，所以查找第 index+1 个节点
        for (int i = 0; i <= index; i++) {
            currentNode = currentNode.next;
        }
        return currentNode.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
          addAtIndex(size,val);
    }
    
    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        ListNode currentNode = new ListNode(0);
        currentNode.next=head;
        for(int i=0;i<=index;i++){
             currentNode=currentNode.next;
        }
        ListNode newNode =new ListNode(val);
        ListNode temp =currentNode.next;
        currentNode.next=newNode;
        newNode.next=temp;
        size++;
    }
    
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode currentNode = new ListNode(0);
        currentNode.next=head;
        for(int i=0;i<=index;i++){
             currentNode=currentNode.next;
        }
        currentNode.next = currentNode.next.next;  
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
 //单链表
class ListNode {
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val) {
        this.val=val;
    }

}
```

Python:

```Python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class MyLinkedList:

    def __init__(self, val=0, next=None):
        self.dummy_head = ListNode()
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        current = self.dummy_head.next

        for i in range(index):
            current = current.next
        return current.val

    def addAtHead(self, val: int) -> None:
        self.addAtIndex(0, val)

    def addAtTail(self, val: int) -> None:
        self.addAtIndex(self.size, val)

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        current = self.dummy_head
        for i in range(index):
            current = current.next
        current.next = ListNode(val, current.next)
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        current = self.dummy_head
        for i in range(index):
            current = current.next
        current.next = current.next.next
        self.size -= 1


# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

### 3.2 双链表

```Java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //头结点逻辑
        while (head != null && head.val == val) {
            head = head.next;//C++这里要记录head并手动释放内存
        }
        ListNode cur = head;
        //非头节点逻辑
        while ((cur != null && cur.next != null)) {
            if (cur.next.val == val) {
                cur.next = cur.next.next;//C++这里要记录head并手动释放内存
            } else {
                cur= cur.next;
            }
        }
        return cur;
    }
}
```

Python 双链表

```Python
class ListNode:
    def __init__(self, val=0, prev=None,next=None):
        self.val = val
        self.prev =prev
        self.next = next

class MyLinkedList:

    def __init__(self, val=0, next=None):
        self.head =None
        self.tail =None
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        if index < self.size // 2:
            current = self.head
            for i in range(index):
                current = current.next
        else:
            current = self.tail
            for i in range(self.size-index-1):
                current = current.prev

        return current.val

    def addAtHead(self, val: int) -> None:
         new_node = ListNode(val, None, self.head)
         if self.head:
            self.head.prev = new_node
         else:
            self.tail = new_node
         self.head = new_node
         self.size +=1   

    def addAtTail(self, val: int) -> None:
        new_node = ListNode(val,self.tail,None)
        if self.tail:
            self.tail.next = new_node
        else:
            self.head = new_node
        self.tail = new_node    
        self.size +=1   

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        if index ==0:
            self.addAtHead(val)
        elif index == self.size:
            self.addAtTail(val)
        else:
            if index < self.size // 2:
                current = self.head
                for i in range(index-1):
                    current = current.next
            else:
                current = self.tail
                for i in range(self.size-index):
                    current = current.prev
            new_node = ListNode(val,current,current.next)
            current.next.prev = new_node
            current.next = new_node
            self.size +=1            

    def deleteAtIndex(self, index: int) -> None:
        if index<0 or index>=self.size:
            return
        if index == 0:
            self.head = self.head.next
            if self.head:
                self.head.prev = None
            else:
                self.tail = None    
        elif index == self.size -1:
            self.tail = self.tail.prev
            if self.tail: 
                self.tail.next = None
            else:
                self.head = None
        else:
            if index < self.size // 2:
                current = self.head
                for i in range(index):
                    current = current.next
            else:
                current = self.tail
                for i in range(self.size-1-index):
                    current = current.prev
            current.prev.next =current.next
            current.next.prev = current.prev    
        self.size -= 1

    def print(self):
        currentNode = self.head  # Skip the dummy head node
        while currentNode:
            print(currentNode.val, end=" -> ")
            currentNode = currentNode.next
        print("null")
# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

## 四、练习题

# 翻转链表

## 一、经典例题

> https://leetcode.cn/problems/reverse-linked-list/description/

## 二、思路

### 2.1 双指针

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk4MWE4OWRkOGYwMGE0NzAyODM0YWY1MDRiZTBhYmRfRUY2cm96bTZGNlJoakpmTWNzb2JaRnYzNnJ0czZ4dm1fVG9rZW46UlliVWJxRDBGb2JIeWt4T2ZqNWNTWnBKbmZlXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

- 遍历每个指针，对每个指针进行翻转
    
    - 下一个遍历的节点在翻转箭头后，将遍历不到，翻转前先保存在临时变量里，保证遍历
        
    - pre依赖于当前的cur，所以移动指针先移动pre后移动cur
        

### 2.2 递归

  

## 三、实现

### 3.1 双指针

```Java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null; // 上一个节点，初始为空
        ListNode next; // 用于保存下一个节点
        
        while (head != null) {
            next = head.next; // 保存下一个节点
            head.next = prev; // 反转当前节点的指针
            prev = head; // 移动 prev 到当前节点
            head = next; // 移动 head 到下一个节点
        }
        
        return prev; // prev 现在是新的头节点
    }
}
```

### 3.2 递归

```Java
// 递归 
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    private ListNode reverse(ListNode prev, ListNode cur) {
        if (cur == null) {
            return prev;
        }
        ListNode temp = cur.next;// 先保存下一个节点
        cur.next = prev;// 反转
        // 传入下个节点要的参数，对下个节点反转
        return reverse(cur, temp);
    }
}
```

# [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

## 一、经典例题

> https://leetcode.cn/problems/swap-nodes-in-pairs/description/

## 二、思路

### 2.1 双指针

- 使用临时节点，找到遍历终止的条件
    
- 修改链表中节点的指针，如果该节点的指针需要时，需要在修改前暂存起来
    
- 设置一个虚拟头结点以处理节点之间的链接重置问题
    

#### 2.1.3 复杂度

- 时间复杂度：O(n)
    
- 空间复杂度：O(1
    

## 三、实现

### 3.1 双指针

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
       ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点
        dumyhead.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode cur = dumyhead;
         while (cur.next != null && cur.next.next != null) {
          // 保存第一个节点位置
          ListNode temp = cur.next;
          // 保存第二个节点指向的后一个节点的位置
          ListNode temp2 =cur.next.next.next;
          // cur节点和第一个节点链接断开，指向第二个节点
          cur.next = cur.next.next;
          // 原第二个节点指向第一个节点
          cur.next.next = temp;
          // 原来的第一个节点指向原来第二个节点的后一个元素
          cur.next.next.next = temp2;
          // 当前两元素处理完成，当前指针向后平移两位
          cur = cur.next.next;
          
        }
        return dumyhead.next;  
    }
}
```

# 删除链表的倒数第N个节点

## 一、经典例题

> https://leetcode.cn/problems/remove-nth-node-from-end-of-list/

## 二、思路

### 2.1 双指针

- 使用临时节点，找到遍历终止的条件
    
- 修改链表中节点的指针，如果该节点的指针需要时，需要在修改前暂存起来
    
- 设置一个虚拟头结点以处理节点之间的链接重置问题
    

#### 2.1.3 复杂度

- 时间复杂度：O(n)
    
- 空间复杂度：O(1)
    

## 三、实现

### 3.1 快慢指针

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //新建一个虚拟头节点指向head
        ListNode dummyNode = new ListNode(0);
        dummyNode.next =head;
        //快慢指针指向虚拟头节点
        ListNode fastIndex = dummyNode;
        ListNode slowIndex = dummyNode;
        while(n>=0){
             fastIndex = fastIndex.next;
             n--;
        }
         while (fastIndex != null) {
            fastIndex = fastIndex.next;
            slowIndex = slowIndex.next;
        }
        // 此时 slowIndex 的位置就是待删除元素的前一个位置。
        // 具体情况可自己画一个链表长度为 3 的图来模拟代码来理解
        // 检查 slowIndex.next 是否为 null，以避免空指针异常
        if (slowIndex.next != null) {
            slowIndex.next = slowIndex.next.next;
        }
        return dummyNode.next;
    }
}
```

# 链表相交

## 一、经典例题

> https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/

## 二、思路

求各自的长度，求长度差，让长的移动长度差个位置，知道他们结尾的元素数是相同的。然后去找胶是否相同的元素。

## 三、实现

### 3.1 解法一

```Java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;
        int lenA = 0, lenB = 0;
        while (curA != null) { // 求链表A的长度
            lenA++;
            curA = curA.next;
        }
        while (curB != null) { // 求链表B的长度
            lenB++;
            curB = curB.next;
        }
        curA = headA;
        curB = headB;
        // 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            //1. swap (lenA, lenB);
            int tmpLen = lenA;
            lenA = lenB;
            lenB = tmpLen;
            //2. swap (curA, curB);
            ListNode tmpNode = curA;
            curA = curB;
            curB = tmpNode;
        }
        // 求长度差
        int gap = lenA - lenB;
        // 让curA和curB在同一起点上（末尾位置对齐）
        while (gap-- > 0) {
            curA = curA.next;
        }
        // 遍历curA 和 curB，遇到相同则直接返回
        while (curA != null) {
            if (curA == curB) {
                return curA;
            }
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }

}
```

  

```TypeScript
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        A,B = headA,headB
        lenA,lenB =0,0
        while A!= None:

           A =A.next
           lenA +=1
        while B!= None:
           B =B.next
           lenB +=1
        A,B = headA,headB
        if lenB>lenA:
            lenA,lenB = lenB,lenA
            A,B = headB,headA
        for i in range(lenA-lenB): 
            if(A):
                A =  A.next        
        
        while A!=None:
            if(A==B):
               return A   
            A = A.next
            B = B.next
     
        return None   
        
```

### 3.1 解法二

```TypeScript
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        A,B = headA,headB
        while A!=B:
            A =A.next if A else headB
            B = B.next if B else headA
        return A     
        
```

  

# [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

## 一、经典例题

> https://leetcode.cn/problems/linked-list-cycle-ii/description/

## 二、思路

主要考察两知识点：

- 判断链表是否环
    
- 如果有环，如何找到这个环的入口
    

### 有环怎么判断

fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。

#### 如果有环怎么找到入口

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=MmZmM2YyOTNmODRhN2Y1YWMxODEzMDg3MDUzZTkyZThfd1dudjhBWWN4TWNuVHlEZGlrVTVQY2JZMWVhZEdTYmhfVG9rZW46VTd5MGJid0d5b1NFSHh4S0JRaGN2Z3Vsbng3XzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

相遇时： slow指针走过的节点数为: `x + y`， fast指针走过的节点数：`x + y + n (y + z)`

(x + y) * 2 = x + y + n (y + z)

x + y = n (y + z)

x = n (y + z) - y

n=0不成立，n就是大于等于1

`x = (n - 1) (y + z) + z`

  

为什么第一次在环中相遇，slow的 步数 是 x+y 而不是 x + 若干环的长度 + y 呢？

如果slow进环入口，fast也在环入口，那么把这个环展开成直线，就是如下图的样子：

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjcyODEwNTQzODEzMDJhNTY3ZTQ0YmY2Yzg0ZTU5NTFfd3JEcnhuVXJnajg1UTRQSVN6MmszdVUzcGl4aW16eFZfVG9rZW46TFROOWJiYklab0s0Q2l4MEJ3SGNIUjRhbnFlXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

可以看出如果slow 和 fast同时在环入口开始走，一定会在环入口3相遇，slow走了一圈，fast走了两圈。

重点来了，slow进环的时候，fast一定是在环的任意一个位置，如图：

![](https://owh4nhzcow5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTNlNTVhZTlmMjJhN2ZhZmU2YzBiNTRhZmQ3ODFjZTNfWUdMSnI3ZTNXRmNFMW15ZVd0ZkQ1dTVxQWlMTEVGTkxfVG9rZW46V2dQU2JhbjhybzBZSXh4V3c1VmN6a1dBbkNiXzE3NjMxOTI1MjM6MTc2MzE5NjEyM19WNA)

那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。

因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n。

也就是说**slow一定没有走到环入口3，而fast已经到环入口3了。**

  

  

## 三、实现

### 3.1 快慢指针

```Java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {// 有环
                ListNode index1 = fast;
                ListNode index2 = head;
                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```

### 3.2 集合（自己写的）

```Java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set<ListNode> set = new HashSet();
        Integer i =0;
        while(head!=null){
            if(!set.contains(head)){
             set.add(head);
            }else{
                return head;
            }
             if(head.next!=null){
                head=head.next;
             }else{
                return null;
             }
        }
        return null;
    }
}
```