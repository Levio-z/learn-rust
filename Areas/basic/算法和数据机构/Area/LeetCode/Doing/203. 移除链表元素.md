---
tags:
  - LeetCode
topic:
  - LeetCode
alog_tag: 链表
status:
  - Doing
难度:
  - 简单
---
## 思路

### 套路 1

要想删除节点 node，必须在 node 的前一个节点执行删除操作。
例如链表 1→2→3，要想删除 2，必须在节点 1 处操作，也就是把节点 1 的 next 更新为节点 3。

### 套路 2
如果头节点可能被删除，那么要在头节点之前添加一个哨兵节点，这样我们无需特判头节点被删除的情况，从而简化代码逻辑。
或者说，根据套路 1，要想删除头节点，必须在头节点的前一个节点操作，所以要添加一个哨兵节点。

### 算法

初始化哨兵节点 dummy，其 next 为 head。

- 遍历链表，初始化 cur=dummy。
- 循环直到 cur 的下一个节点为空。
- 如果 cur 的下一个节点的值等于 val，那么删除下一个节点，把 cur.next 更新为 cur.next.next。
- 如果 cur 的下一个节点的值不等于 val，那么不删除下一个节点，继续看下下一个节点是否要删除，即更新 cur 为 cur.next。
- 循环结束，返回 dummy.next，即删除节点后的新链表的头节点。

## 代码

### Rust1

```java
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
 pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {
    // p作为一个指针，一定需要可变的
    let mut p = &mut head;
    // 判断p是不是空指针
    while let Some(node) = p{
        if node.val == val{
            // 直接修改了p的内容
            *p = node.next.take();
        }else{
            p = &mut p.as_mut().unwrap().next;
        }
    }
    head
    }
}
```

### Rust2

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn remove_elements(head: Option<Box<ListNode>>   , val: i32) -> Option<Box<ListNode>> {
        let mut dummy = Box::new(ListNode { val: 0, next: head });
        // dummy产生了一个引用cur
        let mut cur = &mut dummy;
    
        // 使用dummy引用访问字段，获取cur.next对象的引用,cur.next产生了一个引用，nxt
        while let Some(ref mut nxt) = cur.next {
            // 使用nxt
            if nxt.val == val {
                // 右边 使用nxt
                cur.next = nxt.next.take(); 
                
            } else {
                // 获取字段的引用
                cur = cur.next.as_mut().unwrap(); // 继续向后遍历链表

            }
        }
        // dummy的引用生命周期结束
        dummy.next
    }
}
```
- 访问借用的字段是使用借用 → 合法；  
- 重新绑定 cur 是修改结构 → 与活跃可变借用冲突 → 非法。
# Java

## 一、经典例题

> [https://leetcode.cn/problems/remove-linked-list-elements/description/](https://leetcode.cn/problems/remove-linked-list-elements/description/)

## 二、思路

移除操作，就是让节点next指针直接指向下下一个节点就可以了。需要被删除节点的上一个指针的索引。

- 直接使用原来的链表来进行删除操作。
- 设置一个虚拟头结点在进行删除操作。

## 三、实现

### 3.1 虚拟头节点

```
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0, head);
        ListNode cur = dummy;
        while (cur.next != null) {
            if (cur.next.val == val) {
                cur.next = cur.next.next; // 删除下一个节点
            } else {
                cur = cur.next; // 继续向后遍历链表
            }
        }
        return dummy.next;
    }
}

```

> C要手动释放内存与定义的dummyHead

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummyHead = ListNode(next=head)
        cur = dummyHead
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return dummyHead.next

```

### 3.1.2 复杂度

- 时间复杂度 O(n):
- 空间复杂度 O(1)

### 3.2 递归

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
       if not head:
           return
       head.next = self.removeElements(head.next, val)
       return head.next if head.val == val else head

```

### rust的借用检查报错
