### 一、核心定义与区别概览

|项目|LFU（最少使用）|LRU（最近最少使用）|
|---|---|---|
|**淘汰依据**|被访问的次数（频率）最少|距离现在最久未被访问|
|**核心思想**|使用频率低的对象被淘汰|最近没有被访问的对象被淘汰|
|**适合场景**|热点数据长期稳定|热点数据经常变化|
|**时间维度**|长期统计|短期访问行为|
### 2.五花八门的链表结构
#### 从底层的存储结构分析
从图中我们看到，数组需要⼀块连续的内存空间来存储，对内存的要求⽐较⾼。如果我们申请⼀个100MB⼤⼩的数组，当内存中没有连续的、⾜够⼤的存储空间时，即便内存的剩余总可⽤空间⼤于100MB，仍然会申请失败
⽽链表恰恰相反，它并不需要⼀块连续的内存空间，它通过“指针”将⼀组零散的内存块串联起来使⽤，所以如果我们申请的是100MB⼤⼩的链表，根本不会有问题。
![](../../asserts/Pasted%20image%2020250728212227.png)
#### 单链表
链表**通过指针将⼀组零散的内存块串联在⼀起**。其中，我们把内存块称为链表的“结点”。为了将所有的结点串 起来，每个链表的结点除了存储数据之外，还需要记录链上的下⼀个结点的地址。如图所示，我们把这个记录下个结点地址的 指针叫作后继指针next。
![](../../asserts/Pasted%20image%2020250728212405.png)从我画的单链表图中，你应该可以发现，其中有两个结点是⽐较特殊的，它们分别是第⼀个结点和最后⼀个结点。我们习惯性地把第⼀个结点叫作头结点，把最后⼀个结点叫作尾结点。其中，头结点⽤来记录链表的基地址。有了它，我们就可以遍历得 到整条链表。⽽尾结点特殊的地⽅是：指针不是指向下⼀个结点，⽽是指向⼀个空地址NULL，表示这是链表上最后⼀个结点。

与数组⼀样，链表也⽀持数据的查找、插⼊和删除操作。
- 我们知道，在进⾏数组的插⼊、删除操作时，为了保持内存数据的连续性，需要做⼤量的数据搬移，所以时间复杂度是O(n)。 ⽽在链表中插⼊或者删除⼀个数据，我们并不需要为了保持内存的连续性⽽搬移结点，因为链表的存储空间本身就不是连续 的。所以，在链表中插⼊和删除⼀个数据是⾮常快速的。
- 为了⽅便你理解，我画了⼀张图，从图中我们可以看出，针对链表的插⼊和删除操作，我们只需要考虑相邻结点的指针改变， 所以对应的时间复杂度是O(1)。
![](../../asserts/Pasted%20image%2020250728214019.png)
但是，有利就有弊。链表要想随机访问第k个元素，就没有数组那么⾼效了。因为链表中的数据并⾮连续存储的，所以⽆法像数组那样，根据⾸地址和下标，通过寻址公式就能直接计算出对应的内存地址，⽽是需要根据指针⼀个结点⼀个结点地依次遍 历，直到找到相应的结点。

你可以把链表想象成⼀个队伍，队伍中的每个⼈都只知道⾃⼰后⾯的⼈是谁，所以当我们希望知道排在第k位的⼈是谁的时候，我们就需要从第⼀个⼈开始，⼀个⼀个地往下数。所以，链表随机访问的性能没有数组好，需要O(n)的时间复杂度。

好了，单链表我们就简单介绍完了，接着来看另外两个复杂的升级版，循环链表和双向链表。

循环链表是⼀种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯⼀的区别就在尾结点。我们知道，单链表的尾结点 指针指向空地址，表示这就是最后的结点了。⽽循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该 可以看出来，它像⼀个环⼀样⾸尾相连，所以叫作“循环”链表。

