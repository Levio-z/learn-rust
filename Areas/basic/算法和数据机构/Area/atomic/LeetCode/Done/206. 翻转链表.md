---
tags:
  - LeetCode
topic:
  - LeetCode
alog_tag: 链表
status:
  - Done
难度:
  - 简单
url: https://leetcode.cn/problems/reverse-linked-list/description/
github_url: https://github.com/Levio-z/leetcode-rust/blob/master/doc/s0206_01_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8_%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%80%92%E5%BD%92.md
实现: https://github.com/Levio-z/leetcode-rust/blob/master/src/solution/s0206_reverse_linked_list.rs
---
- [rust实现](https://github.com/Levio-z/leetcode-rust/blob/master/src/solution/s0206_reverse_linked_list.rs)
- 遍历每个指针，对每个指针进行翻转
    - 下一个遍历的节点在翻转箭头后，将遍历不到，翻转前先保存在临时变量里，保证遍历
    - pre依赖于当前的cur，所以移动指针先移动pre关联现在cur，后再修改cur

### Java
```Java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null; // 上一个节点，初始为空
        ListNode next; // 用于保存下一个节点
        
        while (head != null) {
            next = head.next; // 保存下一个节点
            head.next = prev; // 反转当前节点的指针
            prev = head; // 移动 prev 到当前节点
            head = next; // 移动 head 到下一个节点
        }
        
        return prev; // prev 现在是新的头节点
    }
}
```

```Java
// 递归 
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    private ListNode reverse(ListNode prev, ListNode cur) {
        if (cur == null) {
            return prev;
        }
        ListNode temp = cur.next;// 先保存下一个节点
        cur.next = prev;// 反转
        // 传入下个节点要的参数，对下个节点反转
        return reverse(cur, temp);
    }
}
```