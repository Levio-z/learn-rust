在本节中，我们讨论运输层的多路复用与多路分解，也就是将由网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务。为了使讨论具体起见，我们将在因特网环境中讨论这种基本的运输层服务。然而，需要强调的是，多路复用与多路分解服务是所有计算机网络都需要的。
- 在目的主机，运输层从紧邻其下的网络层接收报文段。运输层负责**将这些报文段中的数据交付给在主机上运行的适当应用程序进程**。
	- 例子
		- 我们来看一个例子。假定你正坐在计算机前下载Web页面，同时还在运行一个FTP会话和两个Telnet会话。这样你就有4个网络应用进程在运行，即两个Telnet进程，一个FTP进程和一个HTTP进程。当你的计算机中的运输层从底层的网络层接收数据时，它需要将所接收到的数据定向到这4个进程中的一个。现在我们来研究这是怎样完成的。
		- 首先回想2.7节的内容，一个进程（作为网络应用的一部分）有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，如图3-2所示，在接收主机中的**运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字**。由于在任一时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式取决于它是UDP还是TCP套接字，我们将很快对它们进行讨论。
![](Pasted%20image%2020250617163822.png)
接收主机怎样将一个到达的运输层报文段定向到适当的套接字？
- 多路分解：为此目的，每个运输层报文段中具有几个字段。在接收端，运输层**检查这些字段，标识出接收套接字**，进而**将报文段定向到该套接字**。将运输层报文段中的数据交付到正确的套接字的工作称为多路分解(demultiplexing)。
- 多路复用：在源主机从**不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络层**，所有这些工作称为多路复用(multiplexing)。
- 值得注意的是，图3-2 中的中间那台主机的运输层必须将从其下的网络层收到的报文段分解后交给其上的P进程;这一过程是通过将到达的报文段数据定向到对应进程的套接字来完成的。
- 中间主机中的运输层也必须收集从这些套接字输出的数据，形成运输层报文段，然后将其向下传递给网络层。尽管我们在因特网运输层协议的环境下引人了多路复用和多路分解，认识到下列事实是重要的:它们与在某层(在运输层或别处)的单一协议何时被位于接下来的较高层的多个协议使用有关。
- 为了说明分解的工作过程，再回顾一下前面一节的家庭类比。每一个孩子通过他们的名字来标识。当 Bill 从邮递员处收到一批信件，并通过查看收信人名字而将信件亲手交付给他的兄弟姐妹们时，他执行的就是一个分解操作。当 Ann 从兄弟姐妹们那里收集信件并将它们交给邮递员时，她执行的就是一个多路复用操作。

在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那样，UDP 大体上是这样做的。然而，也将如我们所见，TCP 中的多路复用与多路分解更为复杂。

主机实际是怎么工作的
- 运输层邮多路复用要求
	- 套接字有唯一标识符
	- 每个报文段有特殊字段来指示该报文段交付的套接字
- 特殊字段：源端口号字段和目的端口号字段
- 16比特 0-65535之间
- 0-1023是周知端口号，是受限制，保留HTTP或FTP之类的周知应用层协议。
### 1.无连接的多路复用和多路分解

创建一个UDP套接字：
- 当用这种方式创建一个UDP套接字时，运输层自动地为该套接字分配一个端口号。特别是，运输层从范围1024~65535 内分配一个端口号，该端口号是当前未被该主机中任何其他UDP端口使用的号。另外一种方法是，在创建一个套接字后，我们能够在 Python程序中增加一行代码，通过套接字bind()方法为这个UDP套接字关联一个特定的端口号(如19157)
```
elientSocket.bind(('',19157))
```
- 如果应用程序开发者所编写的代码实现的是一个“周知协议”的服务器端，那么开发者就必须为其分配一个相应的周知端口号。
- 通常，应用程序的客户端让运输层自动地(并且是透明地)分配端口号，而服务器端则分配一个特定的端口号。

通过为UDP套接字分配端口号，我们现在能够精确地描述UDP的复用与分解了。
- 假定在主机A中的一个进程具有UDP端口19157，他要发送一个应用程序数据块给位于主机B中的另一进程，该进程具有端口46428。主机A中的运输层创建一个运输层报文段，其中包括应用程序数据、源端口号、目的端口号和两个其他值。然后运输层将报文传递到网络层。网络层将报文段封装到一个IP数据报，并尽而为将报文段交付给接受主机。如果该报文段到达接收主机B，接收主机运输层就检查该报文段中的目的端口号(46428)并将该报文段交付给端口号46428所标识的套接字。值得注意的是，主机B能够运行多个进程，每个进程有自己的UDP套接字及相应的端口号。值得注意的是，主机B可能运行多个进程，每个进程都具有其自己的UDP 套接字和相联系的端口号。当 UDP 报文段从网络到达时，主机B通过检查该报文段中的目的端口号，将每个报文段定向(分解)到相应的套接字。

UDP套接字组成：一个UDP套接字是由一个二元组全面标识的，**该二元组包含一个目的IP地址和一个目的端口号**。因此，如果两个UDP报文段有不同的源IP 地址和/或源端口号，但具有相同的目的IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。

源端口号的用途：作为返回地址的一部分。当B需要回发一个报文段给A时，B到A的报文段中的目的端口号便从A到B的报文段中的源端口号中取值。

### 2.面向连接的多路复用与多路分解
TCP套接字是由一个四元组(源IP 地址，源端口号，目的 IP 地址，目的端口号)来标识的。

因此，当一个 TCP 报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向(分解)到相应的套接字。特别与UDP 不同的是，两个具有不同源IP地址或源端口号的到达TCP 报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。

  - ·TCP服务器应用程序有一个“欢迎套接字”​，它在12000 号端口上等待来自 TCP 客户(见图2-27)的连接建立请求。
  - 一条连接建立请求只不过是一个目的端口号为12000，TCP首部的特定“连接建立位”置位的TCP报文段(在3.5节进行讨论)。这个报文段也包含一个由客户选择的源端口号。
  - 当运行服务器进程的计算机的主机操作系统接收到具有目的端口12000的人连接请求报文段后，它就定位服务器进程，该进程正在端口号12000等待接受连接。该服务器进程则创建一个新的套接字:
  - 该服务器的运输层还注意到连接请求报文段中的下列4个值:
	  - 该报文段中的源端口号
	  - 源主机IP地址
	  - 该报文段中的目的端口号
	  - 自身的 IP 地址
新创建的连接套接字通过这4个值来标识。所有后续到达的报文段，如果它们的源端口号、源主机 IP 地址、目的端口号和目的 IP 地址都与这 4 个值匹配，则被分解到这个套接字。服务器主机可以支持很多并行的 TCP 套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字。当一个 TCP 报文段到达主机时，所有4个字段(源 IP 地址，源端口，目的IP地址，目的端口)被用来将报文段定向(分解)到相应的套接字。
### 关注安全性
#### 端口扫描
我们已经看到一个服务器进程潜在地在一个打开的端口等待远程客户的接触。某些端口为周知应用程序(例如Web、FTP、DNS和SMTP服务器)所预留;依照惯例其他端口由流行应用程序(例如微软2000SQL服务器在UDP1434端口上监听请求)使用。因此，如果我们确定一台主机上打开了一个端口，也许就能够将该端口映射到在该主机运行的一个特定的应用程序上。这对于系统管理员非常有用，系统管理员通常希望知晓有什么样的网络应用程序正运行在他们的网络主机上。而攻击者为了“寻找突破口”​，也要知道在目标主机上有哪些端口打开。如果发现一台主机正在运行具有已知安全缺陷的应用程序(例如，在端口1434 上监听的一台SQL服务器会遭受缓存溢出，使得一个远程用户能在易受攻击的主机上执行任意代码，这是一种由Slammer蠕虫所利用的缺陷`[CERT 2003-04]`)，那么该主机已成为攻击者的囊中之物了。
确定哪个应用程序正在监听哪些端口是一件相对容易的事情。事实上有许多公共域程序(称为端口扫描器)做的正是这种事情。也许它们之中使用最广泛的是nmap，该程

### 3.Web服务器与TCP
然而，我们要提及的是，连接套接字与进程之间并非总是有着一一对应的关系。事实上，当今的高性能Web 服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。(线程可被看作是一个轻量级的子进程。) 如果做了第2章的第一个编程作业，你所构建的 Web服务器就是这样工作的。对于这样一台服务器，在任意给定的时间内都可能有(具有不同标识的)许多连接套接字连接到。
持续HTTP和非持续HTTP
- 如果客户与服务器使用持续 HTTP，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换 HTTP 报文。然而，如果客户与服务器使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭。这种套接字的频繁创建和关闭会严重地影响一个繁忙的 Web服务器的性能(尽管有许多操作系统技巧可用来减轻这个问题的影响)。读者若对与持续和非持续HTTP 有关的操作系统问题感兴趣的话，可参见`[Nielsen 1997Nahum 2002]`​。既然我们已经讨论过了运输层多路复用与多路分解问题，下面我们就继续讨论因特网运输层协议之一，即UDP。在下一节中，我们将看到UDP 无非就是对网络层协议增加了一点(多路)复用/(多路)分解服务而已。

