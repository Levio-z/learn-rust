
前面讲过，一条 TCP 连接的每一侧主机都为该连接设置了接收缓存。**当该 TCP 连接收到正确、按序的字节后，它就将数据放入接收缓存。相关联的应用程序进程会从该缓存中读取数据**，但不必是数据刚一到达就立即读取。事实上，接收方应用也许正忙于其他任务，甚至要过很长时间后才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。

TCP为它的应用程序提供了流量控制服务(flow-control service)以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。前面提到过，TCP 发送方也可能因为IP网络的拥塞而被遏制;这种形式的发送方的控制被称为拥塞控制(congestioncontrol)，我们将在3.6节和3.7节详细地讨论这个主题。即使流量控制和拥塞控制采取的动作非常相似(对发送方的遏制)，但是它们显然是针对完全不同的原因而采取的措施。不幸的是，许多作者把这两个术语混用，理解力强的读者会明智地区分这两种情况。现在我们来讨论 TCP 如何提供流量控制服务的。为了能从整体上看问题，我们在本节都假设TCP 是这样实现的，即 TCP接收方丢弃失序的报文段。

TCP通过让发送方**维护一个称为接收窗口(receive window)的变量来提供流量控制**。通俗地说，**接收窗口用于给发送方一个指示--该接收方还有多少可用的缓存空间**。因为TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。我们在文件传输的情况下研究接收窗口。假设主机A通过一条TCP连接向主机B发送一个大文件。**主机B为该连接分配了一个接收缓存，并用 RevBuffer来表示其大小**。主机B上的应用进程不时地从该缓存中读取数据。我们定义以下变量:
- LastByteRead:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号
- LastByteRevd:从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号

由于 TCP 不允许已分配的缓存溢出，下式必须成立： `LastByteRecvd−LastByteRead≤RecvBuffer`
接收窗口用 `rwnd` 表示，根据缓存可用空间的数量来设置： 
`rwnd=RecvBuffer−[LastByteRecvd−LastByteRead]`
由于该空间是随着时间变化的，所以 `rwnd` 是动态的。图 3-38 对变量 `rwnd` 进行了图示。
连接是如何使用变量 `rwnd` 来提供流量控制服务的呢？**主机 B 通过把当前的 `rwnd` 值放入它发给主机 A 的报文段接收窗口字段中，通知主机 A 它在该连接的缓存中还有多少可用空间**。开始时，主机 B 设置 `rwnd = RecvBuffer`。注意到为了实现这一点，主机 B 必须跟踪几个与连接有关的变量。

图 3-38 接收窗口（rwnd）和接收缓存（RecvBuffer）

![](Pasted%20image%2020250618164448.png)

主机A轮流跟踪两个变量，LastByteSent和LastByteAcked，这两个变量的意义很明显。注意到这两个变量之间的差LastByteSent-LastByteAcked，就是**主机A发送到连接中但未被确认的数据量**。通过将未确认的数据量控制在值rwnd 以内，就可以保证主机A 不会使主机B 的接收缓存溢出。因此，主机 A在该连接的整个生命周期须保证:

LastByteSent-LastByteAcked<=`rwnd`


描述了TCP的流量控制服务以后，我们在此要简要地提一下UDP并不提供流量控制，报文段由于缓存溢出可能在接收方丢失。例如，考虑一下从主机A上的一个进程向主机B上的一个进程发送一系列UDP报文段的情形。对于一个典型的UDP实现，**UDP 将在一个有限大小的缓存中加上报文段，该缓存在相应套接字(进程的门户)“之前”**​。进程每次从缓存中读取一个完整的报文段。**如果进程从缓存中读取报文段的速度不够快，那么缓存将会溢出，并且将丢失报文段。**


