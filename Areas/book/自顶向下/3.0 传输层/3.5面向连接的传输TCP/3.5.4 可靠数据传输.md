前面讲过，因特网的网络层服务(IP服务)是不可靠的。IP 不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性。对于IP服务，数据报能够溢出路由器缓存而永远不能到达目的地，数据报也可能是乱序到达，而且数据报中的比特可能损坏(由0变为1或者相反)。由于运输层报文段是被IP数据报携带着在网络中传输的，所以运输层的报文段也会遇到这些问题。
TCP在IP 不可靠的尽力而为服务之上创建了一种可靠数据传输服务(reliable datatransfer service)。TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流;即该字节流与连接的另一方端系统发送出的字节流是完全相同。TCP 提供可靠数据传输的方法涉及我们在 3.4 节中所学的许多原理。

在我们前面研发可靠数据传输技术时，曾假定每一个已发送但未被确认的报文段都与一个定时器相关联，这在概念上是最简单的。虽然这在理论上很好，但**定时器的管理却需要相当大的开销**。因此，**推荐的定时器管理过程`[RFC 6298]`仅使用单一的重传定时器**，即使有多个已发送但还未被确认的报文段。在本节中描述的TCP协议遵循了这种单一定时器的推荐。
图3-33给出了一个TCP发送方高度简化的描述。我们看到在TCP发送方有3个与发送和重传有关的主要事件:
- 从上层应用程序接收数据;
- 定时器超时和收到ACK。
- 一旦第一个主要事件发生，TCP 从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。

注意到**每一个报文段都包含一个序号**，如3.5.2 节所讲的那样，这个序号就是该报文段第一个数据字节的字节流编号。还要注意到**如果定时器还没有为某些其他报文段而运行，则当报文段被传给IP 时，TCP就启动该定时器**。(**将定时器想象为与最早的未被确认的报文段相关联是有帮助**的。)该定时器的过期间隔是TimeoutInterval，它是由3.5.3节中所描述的EstimatedRTT 和DevRTT计算得出的。
```

NextSeqNum = InitialSeqNumber
SendBase = InitialSeqNumber

loop (永远) {
    switch (事件) {

        事件：从上层应用程序接收到数据 e
            // 构造并发送 TCP 报文段
            segment = 封装TCP报文段(e, seq=NextSeqNum)
            if (定时器当前没有运行)
                启动定时器()
			向IP传递报文段
            NextSeqNum = NextSeqNum + 长度(e)
            break

        事件：收到对段的 ACK 报文段 ack
            if (ack >= SendBase)
                SendBase = ack + 1

                if (SendBase == NextSeqNum)
                    停止定时器()
                else
                    重新启动定时器()
            break

        事件：定时器超时
            重传具有最小序号但仍未应答的报文段
            启动定时器()
            break
    }
}


```
图3-33简化的TCP 发送方

第二个主要事件是超时。TCP通过重传引起超时的报文段来响应超时事件。然后TCP重启定时器。

TCP发送方必须处理的第三个主要事件是，到达一个来自接收方的确认报文段(ACK)(更确切地说，是一个包含了有效ACK 字段值的报文段)。当该事件发生时，TCP 将 ACK 的值y与它的变量SendBase 进行比较。TCP 状态变量SendBase 是最早未被确认的字节的序号。(因此SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号。 如前面指出的那样，TCP 采用累积确认，所以y确认了字节编号在y之前的所有字节都已经收到。如果y>SendBase，则该ACK是在确认一个或多个先前未被确认的报文段。因此发送方更新它的 SendBase 变量;如果当前有未被确认的报文段，TCP 还要重新启动定时器。

### 1.一些有趣的情况
我们刚刚描述了一个关于TCP 如何提供可靠数据传输的高度简化的版本。但即使这种高度简化的版本，仍然存在着许多微妙之处。为了较好地感受该协议的工作过程，我们来看几种简单情况。
**确认丢失，重传相同报文**：图3-34描述了第一种情况，主机A 向主机B发送一个报文段。假设该报文段的序号是92，而且包含8字节数据。在发出该报文段之后，主机A等待一个来自主机B 的确认号为100的报文段。虽然A 发出的报文段在主机B 上被收到，但从主机 B发往主机A的确认报文丢失了。在这种情况下，超时事件就会发生，主机A 会重传相同的报文段。当然，当主机B收到该重传的报文段时，它将通过序号发现该报文段包含了早已收到的数据。因此，主机B中的TCP 将丢弃该重传的报文段中的这些字节。

**超时前到达，第二个报文段不会重传**：在第二种情况中，如图3-35所示，主机A连续发回了两个报文段。第一个报文段序号是92，包含8字节数据;第二个报文段序号是100，包含20字节数据。假设两个报文段都完好无损地到达主机B，并且主机B为每一个报文段分别发送一个确认。第一个确认报文的确认号是100，第二个确认报文的确认号是120。现在假设在超时之前这两个报文段中没有一个确认报文到达主机A。当超时事件发生时，主机A 重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段将不会被重传。
![](Pasted%20image%2020250618161531.png)
**累计确认确保两个报文段都不重传**：第三和第二个一样，超时发送之前，第一个报文段的确认报文在网络丢失，A收到了第二个确认号为120的确认报文。主机A知道了主机B已经收到了序号为119之前的所有字节，所有主机A不会重传这两个报文段中的任何一个。
![](Pasted%20image%2020250618161804.png)

### 2.超时间隔加倍
我们现在讨论一下在大多数TCP实现中所做的一些修改。首先关注的是定时器间隔过期后超时间隔的长度。在这种修改中，每当超时事件发生时，TCP会重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从EstimatedRTT和DevRTT推算出的值（如在3.5.3节中所描述的）。

例如，假设当定时器第一次过期时，与最早的未被确认的报文段相关联的timeoutInterval是0.75秒。TCP就会重传该报文段，并把新的过期时间设置为1.5秒。如果1.5秒后定时器又过期了，则TCP将再次重传该报文段，并把过期时间设置为3.0秒。因此，超时间隔在每次重传后会呈指数型增长。然而，每当定时器在另两个事件（即收到上层应用的数据和收到ACK）中的任意一个启动时，TimeoutInterval由最近的EstimatedRTT值与DevRTT值推算得到。

这种修改提供了一个形式受限的拥塞控制。(更复杂的TCP拥塞控制形式将在3.7 节中学习。)定时器过期很可能是由网络拥塞引起的，即太多的分组到达源与目的地之间路径上的一台(或多台)路由器的队列中，造成分组丢失或长时间的排队时延。在拥塞的时候，如果源持续重传分组，会使拥塞更加严重。相反，TCP 使用更文雅的方式，每个发送方的重传都是经过越来越长的时间间隔后进行的。当我们在第6章学习CSMA/CD时，将看到以太网采用了类似的思路。
### 3. 快速重传
超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前**通过注意所谓冗余ACK来较好地检测到丢包情况。冗余ACK(duplicate ACK)就是再次确认某个报文段的ACK**，而发送方先前已经收到对该报文段的确认。要理解发送方对冗余 ACK 的响应，我们必须首先看一下接收方为什么会发送冗余ACK。表3-2总结了TCP 接收方的ACK 生成策略`[RFC5681]​`。当TCP接收方收到一个具有这样序号的报文段时，即其序号大于下一个所期望的、按序的报文段，它检测到了数据流中的一个间隔，这就是说有报文段丢失。这个间隔可能是由于在网络中报文段丢失或重新排序造成的。因为TCP 不使用否定确认，所以接收方不能向发送方发回一个显式的否定确认。相反，它只是对已经接收到的最后一个按序字节数据进行重复确认(即产生一个冗余ACK)即可。(注意到在表3-2 中允许接收方不丢弃失序报文段。)
![](Pasted%20image%2020250618162323.png)
因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。**如果 TCP 发送方接收到对相同数据的3 个冗余 ACK，它把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失**。(在课后习题中，我们将考虑为什么发送方等待3个冗余ACK，而不是仅仅等待一个冗余ACK。)一旦收到3个冗余ACK，TCP就执行快速重传(fast retransmit)`[RFC 5681]`​，即在该报文段的定时器过期之前重传丢失的报文段。对于采用快速重传的TCP，可用下列代码片段代替图3-33中的ACK收到事件

前面讲过，当在如 TCP 这样一个实际协议中实现超时/重传机制时，会产生许多微妙的问题。上面的过程是在超过20年的TCP定时器使用经验的基础上演化而来的，读者应当理解实际情况确实是这样的。
```
NextSeqNum = InitialSeqNumber
SendBase = InitialSeqNumber
冗余ACK计数器 = 0

loop (永远) {
    switch (事件) {

        事件：从上层应用程序接收到数据 e
            segment = 封装TCP报文段(e, seq=NextSeqNum)
            向IP传递报文段(segment)

            if (定时器当前没有运行)
                启动定时器()

            NextSeqNum = NextSeqNum + 长度(e)
            break

        事件：收到对段的 ACK 报文段 ack
            if (ack > SendBase - 1) {
                // 收到新的 ACK，更新窗口，重置冗余ACK计数器
                SendBase = ack
                冗余ACK计数器 = 0

                if (SendBase == NextSeqNum)
                    停止定时器()
                else
                    重新启动定时器()

            } else if (ack == SendBase - 1) {
                // 收到冗余 ACK
                冗余ACK计数器 += 1

                if (冗余ACK计数器 == 3) {
                    // 触发快速重传
                    重传段(seq=SendBase)
                    启动定时器()
                }
            }
            break

        事件：定时器超时
            重传具有最小序号但仍未应答的报文段（seq=SendBase）
            启动定时器()
            break
    }
}


```
### 4.是回退N步还是选择重传
考虑下面这个问题来结束有关TCP差错恢复机制的学习:TCP是一个GBN协议还是一个SR 协议?前面讲过，TCP 确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的。因此，如图3-33所示(也可参见图3-19)，TCP 发送方仅需维持已发送过但未被确认的字节的最小序号(SendBase)和下一个要发送的字节的序号(NextSeqNum)。在这种意义下，TCP 看起来更像一个GBN 风格的协议。但是TCP 和 GBN协议之间有着一些显著的区别。许多 TCP 实现会将正确接收但失序的报文段缓存起来`[ Stevens 1994]`​。
另外考虑一下，当发送方发送的一组报文段1，2，…，N，并且所有的报文段都按需无差错地到达接收方会发生的情况。进一步假设对分组 n < N 的确认报文丢失，但是其余 N-1 个确认报文在分别超时以前到达发送端，这时又会发生的情况。在该例中，GBN不仅会重传分组 n，还会重传所有后继的分组 n+1，n+2，...，N。在另一方面，TCP 将重传至多一个报文段，即报文段 n。此外，如果对报文段 n+1 的确认报文在报文段 n 超时之前到达，TCP 甚至不会重传报文段 n。

对 TCP 提出的一种修改意见是所谓的选择确认（selective acknowledgment）`[RFC 2018]`，它允许 TCP 接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。当将该机制与选择重传机制结合起来使用时（即跳过重传那些已被接收方选择性地确认过的报文段），TCP 看起来就很像我们通常的 SR 协议。因此，TCP 的差错恢复机制也许最好被分类为 GBN 协议与 SR 协议的混合体。

![](Pasted%20image%2020250618163520.png)
