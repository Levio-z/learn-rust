回退N步(GBN)协议中，允许发送方发送多个分组(当有多个分组可用时)而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数 N。在本节中我们较为详细地描述GBN。但在继续阅读之前，建议你操作本书配套 Web网站上的GBNJava小程序(这是一个非常好的Java程序)。
![](Pasted%20image%2020250618140039.png)
图3-19在GBN中发送方看到的序号
图3-19显示了发送方看到的GBN协议的序号范围。如果我们将基序号(base)定义为最早未确认分组的序号，将下一个序号(nextseqnum)定义为最小的未使用序号(即下一个待发分组的序号)，则可将序号范围分割成4段。在`[0，base-1]` 段内的序号对应于已经发送并被确认的分组。​`[base，nextseqnum-1]` 段内对应已经发送但未被确认的分组。`​[nextseqnum，base+N-1]` 段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。最后，大于或等于base+N的序号是不能使用的，直到当前流水线中未被确认的分组(特别是序号为base 的分组)已得到确认为止。
如图 3-19 所提示的那样，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N常被称为窗口长度(windowsize)，GBN 协议也常被称为滑动窗口协议(sliding-window protocol)。你也许想知道，我们为什么先要限制这些被发送的、未被确认的分组的数目为N呢?为什么不允许这些分组为无限制的数目呢?我们将在3.5 节看到，流量控制是对发送方施加限制的原因之一。我们将在 3.7 节学习 TCP拥塞控制时分析另一个原因。
在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是k，则该序号范围是`[0，2'-1]`​。在一个有限的序号范围内，所有涉及序号的运算必须使用模2运算。(即序号空间可被看作是一个长度为2的环，其中序号2-1紧接着序号0。)前面讲过，rdt3.0有一个1比特的序号，序号范围是`[0，1]​`。在本章末的几道习题中探讨了一个有限的序号范围所产生的结果。我们将在3.5 节看到，TCP有一个32比特的序号字段，其中的TCP序号是按字节流中的字节进行计数的，而不是按分组计数。
图3-20和图3-21给出了一个基于ACK、无NAK的GBN 协议的发送方和接收方这两端的扩展FSM描述。我们称该FSM描述为扩展FSM，是因为我们已经增加了变量(类似于编程语言中的变量)base 和nextseqnum，还增加了对这些变量的操作以及与这些变量有关的条件动作。注意到该扩展的FSM规约现在变得有点像编程语言规约。 `[Bochman1984]`对FSM扩展技术提供了一个很好的综述，也提供了用于定义协议的其他基于编程语言的技术。
![](Pasted%20image%2020250618140356.png)图3-21 GBN 接收方的扩展FSM描述
GBN发送方必须响应三种类型的事件:
- 上层的调用
	- 当上层调用rdt_send()时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过一会儿再试。**在实际实现中，发送方更可能缓存(并不立刻发送)这些数据，或者使用同步机制(如一个信号量或标志)允许上层在仅当窗口不满时才调用rdt_send()。**
- 收到一个ACK
	- 在GBN 协议中，对序号为n的分组的确认采取累积确认(cumu-lative acknowledgment)的方式。表明接收方已正确接收到序号为n的以前目包括n在内的所有分组。稍后讨论 GBN 接收方一端时，我们将再次研究这个主题。
- 超时事件
	- 协议的名称“回退N步”来源于出现丢失和时延分组时发送方的行为。
		- 定时器将再次用于恢复数据或确认分组的丢失。如果出现超时，发送方重传所有已发送但未被确认过的分组。
		- 图中仅使用一个定时器，它可以被看做是最早的已发送但未被确认过的分组。如果收到一个ack，但是仍有发送但未被确认的分组，定时器被重新启动。如果没有已发送但未被确认的分组，停止定时器。
接受方
- 在 GBN 中，接收方的动作也很简单。**如果一个序号为 n 的分组被正确接收到，并且按序（上次交付给上层的数据是序号 n-1 的分组），则接收方为分组 n 发送一个 ACK，并将该分组中的数据部分交付到上层**。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK。注意到因为一次交付给上层一个分组，如果分组 k 已被接收并交付，则所有序号比 k 小的分组也已经交付。**因此，使用累积确认是 GBN 的自然的选择。**

**在 GBN 协议中，接收方丢弃所有失序分组。尽管丢弃一个正确接收（但失序）的分组有点愚蠢和浪费，但这样做是有理由的**。
- 前面讲过，接收方必须按序将数据交付给上层。假定现在希望接收分组 n，而分组 n+1 却到了。因为数据必须按序交付，接收方可能缓存（保存）分组 n+1，然后，在它收到并交付分组 n 后，再将该分组交付到上层。然而，如果分组 n 丢失，则该分组及分组 n+1 最终将在发送方根据 GBN 重传规则而被重传。因此，接收方只需丢弃分组 n+1 即可。**这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组**。因此，虽然发送方必须维护窗口的上下边界及 nextseqnum 在该窗口中的位置，但是接收方需要维护的唯一信息就是下一个按序接收的分组的序号。该值保存在 expectedseqnum 变量中，如图 3-21 中接收方 FSM 所示。当然，丢弃一个正确接收的分组的缺点是随后对该分组的重传也许会丢失或出错，因此甚至需要更多的重传。

图 3-22 给出了窗口长度为 4 个分组的 GBN 协议的运行情况。因为该窗口长度的限制，发送方发送分组 0~3，然后在继续发送之前，必须等待直到已发送多个分组被确认。当接收到每一个连续的 ACK（例如 ACK 0 和 ACK 1）时，该窗口便向前滑动，发送方便可以发送新的分组（分别是分组 4 和分组 5）。在接收方，分组 2 丢失，因此分组 3、4 和 5 被发现是失序分组并被丢弃。
![](Pasted%20image%2020250618141440.png)
在结束对 GBN 的讨论之前，需要提请注意的是，在协议栈中实现该协议可能与图 3-20 中的扩展 FSM 有相似的结构。该实现也可能是以各种过程形式出现，每个过程实现了在响应各种可能出现的事件时要采取的动作。在这种基于事件的编程(event-based programming)方式中，这些过程要么被协议栈中的其他过程调用，要么作为一次中断的结果。在发送方，这些事件包括:①来自上层实体的调用去调用rdt_send();②定时器中断;③报文到达时，来自下层的调用去调用rdt_rev()。本章后面的编程作业会使你有机会在一个模拟网络环境中实际实现这些例程，但该环境却是真实的。
这里我们注意到，GBN 协议中综合了我们将在3.5 节中学习 TCP 可靠数据传输构件时遇到的所有技术。这些技术包括使用序号、累积确认、检验和以及超时/重传操作。