```
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
                            TCP Header Format  
  
          Note that one tick mark represents one bit position.  
  
                               Figure 3.  
  
  Source Port:  16 bits  
  
    The source port number.  
  
  Destination Port:  16 bits  
  
    The destination port number.
```
- 序号
	- 32比特的序号字段(sequence number field)
- 确认号
	- 32比特的确认号字段(acknowl-edgment number field)。这些字段被TCP发送方和接收方用来实现可靠数据传输服务，讨论见后。
- 接收窗口字段
	- 16 比特的接收窗口字段(receive window field)，该字段用于流量控制。我们很快就会看到，该字段用于指示接收方愿意接受的字节数量。
- 4比特的首部长度字段(header length field)
	- 4比特的首部长度字段(header length field)，该字段指示了以32比特的字为单位的 TCP 首部长度。由于TCP 选项字段的原因，TCP 首部的长度是可变的。(通常，选项字段为空，所以TCP首部的典型长度是20字节。
- 可选与变长的选项字段(options field)
	- 该字段用于发送方与接收方协商最大报文段长度(MSS)时，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。可参见RFC 854和RFC1323了解其他细节。
- 6比特的标志字段(flag field)。
	- ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。RST、SYN 和 FIN 比特用于连接建立和拆除，我们将在本节后面讨论该问题。在明确拥塞通告中使用了 CWR 和ECE 比特，如 3.7.2节中讨论的那样。当 PSH 比特被置位时，就指示接收方应立即将数据交给上层。最后，URG 比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据指针字段(urgent data pointer field)指出。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP 必须通知接收端的上层实体。(在实践中，PSH、URG 和紧急数据指针并没有使用。为了完整性起见，我们才提到这些字段。
###  1.序号和确认号

TCP 报文段首部中两个最重要的字段是序号字段和确认号字段。这两个字段是 TCP 可靠传输服务的关键部分。但是在讨论这两个字段是如何用于提供可靠数据传输之前，我们首先来解释一下TCP在这两个字段中究竟放置了什么。

TCP把数据看成一个**无结构的、有序的字节流**。
- 因为是字节流，编号是字节的序号，来标记报文段的。
我们从 TCP 对序号的使用上可以看出这一点，因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号(sequence number for a segment)因此是该报文段首字节的字节流编号。举例来说，假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如图3-30所示，该 TCP 将为该数据流构建 500个报文段。给第一个报文段分配序号 0，第二个报文段分配序号1000，第三个报文段分配序号2000，以此类推。每一个序号被填人到相应TCP报文段首部的序号字段中。
![](Pasted%20image%2020250602182834.png)
图3-30 文件数据划分成TCP报文段

现在我们考虑一下确认号。确认号要比序号难处理一些。前面讲过，TCP 是全双工的，因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据(都是同一条TCP连接的一部分)。
- 流入数据编号：从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。
- 确认号：主机A填充进报文段的确认号是主机**A期望从主机B收到的下一字节的序号**。
- 看一些例子有助于理解实际发生的事情。假设主机A已收到了来自主机B的编号为0~535 的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节 536 及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536。
- 累计确认：因为TCP **只确认该流中至第一个丢失字节为止的字节**，所以TCP被称为**提供累积确认**(cumulative acknowledgment)。就算此时 837-1000的数据到了。
- 主机A在收到第二个报文段(字节536~899)之前收到第三个报文段(字节900~1000)。
	- CPRFC 并没有为此明确规定任何规则
		- 有两种实现
			- :①接收方立即丢弃失序报文段(如前所述，这可以简化接收方的设计);
			- ②接收方保留失序的字节，并等待缺少的字节以填补该间隔。显然，后一种选择对网络带宽而言更为有效，是实践中采用的方法。
- 在图3-30 中，我们假设初始序号为0。事实上，一条 TCP连接的双方均可随机地选择初始序号。这样做可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性(它碰巧与旧连接使用了相同的端口号)[Sunshine1978]​。
	- 如果 **SYN 标志**置位（建立连接时），
	- 这段报文段没有携带数据，
	- 它的 Sequence Number 表示 **初始序列号 ISN**（Initial Sequence Number）。
### 2.Telnet:序号和确认号的一个学习案例
所示，假设客户和服务器的起始序号分别是42 和79。前面讲过，一个报文段的序号就是该报文段数据字段首字节的序号。因此，客户发送的第一个报文段的序号为42，服务器发送的第一个报文段的序号为79。前面讲过，确认号就是主机正在等待的数据的下一个字节序号。在TCP连接建立后但没有发送任何数据之前，该客户等待字节 79，而该服务器等待字节 42。
第二个报文段是由服务器发往客户。它有两个目的:首先它是为该服务器所收到数据提供一个确认。通过在确认号字段中填人43，服务器告诉客户它已经成功地收到字节 42及以前的所有字节，现在正等待着字节 43的出现。该报文段的第二个目的是回显字符C'。因此，在第二个报文段的数据字段里填入的是字符'C的ASCH码。第二个报文段的序号为79，它是该TCP连接上从服务器到客户的数据流的起始序号，这也正是服务器要发送的第一个字节的数据。值得注意的是，对**客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中;这种确认被称为是被捎带(piggybacked)在服务器到客户的数据报文段中的。**
第三个报文段是从客户发往服务器的。**它的唯一目的是确认已从服务器收到的数据**。(前面讲过，第二个报文段中包含的数据是字符C，是从服务器到客户的。) 该报文段的数据字段为空(即确认信息没有被任何从客户到服务器的数据所捎带)。该报文段的确认号字段填人的是80，因为客户已经收到了字节流中序号为79 及以前的字节，它现在正等待着字节 80 的出现。你可能认为这有点奇怪，即使该报文段里没有数据还仍有序号。这是因为TCP存在序号字段，报文段需要填入某个序号。