方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有 GET、POST 和 HEAD 等。### 2.1 HTTP协议用于客户端和服务器端之间的通信
HTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就**仅从一条通信路线来说，服务器端和客户端的角色是确定的**，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端。

### 2.2 通过请求和响应的交换达成通信

HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。

下面，我们来看一个具体的示例。

![](asserts/Pasted%20image%2020251014145709.png)
下面则是从客户端发送给某个HTTP服务器端的请求报文中的内容。
```
GET /index.htm HTTP/1.1 
Host:hackr.jp
```
起始行开头的GET表示**请求访问服务器的类型**，称为方法(method)。随后的字符串/index.htm指明了请求访问的**资源对象**，也叫做请求URI(request-URI)。最后的HTTP/1.1，即HTTP的版本号，用来提示客户端使用的HTTP协议功能。

综合来看，这段请求内容的意思是：请求访问某台HTTP服务器上的/index.htm页面资源。

请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。
![](asserts/Pasted%20image%2020251014145909.png)图：请求报文的构成

请求首部字段及内容实体稍后会作详细说明。接下来，我们继续讲解。接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。
```
HTTP/1.1200 OK 
Date:Tue,10 Jul 2012 06:50:15 GMT
Content-Length:362
Content-Type:text/html 
<html> 
……
```
在起始行开头的HTTP/1.1表示服务器对应的HTTP版本。
紧挨着的200 OK表示请求的处理结果的状态码(status code)和原因短语(reason-phrase)。下一行显示了创建响应的日期时间，是首部字段(header field)内的一个属性。
接着以一空行分隔，之后的内容称为资源实体的主体(entity body)。

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）​、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。稍后我们会对这些内容进行详细说明。
![](asserts/Pasted%20image%2020251014150131.png)图：响应报文的构成
### 2.3　HTTP是不保存状态的协议
HTTP是一种不保存状态，即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说**在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理**。也就是说，无法根据之前的状态进行本次的请求处理。
![](asserts/Pasted%20image%2020251014150218.png)图：HTTP协议自身不具备保存之前发送过的请求或响应的功能

使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。**这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。**[无状态的概念和无状态性带来的好处](../../../Zettelkasten/fleeting/无状态的概念和无状态性带来的好处.md)

可是，随着Web的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态。

HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。**有了Cookie再用HTTP协议通信，就可以管理状态了**。有关Cookie的详细内容稍后讲解。
### 2.4　请求URI定位资源

HTTP协议使用URI定位互联网上的资源。正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。

### 2.5　告知服务器意图的HTTP方法
#### GET：获取资源



#### POST：传输实体主体
[HTTP-POST](notes/Archieve/HTTP-POST.md)

#### PUT：传输文件
[HTTP-PUT](notes/Archieve/HTTP-PUT.md)
### HEAD：获得报文首部
[HTTP-Head](notes/Archieve/HTTP-Head.md)
### DELETE
[HTTP-DELETE](notes/Archieve/HTTP-DELETE.md)
### OPTIONS
[HTTP-OPTIONS](notes/Archieve/HTTP-OPTIONS.md)

### TRACE(已淘汰)
追踪路径TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。但是，TRACE方法本来就不怎么常用，再加上它容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。
### 2.6　使用方法下达命令
向请求URI指定的资源发送请求报文时，采用称为方法的命令。
方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有 GET、POST 和 HEAD 等。
![](asserts/Pasted%20image%2020251015164909.png)
下表列出了 HTTP/1.0 和 HTTP/1.1 支持的方法。另外，方法名区分大小写，注意要用大写字母。

**表 2-1：HTTP/1.0 和 HTTP/1.1 支持的方法**

|   |   |   |
|---|---|---|
|**方法**|**说明**|**支持的 HTTP 协议版本**|
|GET|获取资源|1.0、1.1|
|POST|传输实体主体|1.0、1.1|
|PUT|传输文件|1.0、1.1|
|HEAD|获得报文首部|1.0、1.1|
|DELETE|删除文件|1.0、1.1|
|OPTIONS|询问支持的方法|1.1|
|TRACE|追踪路径|1.1|
|CONNECT|要求用隧道协议连接代理|1.1|
|LINK|建立和资源之间的联系|1.0|
|UNLINE|断开连接关系|1.0|

###  2.7　持久连接节省通信量
HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。
![](asserts/Pasted%20image%2020251015165142.png)


以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的情况多了起来。

比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。
#### **2.7.1　持久连接**
为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
![](asserts/Pasted%20image%2020251015165409.png)

**图：持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互**

**持久连接的好处**在于**减少**了 TCP 连接的重复建立和断开所造成的额外**开销**，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。

在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。

#### **2.7.2　管线化**
持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。

这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。
![](asserts/Pasted%20image%2020251015165553.png)
**图：不等待响应，直接发送下一个请求**

比如，当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。


### 2.8　使用 Cookie 的状态管理











## QA
### 1. 为什么 HTTP 的无状态性设计能带来高可伸缩性和性能？
[无状态的概念和无状态性带来的好处](../../../Zettelkasten/fleeting/无状态的概念和无状态性带来的好处.md)
### 2. 可伸缩性 (Scalability) 和性能 (Performance) 之间有什么关系？
[可伸缩性 (Scalability)](../../../Zettelkasten/permanent/可伸缩性%20(Scalability).md)
[性能 (Performance)](../../../Zettelkasten/fleeting/性能%20(Performance).md)
## Todo
- [x] 整理URL和URI的原子笔记
- [x] 无状态带来的可伸缩性