```
use std::fs;
```

导入模块 std::fs，然后就可以访问 read_to_string 函数和 write 函数了：
```rust
use std::env;

use std::fs;

  

fn main() {

    let args = parse_args();

    println! {"args{args:?}"};

  

    if let Ok(current_dir) = env::current_dir() {

        println!("当前工作目录: {}", current_dir.display());

    } else {

        eprintln!("无法获取当前工作目录");

    }

    // 读取文件内容

    let data = match fs::read_to_string(&args.filename) {

        Ok(v) => v,

        Err(e) => {

            eprintln!(

                "{} failed to read from file '{}': {:?}",

                "Error:".red().bold(),

                args.filename,

                e

            );

            std::process::exit(1);

        }

    };

  

    // 写入到输出文件

    match fs::write(&args.output, &data) {

        Ok(_) => {

            println!(

                "{} Successfully wrote to '{}'",

                "Success:".green().bold(),

                args.output

            );

        }

        Err(e) => {

            eprintln!(

                "{} failed to write to file '{}': {:?}",

                "Error:".red().bold(),

                args.output,

                e

            );

            std::process::exit(1);

        }

    };

}

  

#[derive(Debug)]

struct Arguments {

    target: String,

    replacement: String,

    filename: String,

    output: String,

}

  

use text_colorizer::*;

fn print_usage() {

    eprintln!(

        "{} - change occurrences of one string into another",

        "quickreplace".green()

    );

    eprintln!("Usage: quickreplace <target> <replacement> <INPUT> <OUTPUT>");

}

  

fn parse_args() -> Arguments {

    // 跳过程序名，收集命令行参数

    let args: Vec<String> = env::args().skip(1).collect();

  

    // 检查参数数量是否正确

    if args.len() != 4 {

        print_usage();

        eprintln!(

            "{},wrong number of arguments :expected 4, got:{}",

            "Error:".red().bold(),

            args.len()

        );

        std::process::exit(1);

    }

  

    // 构建并返回Arguments实例

    Arguments {

        target: args[0].clone(),

        replacement: args[1].clone(),

        filename: args[2].clone(),

        output: args[3].clone(),

    }

}
```

在当前目录下新建file文件
执行
```
cargo run "find" "replace" file output
```
结果成功