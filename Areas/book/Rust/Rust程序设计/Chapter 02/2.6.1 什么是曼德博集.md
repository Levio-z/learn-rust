 Rust 特有语法实现的 loop 语句无限循环：
```rust
fn square_loop(mut x: f64) { loop { x = x * x; } }
```
在现实世界中，Rust 能看出 x 从未用来做任何事，因此不会计算它的值。但目前，假设代码能按编写的方式运行。那么 x 的值会如何变化呢？对任何小于 1 的数值求平方会使它变得更小，因此它会趋近于 0；1 的平方会得到 1；对大于 1 的数值求平方会使它变大，因此它会趋近于无穷大；对一个负数求平方会先使其变为正数，之后它的变化情况和前面的情况类似，如图 2-3 所示。
![](asserts/Pasted%20image%2020250726155954.png)
图 2-3：重复对数值求平方的效果
因此，根据传给 square_loop 的值，x 的取值为 0 或 1、趋近 0或趋近无穷大。
现在考虑一个略有不同的循环：
```rust
fn square_add_loop(c: f64) { 
	let mut x = 0.; 
	loop {
		 x = x * x + c;
	} 
}
```

这一次，x 从 0 开始，我们通过对它求平方后再加上 c 来调整它在每次迭代中的进度。这更难看出 x 的变化情况了，但通过一些实验会发现，如果 c 大于 0.25 或小于 -2.0，那么 x 最终会变得无限大，否则，它就会停留在 0 附近的某个地方。

下一个问题：如果不再使用 f64 值而是改用复数做同样的循环会怎样？crates.io 上的 num crate 已经提供了开箱即用的复数类型，因此要在程序的 Cargo.toml 文件的 `[dependencies]` 部分添加一行 num。这是迄今为止的整个文件（稍后会添加更多）​：
```toml
[package] 
name = "mandelbrot" 
version = "0.1.0"
edition = "2021" 
# 请到“The Cargo Book”查看更多的键及其定义 
[dependencies] 
num = "0.4"
```
现在可以编写此循环的倒数第二个版本了：
```rust
use num::Complex; 
fn complex_square_add_loop(c: Complex<f64>) {
	let mut z = Complex { re: 0.0, im: 0.0 };
	loop { 
		z = z * z + c;
	}
}
```
传统上会用 z 来代表复数，因此我们重命名了循环变量。表达式Complex { re: 0.0, im: 0.0 } 是使用 num crate 的 Complex 类型编写复数 0 的方式。Complex 是一种 Rust 结构体类型（或struct）​，其定义如下：
```rust
struct Complex<T> {
/// 复数的实部 re:
T, 
/// 复数的虚部 im: 
T, 
}
```

上述代码定义了一个名为 Complex 的结构体，该结构体有两个字段，即 re 和 im。Complex 是一种泛型结构体：可以把在类型名称之后的 `<T> `读作“对于任意类型 T”​。例如，Complex`<f64>`是一个复数，其 re 字段和 im 字段为 f64 值，Complex`<f32>` 则使用 32 位浮点数，等等。根据此定义，像 Complex { re: 0.24,im: 0.3 } 这样的表达式就会生成一个 Complex 值，其 re 字段已初始化为 0.24，im 字段已初始化为 0.3。

num crate 支持用 *、+ 和其他算术运算符来处理 Complex 值，因此该函数的其余部分仍然像之前的版本那样工作，只是它会将数值视作复平面上而不是实数轴上的点进行运算。第 12 章会讲解如何让 Rust 的运算符与自定义类型协同工作。

我们终于抵达了纯数学之旅的终点。曼德博集的定义是：令 z 不会“飞到”无穷远的复数 c 的集合。我们最初的简单平方循环是可以预测的：任何大于 1 或小于 -1 的数值都会“飞”出去。把 +c 放入每次迭代中会使变化情况更难预测：正如前面所说，大于0.25 或小于 -2.0 的 c 值会导致 z“飞”出去。但是将此游戏推广到复数就会生成真正奇异而美丽的图案，这就是我们所要绘制的分形图。

由于复数 c 具有实部 c.re 和虚部 c.im，因此可以把它们视为笛卡儿平面上某个点的 x 坐标和 y 坐标，如果 c 在曼德博集中，就在其中用黑色着色，否则就用浅色。因此，对于图像中的每个像素，必须在复平面上的相应点位运行前面的循环，看看它是逃逸到无穷远还是永远绕着原点运行，并相应地将其着色。

无限循环需要一段时间才能完成，但是对缺乏耐心的人来说有两个小技巧。首先，如果不再永远运行循环而只是尝试一些有限次数的迭代，事实证明仍然可以获得该集合的一个不错的近似值。我们需要多少次迭代取决于想要绘制的边界的精度。其次，业已证明，一旦 z 离开了以原点为中心的半径为 2 的圆，它最终就一定会“飞到”无穷远的地方。所以下面是循环的最终版本，也是程序的核心：

```rust
use num::Complex;

/// 尝试测定复数 `c` 是否属于曼德博集合，最多迭代 `limit` 次。
///
/// # 返回值
/// - 如果 `c` 明显不是集合的成员（即 z 的模方超过 4），返回 `Some(i)`，
///   其中 `i` 是逃逸所需的迭代次数；
/// - 如果无法在 `limit` 次内确认是否逃逸，返回 `None`，
///   代表 `c` 可能属于集合（或至少看起来像）。
fn escape_time(c: Complex<f64>, limit: usize) -> Option<usize> {
    let mut z = Complex { re: 0.0, im: 0.0 };

    for i in 0..limit {
        if z.norm_sqr() > 4.0 {
            return Some(i); // 已经“逃逸”出半径为 2 的圆
        }
        z = z * z + c;
    }

    None // 没有逃逸，可能属于 Mandelbrot 集合
}

```

此函数会接受两个参数：c 是我们要测试其是否属于曼德博集的复数，limit 是要尝试的迭代次数上限，一旦超出这个次数就放弃并认为 c 可能是成员。

该函数的返回值是一个 Option`<usize>`。Rust 的标准库中对Option 类型的定义如下所示：
```rust
enum Option<T> { None, Some(T), }
```

```
for i in 0..limit {
```
- 前面的示例展示了如何用 for 循环遍历命令行参数和向量元素，这个 for 循环则只是遍历从 0 开始到 limit（不含）的整数范围。

- z.norm_sqr() 方法调用会返回 z 与原点距离的平方。要判断 z 是否已经离开半径为 2 的圆，不必计算平方根，只需将此距离的平方与 4.0 进行比较即可，这样速度更快。

- 该程序的其余部分所“关心”的是决定以何种分辨率绘制此集合中的哪个部分，并将此项工作分发给多个线程以加快计算速度。
