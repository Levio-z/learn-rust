要绘制出曼德博集，只需对复平面上的每个点调用escape_time，并根据其结果为图像中的像素着色

```rust
/// 将曼德博集对应的矩形渲染到像素缓冲区中。
///
/// - `pixels`：目标像素缓冲区，每个字节表示一个灰度像素；
/// - `bounds`：像素缓冲区的宽度和高度；
/// - `upper_left` 和 `lower_right`：复平面中对应于缓冲区左上角和右下角的复数坐标。
fn render(
    pixels: &mut [u8],
    bounds: (usize, usize),
    upper_left: Complex<f64>,
    lower_right: Complex<f64>,
) {
    assert_eq!(
        pixels.len(),
        bounds.0 * bounds.1,
        "像素缓冲区大小不匹配 bounds 提供的尺寸"
    );

    for row in 0..bounds.1 {
        for col in 0..bounds.0 {
            let point = pixel_to_point(bounds, (col, row), upper_left, lower_right);
            let value = match escape_time(point, 255) {
                None => 0,
                Some(count) => 255 - count as u8,
            };
            pixels[row * bounds.0 + col] = value;
        }
    }
}

```

此刻，这一切看起来都很熟悉。

如果 escape_time 认为该 point 属于本集合，render 就会将相应像素的颜色渲染为黑色 (0)。否则，render 会将需要更长时间才能逃离圆圈的数值渲染为较深的颜色。

/