Rust 的一大优势是它对并发编程的支持。Rust 中用来确保内存安全的那些规则也同样可以让线程在共享内存的时候避免数据竞争。

- **互斥锁与数据的关联：编译器强制绑定**,C++锁和数据是分离的

> **Rust:**  
> Rust 使用如 `Mutex<T>`、`RwLock<T>` 等类型，把**锁和数据绑定在一起**，你只有通过锁的方式才能访问数据。这是一种**类型系统层面上的强制保护**。
> 在 C++ 中，互斥锁（如 `std::mutex`）和数据是**分离的**

- **只读共享数据：Rust 有 `Arc<T>` + `&T` 保证只读**
	- C++ 允许通过类型转换去除 `const`,只要你能获得原始的可变指针，就可能在其他线程中意外修改数据。
- 所有权模型决定：一旦你把数据的所有权（ownership）移动给别的线程，就**不能再访问原数据**。
	- **强烈依赖于 CPU 缓存行为**（比如缓存一致性协议是否及时同步）。
	- **受最近内存写操作的影响**（写后是否已同步到主内存？别的线程是否能看见？）。

本节的程序绘制了曼德博集（一组分形几何图形，包括著名的海龟图等）​，这是一种对复数反复运行某个简单函数而生成的分形图。人们通常把“绘制曼德博集”称为易并行算法，因为其线程之间的通信模式非常简单，第 19 章会介绍更复杂的模式，但这里的任务已足以演示一些基本要素了。

```rust
cargo new mandelbrot
```