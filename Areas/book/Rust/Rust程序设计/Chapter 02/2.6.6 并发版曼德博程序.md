万事俱备，可以展示一下 main 函数了，我们可以在其中利用并发来完成任务。为简单起见，先来看一个非并发版本：


```
$ cargo build --release
$ time target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20

```
在之前的记录中，我们使用过 Unix 的 time 程序来分析程序的运行时间—对图像的每个像素运行曼德博计算总共需要大约 5秒。但是几乎所有的现代机器都有多个处理器核心，而这个程序只使用了一个。如果可以将此工作分派给机器提供的所有计算资源，则应该能更快地画完图像。为此，可以将图像分成多个部分（每个处理器一个）​，并让每个处理器为分派给它的像素着色。为简单起见，可以将其分成一些水平条带，如图 2-7 所示。当所有处理器都完成后，可以将像素写入磁盘中。
```rust
let threads = 8; // 使用的线程数量
let rows_per_band = bounds.1 / threads + 1; // 每个 band 分配的行数（多加1确保覆盖）

{
    // 将 pixels 切成若干 band，每个 band 对应一组行（按行分块）
    let bands: Vec<&mut [u8]> = pixels
        .chunks_mut(rows_per_band * bounds.0)
        .collect();

    // 创建线程作用域，允许多个线程安全共享 `&mut` 引用
    crossbeam::scope(|spawner| {
        for (i, band) in bands.into_iter().enumerate() {
            // 当前 band 在图像中的起始行
            let top = rows_per_band * i;

            // 当前 band 的高度（像素数 / 每行像素宽度）
            let height = band.len() / bounds.0;
            let band_bounds = (bounds.0, height);

            // 计算该 band 对应的复平面左上角和右下角坐标
            let band_upper_left =
                pixel_to_point(bounds, (0, top), upper_left, lower_right);
            let band_lower_right =
                pixel_to_point(bounds, (bounds.0, top + height),
                               upper_left, lower_right);

            // 为每个 band 启动一个线程进行渲染
            spawner.spawn(move |_| {
                render(band, band_bounds, band_upper_left, band_lower_right);
            });
        }
    }).unwrap(); // 捕获线程中可能发生的 panic
}

```

解释
```
let threads = 8; 
let rows_per_band = bounds.1 / threads + 1;
```
这里我们决定使用 8 个线程。4然后会计算每个条带应该有多少行像素。我们向上舍入行数以确保条带覆盖整个图像，即使其高度并不是 threads 的整数倍。

>num_cpus crate 提供了一个返回当前系统可用 CPU 数量的函数

```rust
let bands: Vec<&mut [u8]> = pixels.chunks_mut(rows_per_band * bounds.0).collect();
```
这里我们将像素缓冲区划分为几个条带。缓冲区的 chunks_mut方法会返回一个迭代器，该迭代器会生成此缓冲区的可变且不重叠的切片，每个切片都包含 rows_per_band * bounds.0 个像素，换句话说，rows_per_band 包含整行的像素。chunks_mut生成的最后一个切片包含的行数可能少一些，但每一行都包含同样数量的像素。最后，此迭代器的 collect 方法会构建一个向量来保存这些可变且不重叠的切片。

现在可以使用 crossbeam 库了：
```
crossbeam::scope(|spawner| { ... }).unwrap();
```

参数 |spawner| { ... } 是 Rust 闭包，它需要一个参数 spawner。请注意，与使用 fn 声明的函数不同，无须声明闭包参数的类型，Rust 将推断它们及其返回类型。在这里，crossbeam::scope 调用了此闭包，并将一个值作为 spawner 参数传给闭包，以便闭包使用 spawner 来创建新线程。**crossbeam::scope 函数会等待所有线程执行完毕后返回。这种机制能让 Rust 确保这些线程不会在pixels 超出作用域后再访问分配给自己的那部分，并能让我们确保当 crossbeam::scope 返回时，图像的计算已然完成**。如果一切顺利，那么 crossbeam::scope 就会返回 Ok(())，但如果我们启动的任何线程发生了 panic，则它会返回一个 Err。我们会对该Result 调用 unwrap，这样一来，在那种情况下我们也会发生panic，并且用户会收到报告。
```
for (i, band) in bands.into_iter().enumerate() {
```
在这里，我们遍历了像素缓冲区的各个条带。into_iter() 迭代器会为循环体的每次迭代赋予独占一个条带的所有权，确保一次只有一个线程可以写入它（第 5 章会详细解释 into_iter() 迭代器的工作原理）​。然后，枚举适配器生成了一些元组，将向量中的元素与其索引配对。

```
 // 为每个 band 启动一个线程进行渲染

            spawner.spawn(move |_| {

                render(band, band_bounds, band_upper_left, band_lower_right);

            });
```
最后，创建一个线程，运行 move |_| { ... } 闭包。前面的 move 关键字表示这个闭包会接手它所用变量的所有权，特别是，只有此闭包才能使用可变切片 band。参数列表 |_| 意味着闭包会接受一个参数，但不使用它（另一个用以启动嵌套线程的启动器）​。如前所述，crossbeam::scope 调用会确保所有线程在它返回之前都已完成，这意味着将图像保存到文件中是安全的，这就是我们下一步要做的。