该程序会接受几个命令行参数来控制我们要写入的图像的分辨率以及要绘制曼德博集里哪部分的图像。由于这些命令行参数遵循着一种共同的格式，因此我们写了一个解析它们的函数：

```rust
use std::str::FromStr;

/// 将字符串 `s`（形如 `"400x600"` 或 `"1.0,0.5"`）解析为一个坐标对。
///
/// 具体来说，`s` 应该具有 `<left><sep><right>` 的格式，
/// 其中 `<sep>` 是由 `separator` 参数给出的字符，
/// `<left>` 和 `<right>` 是可以被 `T::from_str` 解析的字符串。
///
/// `separator` 必须是 ASCII 字符。
///
/// 如果格式正确，返回 `Some((x, y))`；否则返回 `None`。
fn parse_pair<T: FromStr>(s: &str, separator: char) -> Option<(T, T)> {
    match s.find(separator) {
        None => None,
        Some(index) => {
            let left = T::from_str(&s[..index]);
            let right = T::from_str(&s[index + 1..]);
            match (left, right) {
                (Ok(l), Ok(r)) => Some((l, r)),
                _ => None,
            }
        }
    }
}

#[test]
fn test_parse_pair() {
    assert_eq!(parse_pair::<i32>("",        ','), None);
    assert_eq!(parse_pair::<i32>("10,",     ','), None);
    assert_eq!(parse_pair::<i32>(",10",     ','), None);
    assert_eq!(parse_pair::<i32>("10,20",   ','), Some((10, 20)));
    assert_eq!(parse_pair::<i32>("10,20xy", ','), None);
    assert_eq!(parse_pair::<f64>("0.5x",    'x'), None);
    assert_eq!(parse_pair::<f64>("0.5x1.5", 'x'), Some((0.5, 1.5)));
}

```
- `s.find(separator)`：查找分隔符的位置，如果找不到就返回 `None`。
    
- `T::from_str(&s[..index])` 和 `T::from_str(&s[index + 1..])`：尝试将分隔符左右的字符串解析为 `T` 类型。
    
- 使用 `Option<(T, T)>` 返回解析结果，符合 Rust 的类型安全和错误处理习惯。
    
- 泛型 `T: FromStr`：可以支持 `i32`、`f64` 等实现了 `FromStr` 的类型。
分析：
- 可以把 <T: FromStr> 子句读作“对于实现了 FromStr 特型的任意类型 T……”​，这样就能高效地一次定义出整个函数家族：
- parse_pair::<`i32`> 是能解析一对 i32 值的函数、parse_pair::<`f64`> 是能解析一对 f64 浮点值的函数，等等。这很像 C++ 中的函数模板。Rust 程序员会将 T 称作 parse_pair 的类型参数。**当使用泛型函数时，Rust 通常能帮我们推断出类型参数，并且我们不必像这里的测试代码那样把它们明确写出来。**
- 我们的返回类型是 Option<(T, T)>：它或者是 None，或者是一个值 Some((v1, v2))，其中 (v1, v2) 是由两个 T 类型的值构成的元组。parse_pair 函数没有使用显式 return 语句，因此它的返回值是其函数体中最后一个（也是唯一的一个）表达式的值：
```rust
match s.find(separator) { None => None, Some(index) => { ... } }
```
String 类型的 find 方法会在字符串中搜索与 separator 相匹配的字符。如果 find 返回 None，那么就意味着字符串中没有出现分隔符，这样整个 match 表达式的计算结果就为 None，表明解析失败。否则，index 值就是此分隔符在字符串中的位置。

```rust
match (T::from_str(&s[..index]), T::from_str(&s[index + 1..])) { (Ok(l), Ok(r)) => Some((l, r)), _ => None }
```
这里初步展现了 match（匹配）表达式的强大之处。match 的参数是如下元组表达式：

```
(T::from_str(&s[..index]), T::from_str(&s[index + 1..]))
```
表达式 &s`[..index] `和 &s`[index + 1..]` 都是字符串的切片，分别位于分隔符之前和之后。类型参数 T 的关联函数 from_str 会获取其中的每一个元素并尝试将它们解析为类型 T 的值，从而生成结果元组。下面是我们要匹配的目标：
```
(Ok(l), Ok(r)) => Some((l, r)),
```
仅当此元组的两个元素都是 Result 类型的 Ok 变体时，该模式才能匹配上，这表明两个解析都成功了。如果是这样，那么Some((l, r)) 就是匹配表达式的值，也就是函数的返回值。
```
_ => None
```
通配符模式 _ 会匹配任意内容并忽略其值。如果运行到此处，则表明 parse_pair 已然失败，因此其值为 None，并继而作为本函数的返回值。
现在有了 parse_pair，就很容易编写一个函数来解析一对浮点坐标并将它们作为 Complex`<f64>` 值返回：
```rust
/// 把一对用逗号分隔的浮点数解析为复数
fn parse_complex(s: &str) -> Option<Complex<f64>> {

    parse_pair(s, ',').map(|(re, im)| Complex { re, im })

}

  

#[test]

fn test_parse_complex() {

    // 合法输入，应解析为复数

    assert_eq!(

        parse_complex("1.25,-0.0625"),

        Some(Complex { re: 1.25, im: -0.0625 })

    );

  

    // 缺少实部，解析失败

    assert_eq!(parse_complex(",-0.0625"), None);

}

```
parse_complex 函数调用了 parse_pair，如果坐标解析成功则构建一个 Complex 值，如果失败则传回给它的调用者。

如果你很细心，可能会注意到我们用了简写形式来构建 Complex值。用同名变量来初始化结构体中的字段是很常见的写法，所以Rust 不会强迫你写成 Complex { re: re, im: im }，而会让你简写成 Complex { re, im }。这是从 JavaScript 和 Haskell 中的类似写法借鉴来的。

### 总结
- &str 调用find 传入char找到索引
- 定义实现特性的任何类型的泛型，方法中调用特型的方法