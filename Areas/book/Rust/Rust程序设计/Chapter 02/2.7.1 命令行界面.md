这个程序的界面非常简单。它有 4 个参数：要搜索的字符串（或正则表达式）​、要替换成的字符串（或正则表达式）​、输入文件的名称和输出文件的名称。我们将从包含这些参数的结构体开始写 main.rs 文件：
```rust
#[derive(Debug)] 
struct Arguments { 
target: String,
replacement: String,
filename: String, 
output: String, 
}	
```
`#[derive(Debug)] `属性会让编译器生成一些额外的代码，这能让我们在 println! 中使用 {:?} 来格式化 Arguments 结构体。

如果用户输入的参数个数不对，那么通常会打印出一份关于如何使用本程序的简单说明。我们会使用一个名为 print_usage 的简单函数来完成此操作，并从 text-colorizer 导入所有内容，以便为这些输出添加一些颜色：
```rust
use text_colorizer::*; 
fn print_usage() {
eprintln!("{} - change occurrences of one string into another", "quickreplace".green());
eprintln!("Usage: quickreplace <target> <replacement> <INPUT> <OUTPUT>"); 
}
```
只要将 .green() 添加到字符串字面量的末尾，就可以生成包裹在适当 ANSI 转义码中的字符串，从而在终端模拟器中显示为绿色。然后，在打印之前将生成的字符串插到信息中的其他部分。

首先 collect() 方法会生成一个 Vec 参数。然后我们会检查它的参数个数是否正确，如果不正确，则打印一条信息并以返回一个错误代码的形式退出。接下来我们再次对部分信息进行着色，并用.bold() 把这段文本加粗。如果参数个数正确，就把它们放入一个Arguments 结构体中，并返回该结构体。下面添加一个只会调用 parse_args 并打印输出的 main 函数：
```rust
fn parse_args() -> Arguments{

    // 跳过程序名，收集命令行参数

    let args: Vec<String> = env::args().skip(1).collect();

  

    // 检查参数数量是否正确

    if args.len() !=4{

        print_usage();

        eprintln!(

            "{}",wrong number of arguments :expected 4, got:{},

            "Error:".red().bold(),

            args.len()

        );

        std::process::exit(1);

    }

  

    // 构建并返回Arguments实例

    Arguments {

        target: args[0].clone(),

        replacement: args[1].clone(),

        filename: args[2].clone(),

        output: args[3].clone(),

    }

}
```
添加main函数
```rust
fn main() {

   let args = parse_args();

   println!{"args{args:?}"};

}
```
现在，运行本程序，可以看到它正常输出了错误消息：
```rust
cargo run
```
如果传给程序的参数个数正确，那么它就会打印出 Arguments 结构体的文本表示：
```rust
cargo run "find" "replace" file output
```

在这里，我们使用前面写好的 parse_args() 函数并将生成的文件名传给 read_to_string 和 write。对这些函数的输出使用 match语句可以优雅地处理错误，打印出文件名、错误原因，并用一点儿醒目的颜色引起用户的注意。有了这个改写后的 main 函数，运行程序时就可以看到下面这些了，当然，新旧文件的内容是完全相同的