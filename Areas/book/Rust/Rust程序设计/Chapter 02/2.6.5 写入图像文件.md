image crate 提供了读取和写入各种图像格式的函数，以及一些基本的图像处理函数。特别是，此 crate 包含一个 PNG 图像文件格式的编码器，该程序使用这个编码器来保存计算的最终结果。为了使用 image，请将下面这行代码添加到 Cargo.toml 的`[dependencies] `部分：
```
image = "0.13.0"
```
然后可以这样写：
```rust
use image::ColorType;
use image::png::PNGEncoder;
use std::fs::File;

/// 将像素缓冲区写入 PNG 图像文件
///
/// - `filename`: 输出文件名
/// - `pixels`: 灰度图像的像素数据，每个字节代表一个像素
/// - `bounds`: 图像的尺寸 (宽, 高)
///
/// # 返回值
/// 如果写入成功，返回 `Ok(())`；否则返回 I/O 错误。
fn write_image(
    filename: &str,
    pixels: &[u8],
    bounds: (usize, usize),
) -> Result<(), std::io::Error> {
    // 创建输出文件句柄
    let output = File::create(filename)?;

    // 初始化 PNG 编码器
    let encoder = PNGEncoder::new(output);

    // 编码并写入图像数据（8-bit 灰度）
    encoder.encode(
        pixels,
        bounds.0 as u32,
        bounds.1 as u32,
        ColorType::Gray(8),
    )?;

    Ok(())
}

```

这个函数的操作一目了然：它打开一个文件并尝试将图像写入其中。我们给编码器传入来自 pixels 的实际像素数据、来自bounds 的宽度和高度，然后是最后一个参数，以说明如何解释pixels 中的字节：值 ColorType::Gray(8) 表示每字节都是一个 8位的灰度值。这些也同样一目了然。该函数值得一看的地方在于当出现问题时它是如何处理的。一旦遇到错误，就要将错误报告给调用者。正如之前提过的，Rust 中的容错函数应该返回一个 Result 值，成功时为 Ok(s)（其中 s 是成功值）​，失败时为 Err(e)（其中 e 是错误代码）​。那么 write_image 的成功类型和错误类型是什么呢？当一切顺利时，write_image 函数只是把所有值得一看的东西都写到了文件中，没有任何有用的返回值。所以它的成功类型就是单元（unit）类型 ()，而如此命名是因为这个类型只有一个值()。单元类型类似于 C 和 C++ 中的 void。

如果发生错误，那么可能是因为 File::create 无法创建文件或encoder.encode 无法将图像写入其中，此 I/O 操作就会返回错误代码。File::create 的返回类型是 Result<std::fs::File,std::io::Error>，而 encoder.encode 的返回类型是 Result<(),std::io::Error>，所以两者共享着相同的错误类型，即std::io::Error。write_image 函数也应该这么做。在任何情况下，失败都应导致立即返回，并传出用以描述错误原因的std::io::Error 值。

所以，为了正确处理 File::create 的结果，需要 match 它的返回值，如下所示：
```
let output = match File::create(filename) { 
	Ok(f) => f, 
	Err(e) => { return Err(e); 
	} 
};
```
成功时，就将 output 赋值为 Ok 值中携带的 File。失败时，就将错误透传给调用者。
这种 match 语句在 Rust 中是一种非常常见的模式，所以该语言提供了 ? 运算符作为它的简写形式。因此，与其每次在尝试可能失败的事情时都明确地写出这个逻辑，不如使用以下等效且更易读的语句：
```
let output = File::create(filename)?;
```
如果 File::create 失败，那么 ? 运算符就会从 write_image 返回，并传出此错误。否则，output 就会持有已成功打开的 File。

手常犯的一个错误就是试图在 main 函数中使用 ?。但是，由于 main 本身不返回值，因此这样做行不通。应该使用 match 语句，或者像 unwrap 和 expect 这样的简写方法。还可以选择简单地把 main 改成返回一个 Result，稍后会介绍这种方式。