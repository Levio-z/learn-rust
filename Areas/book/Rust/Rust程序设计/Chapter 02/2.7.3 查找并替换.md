这个程序的最后一步是实现它的实际功能：查找并替换。为此，我们将使用 regex crate，它会编译并执行正则表达式。它提供了一个名为 Regex 的结构体，表示已编译的正则表达式。Regex 有一个 replace_all 方法，该方法名副其实：在一个字符串中搜索此正则表达式的所有匹配项，并用给定的替代字符串替换每个匹配项。可以将这段逻辑提取到一个函数中：

```rust
use regex::Regex;

  

/// 使用正则表达式替换文本中的目标字符串

///

/// # 参数

/// * `target` - 要匹配的正则表达式模式

/// * `replacement` - 用于替换匹配项的字符串

/// * `text` - 要进行替换操作的原始文本

///

/// # 返回值

/// 成功时返回替换后的字符串，失败时返回regex::Error

fn replace(target: &str, replacement: &str, text: &str) -> Result<String, regex::Error> {

    // 编译正则表达式

    let regex = Regex::new(target)?;

    // 替换所有匹配项并转换为String返回

    Ok(regex.replace_all(text, replacement).to_string())

}
```

注意看这个函数的返回类型。就像之前使用过的标准库函数一样，replace 也会返回一个 Result，但这次它携带着 regex crate 提供的错误类型。

Regex::new 会编译用户提供的正则表达式，如果给定的字符串无效，那么它就会失败。与曼德博程序中一样，我们使用 ? 符号在Regex::new 失败的情况下短路它，但该函数将返回 regex crate 特有的错误类型。一旦正则表达式编译完成，它的 replace_all 方法就能用给定的替代字符串替换 text 中的任何匹配项。如果 replace_all 找到了匹配项，那么它就会返回一个新的String，而这些匹配项会被替换成我们给它的文本。否则，replace_all 就会返回指向原始文本的指针，以回避不必要的内存分配和复制。然而，在这个例子中，我们想要一个独立的副本，因此无论是哪种情况，都要使用 to_string 方法来获取 String 并返回包裹在 Result::Ok 中的字符串，就像其他函数中的做法一样。现在，是时候将这个新函数合并到 main 代码中了：
```rust
use regex::Regex;

  

/// 使用正则表达式替换文本中的目标字符串

///

/// # 参数

/// * `target` - 要匹配的正则表达式模式

/// * `replacement` - 用于替换匹配项的字符串

/// * `text` - 要进行替换操作的原始文本

///

/// # 返回值

/// 成功时返回替换后的字符串，失败时返回regex::Error

fn replace(target: &str, replacement: &str, text: &str) -> Result<String, regex::Error> {

    // 编译正则表达式

    let regex = Regex::new(target)?;

    // 替换所有匹配项并转换为String返回

    Ok(regex.replace_all(text, replacement).to_string())

}
```

注意看这个函数的返回类型。就像之前使用过的标准库函数一样，replace 也会返回一个 Result，但这次它携带着 regex crate 提供的错误类型。
Regex::new 会编译用户提供的正则表达式，如果给定的字符串无效，那么它就会失败。与曼德博程序中一样，我们使用 ? 符号在Regex::new 失败的情况下短路它，但该函数将返回 regex crate 特有的错误类型。一旦正则表达式编译完成，它的 replace_all 方法就能用给定的替代字符串替换 text 中的任何匹配项。

如果 replace_all 找到了匹配项，那么它就会返回一个新的String，而这些匹配项会被替换成我们给它的文本。否则，replace_all 就会返回指向原始文本的指针，以回避不必要的内存分配和复制。然而，在这个例子中，我们想要一个独立的副本，因此无论是哪种情况，都要使用 to_string 方法来获取 String 并返回包裹在 Result::Ok 中的字符串，就像其他函数中的做法一样。现在，是时候将这个新函数合并到 main 代码中了：
```rust
    // 执行文本替换

    let replaced_data = replace(&args.target, &args.replacement, &data)

        .unwrap_or_else(|e| {

            eprintln!(

                "{} failed to replace text: {:?}",

                "Error:".red().bold(),

                e

            );

            process::exit(1);

        });
```

测试
```
echo "Hello, world" > test.txt
cargo run "world" "Rust" test.txt test-modified.txt
```