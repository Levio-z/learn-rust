现在的情况：在 C 和 C++ 中恰当使用并发的难度极大。通常只有在确信单线程代码无法达到预期的性能时，开发人员才会转向并发。**并行性对现代机器来说太重要了，不应该等到迫不得已时才考虑它**。

事实证明，**Rust 用来确保内存安全的那些限制同样能确保 Rust 程序避免产生数据竞争（data race）**​。只要数据不可变，你就可以在线程之间自由地共享这些数据。会发生变化的数据则只能使用同步原语访问。所有传统的并发工具仍然可用：互斥锁、条件变量、通道、原子等。Rust 只负责检查你是否正确地使用了它们。

这就让 Rust 成了一门能**充分发挥现代多核机器能力**的优秀语言。Rust 的生态系统提供了一些超乎于常规并发原语的库，可帮助你在处理器池之间均匀分布复杂负载、使用无锁同步机制（如读取-复制-更新）等。