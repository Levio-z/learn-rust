这个区别非常重要，它揭示了“低速系统调用”的定义侧重于**可预测性/不确定性**，而不是单纯的**速度快慢**。

你说的非常正确：虽然读写磁盘文件会**暂时阻塞**调用者，但它们通常**不被视为**传统意义上的“低速系统调用”。

### 核心原因：I/O的确定性与可控性

这里的关键在于：磁盘 I/O 的阻塞是**可预期的、局部可控的**，并且它**不会**因为外部的、独立于该进程的**异步事件**（比如另一个进程的写入、网络流控）而导致无限期阻塞，也不会在数据传输过程中被**信号中断**后返回 $\text{EINTR}$。

#### 1. 缓存和内核管理 (可控性)

- **页缓存（Page Cache）：** $\text{UNIX/Linux}$ 系统会使用大量的内存作为**页缓存**。当我们对普通文件执行 $\text{read}$ 或 $\text{write}$ 时：
    
    - **写操作：** 数据通常只是被写入到内核的页缓存中就返回了。真正的磁盘写入（物理 I/O）是由内核的后台进程（如 $\text{flusher}$ 线程）异步完成的。因此，**$\text{write()}$ 系统调用本身几乎总是快速返回。**
        
    - **读操作：** 如果数据在页缓存中（缓存命中），$\text{read()}$ 也是瞬间完成的。如果缓存未命中，$\text{read()}$ 会阻塞，等待数据从磁盘加载到缓存中。但这个等待时间是由**硬件速度**决定的，是可预期的、有限的。
        
- **I/O 调度：** 即使发生物理 I/O 阻塞，内核的 I/O 调度器（CFQ, Deadline, Noop等）也会在内核层面管理这些请求，以确保公平性和效率。这是一种**内核内部的等待**，而不是依赖于**外部通信或竞争**的等待。
    

#### 2. $\text{EINTR}$ 的行为 (确定性)

这是最根本的区别。

- 对于管道、套接字、终端这些**低速系统调用**，它们在阻塞时被信号中断，**会返回 $\text{EINTR}$**，迫使应用程序手动处理重启。
    
- 对于**读写普通文件**的系统调用 ($\text{read}$ 或 $\text{write}$ 到磁盘文件)，如果在阻塞等待物理 I/O 时被信号中断，$\text{UNIX}$ 内核通常会**自动处理这个中断**并**重新发起**该 I/O 操作（或者在 I/O 完成后，在适当的时间将信号交付给进程），而不是简单地返回 $\text{EINTR}$ 让应用层处理。
    

**总结来说：**

“低速系统调用”之所以被称为“低速”，不是因为它们慢，而是因为它们是**不可靠中断的 I/O**，需要特殊的 $\text{EINTR}$ 处理。

读写磁盘文件的阻塞虽然可能比内存操作慢得多，但在内核层面，它们被视为**可靠中断的 I/O**，内核会处理 $\text{EINTR}$，因此应用程序不需要特殊的循环来确保操作完成。