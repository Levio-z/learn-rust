这部分总结得非常精准，是编写健壮 $\text{UNIX/Linux}$ 应用程序的**核心实践**之一。

### 示例代码结构（以 $\text{read}$ 系统调用为例）

为了具体说明这种处理方式，以下是一个标准 $\text{C}$ 语言代码结构，展示了如何在一个循环中安全地处理可能返回 $\text{EINTR}$ 的低速系统调用：

C

```
#include <unistd.h>
#include <errno.h>

ssize_t safe_read(int fd, void *buf, size_t count) {
    ssize_t n;
    
    // 使用 do-while 循环来确保在遇到 EINTR 时可以再次尝试
    do {
        // 尝试执行低速系统调用
        n = read(fd, buf, count);
        
        // 检查返回值 n。如果 n < 0，表示发生错误。
        // 如果 n >= 0，表示读取成功（n 为读取的字节数）或文件结束（n = 0），此时退出循环。
        
        // 如果发生错误，检查错误类型是否为 EINTR
    } while (n == -1 && errno == EINTR);

    // 返回最终结果（成功读取的字节数 n 或其他致命错误 -1）
    return n;
}

// 应用程序中的使用：
/*
int main() {
    char buffer[1024];
    ssize_t bytes_read;

    // ... 文件描述符 fd 已经打开 ...

    bytes_read = safe_read(fd, buffer, sizeof(buffer));

    if (bytes_read == -1) {
        // 遇到非 EINTR 的致命错误，如 EBADF, EFAULT 等
        perror("read failed");
    } else if (bytes_read == 0) {
        // 文件结束
        printf("End of file.\n");
    } else {
        // 成功读取 bytes_read 个字节
        printf("Read %zd bytes.\n", bytes_read);
    }
    return 0;
}
*/
```

### 关键点解释：

1. **循环 ($\text{do-while}$):** 确保 `read` 调用可以在被中断后自动重试。
    
2. **错误检查 ($\text{n == -1}$):** 检查系统调用是否失败。
    
3. **$\text{errno}$ 检查 ($\text{errno == EINTR}$):** 这是区分是**可恢复的中断**（$\text{EINTR}$）还是**致命错误**（如 $\text{EIO}$、$\text{EBADF}$ 等）的关键。
    
4. **$\text{EINTR}$ 时的行为:** 只有当错误是 $\text{EINTR}$ 时，循环才继续执行，再次尝试 `read` 操作。对于任何其他错误，循环都会终止，函数返回 $\text{-1}$。
    

通过这种模式，应用程序即使在处理信号时也能保证 I/O 操作的**原子性和完整性**（即要么完成全部操作，要么返回一个明确的非 $\text{EINTR}$ 错误），极大地提高了程序的健壮性。