### 为什么 $\text{SA\_RESTART}$ 对某些系统调用无效？

内核设计的初衷是让 $\text{SA\_RESTART}$ 标志能处理那些**简单、原子性**的 I/O 操作（比如 $\text{read}$、$\text{write}$、$\text{open}$、$\text{close}$、$\text{wait}$）。但是，对于某些复杂的、具有时间依赖性或涉及多路 I/O 监控的低速系统调用，自动重启可能会导致逻辑错误或不确定的行为。

具体来说：

#### 1. $\text{select()}$ 和 $\text{poll()}$ ($\text{epoll}$ 族通常不阻塞)

- **它们的作用：** 这些函数通常用于**等待多个文件描述符**上的活动，并且它们通常带有一个**超时值**。
    
- **问题所在：**
    
    - 如果 $\text{select()}$ 在等待 $\text{5}$ 秒时，在第 $\text{2}$ 秒被信号中断，然后内核自动重启它。
        
    - **重启后，新的等待时间是从头开始的 $\text{5}$ 秒，**而不是剩余的 $\text{3}$ 秒。这可能会导致应用程序的逻辑（比如，心跳机制、定时器）错误。
        
    - 因此，内核通常不会自动重启 $\text{select()}$ 和 $\text{poll()}$，而是让它们返回 $\text{EINTR}$，强制应用程序自己决定是带着剩余时间重启，还是继续执行其他逻辑。
        

#### 2. $\text{pause()}$ 和 $\text{sleep()}$ 族函数

- **它们的作用：** 这些函数明确是为了让进程暂停一段时间或直到接收到信号。
    
- **问题所在：** 如果一个 $\text{sleep(10)}$ 被信号中断并自动重启，它就会重新开始 $\text{10}$ 秒的休眠。这显然违背了程序员“希望它被信号唤醒”的意图。这些函数的核心目的就是等待，信号的到达就意味着等待条件的改变。
    
- 因此，当这些函数被信号中断时，它们通常会返回**剩余的休眠时间**，或者干脆返回 $\text{EINTR}$，让程序继续执行。
    

### 结论：开发者责任

$\text{SA\_RESTART}$ 标志是**极大的便利**，但它不是万能药。它适用于大多数基本的 I/O 操作，让代码更干净。

对于那些涉及**超时机制**、**多个文件描述符**或**明确等待信号**的低速系统调用（如 $\text{select}$、$\text{poll}$、$\text{nanosleep}$ 等），开发者**仍然必须**编写手动处理 $\text{EINTR}$ 的循环代码，以确保程序逻辑的正确性，特别是处理超时逻辑。