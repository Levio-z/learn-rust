### 总结“低速系统调用”的核心概念：

低速系统调用，本质上就是那些**可能导致调用进程（线程）长时间（甚至“永远”）阻塞**，直到某个外部事件发生的系统调用。

**它们共同的特点是：**

1. **依赖外部条件：** 它们的操作完成依赖于外部世界（如其他进程写入数据、网络数据包到达、硬件完成操作、锁被释放）。
    
2. **默认阻塞行为：** 在默认的阻塞 I/O 模式下，如果外部条件不满足，调用会暂停程序的执行流，等待条件满足。
    

### 常见的低速系统调用类别回顾：

| **类别**          | **描述的阻塞原因**      | **示例目标**                    |
| --------------- | ---------------- | --------------------------- |
| **读操作**         | 数据尚未准备好（空）       | 管道、终端、网络套接字                 |
| **写操作**         | 目标缓冲区已满，无法立即接受数据 | 管道、网络套接字（受流控）               |
| **打开文件**        | 必须等待特定条件才能完成打开   | 终端设备（等待调制解调器）、FIFO（等待读/写对端） |
| **读写加锁文件**      | 文件被强制性记录锁锁定      | 共享文件                        |
| **`ioctl` 操作**  | 等待硬件或驱动程序内部的耗时操作 | 各种设备驱动                      |
| **进程间通信 (IPC)** | 等待其他进程发送数据或释放信号量 | 消息队列、信号量、共享内存操作（在特定情况下）     |

### 为什么区分“低速”和“其他”很重要？

这种区分在处理**信号（Signals）**时尤为重要：

当一个进程因为执行一个**低速系统调用**而阻塞时，如果此时接收到一个信号，系统默认的行为是中断该系统调用。当信号处理函数返回后，有两种主要的做法：

1. **自动重启（`SA_RESTART`）：** 系统会自动重新发起被中断的低速系统调用，就像它从未被中断过一样。
    
2. **返回错误（默认）：** 系统调用返回一个错误码 `EINTR`（Interrupted system call），要求应用程序自己处理并决定是否要重新调用该函数。
    

因此，理解哪些调用是“低速”的，对于编写健壮、能够正确处理信号的 UNIX/Linux 应用程序至关重要。