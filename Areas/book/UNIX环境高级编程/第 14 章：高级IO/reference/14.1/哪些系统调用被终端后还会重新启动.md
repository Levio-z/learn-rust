在类 Unix 系统中，系统调用被信号中断后是否**重新启动**，主要取决于程序在设置信号处理时是否使用了特定的**标志（Flag）**。

### 关键机制：`SA_RESTART` 标志

控制系统调用是否自动重新启动的机制是 **`sigaction`** 系统调用中的 **`SA_RESTART`** 标志。

1. **默认行为（无 $\text{SA\_RESTART}$）：**
    
    - **大多数**可中断的系统调用（如 $\text{read}$、$\text{write}$、$\text{accept}$、$\text{wait}$、$\text{sleep}$ 等）在被信号中断后，**不会**自动重新启动。
        
    - 它们会立即返回 **-1**，并将全局错误变量 **$\text{errno}$** 设置为 **$\text{EINTR}$**（正如您原始问题所述）。
        
    - 此时，需要程序编写者手动编写循环逻辑来重新调用系统调用。
        
2. **设置 $\text{SA\_RESTART}$ 标志：**
    
    - 当程序使用 **$\text{sigaction}$** 函数设置信号处理程序时，如果在 `sa_flags` 字段中设置了 **$\text{SA\_RESTART}$** 标志，那么当某些系统调用被该信号中断后，内核会**自动**重新启动这个系统调用，而不是返回 $\text{EINTR}$。
        
    - 这可以简化许多程序的错误处理代码，使其不必显式地检查和处理 $\text{EINTR}$。
        

---

### 哪些系统调用可以自动重新启动？

可以被 **$\text{SA\_RESTART}$** 标志影响并自动重新启动的系统调用通常是那些**可能长时间阻塞**的函数。这些系统调用包括：

|**系统调用类别**|**常见函数示例**|**备注**|
|---|---|---|
|**I/O 操作**|$\text{read}$、$\text{write}$|在套接字（Socket）或管道（Pipe）上进行读写操作。|
|**网络 I/O**|$\text{recv}$、$\text{send}$、$\text{recvfrom}$、$\text{sendto}$|数据传输操作。|
|**连接接受**|$\text{accept}$|等待客户端连接。|
|**文件锁**|$\text{flock}$|在等待文件锁时被中断。|
|**进程等待**|$\text{wait}$、$\text{waitpid}$|**注意：** $\text{wait}$ 系列函数在某些系统上，即使设置了 $\text{SA\_RESTART}$ 也可能不会自动重启，或者仅在 Linux 上重启。|
|**系统等待**|$\text{poll}$、$\text{select}$、$\text{sleep}$、$\text{usleep}$|这些函数在被中断后，**通常不会**自动重启，而是返回剩余的等待时间或 $-1$ ($\text{EINTR}$)。**这是 $\text{SA\_RESTART}$ 标志的例外**。|

**总结：**

一个系统调用是否在中断后重新启动，**不是由系统调用本身决定的**，而是由程序在**设置**触发中断的那个**信号**的**处理行为**时，是否设置了 **$\text{SA\_RESTART}$** 标志来决定的。

> **提示：** 尽管 $\text{SA\_RESTART}$ 可以简化代码，但一些严格的编程标准和经验法则**不建议**依赖它。推荐的做法是**手动**在程序中检查 $\text{EINTR}$ 错误，并显式地重新调用系统调用，这样可以更好地控制程序的行为，确保在所有类 Unix 系统上的一致性和可移植性。