### 关键点：处理中断（$\text{EINTR}$）

**1. 应用程序的健壮性（Robustness）：**

对于非低速系统调用（如 $\text{getpid()}$、$\text{time()}$ 等），它们通常瞬间完成，不会阻塞。因此，它们在被信号中断的可能性极低，通常不需要特殊的错误处理。

然而，**低速系统调用**的目的是等待外部事件，它们随时可能被信号中断，导致返回 $\text{EINTR}$ 错误。

- **如果应用程序没有处理 $\text{EINTR}$：** 进程可能会误以为操作永久失败。例如，一个程序在读取一个大文件时，读取了部分数据后被信号中断，如果它直接退出，就会丢失数据或提前结束任务。
    
- **正确的处理方式：** 对于低速系统调用，健壮的应用程序必须在一个循环中检查返回值，如果返回值为 $\text{-1}$ 并且 $\text{errno}$ 为 $\text{EINTR}$，就应该**再次尝试**调用该系统调用，直到成功或遇到其他致命错误。
- [EINTR细节](EINTR细节.md)

**2. $\text{SA\_RESTART}$ 标志的作用：**

这个标志是简化编程的关键。

- **启用 $\text{SA\_RESTART}$：** 当使用 $\text{sigaction}$ 设置信号处理函数时，如果设置了 $\text{SA\_RESTART}$ 标志，**内核**就会自动替应用程序处理被中断的低速系统调用，自动重启它。这使得应用程序的 I/O 代码可以写得更简洁，不必手动编写 $\text{EINTR}$ 处理循环。
    
- **并非所有低速调用都可重启：** 值得注意的是，即使设置了 $\text{SA\_RESTART}$，**并非所有**低速系统调用都能被内核自动重启（例如，$\text{poll}$、$\text{select}$、$\text{pause}$ 等通常不会自动重启）。这仍然要求开发者了解并区别对待这些特殊的低速调用。
    

**3. 资源效率和响应性：**

在服务器环境中，许多程序使用 $\text{select/poll/epoll}$ 来监控多个 I/O 通道，这些函数也属于低速系统调用。

- 如果这些函数被信号中断并返回 $\text{EINTR}$，程序必须能够立即重启它们。
    
- 如果程序在信号处理中卡住或退出，它将失去对连接的监控，导致服务器响应性下降甚至连接断开。
    

**简而言之：**

区分“低速”和“其他”系统调用，是区分**“可能会被中断”**和**“几乎不可能被中断”**的系统调用。只有识别出那些“可能会被中断”的低速调用，开发者才能采取必要的措施（如设置 $\text{SA\_RESTART}$ 或手动处理 $\text{EINTR}$ 循环），确保程序在接收到信号后能够**正确地恢复**其 I/O 操作，而不是意外失败。

### TODO
- **正确的处理方式：** 对于低速系统调用，健壮的应用程序必须在一个循环中检查返回值，如果返回值为 $\text{-1}$ 并且 $\text{errno}$ 为 $\text{EINTR}$，就应该**再次尝试**调用该系统调用，直到成功或遇到其他致命错误。