关于 $\text{read}$ 和 $\text{write}$ 的 $\text{EINTR}$ 细节
对于 $\text{read}$ 和 $\text{write}$ 这类 I/O 函数，当它们被信号中断时，存在两种返回情况：

1. **在传输开始之前被中断：** 此时函数返回 $\text{-1}$，$\text{errno}$ 设置为 $\text{EINTR}$。调用者没有传输任何数据。在这种情况下，直接简单地重启调用是安全的。
    
2. **在传输了部分数据之后被中断：**
    
    - **$\text{read}$ 函数：** 如果已经成功读取了部分数据（例如，请求读取 $\text{1024}$ 字节，但只读取了 $\text{500}$ 字节后被中断），$\text{read}$ 函数**通常会返回已读取的字节数（$\text{500}$）**，而不是返回 $\text{EINTR}$。 $\text{EINTR}$ 只有在**没有传输任何数据**时才最可能发生。
        
    - **$\text{write}$ 函数：** 同样，如果已经成功写入了部分数据，$\text{write}$ 函数**通常会返回已写入的字节数**，而不是返回 $\text{EINTR}$。
        

#### 为什么这是重要的区分？

对于 $\text{read}$ 和 $\text{write}$ 来说，**最健壮的处理循环**不仅要处理 $\text{EINTR}$ 错误，还要处理**部分读写（Partial I/O）**的情况。

**完善后的健壮 $\text{read/write}$ 循环逻辑：**

|**场景**|**错误处理（仅重启 read/write 调用的代码）**|**字节处理（处理 Partial I/O 的代码）**|
|---|---|---|
|**中断 ($\text{EINTR}$)**|**返回 $\text{-1}$ 且 $\text{errno} = \text{EINTR}$**：循环重试整个操作。|**返回已读/写字节数**：循环重试，但只请求**剩余未完成的字节**。|

因此，虽然你提到的“简单 $\text{EINTR}$ 循环”对于 $\text{select/poll/accept}$ 等**非数据传输**的低速调用是完美的，但对于 $\text{read}$ 和 $\text{write}$ 来说，**最健壮的代码**需要一个更复杂的循环来**追踪并完成剩余的字节传输**，同时处理 $\text{EINTR}$。

---

### 总结：处理 $\text{EINTR}$ 的两种模式

|**模式**|**适用于哪类低速系统调用？**|**目标**|**核心逻辑**|
|---|---|---|---|
|**模式一：简单重启**|$\text{accept()}$, $\text{select()}$, $\text{poll()}$, $\text{connect()}$, $\text{open()}$, $\text{sleep()}$ 等|简单等待事件，不涉及数据传输总量。|`while (result == -1 && errno == EINTR) { call_again(); }`|
|**模式二：追踪进度**|$\text{read()}$, $\text{write()}$ 等|确保请求的所有字节都被传输完成。|在循环中不断**调整要读写的大小和缓冲区指针**，直到 $\text{count}$ 达到 $\text{0}$ 或遇到非 $\text{EINTR}$ 错误。|

您的原总结强调了处理 $\text{EINTR}$ 的必要性，这是完全正确的。这个补充只是提供了 $\text{read}$ 和 $\text{write}$ 在健壮性编程实践中更精细的实现细节。