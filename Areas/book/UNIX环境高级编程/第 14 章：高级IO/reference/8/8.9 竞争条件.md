您提到的信号集（`sigset_t` 类型的变量，如 `zeromask` 和 `newmask`）在 $\text{UNIX/Linux}$ 进程间同步和信号处理中起着至关重要的作用。

**信号集 ($\text{sigset\_t}$) 的作用可以概括为以下三点：**

### 1. 信号的容器（集合表示）

信号集本质上是一个**位掩码（Bitmask）**或**位图（Bitmap）**，用于存储一组信号编号。

- **表示：** 它允许程序将多个信号视为一个单元进行操作。例如，您可以使用 `sigaddset()` 将 $\text{SIGUSR1}$ 和 $\text{SIGUSR2}$ 都放入一个信号集 `newmask` 中。
    
- **操作：** 您可以使用一系列函数（如 `sigemptyset`、`sigfillset`、`sigaddset`、`sigdelset` 等）来清空、填充或修改信号集的内容。
    

### 2. 控制信号的阻塞和解除阻塞（`sigprocmask`）

信号集最核心的用途是用来控制进程的**信号屏蔽字（Signal Mask）**。

- **阻塞：** 当一个信号集作为参数传给 $\text{sigprocmask}$ 并使用 $\text{SIG\_BLOCK}$ 操作时，信号集中的所有信号都会被添加到进程的屏蔽字中，从而被**阻塞**。被阻塞的信号不会立即递送给进程，而是保持**挂起（pending）**状态，直到被解除阻塞。
    
- **解除阻塞：** 当使用 $\text{SIG\_UNBLOCK}$ 操作时，信号集中的信号会被从屏蔽字中移除，从而被**解除阻塞**，挂起的信号随后会被递送。
    

在您的 `TELL_WAIT()` 示例中，`newmask` 就用于告诉 $\text{sigprocmask}$ 要阻塞 $\text{SIGUSR1}$ 和 $\text{SIGUSR2}$。

### 3. 在原子操作中临时修改屏蔽字并等待信号（`sigsuspend`）

这是信号集在进程同步中最精妙的用途。`sigsuspend()` 函数接受一个信号集作为参数，这个参数通常用于**临时修改**进程的屏蔽字并让进程进入休眠，直到收到一个**未被屏蔽**的信号。

- **`zeromask` 的典型用途：** 您示例中的 `zeromask` ($\text{sigemptyset}$ 后的空集) 经常与 $\text{sigsuspend}$ 配合使用。在 $\text{WAIT\_}$ 族函数中：
    
    1. 进程可能已经阻塞了 $\text{SIGUSR1}$ 和 $\text{SIGUSR2}$。
        
    2. 调用 $\text{sigsuspend}(\&zeromask)$ 会：
        
        - **原子性地**将进程的信号屏蔽字设置为 $\text{zeromask}$（即暂时解除所有信号的阻塞，包括 $\text{SIGUSR1/2}$）。
            
        - 让进程进入休眠等待状态。
            
    3. 一旦收到 $\text{SIGUSR1}$ 或 $\text{SIGUSR2}$，进程被唤醒，信号处理函数 $\text{sig\_usr}$ 运行。
        
    4. $\text{sigsuspend}$ 返回，并且**原子性地**将信号屏蔽字恢复到调用前的状态（即重新阻塞 $\text{SIGUSR1/2}$）。
        

这种机制是实现**可靠信号等待**的关键，它避免了在解除阻塞和休眠之间产生竞争条件（即：防止信号在进程进入休眠前到达并被错过）。