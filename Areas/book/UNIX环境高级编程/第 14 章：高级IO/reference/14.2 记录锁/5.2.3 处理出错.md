应当了解，用F_GETLK测试能否建立一把锁，然后用F_SETLK或F_SETLKW企图建立那把锁，这两者不是一个原子操作。因此不能保证在这两次fcntl调用之间不会有另一个进程插入并建立一把相同的锁。如果不希望在等待锁变为可用时产生阻塞，就必须处理由F_SETLK返回的可能的出错。

你提出的这一点是关于 $\text{UNIX/Linux}$ **文件锁**机制中一个**非常关键且常见的陷阱**，它直接关系到多进程并发控制的可靠性。

### 核心问题：非原子操作导致的竞态条件

**结论：** **$\text{F\_GETLK}$ + $\text{F\_SETLK}$ (或 $\text{F\_SETLKW}$) 不是一个原子操作。**

|**操作序列**|**描述**|**结果**|
|---|---|---|
|**进程 A (1)**|调用 $\text{F\_GETLK}$ 查询锁：**报告无冲突。**|进程 A 决定可以加锁。|
|**进程 B (2)**|**(插入)** 快速调用 $\text{F\_SETLK}$ 成功**建立**了这把锁。|进程 B 持有锁。|
|**进程 A (3)**|接着调用 $\text{F\_SETLK}$ 企图建立锁。|**失败！** 进程 A 发现锁已经被进程 B 持有。|

这种在**查询**（$\text{F\_GETLK}$）和**实际加锁**（$\text{F\_SETLK}$）之间，另一个进程抢先完成操作的情况，就是典型的**竞态条件 ($\text{Race Condition}$)**。

### 避免阻塞时对 $\text{F\_SETLK}$ 的处理

这段话的最后一句给出了**正确的编程实践**：

> “如果不希望在等待锁变为可用时产生阻塞，就必须处理由 $\text{F\_SETLK}$ 返回的可能的出错。”

**正确的非阻塞加锁流程：**

1. **直接尝试加锁：** **不要**先使用 $\text{F\_GETLK}$ 查询，而是直接使用 **$\text{F\_SETLK}$** 尝试加锁。
    
2. **处理 $\text{EAGAIN}$：** 如果 $\text{F\_SETLK}$ 返回 $\mathbf{-1}$ 且 $\mathbf{errno}$ 设置为 **$\text{EAGAIN}$**（或 $\text{EACCES}$），这意味着：
    
    - **锁已被占用。** 你的程序知道此时不能加锁，但它没有阻塞。
        
    - 你的程序可以执行其他任务（例如 $\text{I/O}$ 多路复用），并在稍后**重试**加锁操作。
        

**总结：**

在 $\text{UNIX}$ 系统编程中，如果你想避免阻塞，你应该：**尝试操作 $\rightarrow$ 检查错误 $\rightarrow$ 决定下一步**，而不是**查询状态 $\rightarrow$ 尝试操作 $\rightarrow$ 假设成功**。

直接使用 $\text{F\_SETLK}$ 并处理 $\text{EAGAIN}$ 是唯一能保证**非阻塞**且**正确处理竞争**的方法。