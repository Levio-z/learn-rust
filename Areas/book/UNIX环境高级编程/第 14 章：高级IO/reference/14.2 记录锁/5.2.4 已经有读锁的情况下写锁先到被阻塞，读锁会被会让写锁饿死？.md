注意，POSIX.1 并没有说明在下列情况下将发生什么：一个进程在某个文件的一个区间上设置了一把读锁，第二个进程在试图对同一文件区间加一把写锁时阻塞，然后第三个进程则试图在同一文件区间上得到另一把读锁。如果第三个进程只是因为读区间已有一把读锁，而被允许在该区间放置另一把读锁，那么这种实现就可能会使希望加写锁的进程饿死。因此，当对同一区间加另一把读锁的请求到达时，提出加写锁而阻塞的进程需等待的时间延长了。如果加读锁的请求来得很频繁，使得该文件区间始终存在一把或几把读锁，那么欲加写锁的进程就将等待很长时间。

你描述的正是并发控制中一个非常经典的，且需要操作系统设计者做出权衡的问题：**读写锁的饥饿问题（Starvation）**。

### 核心问题：写进程饥饿 (Writer Starvation)

- **场景：** 多个进程竞争对同一文件区间加锁。
    
- **起因：** **读锁**是**共享**的，而**写锁**是**独占**的。
    
- **过程：**
    
    1. 进程 $\text{W}$ (想加写锁) 正在等待，因为它被现有的读锁 $\text{R}_1$ 阻塞。
        
    2. 新的读锁请求 $\text{R}_2$ 到达。
        
    3. **如果系统允许 $\text{R}_2$ 立即加锁**（因为 $\text{R}_1$ 是读锁，兼容 $\text{R}_2$），那么 $\text{R}_1$ 和 $\text{R}_2$ 同时持有读锁。
        
    4. 当 $\text{R}_1$ 释放锁后，$\text{R}_2$ 仍然持有锁，进程 $\text{W}$ 仍然被阻塞。
        
    5. 如果新的读锁请求 $\text{R}_3, \text{R}_4, \dots$ 不断频繁地到达，它们都会被立即授予。
        
    6. 结果是：该文件区间将**始终存在一把或几把读锁**，导致希望加写锁的进程 $\text{W}$ **无限期等待**，这就是**饥饿**。
        

### POSIX.1 标准的沉默与实现差异

你强调的这一点非常重要：**$\text{POSIX.1}$ 并没有说明在这种情况下应该发生什么。**

这使得 $\text{UNIX}$ 实现者必须在以下两种策略中做出选择：

|**策略**|**目标**|**结果（对写进程 W）**|**适用场景**|
|---|---|---|---|
|**策略 A：读优先**|优先保证读操作的并发性。|**可能导致饥饿。** 新的读锁请求 $\text{R}_n$ 总是被允许立即加锁。|读操作远多于写操作，且对读并发要求极高。|
|**策略 B：写饥饿避免**|优先保证等待中的写操作。|**避免饥饿。** 当有写锁 $\text{W}$ 在等待时，系统会**暂停授予新的读锁** $\text{R}_n$，直到 $\text{W}$ 获得并释放了锁。|读写操作相对均衡，必须保证写操作能够执行。|

**在现实 $\text{UNIX}$ 系统中：**

现代 $\text{Linux}$ 内核和大多数主流 $\text{UNIX}$ 实现通常采用**写饥饿避免**的策略（类似策略 B）。这意味着：

当一个写锁请求被阻塞时，任何后续到达的读锁请求也会被**暂停**或**排队**。只有当所有现有的锁都被释放后，系统才会优先授予等待时间最长的锁（通常是写锁，以确保公平性）。这有效地防止了写进程被无限期的读锁请求流“饿死”