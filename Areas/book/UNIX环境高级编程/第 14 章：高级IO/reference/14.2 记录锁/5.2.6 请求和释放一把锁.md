字节范围锁包装函数整理（`lock_reg` 函数）
这段代码是一个对 $\text{fcntl}$ 函数的**包装（Wrapper）**，专门用于简化**字节范围锁（记录锁）**的设置、查询或释放操作。

**核心功能：** 封装了 `struct flock` 结构的初始化过程，使得调用者可以直接传递锁的类型、偏移量等参数，而无需手动操作结构体。
```
#include "apue.h"
#include <fcntl.h>

/* * 包装函数：设置、获取或清除文件描述符 fd 上的记录锁
 * fd: 文件描述符
 * cmd: F_GETLK, F_SETLK, F_SETLKW
 * type: F_RDLCK, F_WRLCK, F_UNLCK
 * offset: l_start 偏移量
 * whence: l_whence 参照点 (SEEK_SET, SEEK_CUR, SEEK_END)
 * len: l_len 长度 (0 表示到文件最大偏移量)
 */
int
lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len)
{
    struct flock lock;

    // 1. 初始化 struct flock 结构体
    lock.l_type = type;         /* F_RDLCK, F_WRLCK, F_UNLCK */
    lock.l_start = offset;      /* byte offset, relative to l_whence */
    lock.l_whence = whence;     /* SEEK_SET, SEEK_CUR, SEEK_END */
    lock.l_len = len;           /* #bytes (0 means to EOF) */

    // 2. 调用 fcntl 系统调用并返回结果
    // 注意：l_pid 字段只在 cmd 为 F_GETLK 时由内核返回，此处无需手动设置
    return(fcntl(fd, cmd, &lock));
}
```
图14-5 加锁或解锁一个文件区域的函数

因为大多数锁调用是加锁或解锁一个文件区域（命令F_GETLK很少使用）​，故通常使用下列5个宏中的一个，这5个宏都定义在apue.h中（见附录B）​。

	我们有目的地用与lseek函数同样的顺序定义了这些宏中的前3个参数。
```c
// 文件锁封装宏
// fd      : 文件描述符
// offset  : 偏移量
// whence  : SEEK_SET / SEEK_CUR / SEEK_END
// len     : 锁定长度
#define read_lock(fd, offset, whence, len) \
    lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))

#define readw_lock(fd, offset, whence, len) \
    lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))

#define write_lock(fd, offset, whence, len) \
    lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))

#define writew_lock(fd, offset, whence, len) \
    lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))

#define un_lock(fd, offset, whence, len) \
    lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

```
### 说明

1. **read_lock / write_lock**：非阻塞锁，若锁冲突立即返回失败。
    
2. **readw_lock / writew_lock**：阻塞锁，若锁冲突会等待直到锁可用。
    
3. **un_lock**：释放锁。

实例：测试一把锁图14-6中定义了一个函数lock_test，我们将用它测试一把锁。


```c
#include "apue.h"
#include <fcntl.h>

/*
 * 文件锁测试函数
 * 功能：测试指定文件区域是否被其他进程锁定
 * 
 * 参数：
 *   fd     - 文件描述符
 *   type   - 锁类型（F_RDLCK 读锁 或 F_WRLCK 写锁）
 *   offset - 偏移量（相对于whence的字节偏移）
 *   whence - 偏移基准（SEEK_SET, SEEK_CUR, SEEK_END）
 *   len    - 锁定的字节长度（0表示到文件末尾）
 * 
 * 返回值：
 *   0      - 区域未被锁定（可以加锁）
 *   pid_t  - 区域已被锁定，返回锁持有者的进程ID
 */
pid_t
lock_test(int fd, int type, off_t offset, int whence, off_t len)
{
	struct flock	lock;	// 文件锁结构体

	// 设置锁参数
	lock.l_type = type;		/* F_RDLCK 或 F_WRLCK - 读锁或写锁 */
	lock.l_start = offset;	/* 字节偏移量，相对于 l_whence */
	lock.l_whence = whence;	/* SEEK_SET, SEEK_CUR, SEEK_END - 偏移基准 */
	lock.l_len = len;		/* 字节数（0表示到文件末尾） */

	// 使用 F_GETLK 命令测试锁状态
	// F_GETLK 不会实际加锁，只是检查是否可以加锁
	if (fcntl(fd, F_GETLK, &lock) < 0)
		err_sys("fcntl error");	// 如果fcntl调用失败，输出错误信息

	// 检查锁状态
	if (lock.l_type == F_UNLCK)
		return(0);		/* false - 区域未被其他进程锁定，可以加锁 */
	return(lock.l_pid);	/* true - 区域已被锁定，返回锁持有者的进程ID */
}
```


|**宏名称**|**对应的 lock_test 参数组合**|**行为**|**作用描述**|
|---|---|---|---|
|**$\text{is\_read\_lockable}$**|$\text{lock\_test}(\text{fd}, \mathbf{F\_RDLCK}, \dots) == 0$|**非阻塞查询**|判断是否可以在指定的区域**加一个读锁**（共享锁）。如果返回 $\mathbf{1}$ ($\text{true}$)，表示**可加**（无冲突）。|
|**$\text{is\_write\_lockable}$**|$\text{lock\_test}(\text{fd}, \mathbf{F\_WRLCK}, \dots) == 0$|**非阻塞查询**|判断是否可以在指定的区域**加一个写锁**（独占锁）。如果返回 $\mathbf{1}$ ($\text{true}$)，表示**可加**（无冲突）。|

```
#define is_read_lockable(fd, offset, whence, len) \
(lock_test((fd), F_RDLCK, (offset), (whence), (len)) == 0)
#define is_write_lockable(fd, offset, whence, len) \
(lock_test((fd), F_WRLCK, (offset), (whence), (len)) == 0)
```