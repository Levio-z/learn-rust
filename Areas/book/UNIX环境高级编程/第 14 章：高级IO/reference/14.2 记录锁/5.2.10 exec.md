您提到的 `exec` 是一系列 $\text{UNIX/Linux}$ 系统函数（如 `execl`, `execv`, `execle`, `execve` 等）的统称。

**`exec` 的核心作用是：**

> **用一个全新的程序替换掉当前进程的执行映像。**

### 详细解释 `exec`

#### 1. 定义

`exec` 函数族并不创建新进程（不像 `fork()`）。它在**当前进程**内部执行，将：

- 新程序的机器代码和数据加载到当前进程的内存空间。
    
- 覆盖掉原程序的代码、数据、堆和栈。
    
- 将进程的**执行流**转移到新程序的 `main()` 函数。
    

**替换而非创建：** 虽然进程中运行的代码完全变了，但是**进程 ID ($\text{PID}$) 保持不变**。

#### 2. `exec` 对文件描述符和锁的影响

您的描述正确地指出了 $\text{exec}$ 对文件描述符和锁的影响：

- **默认继承：** 默认情况下，$\text{exec}$ 后的**新程序会继承**原进程打开的**所有文件描述符**。由于文件描述符保持打开，因此原程序对文件设置的**锁**也会被新程序**继承并保持**。
    
- **执行时关闭标志 ($\text{Close-on-exec Flag}$):**
    
    - 这是一个文件描述符标志 ($\text{FD\_CLOEXEC}$)，可以通过 $\text{fcntl()}$ 设置。
        
    - 如果一个文件描述符设置了 $\text{FD\_CLOEXEC}$，那么在执行 $\text{exec}$ 时，操作系统会在加载新程序之前**自动关闭**这个文件描述符。
        
    - **锁的释放：** 当文件描述符被关闭时，操作系统会**自动释放**该文件描述符所持有的**所有劝告性锁**（Advisory Locks）。因此，设置了 $\text{FD\_CLOEXEC}$ 标志是确保文件锁在程序替换时被释放的标准方法。
        

#### 3. 典型使用场景

`exec` 函数通常在**子进程**中使用。一个典型的流程是：

1. **`fork()`:** 父进程调用 `fork()` 创建一个子进程。
    
2. **子进程中：** 子进程调用某个 `exec` 函数，加载并运行一个**不同的**程序（例如运行 $\text{shell}$ 命令、启动另一个应用程序）。
    
3. **父进程中：** 父进程通常调用 $\text{wait()}$ 来等待子进程执行完毕。
    

通过 `fork()` 和 `exec` 的组合，$\text{UNIX}$ 系统实现了进程的创建和程序执行的隔离。