### 为什么“不可用也会被唤醒”？
 
第二种情况——**“休眠由信号中断”**——就是你所说的“不可用也会被唤醒”的情况。

- 当进程被**信号**（例如 $\text{Ctrl+C}$ 产生的 $\text{SIGINT}$，或者由其他进程发出的 $\text{SIGTERM}$ 等）中断时，内核会唤醒进程，但**此时锁可能仍未被释放**。
    
- 在这种情况下，$\text{F\_SETLKW}$ 系统调用会失败，返回 **$\mathbf{-1}$**，并将 $\text{errno}$ 设置为 **$\mathbf{EINTR}$**（Interrupted system call，被中断的系统调用）


- 当你调用 `fcntl(fd, F_SETLKW, &flock)` 时：
    

1. **锁可用** → 立即设置成功，返回 0
    
2. **锁不可用** → 进程进入 **睡眠状态**
    
    - 系统会唤醒进程：
        
        1. **锁变得可用** → 内核授予锁，返回 0
            
        2. **接收到信号（如 SIGINT）** → 返回 -1，并设置 `errno = EINTR`
            

> 注意：锁 **不可用** 时调用会阻塞休眠，直到锁可用或信号中断，不会因为锁不可用而直接返回。

所以你的问题：

> 不可用也会被唤醒？

- **是的，但只有两种情况会被唤醒**：
    
    1. **锁可用** → 成功获得锁
        
    2. **被信号中断** → 返回错误
        
- **不会因为锁仍不可用而无条件被唤醒**（除非系统异常，比如进程被杀）