你提供的图片（`image_57bb0f.png`）是一个关于 $\text{UNIX/Linux}$ 系统中**文件锁定**特性的比较表格，其中列出了 **建议性 (Advisory)** 和 **强制性 (Mandatory)** 锁定。

这两个术语是描述文件锁定的**执行方式和严格程度**的关键概念。

### 1. 建议性锁定 (Advisory Locking)

建议性锁定是 **$\text{UNIX}$ 系统中文件锁的默认行为**，也是最常用的方式。

- **含义：** 锁定的存在是“建议”性的。它不被操作系统内核**强制执行**，而是依赖于**所有协作的应用程序**自觉地去检查并遵守这个锁。
    
- **执行方式：** 内核提供了锁定机制（例如 $\text{fcntl}$），但它只会阻止**同样尝试获取锁**的进程访问被锁定的区域。
    
- **非协作进程：** 如果一个应用程序**没有调用**任何锁定函数（如 $\text{fcntl}$），它就可以完全**无视**建议锁的存在，直接对文件进行读取或写入操作，从而破坏锁定的目的。
    
- **优点：** 性能开销小，灵活性高。
    
- **总结：** 依赖于程序猿的**良好编程习惯**和**合作精神**。
    

### 2. 强制性锁定 (Mandatory Locking)

强制性锁定是更严格的文件锁定机制，但不是所有 $\text{UNIX}$ 系统都支持（如表格所示，$\text{SUS}$ 和 $\text{FreeBSD}$ 默认不支持）。

- **含义：** 锁定的存在是“强制”性的。一旦文件的一个区域被锁住，**内核**会阻止**所有**其他进程对这个区域进行任何形式的**访问**（包括 $\text{read}$ 和 $\text{write}$），而不管这些进程是否尝试去获取锁。
    
- **执行方式：**
    
    1. **文件设置：** 文件必须设置一个特殊的权限位（通常是 $\text{set-group-ID}$ 位被设置，但组可执行位被清除）。
        
    2. **文件系统挂载：** 某些系统可能要求文件系统以特殊的方式挂载。
        
    3. **内核检查：** 当一个进程尝试对被强制锁定的文件区域执行 $\text{read}$ 或 $\text{write}$ 时，内核会**检查锁**。如果操作冲突，内核会使该进程**阻塞**（直到锁被释放）或返回错误。
        
- **非协作进程：** 即使一个进程不知道锁的存在，它的 $\text{read}$ 或 $\text{write}$ 也会被内核**拦截**和**阻止**。
    
- **缺点：** 性能开销相对大，因为内核必须对所有 $\text{read/write}$ 操作进行额外的检查。
    
- **总结：** 提供最高级别的**数据完整性保证**，即使面对“不合作”的或编写不良的应用程序。
    

---

### 表格内容解释

根据你提供的表格 ($\text{image\_57bb0f.png}$)，我们可以看到不同系统对这两种锁定的支持情况：

|**系统**|**建议性 (Advisory)**|**强制性 (Mandatory)**|**解释**|
|---|---|---|---|
|**SUS (Single UNIX Specification)**|**支持**|**不支持**|$\text{POSIX/SUS}$ 标准只要求支持**建议性**锁定。|
|**Linux 3.2.0**|**支持**|**支持**|$\text{Linux}$ 通过特殊的文件权限和挂载选项，**支持**强制性锁定。|
|**Solaris 10**|**支持**|**支持**|$\text{Solaris}$ 也支持这两种锁定。|
|**FreeBSD/Mac OS X**|**支持**|**不支持**|这些 $\text{BSD}$ 派生系统通常**不支持**标准的强制性锁定，主要依赖建议性锁定。|

简而言之：**建议性**是开发者之间的**君子协定**；**强制性**是内核对所有进程的**法律约束**。