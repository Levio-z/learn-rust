在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。例如，若第 100～199 字节是加锁的区，需解锁第 150 字节，则内核将维持两把锁，一把用于第 100～149 字节，另一把用于第151～199字节。图14-4说明了这种情况下的字节范围锁。
![](asserts/Pasted%20image%2020251020170131.png)
图14-4 文件字节范围锁假定我们又对第150字节加锁，那么系统将会再把3个相邻的加锁区合并成一个区（第100～199字节）​。其结果如图14-4中的第一个图所示，又跟开始的时候一样了。




你引用的内容描述了 $\text{UNIX/Linux}$ 内核在处理 **$\text{fcntl}$ 字节范围锁**（记录锁）时，为了管理和优化锁定的文件区域而采取的**内部机制**。

### 核心机制：锁的组合与分裂 (Merging and Splitting)

**结论：** 当一个进程请求对一个**已经被锁定**的区域进行**解锁**或**重新锁定**时，内核不会简单地移除整个锁，而是根据请求的字节范围，自动地对原有的锁进行**分裂（Splitting）**或**组合（Merging）**。

#### 1. 锁的分裂（$\text{Splitting}$）案例

| **动作**   | **描述**                                                            | **结果**                      |
| -------- | ----------------------------------------------------------------- | --------------------------- |
| **原始状态** | 第 $\mathbf{100}$ 到 $\mathbf{199}$ 字节被一个**单独的锁**覆盖。                | $[100, 199]$                |
| **请求操作** | 请求**解锁**第 $\mathbf{150}$ 字节（假设长度为 1 字节）。                          | 锁被解除，但在文件系统上留下了两个加锁的区域。     |
| **内核维持** | 内核将维持**两把独立的锁**：一把用于第 $100 \sim 149$ 字节，另一把用于第 $151 \sim 199$ 字节。 | $[100, 149]$ 和 $[151, 199]$ |

这种分裂操作确保了：

- **精确释放：** 只有用户请求的精确字节范围被解锁。
    
- **资源保护：** 被解锁区域两边的字节仍然受到原有锁的保护。
    

#### 2. 锁的组合（$\text{Merging}$）


虽然你的引文没有提到组合，但它是分裂的反面。

- 如果一个进程在文件上的**相邻且类型兼容**的区域（例如 $\mathbf{[100, 149]}$ 和 $\mathbf{[150, 199]}$ 都是由同一个进程持有的读锁）设置了锁，内核可能会将它们**组合成一个单一的锁** $\mathbf{[100, 199]}$。
    
- 这优化了内核对锁的管理效率，减少了锁记录的数量。
    

### 总结

这种“组合或分裂相邻区”的机制是**内核内部的实现细节**，对应用程序员而言是透明的。它允许程序员在不担心底层管理的情况下，灵活地锁定和解锁文件中的任意字节范围。