### 一、核心定义与设计思路

#### 1. 设计目的

该模块实现《APUE（Advanced Programming in the UNIX Environment）》中**父子进程同步机制**的经典信号版实现（TELL_WAIT、TELL_PARENT、WAIT_PARENT、TELL_CHILD、WAIT_CHILD）。  
在 `fork()` 后，父子进程是异步执行的，为保证执行顺序（如父先打印、子后打印），需要同步手段。这里利用 `SIGUSR1` 和 `SIGUSR2` 信号在父子间传递同步通知。

#### 2. 信号同步的基本思想

- **父进程 → 子进程**：通过 `SIGUSR1` 通知。
    
- **子进程 → 父进程**：通过 `SIGUSR2` 通知。
    
- 通过一个全局变量 `sigflag` 表示“信号是否到达”。
    
- 通过 `sigprocmask` + `sigsuspend` 实现“安全等待”，避免信号丢失。
    

---

### 二、源码结构与作用分析

#### 1. 全局变量部分

```c
static volatile sig_atomic_t sigflag; // 信号标志，volatile确保多线程/异步内存可见性
static sigset_t newmask, oldmask, zeromask; // 信号掩码集（阻塞集、旧掩码、空集）
```

**作用说明**：

- `sigflag`：进程同步标志，信号到达后由处理函数设置为 `1`。
    
- `volatile`：防止编译器优化掉对信号修改的读取。
    
- `sigset_t`：内核表示信号集合的标准结构，用于管理屏蔽信号。
    

---

#### 2. 信号处理函数

```c
static void sig_usr(int signo) {
    sigflag = 1;
}
```

**要点说明**：

- 极简信号处理函数：只设标志，不执行复杂逻辑。
    
- 保证**异步信号安全（async-signal-safe）**。
    
- 当 `SIGUSR1` 或 `SIGUSR2` 到达时，设置 `sigflag=1`，表示“对方已通知我”。
    

---

#### 3. 初始化函数 TELL_WAIT()

```c
void TELL_WAIT() {
    signal(SIGUSR1, sig_usr);
    signal(SIGUSR2, sig_usr);

    sigemptyset(&zeromask);
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGUSR1);
    sigaddset(&newmask, SIGUSR2);

    sigprocmask(SIG_BLOCK, &newmask, &oldmask);
}
```

**功能定义**：

- 在 `fork()` 前调用，建立父子双方共享的同步机制。
    
- 阻塞 `SIGUSR1` 与 `SIGUSR2`，防止在信号处理器安装前信号到达而丢失。
    
- 保存原始掩码 `oldmask`，为后续恢复提供依据。
    

**核心机制原理**：  
`sigprocmask(SIG_BLOCK)` 会更新当前线程的信号屏蔽集，使这两个信号在正常执行时不会立即被递送，只能在 `sigsuspend()` 临时解除时接收。

---

#### 4. 通知函数：父→子 / 子→父

```c
void TELL_PARENT(pid_t pid) { kill(pid, SIGUSR2); }
void TELL_CHILD(pid_t pid)  { kill(pid, SIGUSR1); }
```

**设计逻辑**：

- `kill()` 系统调用用于发送信号给指定进程。
    
- 父子双方通过各自定义的信号编号区分通信方向。
    
- 不做阻塞等待，只发送通知即可。
    

---

#### 5. 等待函数：父等待子 / 子等待父

```c
void WAIT_PARENT() {
    while (sigflag == 0)
        sigsuspend(&zeromask);
    sigflag = 0;
    sigprocmask(SIG_SETMASK, &oldmask, NULL);
}

void WAIT_CHILD() {
    while (sigflag == 0)
        sigsuspend(&zeromask);
    sigflag = 0;
    sigprocmask(SIG_SETMASK, &oldmask, NULL);
}
```

**核心机制解析**：

1. `sigflag` 初始为 0，表示“还没收到信号”；
    
2. `sigsuspend(&zeromask)`：临时替换当前信号掩码为空集（解除阻塞），让 `SIGUSR1`/`SIGUSR2` 可以递送；
    
3. 信号到达 → 执行 `sig_usr()` → `sigflag=1`；
    
4. `sigsuspend()` 被中断返回 → 跳出循环；
    
5. 重置 `sigflag=0` 并恢复信号掩码。
    

**安全性优势**：  
`while (sigflag == 0) sigsuspend()` 的模式能避免**信号丢失竞态（race condition）**，保证同步操作的可靠性。

---

### 三、底层工作原理分析

#### 1. 为什么要阻塞信号？

若不阻塞，在注册处理函数和进入等待之间可能出现竞态（信号先到达导致永远等待），阻塞能确保在显式解除前信号不丢。

#### 2. sigsuspend 的原子性

`sigsuspend` = 临时替换信号屏蔽集 + 挂起等待信号 + 信号返回后恢复原屏蔽集，整个过程原子执行。

#### 3. sig_atomic_t 的作用

防止信号处理过程中被中断读写，使 `sigflag` 变量的访问保持一致性。

---

### 四、使用场景与示例

典型使用流程：

```c
TELL_WAIT();
if ((pid = fork()) == 0) {
    // 子进程
    WAIT_PARENT();     // 等待父进程通知
    // 执行任务...
    TELL_PARENT(getppid());
} else {
    // 父进程
    // 初始化工作...
    TELL_CHILD(pid);   // 通知子进程
    WAIT_CHILD();      // 等待子进程
}
```

**场景**：

- 文件拷贝时父子交替读写。
    
- 控制父子顺序输出或初始化资源访问顺序。
    
- 避免使用管道或共享内存的轻量级同步方案。
    

---

### 五、扩展与改进

#### 1. 替代机制

- **信号版**：轻量但有限，只能传递“事件”，无数据。
    
- **pipe版**：可传递同步与简单数据。
    
- **semaphore / futex**：更高效、可扩展至多进程。
    

#### 2. 可移植增强

在多线程环境中，应使用 `pthread_sigmask()` 替代 `sigprocmask()`。  
在高可靠场景，可考虑自定义 `sigaction()` 注册函数，避免老式 `signal()` 不可重入问题。

---

### 六、小结与学习方法论

**总结要点**：

- 本代码是 Unix 信号同步的经典实现，依赖信号机制的异步通知 + 屏蔽集控制实现安全等待。
    
- 精髓在于：
    
    - 阻塞信号防止竞态；
        
    - `sigsuspend` 保证安全解除；
        
    - `sig_atomic_t` 保证访问一致性。
        

**学习方法论**：

1. **源码级理解**：逐步执行信号掩码变化过程。
    
2. **动手调试**：使用 `strace` 或 `psiginfo` 观察信号递送顺序。
    
3. **竞态演示**：删除 `sigprocmask`，复现信号丢失场景。
    
4. **并行比较**：对比管道版 TELL_WAIT 实现，加深同步抽象理解。
    

**练习题建议**：

1. 改写为使用 `pipe()` 的同步实现，并比较差异。
    
2. 将信号编号换为 `SIGRTMIN+1` 与 `SIGRTMIN+2`，分析实时信号可靠性提升点。
    
3. 在 `WAIT_PARENT()` 中插入打印日志，分析信号掩码的变化。
    
4. 尝试添加超时机制（使用 `sigtimedwait()` 替代 `sigsuspend()`）。
    

**重点底层知识**：

- 信号掩码管理（`sigprocmask` / `sigset_t`）
    
- 信号处理的异步安全语义
    
- `sigsuspend` 的原子性与竞态防御
    
- 进程同步与调度关系
    

这些是进程控制与信号系统调用层的核心底层能力，掌握后能深入理解 Unix 进程模型与信号子系统设计。